record_number,buggy_code,fixed_code,code_similarity
18001,"public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new ProcessLockerRuntimeException(""String_Node_Str"" + waitMS);
  }
}","public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new TestUtilRuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new TestUtilRuntimeException(""String_Node_Str"" + waitMS);
  }
}",0.9830310122878876
18002,"public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new ProcessLockerRuntimeException(e);
    }
  }
}","public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new TestUtilRuntimeException(e);
    }
  }
}",0.9540481400437636
18003,"/** 
 * simple main to start the tool
 * @param args not used
 */
public static void main(final String[] args) throws Exception {
  activateLoggingToJiraMarkupFile(ACCEPT_HEADER_REQUEST_JIRA_FILENAME);
  final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<TestPath> testPaths=TestPath.createTestPaths(paths,headerValues);
  final CallerResultHandler handler=new CallerResultHandler();
  final String localBaseUrl=""String_Node_Str"";
  final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
  AcceptHeaderCaller.create(localConfig).call();
  final String result=handler.getResult();
  LOG.info(""String_Node_Str"" + new SimpleDateFormat().format(new Date()) + ""String_Node_Str"");
  LOG.info(result);
}","/** 
 * simple main to start the tool
 * @param args not used
 */
public static void main(final String[] args){
  try {
    activateLoggingToJiraMarkupFile(ACCEPT_HEADER_REQUEST_JIRA_FILENAME);
    final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<TestPath> testPaths=TestPath.createTestPaths(paths,headerValues);
    final CallerResultHandler handler=new CallerResultHandler();
    final String localBaseUrl=""String_Node_Str"";
    final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
    AcceptHeaderCaller.create(localConfig).call();
    final String result=handler.getResult();
    LOG.info(""String_Node_Str"" + new SimpleDateFormat().format(new Date()) + ""String_Node_Str"");
    LOG.info(result);
  }
 catch (  Exception e) {
    throw new TestUtilRuntimeException(e);
  }
}",0.9549745824255628
18004,"private void initProxy() throws IllegalArgumentException {
  final String proxyUrl=config.getProxy();
  final String[] hostAndPort=proxyUrl.split(""String_Node_Str"");
  if (hostAndPort.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String host=hostAndPort[0];
  int port;
  try {
    port=Integer.parseInt(hostAndPort[1]);
  }
 catch (  final NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final HttpHost proxy=new HttpHost(host,port);
  LOG.info(""String_Node_Str"",proxy.getHostName(),proxy.getPort());
  httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
}","private void initProxy() throws IllegalArgumentException {
  final String proxyUrl=config.getProxy();
  final String[] hostAndPort=proxyUrl.split(""String_Node_Str"");
  if (hostAndPort.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String host=hostAndPort[0];
  int port;
  try {
    port=Integer.parseInt(hostAndPort[1]);
  }
 catch (  final NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  final HttpHost proxy=new HttpHost(host,port);
  LOG.info(""String_Node_Str"",proxy.getHostName(),proxy.getPort());
  httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
}",0.9984939759036144
18005,"@Before public void before(){
  try {
    service=createService();
    server.startServer(service);
  }
 catch (  final ODataException e) {
    throw new TestUtilException(e);
  }
}","@Before public void before(){
  try {
    service=createService();
    server.startServer(service);
  }
 catch (  final ODataException e) {
    throw new TestUtilRuntimeException(e);
  }
}",0.981029810298103
18006,"@After public void after(){
  try {
    server.stopServer();
  }
 catch (  final Exception e) {
    throw new TestUtilException(e);
  }
}","@After public void after(){
  try {
    server.stopServer();
  }
 catch (  final Exception e) {
    throw new TestUtilRuntimeException(e);
  }
}",0.9750889679715302
18007,"public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new ProcessLockerRuntimeException(""String_Node_Str"" + waitMS);
  }
}","public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new TestUtilRuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new TestUtilRuntimeException(""String_Node_Str"" + waitMS);
  }
}",0.9830310122878876
18008,"public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new ProcessLockerRuntimeException(e);
    }
  }
}","public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new TestUtilRuntimeException(e);
    }
  }
}",0.9540481400437636
18009,"/** 
 * simple main to start the tool
 * @param args not used
 */
public static void main(final String[] args) throws Exception {
  activateLoggingToJiraMarkupFile(ACCEPT_HEADER_REQUEST_JIRA_FILENAME);
  final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<TestPath> testPaths=TestPath.createTestPaths(paths,headerValues);
  final CallerResultHandler handler=new CallerResultHandler();
  final String localBaseUrl=""String_Node_Str"";
  final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
  AcceptHeaderCaller.create(localConfig).call();
  final String result=handler.getResult();
  LOG.info(""String_Node_Str"" + new SimpleDateFormat().format(new Date()) + ""String_Node_Str"");
  LOG.info(result);
}","/** 
 * simple main to start the tool
 * @param args not used
 */
public static void main(final String[] args){
  try {
    activateLoggingToJiraMarkupFile(ACCEPT_HEADER_REQUEST_JIRA_FILENAME);
    final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final List<TestPath> testPaths=TestPath.createTestPaths(paths,headerValues);
    final CallerResultHandler handler=new CallerResultHandler();
    final String localBaseUrl=""String_Node_Str"";
    final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
    AcceptHeaderCaller.create(localConfig).call();
    final String result=handler.getResult();
    LOG.info(""String_Node_Str"" + new SimpleDateFormat().format(new Date()) + ""String_Node_Str"");
    LOG.info(result);
  }
 catch (  Exception e) {
    throw new TestUtilRuntimeException(e);
  }
}",0.9549745824255628
18010,"private void initProxy() throws IllegalArgumentException {
  final String proxyUrl=config.getProxy();
  final String[] hostAndPort=proxyUrl.split(""String_Node_Str"");
  if (hostAndPort.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String host=hostAndPort[0];
  int port;
  try {
    port=Integer.parseInt(hostAndPort[1]);
  }
 catch (  final NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final HttpHost proxy=new HttpHost(host,port);
  LOG.info(""String_Node_Str"",proxy.getHostName(),proxy.getPort());
  httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
}","private void initProxy() throws IllegalArgumentException {
  final String proxyUrl=config.getProxy();
  final String[] hostAndPort=proxyUrl.split(""String_Node_Str"");
  if (hostAndPort.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String host=hostAndPort[0];
  int port;
  try {
    port=Integer.parseInt(hostAndPort[1]);
  }
 catch (  final NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  final HttpHost proxy=new HttpHost(host,port);
  LOG.info(""String_Node_Str"",proxy.getHostName(),proxy.getPort());
  httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
}",0.9984939759036144
18011,"private void appendAtomMandatoryParts(final XMLStreamWriter writer,final EntityInfoAggregator eia,final Map<String,Object> data) throws EntityProviderException {
  try {
    writer.writeStartElement(FormatXml.ATOM_ID);
    location=properties.getServiceRoot().toASCIIString() + createSelfLink(eia,data,null);
    writer.writeCharacters(location);
    writer.writeEndElement();
    writer.writeStartElement(FormatXml.ATOM_TITLE);
    writer.writeAttribute(FormatXml.M_TYPE,""String_Node_Str"");
    EntityPropertyInfo titleInfo=eia.getTargetPathInfo(EdmTargetPath.SYNDICATION_TITLE);
    if (titleInfo != null) {
      EdmSimpleType st=(EdmSimpleType)titleInfo.getType();
      Object object=data.get(titleInfo.getName());
      String title=st.valueToString(object,EdmLiteralKind.DEFAULT,titleInfo.getFacets());
      writer.writeCharacters(title);
    }
 else {
      writer.writeCharacters(eia.getEntitySetName());
    }
    writer.writeEndElement();
    writer.writeStartElement(FormatXml.ATOM_UPDATED);
    Object updateDate=null;
    EdmFacets updateFacets=null;
    EntityPropertyInfo updatedInfo=eia.getTargetPathInfo(EdmTargetPath.SYNDICATION_UPDATED);
    if (updatedInfo != null) {
      updateDate=data.get(updatedInfo.getName());
      if (updateDate != null) {
        updateFacets=updatedInfo.getFacets();
      }
    }
    if (updateDate == null) {
      updateDate=new Date();
    }
    writer.writeCharacters(EdmDateTimeOffset.getInstance().valueToString(updateDate,EdmLiteralKind.DEFAULT,updateFacets));
    writer.writeEndElement();
  }
 catch (  XMLStreamException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
catch (  EdmSimpleTypeException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
}","private void appendAtomMandatoryParts(final XMLStreamWriter writer,final EntityInfoAggregator eia,final Map<String,Object> data) throws EntityProviderException {
  try {
    writer.writeStartElement(FormatXml.ATOM_ID);
    location=properties.getServiceRoot().toASCIIString() + createSelfLink(eia,data,null);
    writer.writeCharacters(location);
    writer.writeEndElement();
    writer.writeStartElement(FormatXml.ATOM_TITLE);
    writer.writeAttribute(FormatXml.M_TYPE,""String_Node_Str"");
    EntityPropertyInfo titleInfo=eia.getTargetPathInfo(EdmTargetPath.SYNDICATION_TITLE);
    if (titleInfo != null) {
      EdmSimpleType st=(EdmSimpleType)titleInfo.getType();
      Object object=data.get(titleInfo.getName());
      String title=st.valueToString(object,EdmLiteralKind.DEFAULT,titleInfo.getFacets());
      if (title != null) {
        writer.writeCharacters(title);
      }
    }
 else {
      writer.writeCharacters(eia.getEntitySetName());
    }
    writer.writeEndElement();
    writer.writeStartElement(FormatXml.ATOM_UPDATED);
    Object updateDate=null;
    EdmFacets updateFacets=null;
    EntityPropertyInfo updatedInfo=eia.getTargetPathInfo(EdmTargetPath.SYNDICATION_UPDATED);
    if (updatedInfo != null) {
      updateDate=data.get(updatedInfo.getName());
      if (updateDate != null) {
        updateFacets=updatedInfo.getFacets();
      }
    }
    if (updateDate == null) {
      updateDate=new Date();
    }
    writer.writeCharacters(EdmDateTimeOffset.getInstance().valueToString(updateDate,EdmLiteralKind.DEFAULT,updateFacets));
    writer.writeEndElement();
  }
 catch (  XMLStreamException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
catch (  EdmSimpleTypeException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
}",0.989713650264109
18012,"public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new RuntimeException(""String_Node_Str"" + waitMS);
  }
}","public static void crossProcessLockAcquire(final Class<?> c,final long waitMS){
  RandomAccessFile randomAccessFile=null;
  if ((fileLock == null) && (c != null) && (waitMS > 0)) {
    try {
      final long dropDeadTime=System.currentTimeMillis() + waitMS;
      final File file=new File(lockTempDir,c.getName() + ""String_Node_Str"");
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      final FileChannel fileChannel=randomAccessFile.getChannel();
      while (System.currentTimeMillis() < dropDeadTime) {
        fileLock=fileChannel.tryLock();
        if (fileLock != null) {
          break;
        }
        Thread.sleep(250);
      }
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
  }
  if (fileLock == null) {
    throw new ProcessLockerRuntimeException(""String_Node_Str"" + waitMS);
  }
}",0.9923213230950976
18013,"public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new RuntimeException(e);
    }
  }
}","public static void crossProcessLockRelease(){
  if (fileLock != null) {
    try {
      fileLock.release();
      fileLock=null;
    }
 catch (    final IOException e) {
      throw new ProcessLockerRuntimeException(e);
    }
  }
}",0.9710467706013364
18014,"public void stopServer(){
  try {
    if (server != null) {
      FitStaticServiceFactory.unbindService(this);
      server.stop();
      log.trace(""String_Node_Str"" + getEndpoint().toASCIIString());
    }
  }
 catch (  final Exception e) {
    throw new ServerException(e);
  }
}","public void stopServer(){
  try {
    if (server != null) {
      FitStaticServiceFactory.unbindService(this);
      server.stop();
      log.trace(""String_Node_Str"" + getEndpoint().toASCIIString());
    }
  }
 catch (  final Exception e) {
    throw new ServerRuntimeException(e);
  }
}",0.9876543209876544
18015,"private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType,String entityName) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  HashMap<String,String> embeddableKey=new HashMap<String,String>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length > 1) {
        jpaEmbeddableKeyObjectMap.put(propertyName,propertyClass);
        embeddableKey.put(propertyName,name);
      }
 else       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  if (!embeddableKey.isEmpty()) {
    jpaEmbeddableKeyMap.put(jpaEntity.getClass().getName(),embeddableKey);
  }
  return setters;
}","private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  HashMap<String,String> embeddableKey=new HashMap<String,String>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length > 1) {
        jpaEmbeddableKeyObjectMap.put(propertyName,propertyClass);
        embeddableKey.put(propertyName,name);
      }
 else       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  if (!embeddableKey.isEmpty()) {
    jpaEmbeddableKeyMap.put(jpaEntity.getClass().getName(),embeddableKey);
  }
  return setters;
}",0.9966279505432748
18016,"@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType,entityName));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  HashMap<String,String> embeddableKeys=jpaEmbeddableKeyMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue instanceof java.util.GregorianCalendar) {
        propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
      }
      if (method != null) {
        if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
          Object complexObject=jpaComplexObjectMap.get(propertyName);
          parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
          setters.get(key).invoke(jpaEntity,complexObject);
        }
 else         setters.get(key).invoke(jpaEntity,propertyValue);
      }
    }
    if (embeddableKeys != null) {
      Object embeddableKeyObj=null;
      Method method=null;
      for (      String key : embeddableKeys.keySet()) {
        String name=embeddableKeys.get(key);
        String[] nameParts=name.split(""String_Node_Str"");
        Object propertyValue=jpaEntity;
        Class<?> propertyClass=null;
        try {
          for (          EntityType<?> entity : metamodel.getEntities()) {
            if (entity.getName().equals(entityName)) {
              Attribute<?,?> attribute=entity.getAttribute(nameParts[0].substring(3,4).toLowerCase() + nameParts[0].substring(4));
              propertyClass=attribute.getJavaType();
              if (embeddableKeyObj == null) {
                try {
                  embeddableKeyObj=propertyClass.newInstance();
                }
 catch (                InstantiationException e) {
                  throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
                }
              }
              break;
            }
          }
          method=propertyValue.getClass().getMethod(nameParts[0],propertyClass);
          populateEmbeddableKey(embeddableKeyObj,key,nameParts[1],propertyValueMap);
        }
 catch (        NoSuchMethodException e) {
          throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
        }
      }
      method.invoke(jpaEntity,embeddableKeyObj);
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  HashMap<String,String> embeddableKeys=jpaEmbeddableKeyMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue instanceof java.util.GregorianCalendar) {
        propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
      }
      if (method != null) {
        if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
          Object complexObject=jpaComplexObjectMap.get(propertyName);
          parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
          setters.get(key).invoke(jpaEntity,complexObject);
        }
 else         setters.get(key).invoke(jpaEntity,propertyValue);
      }
    }
    if (embeddableKeys != null) {
      Object embeddableKeyObj=null;
      Method method=null;
      for (      String key : embeddableKeys.keySet()) {
        String name=embeddableKeys.get(key);
        String[] nameParts=name.split(""String_Node_Str"");
        Object propertyValue=jpaEntity;
        Class<?> propertyClass=null;
        try {
          for (          EntityType<?> entity : metamodel.getEntities()) {
            if (entity.getName().equals(entityName)) {
              Attribute<?,?> attribute=entity.getAttribute(nameParts[0].substring(3,4).toLowerCase() + nameParts[0].substring(4));
              propertyClass=attribute.getJavaType();
              if (embeddableKeyObj == null) {
                try {
                  embeddableKeyObj=propertyClass.newInstance();
                }
 catch (                InstantiationException e) {
                  throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
                }
              }
              break;
            }
          }
          method=propertyValue.getClass().getMethod(nameParts[0],propertyClass);
          populateEmbeddableKey(embeddableKeyObj,key,nameParts[1],propertyValueMap);
        }
 catch (        NoSuchMethodException e) {
          throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
        }
      }
      method.invoke(jpaEntity,embeddableKeyObj);
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.998625858838226
18017,"private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType,String entityName) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length == 1)       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return setters;
}","private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length == 1)       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return setters;
}",0.9961848240779992
18018,"@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType,entityName));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue != null) {
        if (propertyValue instanceof java.util.GregorianCalendar) {
          propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
        }
        if (method != null) {
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            Object complexObject=jpaComplexObjectMap.get(propertyName);
            parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
            setters.get(key).invoke(jpaEntity,complexObject);
          }
 else           setters.get(key).invoke(jpaEntity,propertyValue);
        }
      }
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  List<EdmProperty> keyProperties=null;
  if (edmEntityType instanceof EdmEntityType) {
    try {
      keyProperties=((EdmEntityType)edmEntityType).getKeyProperties();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
    }
  }
  boolean isKeyProperty=false;
  try {
    for (    String key : setters.keySet()) {
      isKeyProperty=false;
      if (keyProperties != null) {
        for (        EdmProperty keyProperty : keyProperties) {
          if (keyProperty.getName().equalsIgnoreCase(key)) {
            isKeyProperty=true;
            break;
          }
        }
        if (isKeyProperty) {
          continue;
        }
      }
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue != null) {
        if (propertyValue instanceof java.util.GregorianCalendar) {
          propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
        }
        if (method != null) {
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            Object complexObject=jpaComplexObjectMap.get(propertyName);
            parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue);
            setters.get(key).invoke(jpaEntity,complexObject);
          }
 else           setters.get(key).invoke(jpaEntity,propertyValue);
        }
      }
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.8696728558797524
18019,"public <T>Object build(Object jpaEntity,PutMergePatchUriInfo putUriInfo,InputStream content,String requestContentType) throws ODataJPARuntimeException {
  final EdmEntitySet entitySet=putUriInfo.getTargetEntitySet();
  EdmEntityType entityType=null;
  try {
    entityType=entitySet.getEntityType();
  }
 catch (  EdmException e3) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e3.getMessage()),e3);
  }
  String entityName=null;
  try {
    if (entityType.getMapping() != null && entityType.getMapping().getInternalName() != null) {
      entityName=entityType.getMapping().getInternalName();
    }
 else {
      entityName=entityType.getName();
    }
  }
 catch (  EdmException e1) {
  }
  Set<EntityType<?>> entityTypeSet=this.metamodel.getEntities();
  String currentEntityName=null;
  for (  EntityType<?> entityTypeTemp : entityTypeSet) {
    if (entityTypeTemp.getJavaType().getName().endsWith(""String_Node_Str"" + entityName)) {
      currentEntityName=entityTypeTemp.getName();
      break;
    }
  }
  ODataEntry entryValues=null;
  try {
    entryValues=parseEntry(entitySet,content,requestContentType,false,new HashMap<String,Object>());
  }
 catch (  ODataBadRequestException e1) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e1.getMessage()),e1);
  }
  try {
    Map<String,Object> propertValueMap=entryValues.getProperties();
    parse2JPAEntityValueMap(jpaEntity,entityType,propertValueMap,currentEntityName);
  }
 catch (  ODataJPARuntimeException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","public <T>Object build(Object jpaEntity,PutMergePatchUriInfo putUriInfo,InputStream content,String requestContentType) throws ODataJPARuntimeException {
  final EdmEntitySet entitySet=putUriInfo.getTargetEntitySet();
  EdmEntityType entityType=null;
  try {
    entityType=entitySet.getEntityType();
  }
 catch (  EdmException e3) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e3.getMessage()),e3);
  }
  ODataEntry entryValues=null;
  try {
    entryValues=parseEntry(entitySet,content,requestContentType,false,new HashMap<String,Object>());
  }
 catch (  ODataBadRequestException e1) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e1.getMessage()),e1);
  }
  try {
    Map<String,Object> propertValueMap=entryValues.getProperties();
    parse2JPAEntityValueMap(jpaEntity,entityType,propertValueMap);
  }
 catch (  ODataJPARuntimeException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.7767825152275171
18020,"public JPAUpdateContext(Metamodel metamodel){
  this();
  this.metamodel=metamodel;
}","public JPAUpdateContext(Metamodel metamodel){
  this();
}",0.8028169014084507
18021,"private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType,String entityName) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  HashMap<String,String> embeddableKey=new HashMap<String,String>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length > 1) {
        jpaEmbeddableKeyObjectMap.put(propertyName,propertyClass);
        embeddableKey.put(propertyName,name);
      }
 else       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  if (!embeddableKey.isEmpty()) {
    jpaEmbeddableKeyMap.put(jpaEntity.getClass().getName(),embeddableKey);
  }
  return setters;
}","private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  HashMap<String,String> embeddableKey=new HashMap<String,String>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length > 1) {
        jpaEmbeddableKeyObjectMap.put(propertyName,propertyClass);
        embeddableKey.put(propertyName,name);
      }
 else       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  if (!embeddableKey.isEmpty()) {
    jpaEmbeddableKeyMap.put(jpaEntity.getClass().getName(),embeddableKey);
  }
  return setters;
}",0.9966279505432748
18022,"@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType,entityName));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  HashMap<String,String> embeddableKeys=jpaEmbeddableKeyMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue instanceof java.util.GregorianCalendar) {
        propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
      }
      if (method != null) {
        if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
          Object complexObject=jpaComplexObjectMap.get(propertyName);
          parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
          setters.get(key).invoke(jpaEntity,complexObject);
        }
 else         setters.get(key).invoke(jpaEntity,propertyValue);
      }
    }
    if (embeddableKeys != null) {
      Object embeddableKeyObj=null;
      Method method=null;
      for (      String key : embeddableKeys.keySet()) {
        String name=embeddableKeys.get(key);
        String[] nameParts=name.split(""String_Node_Str"");
        Object propertyValue=jpaEntity;
        Class<?> propertyClass=null;
        try {
          for (          EntityType<?> entity : metamodel.getEntities()) {
            if (entity.getName().equals(entityName)) {
              Attribute<?,?> attribute=entity.getAttribute(nameParts[0].substring(3,4).toLowerCase() + nameParts[0].substring(4));
              propertyClass=attribute.getJavaType();
              if (embeddableKeyObj == null) {
                try {
                  embeddableKeyObj=propertyClass.newInstance();
                }
 catch (                InstantiationException e) {
                  throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
                }
              }
              break;
            }
          }
          method=propertyValue.getClass().getMethod(nameParts[0],propertyClass);
          populateEmbeddableKey(embeddableKeyObj,key,nameParts[1],propertyValueMap);
        }
 catch (        NoSuchMethodException e) {
          throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
        }
      }
      method.invoke(jpaEntity,embeddableKeyObj);
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  HashMap<String,String> embeddableKeys=jpaEmbeddableKeyMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue instanceof java.util.GregorianCalendar) {
        propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
      }
      if (method != null) {
        if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
          Object complexObject=jpaComplexObjectMap.get(propertyName);
          parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
          setters.get(key).invoke(jpaEntity,complexObject);
        }
 else         setters.get(key).invoke(jpaEntity,propertyValue);
      }
    }
    if (embeddableKeys != null) {
      Object embeddableKeyObj=null;
      Method method=null;
      for (      String key : embeddableKeys.keySet()) {
        String name=embeddableKeys.get(key);
        String[] nameParts=name.split(""String_Node_Str"");
        Object propertyValue=jpaEntity;
        Class<?> propertyClass=null;
        try {
          for (          EntityType<?> entity : metamodel.getEntities()) {
            if (entity.getName().equals(entityName)) {
              Attribute<?,?> attribute=entity.getAttribute(nameParts[0].substring(3,4).toLowerCase() + nameParts[0].substring(4));
              propertyClass=attribute.getJavaType();
              if (embeddableKeyObj == null) {
                try {
                  embeddableKeyObj=propertyClass.newInstance();
                }
 catch (                InstantiationException e) {
                  throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
                }
              }
              break;
            }
          }
          method=propertyValue.getClass().getMethod(nameParts[0],propertyClass);
          populateEmbeddableKey(embeddableKeyObj,key,nameParts[1],propertyValueMap);
        }
 catch (        NoSuchMethodException e) {
          throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
        }
      }
      method.invoke(jpaEntity,embeddableKeyObj);
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.998625858838226
18023,"private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType,String entityName) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length == 1)       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return setters;
}","private HashMap<String,Method> getSetters(Object jpaEntity,EdmStructuralType structuralType) throws ODataJPARuntimeException {
  HashMap<String,Method> setters=new HashMap<String,Method>();
  try {
    for (    String propertyName : structuralType.getPropertyNames()) {
      EdmProperty property=(EdmProperty)structuralType.getProperty(propertyName);
      Class<?> propertyClass=null;
      try {
        if (property.getMapping() != null && ((JPAEdmMappingImpl)property.getMapping()).getJPAType() != null) {
          propertyClass=((JPAEdmMappingImpl)property.getMapping()).getJPAType();
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            try {
              if (((JPAEdmMappingImpl)property.getMapping()).getInternalName() != null)               jpaComplexObjectMap.put(((JPAEdmMappingImpl)property.getMapping()).getInternalName(),propertyClass.newInstance());
 else               jpaComplexObjectMap.put(propertyName,propertyClass.newInstance());
            }
 catch (            InstantiationException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
catch (            IllegalAccessException e) {
              throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
            }
          }
        }
 else         propertyClass=EdmTypeConvertor.convertToJavaType(property.getType());
      }
 catch (      ODataJPAModelException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
      }
      String name=getSetterName(property);
      String[] nameParts=name.split(""String_Node_Str"");
      if (nameParts.length == 1)       setters.put(propertyName,jpaEntity.getClass().getMethod(name,propertyClass));
    }
  }
 catch (  NoSuchMethodException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return setters;
}",0.9961848240779992
18024,"@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap,String entityName) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType,entityName));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  try {
    for (    String key : setters.keySet()) {
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue != null) {
        if (propertyValue instanceof java.util.GregorianCalendar) {
          propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
        }
        if (method != null) {
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            Object complexObject=jpaComplexObjectMap.get(propertyName);
            parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue,propertyName);
            setters.get(key).invoke(jpaEntity,complexObject);
          }
 else           setters.get(key).invoke(jpaEntity,propertyValue);
        }
      }
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","@SuppressWarnings(""String_Node_Str"") public final Object parse2JPAEntityValueMap(Object jpaEntity,EdmStructuralType edmEntityType,Map<String,Object> propertyValueMap) throws ODataJPARuntimeException {
  if (jpaEntity == null || edmEntityType == null)   return null;
  String jpaEntityAccessKey=jpaEntity.getClass().getName();
  if (!jpaEntityAccessMap.containsKey(jpaEntityAccessKey))   jpaEntityAccessMap.put(jpaEntityAccessKey,getSetters(jpaEntity,edmEntityType));
  HashMap<String,Method> setters=jpaEntityAccessMap.get(jpaEntityAccessKey);
  List<EdmProperty> keyProperties=null;
  if (edmEntityType instanceof EdmEntityType) {
    try {
      keyProperties=((EdmEntityType)edmEntityType).getKeyProperties();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
    }
  }
  boolean isKeyProperty=false;
  try {
    for (    String key : setters.keySet()) {
      isKeyProperty=false;
      if (keyProperties != null) {
        for (        EdmProperty keyProperty : keyProperties) {
          if (keyProperty.getName().equalsIgnoreCase(key)) {
            isKeyProperty=true;
            break;
          }
        }
        if (isKeyProperty) {
          continue;
        }
      }
      EdmProperty property=(EdmProperty)edmEntityType.getProperty(key);
      String propertyName=null;
      if (property.getMapping() != null && property.getMapping().getInternalName() != null) {
        propertyName=property.getMapping().getInternalName();
      }
 else {
        propertyName=property.getName();
      }
      Method method=setters.get(key);
      Object propertyValue=propertyValueMap.get(key);
      if (propertyValue != null) {
        if (propertyValue instanceof java.util.GregorianCalendar) {
          propertyValue=((java.util.GregorianCalendar)propertyValue).getTime();
        }
        if (method != null) {
          if (property.getType().getKind().equals(EdmTypeKind.COMPLEX)) {
            Object complexObject=jpaComplexObjectMap.get(propertyName);
            parse2JPAEntityValueMap(complexObject,((EdmComplexType)property.getType()),(Map<String,Object>)propertyValue);
            setters.get(key).invoke(jpaEntity,complexObject);
          }
 else           setters.get(key).invoke(jpaEntity,propertyValue);
        }
      }
    }
  }
 catch (  SecurityException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalAccessException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  InvocationTargetException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.8696728558797524
18025,"public <T>Object build(Object jpaEntity,PutMergePatchUriInfo putUriInfo,InputStream content,String requestContentType) throws ODataJPARuntimeException {
  final EdmEntitySet entitySet=putUriInfo.getTargetEntitySet();
  EdmEntityType entityType=null;
  try {
    entityType=entitySet.getEntityType();
  }
 catch (  EdmException e3) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e3.getMessage()),e3);
  }
  String entityName=null;
  try {
    if (entityType.getMapping() != null && entityType.getMapping().getInternalName() != null) {
      entityName=entityType.getMapping().getInternalName();
    }
 else {
      entityName=entityType.getName();
    }
  }
 catch (  EdmException e1) {
  }
  Set<EntityType<?>> entityTypeSet=this.metamodel.getEntities();
  String currentEntityName=null;
  for (  EntityType<?> entityTypeTemp : entityTypeSet) {
    if (entityTypeTemp.getJavaType().getName().endsWith(""String_Node_Str"" + entityName)) {
      currentEntityName=entityTypeTemp.getName();
      break;
    }
  }
  ODataEntry entryValues=null;
  try {
    entryValues=parseEntry(entitySet,content,requestContentType,false,new HashMap<String,Object>());
  }
 catch (  ODataBadRequestException e1) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e1.getMessage()),e1);
  }
  try {
    Map<String,Object> propertValueMap=entryValues.getProperties();
    parse2JPAEntityValueMap(jpaEntity,entityType,propertValueMap,currentEntityName);
  }
 catch (  ODataJPARuntimeException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}","public <T>Object build(Object jpaEntity,PutMergePatchUriInfo putUriInfo,InputStream content,String requestContentType) throws ODataJPARuntimeException {
  final EdmEntitySet entitySet=putUriInfo.getTargetEntitySet();
  EdmEntityType entityType=null;
  try {
    entityType=entitySet.getEntityType();
  }
 catch (  EdmException e3) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e3.getMessage()),e3);
  }
  ODataEntry entryValues=null;
  try {
    entryValues=parseEntry(entitySet,content,requestContentType,false,new HashMap<String,Object>());
  }
 catch (  ODataBadRequestException e1) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e1.getMessage()),e1);
  }
  try {
    Map<String,Object> propertValueMap=entryValues.getProperties();
    parse2JPAEntityValueMap(jpaEntity,entityType,propertValueMap);
  }
 catch (  ODataJPARuntimeException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return jpaEntity;
}",0.7767825152275171
18026,"public JPAUpdateContext(Metamodel metamodel){
  this();
  this.metamodel=metamodel;
}","public JPAUpdateContext(Metamodel metamodel){
  this();
}",0.8028169014084507
18027,"/** 
 * @param reader
 * @param entitySet
 * @throws XMLStreamException
 * @throws EdmException
 * @throws EntityProviderException
 */
private void readProperties(final XMLStreamReader reader,final EntityInfoAggregator entitySet) throws XMLStreamException, EdmException, EntityProviderException {
  checkAllMandatoryNamespacesAvailable();
  validateNamespace(reader.getName(),Edm.NAMESPACE_M_2007_08);
  if (entitySet.getEntityType().hasStream()) {
    checkCurrentHandledStartTag(FormatXml.M_PROPERTIES);
  }
 else {
    checkCurrentHandledStartTag(ATOM_CONTENT);
  }
  int nextTagEventType=reader.next();
  XmlPropertyConsumer xpc=new XmlPropertyConsumer();
  boolean run=true;
  EntityPropertyInfo property;
  while (run) {
    if (nextTagEventType == XMLStreamConstants.START_ELEMENT) {
      if (isEdmNamespaceProperty(reader)) {
        String name=getValidPropertyName(reader);
        property=getValidatedPropertyInfo(entitySet,name);
        Object value=xpc.readStartedElement(reader,property,typeMappings);
        properties.put(name,value);
      }
    }
 else     if (nextTagEventType == XMLStreamConstants.END_ELEMENT) {
      String name=reader.getLocalName();
      if (M_PROPERTIES.equals(name)) {
        run=false;
      }
    }
    nextTagEventType=reader.next();
  }
}","/** 
 * @param reader
 * @param entitySet
 * @throws XMLStreamException
 * @throws EdmException
 * @throws EntityProviderException
 */
private void readProperties(final XMLStreamReader reader,final EntityInfoAggregator entitySet) throws XMLStreamException, EdmException, EntityProviderException {
  checkAllMandatoryNamespacesAvailable();
  validateNamespace(reader.getName(),Edm.NAMESPACE_M_2007_08);
  if (entitySet.getEntityType().hasStream()) {
    checkCurrentHandledStartTag(FormatXml.M_PROPERTIES);
  }
 else {
    checkCurrentHandledStartTag(ATOM_CONTENT);
  }
  EntityPropertyInfo property;
  String closeTag=null;
  int nextTagEventType=reader.next();
  XmlPropertyConsumer xpc=new XmlPropertyConsumer();
  boolean run=true;
  while (run) {
    if (nextTagEventType == XMLStreamConstants.START_ELEMENT && closeTag == null) {
      closeTag=reader.getLocalName();
      if (isEdmNamespaceProperty(reader)) {
        String name=getValidPropertyName(reader);
        property=getValidatedPropertyInfo(entitySet,name);
        Object value=xpc.readStartedElement(reader,property,typeMappings);
        properties.put(name,value);
        closeTag=null;
      }
    }
 else     if (nextTagEventType == XMLStreamConstants.END_ELEMENT) {
      String name=reader.getLocalName();
      if (M_PROPERTIES.equals(name)) {
        run=false;
      }
 else       if (name.equals(closeTag)) {
        closeTag=null;
      }
    }
    nextTagEventType=reader.next();
  }
}",0.9133744110184848
18028,"/** 
 * Duplicated occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test @Ignore(""String_Node_Str"") public void validationOfDoublePropertyDifferentTagHierachyD_Namespace() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}","/** 
 * Duplicated occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test public void validationOfDoublePropertyDifferentTagHierachyD_Namespace() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}",0.9859007832898172
18029,"public void validate(final EntityInfoAggregator eia,final ODataEntryImpl entry) throws EntityProviderException {
  Collection<EntityPropertyInfo> propertyInfos=eia.getPropertyInfos();
  Map<String,Object> data=entry.getProperties();
  for (  EntityPropertyInfo entityPropertyInfo : propertyInfos) {
    boolean mandatory=entityPropertyInfo.isMandatory();
    if (mandatory) {
      if (!data.containsKey(entityPropertyInfo.getName())) {
        throw new EntityProviderException(EntityProviderException.MISSING_PROPERTY.addContent(entityPropertyInfo.getName()));
      }
    }
  }
}","public void validate(final EntityInfoAggregator eia,final ODataEntryImpl entry) throws EntityProviderException {
  Collection<EntityPropertyInfo> propertyInfos=new ArrayList<EntityPropertyInfo>(eia.getPropertyInfos());
  propertyInfos.removeAll(eia.getKeyPropertyInfos());
  Map<String,Object> data=entry.getProperties();
  for (  EntityPropertyInfo entityPropertyInfo : propertyInfos) {
    boolean mandatory=entityPropertyInfo.isMandatory();
    if (mandatory) {
      if (!data.containsKey(entityPropertyInfo.getName())) {
        throw new EntityProviderException(EntityProviderException.MISSING_PROPERTY.addContent(entityPropertyInfo.getName()));
      }
    }
  }
}",0.8954509177972865
18030,"@Test(expected=EntityProviderException.class) public void validationOfNamespacesMissingD_NamespaceAtRequiredTag() throws Exception {
  String roomWithValidNamespaces=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(roomWithValidNamespaces);
  readAndExpectException(entitySet,reqContent,false,EntityProviderException.MISSING_PROPERTY.addContent(""String_Node_Str""));
}","/** 
 * Missing _d_ namespace at mandatory property/tag (_Version_) results in an exception.
 * @throws Exception
 */
@Test(expected=EntityProviderException.class) public void validationOfNamespacesMissingD_NamespaceAtRequiredTag() throws Exception {
  String roomWithValidNamespaces=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(roomWithValidNamespaces);
  readAndExpectException(entitySet,reqContent,false,EntityProviderException.MISSING_PROPERTY.addContent(""String_Node_Str""));
}",0.8979057591623036
18031,"/** 
 * Duplicated occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test public void validationOfDoublePropertyDifferentTagHierachyD_Namespace() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}","/** 
 * Double occurrence of <code>d:Name</code> tag within an unknown (and hence ignored) property is allowed.
 * @throws Exception
 */
@Test public void validationOfDoublePropertyDifferentTagHierachyD_Namespace() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}",0.9498432601880876
18032,"/** 
 * Duplicated occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test(expected=EntityProviderException.class) public void validationOfDuplicatedPropertyException() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  readAndExpectException(entitySet,reqContent,EntityProviderException.DOUBLE_PROPERTY.addContent(""String_Node_Str""));
}","/** 
 * Double occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test(expected=EntityProviderException.class) public void validationOfDuplicatedPropertyException() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  readAndExpectException(entitySet,reqContent,EntityProviderException.DOUBLE_PROPERTY.addContent(""String_Node_Str""));
}",0.9944873208379272
18033,"/** 
 * Duplicated occurrence of <code>d:Name</code> tag must result in an exception.
 * @throws Exception
 */
@Test public void validationOfDoublePropertyDifferentTagHierachy() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}","/** 
 * Double occurrence of <code>Name</code> tag within ignored/unknown property AND different namespace is allowed.
 * @throws Exception
 */
@Test public void validationOfDoublePropertyDifferentTagHierachy() throws Exception {
  String room=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  EdmEntitySet entitySet=MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet(""String_Node_Str"");
  InputStream reqContent=createContentAsStream(room);
  XmlEntityConsumer xec=new XmlEntityConsumer();
  ODataEntry result=xec.readEntry(entitySet,reqContent,false);
  assertNotNull(result);
}",0.9436545550289626
18034,"private void buildCombinedTree(final ExpandSelectTreeNodeImpl root) throws EdmException {
  for (  SelectItem item : initialSelect) {
    ExpandSelectTreeNodeImpl actualNode=root;
    List<NavigationPropertySegment> segmentsList=item.getNavigationPropertySegments();
    for (int segmentListIndex=0; segmentListIndex < segmentsList.size(); segmentListIndex++) {
      ExpandSelectTreeNodeImpl childNode=null;
      for (      ArrayList<NavigationPropertySegment> singleExpandList : initialExpand) {
        if (singleExpandList.size() > segmentListIndex) {
          boolean ok=true;
          for (int expandListIndex=0; expandListIndex <= segmentListIndex; expandListIndex++) {
            if (!segmentsList.get(expandListIndex).getNavigationProperty().getName().equals(singleExpandList.get(expandListIndex).getNavigationProperty().getName())) {
              ok=false;
              break;
            }
          }
          if (ok) {
            childNode=new ExpandSelectTreeNodeImpl();
            if ((item.getProperty() == null && !item.isStar()) && segmentListIndex == segmentsList.size() - 1) {
              ExpandSelectTreeNodeImpl expandNodes=childNode;
              for (int expandListIndex=segmentListIndex + 1; expandListIndex < singleExpandList.size(); expandListIndex++) {
                ExpandSelectTreeNode newNode=new ExpandSelectTreeNodeImpl();
                expandNodes.setAllExplicitly();
                expandNodes=(ExpandSelectTreeNodeImpl)expandNodes.addChild(singleExpandList.get(expandListIndex).getNavigationProperty(),newNode);
              }
            }
            break;
          }
        }
      }
      actualNode=(ExpandSelectTreeNodeImpl)actualNode.addChild(segmentsList.get(segmentListIndex).getNavigationProperty(),childNode);
      if (actualNode == null) {
        break;
      }
    }
    if (actualNode != null) {
      if (item.getProperty() != null) {
        actualNode.addProperty(item.getProperty());
      }
 else       if (item.isStar()) {
        actualNode.setAllExplicitly();
      }
    }
  }
}","private void buildCombinedTree(final ExpandSelectTreeNodeImpl root) throws EdmException {
  for (  SelectItem item : initialSelect) {
    ExpandSelectTreeNodeImpl actualNode=root;
    List<NavigationPropertySegment> segmentsList=item.getNavigationPropertySegments();
    for (int segmentListIndex=0; segmentListIndex < segmentsList.size(); segmentListIndex++) {
      ExpandSelectTreeNodeImpl childNode=null;
      for (      ArrayList<NavigationPropertySegment> singleExpandList : initialExpand) {
        if (singleExpandList.size() > segmentListIndex) {
          boolean ok=true;
          for (int expandListIndex=0; expandListIndex <= segmentListIndex; expandListIndex++) {
            if (!segmentsList.get(expandListIndex).getNavigationProperty().getName().equals(singleExpandList.get(expandListIndex).getNavigationProperty().getName())) {
              ok=false;
              break;
            }
          }
          if (ok) {
            childNode=new ExpandSelectTreeNodeImpl();
            if ((item.getProperty() == null && !item.isStar()) && segmentListIndex == segmentsList.size() - 1) {
              ExpandSelectTreeNodeImpl expandNodes=childNode;
              expandNodes.setAllExplicitly();
              for (int expandListIndex=segmentListIndex + 1; expandListIndex < singleExpandList.size(); expandListIndex++) {
                ExpandSelectTreeNodeImpl newNode=new ExpandSelectTreeNodeImpl();
                newNode.setAllExplicitly();
                expandNodes=(ExpandSelectTreeNodeImpl)expandNodes.addChild(singleExpandList.get(expandListIndex).getNavigationProperty(),newNode);
              }
            }
            actualNode.addChild(segmentsList.get(segmentListIndex).getNavigationProperty(),childNode);
          }
        }
      }
      actualNode=(ExpandSelectTreeNodeImpl)actualNode.addChild(segmentsList.get(segmentListIndex).getNavigationProperty(),childNode);
      if (actualNode == null) {
        break;
      }
    }
    if (actualNode != null) {
      if (item.getProperty() != null) {
        actualNode.addProperty(item.getProperty());
      }
 else       if (item.isStar()) {
        actualNode.setAllExplicitly();
      }
    }
  }
}",0.9265882352941176
18035,"@Override public boolean isAll(){
  return (isAll == null) || isAll;
}","@Override public boolean isAll(){
  return isAll.getBoolean();
}",0.7910447761194029
18036,"public void addProperty(final EdmProperty property){
  if (isAll == null) {
    isAll=false;
  }
  if (!isAll && !properties.contains(property)) {
    properties.add(property);
  }
}","public void addProperty(final EdmProperty property){
  if (isAll == AllKinds.IMPLICITLYTRUE) {
    isAll=AllKinds.FALSE;
  }
  if (isAll != AllKinds.EXPLICITLYTRUE && !properties.contains(property)) {
    properties.add(property);
  }
}",0.7511961722488039
18037,"public ExpandSelectTreeNode addChild(final EdmNavigationProperty navigationProperty,final ExpandSelectTreeNode childNode){
  if (isAll == null) {
    isAll=false;
  }
  if (links.containsKey(navigationProperty)) {
    ExpandSelectTreeNodeImpl existingNode=(ExpandSelectTreeNodeImpl)links.get(navigationProperty);
    if (existingNode != childNode && childNode != null) {
      if (existingNode.isAll() || childNode.isAll()) {
        existingNode.setAllExplicitly();
        for (        Map.Entry<EdmNavigationProperty,ExpandSelectTreeNode> entry : childNode.getLinks().entrySet()) {
          if (entry.getValue() != null) {
            existingNode.addChild(entry.getKey(),entry.getValue());
          }
        }
      }
 else {
        for (        EdmProperty property : childNode.getProperties()) {
          existingNode.addProperty(property);
        }
        for (        Map.Entry<EdmNavigationProperty,ExpandSelectTreeNode> entry : childNode.getLinks().entrySet()) {
          existingNode.addChild(entry.getKey(),entry.getValue());
        }
      }
    }
    return existingNode;
  }
  if (isAll && childNode == null) {
    return null;
  }
  links.put(navigationProperty,childNode);
  return childNode;
}","public ExpandSelectTreeNode addChild(final EdmNavigationProperty navigationProperty,final ExpandSelectTreeNode childNode){
  if (isAll == AllKinds.IMPLICITLYTRUE) {
    isAll=AllKinds.FALSE;
  }
  if (links.containsKey(navigationProperty)) {
    ExpandSelectTreeNodeImpl existingNode=(ExpandSelectTreeNodeImpl)links.get(navigationProperty);
    ExpandSelectTreeNodeImpl childNodeInternal=(ExpandSelectTreeNodeImpl)childNode;
    if (existingNode != childNode && childNode != null) {
      if (existingNode.isAllInternal() == AllKinds.EXPLICITLYTRUE || childNodeInternal.isAllInternal() == AllKinds.EXPLICITLYTRUE) {
        existingNode.setAllExplicitly();
        for (        Map.Entry<EdmNavigationProperty,ExpandSelectTreeNode> entry : childNode.getLinks().entrySet()) {
          if (entry.getValue() != null) {
            existingNode.addChild(entry.getKey(),entry.getValue());
          }
        }
      }
 else {
        for (        EdmProperty property : childNode.getProperties()) {
          existingNode.addProperty(property);
        }
        for (        Map.Entry<EdmNavigationProperty,ExpandSelectTreeNode> entry : childNode.getLinks().entrySet()) {
          existingNode.addChild(entry.getKey(),entry.getValue());
        }
      }
    }
    return existingNode;
  }
  if (isAll != AllKinds.FALSE && childNode == null) {
    return null;
  }
  links.put(navigationProperty,childNode);
  return childNode;
}",0.9116314199395772
18038,"public void setAllExplicitly(){
  isAll=true;
  properties.clear();
  Iterator<EdmNavigationProperty> iterator=links.keySet().iterator();
  while (iterator.hasNext()) {
    EdmNavigationProperty navProp=iterator.next();
    if (links.get(navProp) == null) {
      iterator.remove();
    }
  }
}","public void setAllExplicitly(){
  isAll=AllKinds.EXPLICITLYTRUE;
  properties.clear();
  Iterator<EdmNavigationProperty> iterator=links.keySet().iterator();
  while (iterator.hasNext()) {
    EdmNavigationProperty navProp=iterator.next();
    if (links.get(navProp) == null) {
      iterator.remove();
    }
  }
}",0.9555189456342668
18039,"private ContentType doContentNegotiationForFormat(final UriInfoImpl uriInfo) throws ODataException {
  ContentType formatContentType=mapFormat(uriInfo);
  formatContentType=ensureCharsetIsSet(formatContentType);
  final Class<? extends ODataProcessor> processorFeature=dispatcher.mapUriTypeToProcessorFeature(uriInfo);
  final List<ContentType> supportedContentTypes=getSupportedContentTypes(processorFeature);
  for (  final ContentType contentType : supportedContentTypes) {
    if (contentType.equals(formatContentType)) {
      return formatContentType;
    }
  }
  throw new ODataNotAcceptableException(ODataNotAcceptableException.NOT_SUPPORTED_CONTENT_TYPE.addContent(uriInfo.getFormat()));
}","private ContentType doContentNegotiationForFormat(final UriInfoImpl uriInfo) throws ODataException {
  validateFormatQuery(uriInfo);
  ContentType formatContentType=mapFormat(uriInfo);
  formatContentType=ensureCharsetIsSet(formatContentType);
  final Class<? extends ODataProcessor> processorFeature=dispatcher.mapUriTypeToProcessorFeature(uriInfo);
  final List<ContentType> supportedContentTypes=getSupportedContentTypes(processorFeature);
  for (  final ContentType contentType : supportedContentTypes) {
    if (contentType.equals(formatContentType)) {
      return formatContentType;
    }
  }
  throw new ODataNotAcceptableException(ODataNotAcceptableException.NOT_SUPPORTED_CONTENT_TYPE.addContent(uriInfo.getFormat()));
}",0.9775910364145658
18040,"private String createLineForJiraTable(Set<TestResult> results){
  final StringBuilder b=new StringBuilder(SEPARATOR);
  append(b,buildUriForJira(results));
  boolean acceptHeaderUnwritten=true;
  for (  final TestResult result : results) {
    if (acceptHeaderUnwritten) {
      append(b,result.getRequestHeader(HttpHeaders.ACCEPT));
      acceptHeaderUnwritten=false;
    }
    append(b,result.getResponseHeader(HttpHeaders.CONTENT_TYPE));
    append(b,result.getSomeValue(""String_Node_Str""));
  }
  b.append(""String_Node_Str"");
  return b.toString();
}","private String createLineForJiraTable(Set<TestResult> results){
  final StringBuilder b=new StringBuilder(SEPARATOR);
  append(b,buildUriForJira(results));
  boolean acceptHeaderUnwritten=true;
  for (  final TestResult result : results) {
    if (acceptHeaderUnwritten) {
      append(b,result.getRequestHeader(HttpHeaders.ACCEPT));
      acceptHeaderUnwritten=false;
    }
    append(b,result.getResponseHeader(HttpHeaders.CONTENT_TYPE));
    append(b,result.getSomeValue(RESPONSE_STATUS_CODE));
  }
  b.append(""String_Node_Str"");
  return b.toString();
}",0.8874887488748875
18041,"public String getRequestHeader(String name){
  return reqHeaders.get(name);
}","public String getRequestHeader(String name){
  return reqHeaders.get(normalizeHeaderName(name));
}",0.88
18042,"public void addResponseHeader(String name,String value){
  resHeaders.put(name,value);
}","public void addResponseHeader(String name,String value){
  resHeaders.put(normalizeHeaderName(name),value);
}",0.8934010152284264
18043,"public void addRequestHeader(String name,String value){
  reqHeaders.put(name,value);
}","public void addRequestHeader(String name,String value){
  reqHeaders.put(normalizeHeaderName(name),value);
}",0.8923076923076924
18044,"public String getResponseHeader(String name){
  return resHeaders.get(name);
}","public String getResponseHeader(String name){
  return resHeaders.get(normalizeHeaderName(name));
}",0.8813559322033898
18045,"/** 
 * @see ServiceDocumentProcessor
 */
@Override public ODataResponse readServiceDocument(GetServiceDocumentUriInfo uriInfo,String contentType) throws ODataException {
  final Edm entityDataModel=getContext().getService().getEntityDataModel();
  final String serviceRoot=getContext().getPathInfo().getServiceRoot().toASCIIString();
  final ODataResponse response=EntityProvider.writeServiceDocument(contentType,entityDataModel,serviceRoot);
  final ODataResponseBuilder odataResponseBuilder=ODataResponse.fromResponse(response).header(ODataHttpHeaders.DATASERVICEVERSION,ODataServiceVersion.V10);
  if (!(contentType.equals(response.getContentHeader()) || (contentType.contains(""String_Node_Str"") && response.getContentHeader().contains(""String_Node_Str"")))) {
    odataResponseBuilder.contentHeader(contentType);
  }
  return odataResponseBuilder.build();
}","/** 
 * @see ServiceDocumentProcessor
 */
@Override public ODataResponse readServiceDocument(GetServiceDocumentUriInfo uriInfo,String contentType) throws ODataException {
  final Edm entityDataModel=getContext().getService().getEntityDataModel();
  final String serviceRoot=getContext().getPathInfo().getServiceRoot().toASCIIString();
  final ODataResponse response=EntityProvider.writeServiceDocument(contentType,entityDataModel,serviceRoot);
  final ODataResponseBuilder odataResponseBuilder=ODataResponse.fromResponse(response).header(ODataHttpHeaders.DATASERVICEVERSION,ODataServiceVersion.V10);
  if (isContentTypeUpdateNecessary(contentType,response)) {
    odataResponseBuilder.contentHeader(contentType);
  }
  return odataResponseBuilder.build();
}",0.823238566131026
18046,"@Override public List<String> getSupportedContentTypes(Class<? extends ODataProcessor> processorFeature) throws ODataException {
  List<String> result=new ArrayList<String>();
  if (processor instanceof CustomContentType) {
    result.addAll(((CustomContentType)processor).getCustomContentTypes(processorFeature));
  }
  if (processorFeature == BatchProcessor.class) {
    result.add(HttpContentType.MULTIPART_MIXED);
  }
 else   if (processorFeature == EntityProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_XML_ENTRY_UTF8);
    result.add(HttpContentType.APPLICATION_ATOM_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == FunctionImportProcessor.class || processorFeature == EntityLinkProcessor.class || processorFeature == EntityLinksProcessor.class || processorFeature == EntitySimplePropertyProcessor.class || processorFeature == EntityComplexPropertyProcessor.class) {
    result.add(HttpContentType.APPLICATION_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
  }
 else   if (processorFeature == EntityMediaProcessor.class || processorFeature == EntitySimplePropertyValueProcessor.class || processorFeature == FunctionImportValueProcessor.class) {
    result.add(HttpContentType.WILDCARD);
  }
 else   if (processorFeature == EntitySetProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_XML_FEED_UTF8);
    result.add(HttpContentType.APPLICATION_ATOM_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == MetadataProcessor.class) {
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == ServiceDocumentProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_SVC_UTF8);
    result.add(HttpContentType.APPLICATION_ATOM_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else {
    throw new ODataNotImplementedException();
  }
  return result;
}","@Override public List<String> getSupportedContentTypes(Class<? extends ODataProcessor> processorFeature) throws ODataException {
  List<String> result=new ArrayList<String>();
  if (processor instanceof CustomContentType) {
    result.addAll(((CustomContentType)processor).getCustomContentTypes(processorFeature));
  }
  if (processorFeature == BatchProcessor.class) {
    result.add(HttpContentType.MULTIPART_MIXED);
  }
 else   if (processorFeature == EntityProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_XML_ENTRY_UTF8);
    result.add(HttpContentType.APPLICATION_ATOM_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == FunctionImportProcessor.class || processorFeature == EntityLinkProcessor.class || processorFeature == EntityLinksProcessor.class || processorFeature == EntitySimplePropertyProcessor.class || processorFeature == EntityComplexPropertyProcessor.class) {
    result.add(HttpContentType.APPLICATION_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
  }
 else   if (processorFeature == EntityMediaProcessor.class || processorFeature == EntitySimplePropertyValueProcessor.class || processorFeature == FunctionImportValueProcessor.class) {
    result.add(HttpContentType.WILDCARD);
  }
 else   if (processorFeature == EntitySetProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_XML_FEED_UTF8);
    result.add(HttpContentType.APPLICATION_ATOM_XML_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == MetadataProcessor.class) {
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else   if (processorFeature == ServiceDocumentProcessor.class) {
    result.add(HttpContentType.APPLICATION_ATOM_SVC_UTF8);
    result.add(HttpContentType.APPLICATION_JSON_UTF8);
    result.add(HttpContentType.APPLICATION_XML_UTF8);
  }
 else {
    throw new ODataNotImplementedException();
  }
  return result;
}",0.960209673576364
18047,"private ContentType mapFormat(final UriInfoImpl uriInfo){
  String format=uriInfo.getFormat();
  if (""String_Node_Str"".equals(format)) {
    return ContentType.APPLICATION_XML;
  }
 else   if (""String_Node_Str"".equals(format)) {
    return ContentType.APPLICATION_ATOM_XML;
  }
 else   if (""String_Node_Str"".equals(format)) {
    return ContentType.APPLICATION_JSON;
  }
  return ContentType.create(format);
}","private ContentType mapFormat(final UriInfoImpl uriInfo){
  String format=uriInfo.getFormat();
  if (""String_Node_Str"".equals(format)) {
    return ContentType.APPLICATION_XML;
  }
 else   if (""String_Node_Str"".equals(format)) {
    if (uriInfo.getUriType() == UriType.URI0) {
      return ContentType.APPLICATION_ATOM_SVC;
    }
    return ContentType.APPLICATION_ATOM_XML;
  }
 else   if (""String_Node_Str"".equals(format)) {
    return ContentType.APPLICATION_JSON;
  }
  return ContentType.create(format);
}",0.8900979325353645
18048,"@Override ODataSingleProcessor createProcessor() throws ODataException {
  final String contentType=HttpContentType.APPLICATION_ATOM_XML_UTF8;
  final ODataResponse responseAtomXml=ODataResponse.status(HttpStatusCodes.OK).contentHeader(contentType).entity(""String_Node_Str"").build();
  when(((ServiceDocumentProcessor)processor).readServiceDocument(any(GetServiceDocumentUriInfo.class),eq(contentType))).thenReturn(responseAtomXml);
  final ODataResponse value=ODataResponse.status(HttpStatusCodes.OK).contentHeader(""String_Node_Str"").build();
  when(((ServiceDocumentProcessor)processor).readServiceDocument(any(GetServiceDocumentUriInfo.class),eq(""String_Node_Str""))).thenReturn(value);
  when(((CustomContentType)processor).getCustomContentTypes(ServiceDocumentProcessor.class)).thenReturn(Arrays.asList(""String_Node_Str""));
  return processor;
}","@Override ODataSingleProcessor createProcessor() throws ODataException {
  final String contentType=""String_Node_Str"";
  final ODataResponse responseAtomXml=ODataResponse.status(HttpStatusCodes.OK).contentHeader(contentType).entity(""String_Node_Str"").build();
  when(((ServiceDocumentProcessor)processor).readServiceDocument(any(GetServiceDocumentUriInfo.class),eq(contentType))).thenReturn(responseAtomXml);
  final ODataResponse value=ODataResponse.status(HttpStatusCodes.OK).contentHeader(""String_Node_Str"").build();
  when(((ServiceDocumentProcessor)processor).readServiceDocument(any(GetServiceDocumentUriInfo.class),eq(""String_Node_Str""))).thenReturn(value);
  when(((CustomContentType)processor).getCustomContentTypes(ServiceDocumentProcessor.class)).thenReturn(Arrays.asList(""String_Node_Str""));
  return processor;
}",0.966547192353644
18049,"@Test public void testAtomFormatForServiceDocument() throws Exception {
  final HttpResponse response=executeGetRequest(""String_Node_Str"");
  final String responseEntity=StringHelper.httpEntityToString(response.getEntity());
  assertEquals(""String_Node_Str"",responseEntity);
  assertEquals(HttpStatusCodes.OK.getStatusCode(),response.getStatusLine().getStatusCode());
  final Header header=response.getFirstHeader(HttpHeaders.CONTENT_TYPE);
  assertEquals(HttpContentType.APPLICATION_ATOM_XML_UTF8,header.getValue());
}","@Test public void testAtomFormatForServiceDocument() throws Exception {
  final HttpResponse response=executeGetRequest(""String_Node_Str"");
  final String responseEntity=StringHelper.httpEntityToString(response.getEntity());
  assertEquals(""String_Node_Str"",responseEntity);
  assertEquals(HttpStatusCodes.OK.getStatusCode(),response.getStatusLine().getStatusCode());
  final Header header=response.getFirstHeader(HttpHeaders.CONTENT_TYPE);
  assertEquals(""String_Node_Str"",header.getValue());
}",0.9447731755424064
18050,"@Test public void serviceDocumentAcceptHeaderAtom() throws Exception {
  HttpResponse response=callUri(""String_Node_Str"",HttpHeaders.ACCEPT,HttpContentType.APPLICATION_ATOM_XML);
  checkMediaType(response,HttpContentType.APPLICATION_ATOM_SVC_UTF8);
  validateXmlServiceDocument(getBody(response));
}","@Test public void serviceDocumentAcceptHeaderAtom() throws Exception {
  final HttpResponse response=callUri(""String_Node_Str"",HttpHeaders.ACCEPT,HttpContentType.APPLICATION_ATOM_XML,HttpStatusCodes.NOT_ACCEPTABLE);
  assertXmlErrorResponse(response);
}",0.6847826086956522
18051,"@Test public void serviceDocumentAcceptHeaderUtf8Atom() throws Exception {
  HttpResponse response=callUri(""String_Node_Str"",HttpHeaders.ACCEPT,HttpContentType.APPLICATION_ATOM_XML_UTF8);
  checkMediaType(response,HttpContentType.APPLICATION_ATOM_SVC_UTF8);
  validateXmlServiceDocument(getBody(response));
}","@Test public void serviceDocumentAcceptHeaderUtf8Atom() throws Exception {
  final HttpResponse response=callUri(""String_Node_Str"",HttpHeaders.ACCEPT,HttpContentType.APPLICATION_ATOM_XML_UTF8,HttpStatusCodes.NOT_ACCEPTABLE);
  assertXmlErrorResponse(response);
}",0.6947368421052632
18052,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final String header=HttpHeaders.ACCEPT;
  final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<TestPath> testPaths=TestPath.createTestPaths(paths,header,headerValues);
  final CallerResultHandler handler=new CallerResultHandler();
  final String localBaseUrl=""String_Node_Str"";
  final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
  AcceptHeaderCaller.create(localConfig).call();
  final String result=handler.getResult();
  System.out.println(result);
}","/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  final List<String> paths=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final String header=HttpHeaders.ACCEPT;
  final List<String> headerValues=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final List<TestPath> testPaths=TestPath.createTestPaths(paths,header,headerValues);
  final CallerResultHandler handler=new CallerResultHandler();
  final String localBaseUrl=""String_Node_Str"";
  final CallerConfig localConfig=new CallerConfig(localBaseUrl,handler,testPaths);
  AcceptHeaderCaller.create(localConfig).call();
  final String result=handler.getResult();
  System.out.println(result);
}",0.9208984375
18053,"@Test public void testGetConsistentEdmComplexTypes(){
  assertEquals(objComplexType.getConsistentEdmComplexTypes().size(),1);
}","@Test public void testGetConsistentEdmComplexTypes(){
  assertTrue(objComplexType.getConsistentEdmComplexTypes().size() > 0);
}",0.9448818897637796
18054,"@Test public void testGetConsistentEdmComplexTypes(){
  assertEquals(objComplexType.getConsistentEdmComplexTypes().size(),1);
}","@Test public void testGetConsistentEdmComplexTypes(){
  assertTrue(objComplexType.getConsistentEdmComplexTypes().size() > 0);
}",0.9448818897637796
18055,"/** 
 * @see ServiceDocumentProcessor
 */
@Override public ODataResponse readServiceDocument(GetServiceDocumentUriInfo uriInfo,String contentType) throws ODataException {
  final Edm entityDataModel=getContext().getService().getEntityDataModel();
  final String serviceRoot=getContext().getPathInfo().getServiceRoot().toASCIIString();
  final ODataResponse response=EntityProvider.writeServiceDocument(contentType,entityDataModel,serviceRoot);
  final ODataResponseBuilder odataResponseBuilder=ODataResponse.fromResponse(response).header(ODataHttpHeaders.DATASERVICEVERSION,Edm.DATA_SERVICE_VERSION_10);
  if (!(contentType.equals(response.getContentHeader()) || (contentType.contains(""String_Node_Str"") && response.getContentHeader().contains(""String_Node_Str"")))) {
    odataResponseBuilder.contentHeader(contentType);
  }
  return odataResponseBuilder.build();
}","/** 
 * @see ServiceDocumentProcessor
 */
@Override public ODataResponse readServiceDocument(GetServiceDocumentUriInfo uriInfo,String contentType) throws ODataException {
  final Edm entityDataModel=getContext().getService().getEntityDataModel();
  final String serviceRoot=getContext().getPathInfo().getServiceRoot().toASCIIString();
  final ODataResponse response=EntityProvider.writeServiceDocument(contentType,entityDataModel,serviceRoot);
  final ODataResponseBuilder odataResponseBuilder=ODataResponse.fromResponse(response).header(ODataHttpHeaders.DATASERVICEVERSION,ODataServiceVersion.V10);
  if (!(contentType.equals(response.getContentHeader()) || (contentType.contains(""String_Node_Str"") && response.getContentHeader().contains(""String_Node_Str"")))) {
    odataResponseBuilder.contentHeader(contentType);
  }
  return odataResponseBuilder.build();
}",0.9756662804171496
18056,"@Override public InputStream getMetadata() throws ODataException {
  if (schemas == null) {
    schemas=edmProvider.getSchemas();
  }
  OutputStreamWriter writer=null;
  CircleStreamBuffer csb=new CircleStreamBuffer();
  try {
    DataServices metadata=new DataServices().setSchemas(schemas).setDataServiceVersion(getDataServiceVersion());
    writer=new OutputStreamWriter(csb.getOutputStream(),""String_Node_Str"");
    EdmMetadata.writeMetadata(metadata,writer);
    return csb.getInputStream();
  }
 catch (  UnsupportedEncodingException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        LOG.error(e.getLocalizedMessage(),e);
      }
    }
  }
}","@Override public InputStream getMetadata() throws ODataException {
  if (schemas == null) {
    schemas=edmProvider.getSchemas();
  }
  OutputStreamWriter writer=null;
  CircleStreamBuffer csb=new CircleStreamBuffer();
  try {
    DataServices metadata=new DataServices().setSchemas(schemas).setDataServiceVersion(getDataServiceVersion());
    writer=new OutputStreamWriter(csb.getOutputStream(),""String_Node_Str"");
    XmlMetadataProducer.writeMetadata(metadata,writer,null);
    return csb.getInputStream();
  }
 catch (  UnsupportedEncodingException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        LOG.error(e.getLocalizedMessage(),e);
      }
    }
  }
}",0.9882060831781502
18057,"@Override public String getDataServiceVersion() throws ODataException {
  if (schemas == null) {
    schemas=edmProvider.getSchemas();
  }
  if (dataServiceVersion == null) {
    dataServiceVersion=Edm.DATA_SERVICE_VERSION_10;
    if (schemas != null) {
      for (      Schema schema : schemas) {
        List<EntityType> entityTypes=schema.getEntityTypes();
        if (entityTypes != null) {
          for (          EntityType entityType : entityTypes) {
            List<Property> properties=entityType.getProperties();
            if (properties != null) {
              for (              Property property : properties) {
                if (property.getCustomizableFeedMappings() != null) {
                  if (property.getCustomizableFeedMappings().getFcKeepInContent() != null) {
                    if (!property.getCustomizableFeedMappings().getFcKeepInContent()) {
                      dataServiceVersion=Edm.DATA_SERVICE_VERSION_20;
                      return dataServiceVersion;
                    }
                  }
                }
              }
              if (entityType.getCustomizableFeedMappings() != null) {
                if (entityType.getCustomizableFeedMappings().getFcKeepInContent() != null) {
                  if (entityType.getCustomizableFeedMappings().getFcKeepInContent()) {
                    dataServiceVersion=Edm.DATA_SERVICE_VERSION_20;
                    return dataServiceVersion;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dataServiceVersion;
}","@Override public String getDataServiceVersion() throws ODataException {
  if (schemas == null) {
    schemas=edmProvider.getSchemas();
  }
  if (dataServiceVersion == null) {
    dataServiceVersion=ODataServiceVersion.V10;
    if (schemas != null) {
      for (      Schema schema : schemas) {
        List<EntityType> entityTypes=schema.getEntityTypes();
        if (entityTypes != null) {
          for (          EntityType entityType : entityTypes) {
            List<Property> properties=entityType.getProperties();
            if (properties != null) {
              for (              Property property : properties) {
                if (property.getCustomizableFeedMappings() != null) {
                  if (property.getCustomizableFeedMappings().getFcKeepInContent() != null) {
                    if (!property.getCustomizableFeedMappings().getFcKeepInContent()) {
                      dataServiceVersion=ODataServiceVersion.V20;
                      return dataServiceVersion;
                    }
                  }
                }
              }
              if (entityType.getCustomizableFeedMappings() != null) {
                if (entityType.getCustomizableFeedMappings().getFcKeepInContent() != null) {
                  if (entityType.getCustomizableFeedMappings().getFcKeepInContent()) {
                    dataServiceVersion=ODataServiceVersion.V20;
                    return dataServiceVersion;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dataServiceVersion;
}",0.9599491417673236
18058,"private static void writeAnnotationAttributes(Collection<AnnotationAttribute> annotationAttributes,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationAttributes != null) {
    for (    AnnotationAttribute annotationAttribute : annotationAttributes) {
      xmlStreamWriter.writeAttribute(annotationAttribute.getPrefix(),annotationAttribute.getNamespace(),annotationAttribute.getName(),annotationAttribute.getText());
      xmlStreamWriter.writeNamespace(annotationAttribute.getPrefix(),annotationAttribute.getNamespace());
    }
  }
}","private static void writeAnnotationAttributes(Collection<AnnotationAttribute> annotationAttributes,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationAttributes != null) {
    ArrayList<String> setNamespaces=new ArrayList<String>();
    for (    AnnotationAttribute annotationAttribute : annotationAttributes) {
      xmlStreamWriter.writeAttribute(annotationAttribute.getPrefix(),annotationAttribute.getNamespace(),annotationAttribute.getName(),annotationAttribute.getText());
      if (!setNamespaces.contains(annotationAttribute.getNamespace())) {
        xmlStreamWriter.writeNamespace(annotationAttribute.getPrefix(),annotationAttribute.getNamespace());
        setNamespaces.add(annotationAttribute.getNamespace());
      }
    }
  }
}",0.8440090429540317
18059,"private static void writeAnnotationElements(Collection<AnnotationElement> annotationElements,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationElements != null) {
    for (    AnnotationElement annotationElement : annotationElements) {
      xmlStreamWriter.writeStartElement(annotationElement.getPrefix(),annotationElement.getName(),annotationElement.getNamespace());
      xmlStreamWriter.writeNamespace(annotationElement.getPrefix(),annotationElement.getNamespace());
      xmlStreamWriter.writeCharacters(annotationElement.getXmlData());
      xmlStreamWriter.writeEndElement();
    }
  }
}","private static void writeAnnotationElements(Collection<AnnotationElement> annotationElements,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationElements != null) {
    ArrayList<String> setNamespaces=new ArrayList<String>();
    for (    AnnotationElement annotationElement : annotationElements) {
      xmlStreamWriter.writeStartElement(annotationElement.getPrefix(),annotationElement.getName(),annotationElement.getNamespace());
      if (!setNamespaces.contains(annotationElement.getNamespace())) {
        xmlStreamWriter.writeNamespace(annotationElement.getPrefix(),annotationElement.getNamespace());
        setNamespaces.add(annotationElement.getNamespace());
      }
      xmlStreamWriter.writeCharacters(annotationElement.getXmlData());
      xmlStreamWriter.writeEndElement();
    }
  }
}",0.859515570934256
18060,"@Test public void testSchemaStructure() throws Exception {
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
}","@Test public void testSchemaStructure() throws Exception {
  System.out.println(metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
}",0.9618138424821002
18061,"@BeforeClass public static void setup() throws Exception {
  EdmImplProv edmImplProv=new EdmImplProv(new EdmProviderMock());
  EdmServiceMetadata serviceMetadata=edmImplProv.getServiceMetadata();
  metadata=StringHelper.inputStreamToString(serviceMetadata.getMetadata());
  Map<String,String> prefixMap=new HashMap<String,String>();
  prefixMap.put(null,""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  NamespaceContext ctx=new SimpleNamespaceContext(prefixMap);
  XMLUnit.setXpathNamespaceContext(ctx);
}","@BeforeClass public static void setup() throws Exception {
  EdmImplProv edmImplProv=new EdmImplProv(new EdmTestProvider());
  EdmServiceMetadata serviceMetadata=edmImplProv.getServiceMetadata();
  metadata=StringHelper.inputStreamToString(serviceMetadata.getMetadata());
  Map<String,String> prefixMap=new HashMap<String,String>();
  prefixMap.put(null,""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  NamespaceContext ctx=new SimpleNamespaceContext(prefixMap);
  XMLUnit.setXpathNamespaceContext(ctx);
}",0.9942363112391932
18062,"private static void writeAnnotationAttributes(Collection<AnnotationAttribute> annotationAttributes,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationAttributes != null) {
    for (    AnnotationAttribute annotationAttribute : annotationAttributes) {
      xmlStreamWriter.writeAttribute(annotationAttribute.getPrefix(),annotationAttribute.getNamespace(),annotationAttribute.getName(),annotationAttribute.getText());
      xmlStreamWriter.writeNamespace(annotationAttribute.getPrefix(),annotationAttribute.getNamespace());
    }
  }
}","private static void writeAnnotationAttributes(Collection<AnnotationAttribute> annotationAttributes,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationAttributes != null) {
    ArrayList<String> setNamespaces=new ArrayList<String>();
    for (    AnnotationAttribute annotationAttribute : annotationAttributes) {
      xmlStreamWriter.writeAttribute(annotationAttribute.getPrefix(),annotationAttribute.getNamespace(),annotationAttribute.getName(),annotationAttribute.getText());
      if (!setNamespaces.contains(annotationAttribute.getNamespace())) {
        xmlStreamWriter.writeNamespace(annotationAttribute.getPrefix(),annotationAttribute.getNamespace());
        setNamespaces.add(annotationAttribute.getNamespace());
      }
    }
  }
}",0.8440090429540317
18063,"private static void writeAnnotationElements(Collection<AnnotationElement> annotationElements,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationElements != null) {
    for (    AnnotationElement annotationElement : annotationElements) {
      xmlStreamWriter.writeStartElement(annotationElement.getPrefix(),annotationElement.getName(),annotationElement.getNamespace());
      xmlStreamWriter.writeNamespace(annotationElement.getPrefix(),annotationElement.getNamespace());
      xmlStreamWriter.writeCharacters(annotationElement.getXmlData());
      xmlStreamWriter.writeEndElement();
    }
  }
}","private static void writeAnnotationElements(Collection<AnnotationElement> annotationElements,XMLStreamWriter xmlStreamWriter) throws XMLStreamException {
  if (annotationElements != null) {
    ArrayList<String> setNamespaces=new ArrayList<String>();
    for (    AnnotationElement annotationElement : annotationElements) {
      xmlStreamWriter.writeStartElement(annotationElement.getPrefix(),annotationElement.getName(),annotationElement.getNamespace());
      if (!setNamespaces.contains(annotationElement.getNamespace())) {
        xmlStreamWriter.writeNamespace(annotationElement.getPrefix(),annotationElement.getNamespace());
        setNamespaces.add(annotationElement.getNamespace());
      }
      xmlStreamWriter.writeCharacters(annotationElement.getXmlData());
      xmlStreamWriter.writeEndElement();
    }
  }
}",0.859515570934256
18064,"@Test public void testSchemaStructure() throws Exception {
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
}","@Test public void testSchemaStructure() throws Exception {
  System.out.println(metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
  assertXpathExists(""String_Node_Str"",metadata);
}",0.9618138424821002
18065,"@BeforeClass public static void setup() throws Exception {
  EdmImplProv edmImplProv=new EdmImplProv(new EdmProviderMock());
  EdmServiceMetadata serviceMetadata=edmImplProv.getServiceMetadata();
  metadata=StringHelper.inputStreamToString(serviceMetadata.getMetadata());
  Map<String,String> prefixMap=new HashMap<String,String>();
  prefixMap.put(null,""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  NamespaceContext ctx=new SimpleNamespaceContext(prefixMap);
  XMLUnit.setXpathNamespaceContext(ctx);
}","@BeforeClass public static void setup() throws Exception {
  EdmImplProv edmImplProv=new EdmImplProv(new EdmTestProvider());
  EdmServiceMetadata serviceMetadata=edmImplProv.getServiceMetadata();
  metadata=StringHelper.inputStreamToString(serviceMetadata.getMetadata());
  Map<String,String> prefixMap=new HashMap<String,String>();
  prefixMap.put(null,""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  NamespaceContext ctx=new SimpleNamespaceContext(prefixMap);
  XMLUnit.setXpathNamespaceContext(ctx);
}",0.9942363112391932
18066,"public static void writeMetadata(DataServices metadata,Writer writer) throws EntityProviderException {
  try {
    XMLStreamWriter xmlStreamWriter=XMLOutputFactory.newInstance().createXMLStreamWriter(writer);
    xmlStreamWriter.writeStartDocument();
    xmlStreamWriter.setPrefix(Edm.PREFIX_EDMX,Edm.NAMESPACE_EDMX_2007_06);
    xmlStreamWriter.setPrefix(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08);
    xmlStreamWriter.setDefaultNamespace(Edm.NAMESPACE_EDM_2008_09);
    xmlStreamWriter.writeStartElement(Edm.NAMESPACE_EDMX_2007_06,""String_Node_Str"");
    xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    xmlStreamWriter.writeNamespace(Edm.PREFIX_EDMX,Edm.NAMESPACE_EDMX_2007_06);
    xmlStreamWriter.writeStartElement(Edm.NAMESPACE_EDMX_2007_06,""String_Node_Str"");
    xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",metadata.getDataServiceVersion());
    xmlStreamWriter.writeNamespace(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08);
    Collection<Schema> schemas=metadata.getSchemas();
    if (schemas != null) {
      for (      Schema schema : schemas) {
        xmlStreamWriter.writeStartElement(""String_Node_Str"");
        if (schema.getAlias() != null) {
          xmlStreamWriter.writeAttribute(""String_Node_Str"",schema.getAlias());
        }
        xmlStreamWriter.writeAttribute(""String_Node_Str"",schema.getNamespace());
        xmlStreamWriter.writeDefaultNamespace(Edm.NAMESPACE_EDM_2008_09);
        writeAnnotationAttributes(schema.getAnnotationAttributes(),xmlStreamWriter);
        Collection<Using> usings=schema.getUsings();
        if (usings != null) {
          for (          Using using : usings) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",using.getNamespace());
            xmlStreamWriter.writeAttribute(""String_Node_Str"",using.getAlias());
            writeAnnotationAttributes(using.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(using.getDocumentation(),xmlStreamWriter);
            writeAnnotationElements(using.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<EntityType> entityTypes=schema.getEntityTypes();
        if (entityTypes != null) {
          for (          EntityType entityType : entityTypes) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",entityType.getName());
            if (entityType.getBaseType() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",entityType.getBaseType().toString());
            }
            if (entityType.isAbstract()) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
            }
            if (entityType.isHasStream()) {
              xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",""String_Node_Str"");
            }
            writeCustomizableFeedMappings(entityType.getCustomizableFeedMappings(),xmlStreamWriter);
            writeAnnotationAttributes(entityType.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(entityType.getDocumentation(),xmlStreamWriter);
            Key key=entityType.getKey();
            if (key != null) {
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              writeAnnotationAttributes(key.getAnnotationAttributes(),xmlStreamWriter);
              Collection<PropertyRef> propertyRefs=entityType.getKey().getKeys();
              for (              PropertyRef propertyRef : propertyRefs) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                writeAnnotationAttributes(propertyRef.getAnnotationAttributes(),xmlStreamWriter);
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                writeAnnotationElements(propertyRef.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(key.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
            }
            Collection<Property> properties=entityType.getProperties();
            if (properties != null) {
              writeProperties(properties,xmlStreamWriter);
            }
            Collection<NavigationProperty> navigationProperties=entityType.getNavigationProperties();
            if (navigationProperties != null) {
              for (              NavigationProperty navigationProperty : navigationProperties) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getRelationship().toString());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getFromRole());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getToRole());
                writeAnnotationAttributes(navigationProperty.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(navigationProperty.getDocumentation(),xmlStreamWriter);
                writeAnnotationElements(navigationProperty.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            writeAnnotationElements(entityType.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<ComplexType> complexTypes=schema.getComplexTypes();
        if (complexTypes != null) {
          for (          ComplexType complexType : complexTypes) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",complexType.getName());
            if (complexType.getBaseType() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",complexType.getBaseType().toString());
            }
            if (complexType.isAbstract()) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
            }
            writeAnnotationAttributes(complexType.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(complexType.getDocumentation(),xmlStreamWriter);
            Collection<Property> properties=complexType.getProperties();
            if (properties != null) {
              writeProperties(properties,xmlStreamWriter);
            }
            writeAnnotationElements(complexType.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<Association> associations=schema.getAssociations();
        if (associations != null) {
          for (          Association association : associations) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",association.getName());
            writeAnnotationAttributes(association.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(association.getDocumentation(),xmlStreamWriter);
            writeAssociationEnd(association.getEnd1(),xmlStreamWriter);
            writeAssociationEnd(association.getEnd2(),xmlStreamWriter);
            ReferentialConstraint referentialConstraint=association.getReferentialConstraint();
            if (referentialConstraint != null) {
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              writeAnnotationAttributes(referentialConstraint.getAnnotationAttributes(),xmlStreamWriter);
              writeDocumentation(referentialConstraint.getDocumentation(),xmlStreamWriter);
              ReferentialConstraintRole principal=referentialConstraint.getPrincipal();
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              xmlStreamWriter.writeAttribute(""String_Node_Str"",principal.getRole());
              writeAnnotationAttributes(principal.getAnnotationAttributes(),xmlStreamWriter);
              for (              PropertyRef propertyRef : principal.getPropertyRefs()) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(principal.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
              ReferentialConstraintRole dependent=referentialConstraint.getPrincipal();
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              xmlStreamWriter.writeAttribute(""String_Node_Str"",dependent.getRole());
              writeAnnotationAttributes(dependent.getAnnotationAttributes(),xmlStreamWriter);
              for (              PropertyRef propertyRef : dependent.getPropertyRefs()) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(dependent.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
              writeAnnotationElements(referentialConstraint.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
            }
            writeAnnotationElements(association.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<EntityContainer> entityContainers=schema.getEntityContainers();
        if (entityContainers != null) {
          for (          EntityContainer entityContainer : entityContainers) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",entityContainer.getName());
            if (entityContainer.getExtendz() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",entityContainer.getExtendz());
            }
            if (entityContainer.isDefaultEntityContainer()) {
              xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",""String_Node_Str"");
            }
            writeAnnotationAttributes(entityContainer.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(entityContainer.getDocumentation(),xmlStreamWriter);
            Collection<EntitySet> entitySets=entityContainer.getEntitySets();
            if (entitySets != null) {
              for (              EntitySet entitySet : entitySets) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",entitySet.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",entitySet.getEntityType().toString());
                writeAnnotationAttributes(entitySet.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(entitySet.getDocumentation(),xmlStreamWriter);
                writeAnnotationElements(entitySet.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            Collection<AssociationSet> associationSets=entityContainer.getAssociationSets();
            if (associationSets != null) {
              for (              AssociationSet associationSet : associationSets) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",associationSet.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",associationSet.getAssociation().toString());
                writeAnnotationAttributes(associationSet.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(associationSet.getDocumentation(),xmlStreamWriter);
                writeAssociationSetEnd(associationSet.getEnd1(),xmlStreamWriter);
                writeAssociationSetEnd(associationSet.getEnd2(),xmlStreamWriter);
                writeAnnotationElements(associationSet.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            Collection<FunctionImport> functionImports=entityContainer.getFunctionImports();
            if (functionImports != null) {
              for (              FunctionImport functionImport : functionImports) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getName());
                if (functionImport.getReturnType() != null) {
                  xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getReturnType().toString());
                }
                if (functionImport.getEntitySet() != null) {
                  xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getEntitySet());
                }
                if (functionImport.getHttpMethod() != null) {
                  xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",functionImport.getHttpMethod());
                }
                writeAnnotationAttributes(functionImport.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(functionImport.getDocumentation(),xmlStreamWriter);
                Collection<FunctionImportParameter> functionImportParameters=functionImport.getParameters();
                if (functionImportParameters != null) {
                  for (                  FunctionImportParameter functionImportParameter : functionImportParameters) {
                    xmlStreamWriter.writeStartElement(""String_Node_Str"");
                    xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getName());
                    xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getType().getFullQualifiedName().toString());
                    if (functionImportParameter.getMode() != null) {
                      xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getMode());
                    }
                    writeFacets(xmlStreamWriter,functionImportParameter.getFacets());
                    writeAnnotationAttributes(functionImportParameter.getAnnotationAttributes(),xmlStreamWriter);
                    writeDocumentation(functionImportParameter.getDocumentation(),xmlStreamWriter);
                    writeAnnotationElements(functionImportParameter.getAnnotationElements(),xmlStreamWriter);
                    xmlStreamWriter.writeEndElement();
                  }
                }
                writeAnnotationElements(functionImport.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            writeAnnotationElements(entityContainer.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        xmlStreamWriter.writeEndElement();
        writeAnnotationElements(schema.getAnnotationElements(),xmlStreamWriter);
      }
    }
    xmlStreamWriter.writeEndElement();
    xmlStreamWriter.writeEndElement();
    xmlStreamWriter.writeEndDocument();
    xmlStreamWriter.flush();
  }
 catch (  XMLStreamException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
catch (  FactoryConfigurationError e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
}","public static void writeMetadata(DataServices metadata,Writer writer) throws EntityProviderException {
  try {
    XMLStreamWriter xmlStreamWriter=XMLOutputFactory.newInstance().createXMLStreamWriter(writer);
    xmlStreamWriter.writeStartDocument();
    xmlStreamWriter.setPrefix(Edm.PREFIX_EDMX,Edm.NAMESPACE_EDMX_2007_06);
    xmlStreamWriter.setPrefix(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08);
    xmlStreamWriter.setDefaultNamespace(Edm.NAMESPACE_EDM_2008_09);
    xmlStreamWriter.writeStartElement(Edm.NAMESPACE_EDMX_2007_06,""String_Node_Str"");
    xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    xmlStreamWriter.writeNamespace(Edm.PREFIX_EDMX,Edm.NAMESPACE_EDMX_2007_06);
    xmlStreamWriter.writeStartElement(Edm.NAMESPACE_EDMX_2007_06,""String_Node_Str"");
    xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",metadata.getDataServiceVersion());
    xmlStreamWriter.writeNamespace(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08);
    Collection<Schema> schemas=metadata.getSchemas();
    if (schemas != null) {
      for (      Schema schema : schemas) {
        xmlStreamWriter.writeStartElement(""String_Node_Str"");
        if (schema.getAlias() != null) {
          xmlStreamWriter.writeAttribute(""String_Node_Str"",schema.getAlias());
        }
        xmlStreamWriter.writeAttribute(""String_Node_Str"",schema.getNamespace());
        xmlStreamWriter.writeDefaultNamespace(Edm.NAMESPACE_EDM_2008_09);
        writeAnnotationAttributes(schema.getAnnotationAttributes(),xmlStreamWriter);
        Collection<Using> usings=schema.getUsings();
        if (usings != null) {
          for (          Using using : usings) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",using.getNamespace());
            xmlStreamWriter.writeAttribute(""String_Node_Str"",using.getAlias());
            writeAnnotationAttributes(using.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(using.getDocumentation(),xmlStreamWriter);
            writeAnnotationElements(using.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<EntityType> entityTypes=schema.getEntityTypes();
        if (entityTypes != null) {
          for (          EntityType entityType : entityTypes) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",entityType.getName());
            if (entityType.getBaseType() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",entityType.getBaseType().toString());
            }
            if (entityType.isAbstract()) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
            }
            if (entityType.isHasStream()) {
              xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",""String_Node_Str"");
            }
            writeCustomizableFeedMappings(entityType.getCustomizableFeedMappings(),xmlStreamWriter);
            writeAnnotationAttributes(entityType.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(entityType.getDocumentation(),xmlStreamWriter);
            Key key=entityType.getKey();
            if (key != null) {
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              writeAnnotationAttributes(key.getAnnotationAttributes(),xmlStreamWriter);
              Collection<PropertyRef> propertyRefs=entityType.getKey().getKeys();
              for (              PropertyRef propertyRef : propertyRefs) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                writeAnnotationAttributes(propertyRef.getAnnotationAttributes(),xmlStreamWriter);
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                writeAnnotationElements(propertyRef.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(key.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
            }
            Collection<Property> properties=entityType.getProperties();
            if (properties != null) {
              writeProperties(properties,xmlStreamWriter);
            }
            Collection<NavigationProperty> navigationProperties=entityType.getNavigationProperties();
            if (navigationProperties != null) {
              for (              NavigationProperty navigationProperty : navigationProperties) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getRelationship().toString());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getFromRole());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",navigationProperty.getToRole());
                writeAnnotationAttributes(navigationProperty.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(navigationProperty.getDocumentation(),xmlStreamWriter);
                writeAnnotationElements(navigationProperty.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            writeAnnotationElements(entityType.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<ComplexType> complexTypes=schema.getComplexTypes();
        if (complexTypes != null) {
          for (          ComplexType complexType : complexTypes) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",complexType.getName());
            if (complexType.getBaseType() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",complexType.getBaseType().toString());
            }
            if (complexType.isAbstract()) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",""String_Node_Str"");
            }
            writeAnnotationAttributes(complexType.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(complexType.getDocumentation(),xmlStreamWriter);
            Collection<Property> properties=complexType.getProperties();
            if (properties != null) {
              writeProperties(properties,xmlStreamWriter);
            }
            writeAnnotationElements(complexType.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<Association> associations=schema.getAssociations();
        if (associations != null) {
          for (          Association association : associations) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",association.getName());
            writeAnnotationAttributes(association.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(association.getDocumentation(),xmlStreamWriter);
            writeAssociationEnd(association.getEnd1(),xmlStreamWriter);
            writeAssociationEnd(association.getEnd2(),xmlStreamWriter);
            ReferentialConstraint referentialConstraint=association.getReferentialConstraint();
            if (referentialConstraint != null) {
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              writeAnnotationAttributes(referentialConstraint.getAnnotationAttributes(),xmlStreamWriter);
              writeDocumentation(referentialConstraint.getDocumentation(),xmlStreamWriter);
              ReferentialConstraintRole principal=referentialConstraint.getPrincipal();
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              xmlStreamWriter.writeAttribute(""String_Node_Str"",principal.getRole());
              writeAnnotationAttributes(principal.getAnnotationAttributes(),xmlStreamWriter);
              for (              PropertyRef propertyRef : principal.getPropertyRefs()) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(principal.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
              ReferentialConstraintRole dependent=referentialConstraint.getDependent();
              xmlStreamWriter.writeStartElement(""String_Node_Str"");
              xmlStreamWriter.writeAttribute(""String_Node_Str"",dependent.getRole());
              writeAnnotationAttributes(dependent.getAnnotationAttributes(),xmlStreamWriter);
              for (              PropertyRef propertyRef : dependent.getPropertyRefs()) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",propertyRef.getName());
                xmlStreamWriter.writeEndElement();
              }
              writeAnnotationElements(dependent.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
              writeAnnotationElements(referentialConstraint.getAnnotationElements(),xmlStreamWriter);
              xmlStreamWriter.writeEndElement();
            }
            writeAnnotationElements(association.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        Collection<EntityContainer> entityContainers=schema.getEntityContainers();
        if (entityContainers != null) {
          for (          EntityContainer entityContainer : entityContainers) {
            xmlStreamWriter.writeStartElement(""String_Node_Str"");
            xmlStreamWriter.writeAttribute(""String_Node_Str"",entityContainer.getName());
            if (entityContainer.getExtendz() != null) {
              xmlStreamWriter.writeAttribute(""String_Node_Str"",entityContainer.getExtendz());
            }
            if (entityContainer.isDefaultEntityContainer()) {
              xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",""String_Node_Str"");
            }
            writeAnnotationAttributes(entityContainer.getAnnotationAttributes(),xmlStreamWriter);
            writeDocumentation(entityContainer.getDocumentation(),xmlStreamWriter);
            Collection<EntitySet> entitySets=entityContainer.getEntitySets();
            if (entitySets != null) {
              for (              EntitySet entitySet : entitySets) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",entitySet.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",entitySet.getEntityType().toString());
                writeAnnotationAttributes(entitySet.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(entitySet.getDocumentation(),xmlStreamWriter);
                writeAnnotationElements(entitySet.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            Collection<AssociationSet> associationSets=entityContainer.getAssociationSets();
            if (associationSets != null) {
              for (              AssociationSet associationSet : associationSets) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",associationSet.getName());
                xmlStreamWriter.writeAttribute(""String_Node_Str"",associationSet.getAssociation().toString());
                writeAnnotationAttributes(associationSet.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(associationSet.getDocumentation(),xmlStreamWriter);
                writeAssociationSetEnd(associationSet.getEnd1(),xmlStreamWriter);
                writeAssociationSetEnd(associationSet.getEnd2(),xmlStreamWriter);
                writeAnnotationElements(associationSet.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            Collection<FunctionImport> functionImports=entityContainer.getFunctionImports();
            if (functionImports != null) {
              for (              FunctionImport functionImport : functionImports) {
                xmlStreamWriter.writeStartElement(""String_Node_Str"");
                xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getName());
                if (functionImport.getReturnType() != null) {
                  xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getReturnType().toString());
                }
                if (functionImport.getEntitySet() != null) {
                  xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImport.getEntitySet());
                }
                if (functionImport.getHttpMethod() != null) {
                  xmlStreamWriter.writeAttribute(Edm.PREFIX_M,Edm.NAMESPACE_M_2007_08,""String_Node_Str"",functionImport.getHttpMethod());
                }
                writeAnnotationAttributes(functionImport.getAnnotationAttributes(),xmlStreamWriter);
                writeDocumentation(functionImport.getDocumentation(),xmlStreamWriter);
                Collection<FunctionImportParameter> functionImportParameters=functionImport.getParameters();
                if (functionImportParameters != null) {
                  for (                  FunctionImportParameter functionImportParameter : functionImportParameters) {
                    xmlStreamWriter.writeStartElement(""String_Node_Str"");
                    xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getName());
                    xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getType().getFullQualifiedName().toString());
                    if (functionImportParameter.getMode() != null) {
                      xmlStreamWriter.writeAttribute(""String_Node_Str"",functionImportParameter.getMode());
                    }
                    writeFacets(xmlStreamWriter,functionImportParameter.getFacets());
                    writeAnnotationAttributes(functionImportParameter.getAnnotationAttributes(),xmlStreamWriter);
                    writeDocumentation(functionImportParameter.getDocumentation(),xmlStreamWriter);
                    writeAnnotationElements(functionImportParameter.getAnnotationElements(),xmlStreamWriter);
                    xmlStreamWriter.writeEndElement();
                  }
                }
                writeAnnotationElements(functionImport.getAnnotationElements(),xmlStreamWriter);
                xmlStreamWriter.writeEndElement();
              }
            }
            writeAnnotationElements(entityContainer.getAnnotationElements(),xmlStreamWriter);
            xmlStreamWriter.writeEndElement();
          }
        }
        xmlStreamWriter.writeEndElement();
        writeAnnotationElements(schema.getAnnotationElements(),xmlStreamWriter);
      }
    }
    xmlStreamWriter.writeEndElement();
    xmlStreamWriter.writeEndElement();
    xmlStreamWriter.writeEndDocument();
    xmlStreamWriter.flush();
  }
 catch (  XMLStreamException e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
catch (  FactoryConfigurationError e) {
    throw new EntityProviderException(EntityProviderException.COMMON,e);
  }
}",0.9994316387748658
18067,"@Test public void testExpandEdmComplexType(){
  ComplexType complexType=new ComplexType();
  List<Property> properties=new ArrayList<Property>();
  properties.add(new SimpleProperty().setName(""String_Node_Str""));
  properties.add(new SimpleProperty().setName(""String_Node_Str""));
  complexType.setProperties(properties);
  List<Property> expandedList=null;
  try {
    objComplexType.expandEdmComplexType(complexType,expandedList);
  }
 catch (  ClassCastException e) {
    assertTrue(false);
  }
  assertTrue(true);
}","@Test public void testExpandEdmComplexType(){
  ComplexType complexType=new ComplexType();
  List<Property> properties=new ArrayList<Property>();
  properties.add(new SimpleProperty().setName(""String_Node_Str""));
  properties.add(new SimpleProperty().setName(""String_Node_Str""));
  complexType.setProperties(properties);
  List<Property> expandedList=null;
  try {
    objComplexType.expandEdmComplexType(complexType,expandedList,""String_Node_Str"");
  }
 catch (  ClassCastException e) {
    assertTrue(false);
  }
  assertTrue(true);
}",0.98292220113852
18068,"private void setValuesToSet(){
  attributeSet.add((Attribute<? super String,String>)new JPAEdmAttribute(java.lang.String.class,""String_Node_Str""));
  attributeSet.add((Attribute<? super String,String>)new JPAEdmAttribute(java.lang.String.class,""String_Node_Str""));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void setValuesToSet(){
  attributeSet.add((Attribute<? super String,String>)new JPAEdmAttribute(java.lang.String.class,""String_Node_Str""));
  attributeSet.add((Attribute<? super String,String>)new JPAEdmAttribute(java.lang.String.class,""String_Node_Str""));
}",0.9032258064516128
18069,"@Override public void expandEdmComplexType(ComplexType arg0,List<Property> arg1){
}","@Override public void expandEdmComplexType(ComplexType complexType,List<Property> expandedPropertyList,String embeddablePropertyName){
}",0.7123287671232876
18070,"@Override public void expandEdmComplexType(ComplexType arg0,List<Property> arg1){
}","@Override public void expandEdmComplexType(ComplexType complexType,List<Property> expandedPropertyList,String embeddablePropertyName){
}",0.7123287671232876
18071,"@Override public Class<ComplexTypeA> getJavaType(){
  return (Class<ComplexTypeA>)JPAEdmMockData.ComplexType.ComplexTypeA.class;
}","@SuppressWarnings(""String_Node_Str"") @Override public Class<ComplexTypeA> getJavaType(){
  return (Class<ComplexTypeA>)JPAEdmMockData.ComplexType.ComplexTypeA.class;
}",0.8754208754208754
18072,"@Override public void addJPAEdmRefConstraintView(JPAEdmReferentialContraintView arg0){
}","@Override public void addJPAEdmRefConstraintView(JPAEdmReferentialConstraintView arg0){
}",0.9943502824858758
18073,"@Override public void addJPAEdmRefConstraintView(JPAEdmReferentialContraintView arg0){
}","@Override public void addJPAEdmRefConstraintView(JPAEdmReferentialConstraintView arg0){
}",0.9943502824858758
18074,"private EdmSimpleType getEdmSimpleTypeMockedObj(String value) throws EdmException {
  EdmSimpleType edmSimpleType=EasyMock.createMock(EdmSimpleType.class);
  EasyMock.expect(edmSimpleType.getName()).andReturn(value);
  EasyMock.expect(edmSimpleType.getKind()).andReturn(EdmTypeKind.SIMPLE).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,null)).andReturn(value).times(10);
  EasyMock.replay(edmSimpleType);
  return edmSimpleType;
}","private EdmSimpleType getEdmSimpleTypeMockedObj(String value) throws EdmException {
  EdmSimpleType edmSimpleType=EasyMock.createMock(EdmSimpleType.class);
  EasyMock.expect(edmSimpleType.getName()).andReturn(value);
  EasyMock.expect(edmSimpleType.getKind()).andReturn(EdmTypeKind.SIMPLE).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,getEdmFacetsMockedObj(),null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,null,null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,null)).andReturn(value).times(10);
  EasyMock.replay(edmSimpleType);
  return edmSimpleType;
}",0.994011976047904
18075,"/** 
 * This method evaluated the where expression for read of an entity based on the keys specified in the query.
 * @param keyPredicates
 * @return the evaluated where expression
 */
public static String parseKeyPredicates(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  String literal=null;
  String propertyName=null;
  EdmSimpleType edmSimpleType=null;
  StringBuilder keyFilters=new StringBuilder();
  int i=0;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    if (i > 0) {
      keyFilters.append(SPACE + JPQLStatement.Operator.AND + SPACE);
    }
    i++;
    literal=keyPredicate.getLiteral();
    try {
      propertyName=keyPredicate.getProperty().getName();
      edmSimpleType=(EdmSimpleType)keyPredicate.getProperty().getType();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    literal=evaluateComparingExpression(literal,edmSimpleType);
    keyFilters.append(tableAlias + DOT + propertyName+ SPACE+ JPQLStatement.Operator.EQ+ SPACE+ literal);
  }
  return keyFilters.toString();
}","/** 
 * This method evaluated the where expression for read of an entity based on the keys specified in the query.
 * @param keyPredicates
 * @return the evaluated where expression
 */
public static String parseKeyPredicates(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  String literal=null;
  String propertyName=null;
  EdmSimpleType edmSimpleType=null;
  StringBuilder keyFilters=new StringBuilder();
  int i=0;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    if (i > 0) {
      keyFilters.append(JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.AND + JPQLStatement.DELIMITER.SPACE);
    }
    i++;
    literal=keyPredicate.getLiteral();
    try {
      propertyName=keyPredicate.getProperty().getMapping().getInternalName();
      edmSimpleType=(EdmSimpleType)keyPredicate.getProperty().getType();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    literal=evaluateComparingExpression(literal,edmSimpleType);
    keyFilters.append(tableAlias + JPQLStatement.DELIMITER.PERIOD + propertyName+ JPQLStatement.DELIMITER.SPACE+ JPQLStatement.Operator.EQ+ JPQLStatement.DELIMITER.SPACE+ literal);
  }
  return keyFilters.toString();
}",0.9281098546042004
18076,"public static HashMap<String,String> parseKeyPredicatesToJPAOrderByExpression(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  String propertyName=null;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    try {
      propertyName=keyPredicate.getProperty().getName();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    orderByMap.put(tableAlias + DOT + propertyName,EMPTY);
  }
  return orderByMap;
}","public static HashMap<String,String> parseKeyPredicatesToJPAOrderByExpression(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  String propertyName=null;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    try {
      propertyName=keyPredicate.getProperty().getMapping().getInternalName();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    orderByMap.put(tableAlias + JPQLStatement.DELIMITER.PERIOD + propertyName,EMPTY);
  }
  return orderByMap;
}",0.961890243902439
18077,"/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + SPACE + JPQLStatement.Operator.AND+ SPACE+ right;
case OR:
return left + SPACE + JPQLStatement.Operator.OR+ SPACE+ right;
case EQ:
return left + SPACE + JPQLStatement.Operator.EQ+ SPACE+ right;
case NE:
return left + SPACE + JPQLStatement.Operator.NE+ SPACE+ right;
case LT:
return left + SPACE + JPQLStatement.Operator.LT+ SPACE+ right;
case LE:
return left + SPACE + JPQLStatement.Operator.LE+ SPACE+ right;
case GT:
return left + SPACE + JPQLStatement.Operator.GT+ SPACE+ right;
case GE:
return left + SPACE + JPQLStatement.Operator.GE+ SPACE+ right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + DOT + ((PropertyExpression)whereExpression).getPropertyName();
return returnStr;
case MEMBER:
final MemberExpression memberExpression=(MemberExpression)whereExpression;
final PropertyExpression propertyExpressionPath=(PropertyExpression)memberExpression.getPath();
return tableAlias + DOT + propertyExpressionPath.getUriLiteral()+ DOT+ memberExpression.getProperty().getUriLiteral();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null,null),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
throw new ODataNotImplementedException();
}
}","/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.AND+ JPQLStatement.DELIMITER.SPACE+ right;
case OR:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.OR+ JPQLStatement.DELIMITER.SPACE+ right;
case EQ:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.EQ+ JPQLStatement.DELIMITER.SPACE+ right;
case NE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.NE+ JPQLStatement.DELIMITER.SPACE+ right;
case LT:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.LT+ JPQLStatement.DELIMITER.SPACE+ right;
case LE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.LE+ JPQLStatement.DELIMITER.SPACE+ right;
case GT:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.GT+ JPQLStatement.DELIMITER.SPACE+ right;
case GE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.GE+ JPQLStatement.DELIMITER.SPACE+ right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + JPQLStatement.DELIMITER.PERIOD + ((EdmProperty)((PropertyExpression)whereExpression).getEdmProperty()).getMapping().getInternalName();
return returnStr;
case MEMBER:
String memberExpStr=EMPTY;
int i=0;
MemberExpression member=null;
CommonExpression tempExp=whereExpression;
while (tempExp != null && tempExp.getKind() == ExpressionKind.MEMBER) {
member=(MemberExpression)tempExp;
if (i > 0) {
memberExpStr=JPQLStatement.DELIMITER.PERIOD + memberExpStr;
}
i++;
memberExpStr=((EdmProperty)((PropertyExpression)member.getProperty()).getEdmProperty()).getMapping().getInternalName() + memberExpStr;
tempExp=member.getPath();
}
memberExpStr=((EdmProperty)((PropertyExpression)tempExp).getEdmProperty()).getMapping().getInternalName() + JPQLStatement.DELIMITER.PERIOD + memberExpStr;
return tableAlias + JPQLStatement.DELIMITER.PERIOD + memberExpStr;
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null,literalType.getDefaultType()),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
throw new ODataNotImplementedException();
}
}",0.8085236854208186
18078,"/** 
 * This method parses the order by condition in the query.
 * @param orderByExpression
 * @return
 * @throws ODataJPARuntimeException
 */
public static HashMap<String,String> parseToJPAOrderByExpression(OrderByExpression orderByExpression,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  if (orderByExpression != null && orderByExpression.getOrders() != null) {
    List<OrderExpression> orderBys=orderByExpression.getOrders();
    String orderByField=null;
    String orderByDirection=null;
    for (    OrderExpression orderBy : orderBys) {
      try {
        orderByField=orderBy.getExpression().getEdmType().getName();
        orderByDirection=(orderBy.getSortOrder() == SortOrder.asc) ? EMPTY : ""String_Node_Str"";
        orderByMap.put(tableAlias + DOT + orderByField,orderByDirection);
      }
 catch (      EdmException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
      }
    }
  }
  return orderByMap;
}","/** 
 * This method parses the order by condition in the query.
 * @param orderByExpression
 * @return
 * @throws ODataJPARuntimeException
 */
public static HashMap<String,String> parseToJPAOrderByExpression(OrderByExpression orderByExpression,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  if (orderByExpression != null && orderByExpression.getOrders() != null) {
    List<OrderExpression> orderBys=orderByExpression.getOrders();
    String orderByField=null;
    String orderByDirection=null;
    for (    OrderExpression orderBy : orderBys) {
      try {
        orderByField=((EdmProperty)((PropertyExpression)orderBy.getExpression()).getEdmProperty()).getMapping().getInternalName();
        orderByDirection=(orderBy.getSortOrder() == SortOrder.asc) ? EMPTY : ""String_Node_Str"";
        orderByMap.put(tableAlias + JPQLStatement.DELIMITER.PERIOD + orderByField,orderByDirection);
      }
 catch (      EdmException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
      }
    }
  }
  return orderByMap;
}",0.9265687583444592
18079,"protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entitySetView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(item.getProperty().getName());
    }
    return selectedFields;
  }
  return null;
}","protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entitySetView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(((EdmProperty)item.getProperty()).getMapping().getInternalName());
    }
    return selectedFields;
  }
  return null;
}",0.9247058823529412
18080,"protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entityView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(item.getProperty().getName());
    }
    return selectedFields;
  }
  return null;
}","protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entityView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(((EdmProperty)item.getProperty()).getMapping().getInternalName());
    }
    return selectedFields;
  }
  return null;
}",0.924170616113744
18081,"private String createJPQLQuery() throws ODataJPARuntimeException {
  StringBuilder jpqlQuery=new StringBuilder();
  String tableAlias=context.getJPAEntityAlias();
  String fromClause=context.getJPAEntityName() + JPQLStatement.DELIMITER.SPACE + tableAlias;
  jpqlQuery.append(JPQLStatement.KEYWORD.SELECT).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(tableAlias).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(JPQLStatement.KEYWORD.FROM).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(fromClause);
  if (context.getWhereExpression() != null) {
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.WHERE).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(context.getWhereExpression());
  }
  if (context.getOrderByCollection() != null && context.getOrderByCollection().size() > 0) {
    StringBuilder orderByBuilder=new StringBuilder();
    Iterator<Entry<String,String>> orderItr=context.getOrderByCollection().entrySet().iterator();
    int i=0;
    while (orderItr.hasNext()) {
      if (i != 0) {
        orderByBuilder.append(JPQLStatement.DELIMITER.SPACE).append(JPQLStatement.DELIMITER.COMMA).append(JPQLStatement.DELIMITER.SPACE);
      }
      Entry<String,String> entry=orderItr.next();
      orderByBuilder.append(tableAlias).append(JPQLStatement.DELIMITER.PERIOD).append(entry.getKey()).append(JPQLStatement.DELIMITER.SPACE);
      orderByBuilder.append(entry.getValue());
      i++;
    }
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.ORDERBY).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(orderByBuilder);
  }
  return jpqlQuery.toString();
}","private String createJPQLQuery() throws ODataJPARuntimeException {
  StringBuilder jpqlQuery=new StringBuilder();
  String tableAlias=context.getJPAEntityAlias();
  String fromClause=context.getJPAEntityName() + JPQLStatement.DELIMITER.SPACE + tableAlias;
  jpqlQuery.append(JPQLStatement.KEYWORD.SELECT).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(tableAlias).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(JPQLStatement.KEYWORD.FROM).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(fromClause);
  if (context.getWhereExpression() != null) {
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.WHERE).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(context.getWhereExpression());
  }
  if (context.getOrderByCollection() != null && context.getOrderByCollection().size() > 0) {
    StringBuilder orderByBuilder=new StringBuilder();
    Iterator<Entry<String,String>> orderItr=context.getOrderByCollection().entrySet().iterator();
    int i=0;
    while (orderItr.hasNext()) {
      if (i != 0) {
        orderByBuilder.append(JPQLStatement.DELIMITER.SPACE).append(JPQLStatement.DELIMITER.COMMA).append(JPQLStatement.DELIMITER.SPACE);
      }
      Entry<String,String> entry=orderItr.next();
      orderByBuilder.append(entry.getKey()).append(JPQLStatement.DELIMITER.SPACE);
      orderByBuilder.append(entry.getValue());
      i++;
    }
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.ORDERBY).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(orderByBuilder);
  }
  return jpqlQuery.toString();
}",0.9827072152653548
18082,"public static void build(JPAEdmAssociationSetView view){
  AssociationSet associationSet=view.getEdmAssociationSet();
  String name=view.getEdmAssociation().getName();
  associationSet.setName(name + ASSOCIATIONSET_SUFFIX);
}","public static void build(JPAEdmAssociationView associationView,JPAEdmPropertyView propertyView,JPAEdmNavigationProperty jpaEdmNavigationProperty){
  NavigationProperty navProp=jpaEdmNavigationProperty.getEdmNavigationProperty();
  String namespace=buildNamespace(associationView.getpUnitName());
  navProp.setRelationship(new FullQualifiedName(namespace,associationView.getEdmAssociation().getName()));
  FullQualifiedName associationEndTypeOne=associationView.getEdmAssociation().getEnd1().getType();
  if (propertyView.getJPAAttribute().getJavaType().getSimpleName().equals(associationEndTypeOne.getName())) {
    navProp.setFromRole(associationView.getEdmAssociation().getEnd2().getRole());
    navProp.setToRole(associationView.getEdmAssociation().getEnd1().getRole());
  }
 else {
    navProp.setToRole(associationView.getEdmAssociation().getEnd2().getRole());
    navProp.setFromRole(associationView.getEdmAssociation().getEnd1().getRole());
  }
  navProp.setName(propertyView.getJPAAttribute().getJavaType().getSimpleName().concat(NAVIGATION_NAME));
}",0.0919719407638347
18083,"@Override public Association searchAssociation(JPAEdmAssociationEndView view){
  for (  Association association : consistentAssociatonList)   if (view.compare(association.getEnd1(),association.getEnd2()))   return association;
  return null;
}","@Override public Association searchAssociation(JPAEdmAssociationEndView view){
  for (  Association association : consistentAssociatonList) {
    if (view.compare(association.getEnd1(),association.getEnd2())) {
      currentAssociation=association;
      return association;
    }
  }
  return null;
}",0.8602941176470589
18084,"@Override public void addJPAEdmAssociationView(JPAEdmAssociationView associationView){
  consistentAssociatonList.add(associationView.getEdmAssociation());
}","@Override public void addJPAEdmAssociationView(JPAEdmAssociationView associationView){
  currentAssociation=associationView.getEdmAssociation();
  consistentAssociatonList.add(currentAssociation);
}",0.8
18085,"@Override public void build() throws ODataJPAModelException {
  Set<javax.persistence.metamodel.EntityType<?>> jpaEntityTypes=metaModel.getEntities();
  if (jpaEntityTypes == null || jpaEntityTypes.isEmpty() == true)   return;
 else   if (consistentEntityTypes == null) {
    consistentEntityTypes=new ArrayList<EntityType>();
  }
  for (  javax.persistence.metamodel.EntityType<?> jpaEntityType : jpaEntityTypes) {
    currentEdmEntityType=new EntityType();
    currentJPAEntityType=jpaEntityType;
    JPAEdmNameBuilder.build(JPAEdmEntityType.this);
    JPAEdmPropertyView propertyView=new JPAEdmProperty(schemaView);
    propertyView.getBuilder().build();
    currentEdmEntityType.setProperties(propertyView.getPropertyList());
    JPAEdmKeyView keyView=propertyView.getJPAEdmKeyView();
    currentEdmEntityType.setKey(keyView.getEdmKey());
    consistentEntityTypes.add(currentEdmEntityType);
  }
}","@Override public void build() throws ODataJPAModelException {
  Set<javax.persistence.metamodel.EntityType<?>> jpaEntityTypes=metaModel.getEntities();
  if (jpaEntityTypes == null || jpaEntityTypes.isEmpty() == true)   return;
 else   if (consistentEntityTypes == null) {
    consistentEntityTypes=new ArrayList<EntityType>();
  }
  for (  javax.persistence.metamodel.EntityType<?> jpaEntityType : jpaEntityTypes) {
    currentEdmEntityType=new EntityType();
    currentJPAEntityType=jpaEntityType;
    JPAEdmNameBuilder.build(JPAEdmEntityType.this);
    JPAEdmPropertyView propertyView=new JPAEdmProperty(schemaView);
    propertyView.getBuilder().build();
    currentEdmEntityType.setProperties(propertyView.getPropertyList());
    if (propertyView.getJPAEdmNavigationPropertyView() != null) {
      JPAEdmNavigationPropertyView navPropView=propertyView.getJPAEdmNavigationPropertyView();
      if (navPropView.getConsistentEdmNavigationProperties() != null && !navPropView.getConsistentEdmNavigationProperties().isEmpty()) {
        currentEdmEntityType.setNavigationProperties(navPropView.getConsistentEdmNavigationProperties());
      }
    }
    JPAEdmKeyView keyView=propertyView.getJPAEdmKeyView();
    currentEdmEntityType.setKey(keyView.getEdmKey());
    consistentEntityTypes.add(currentEdmEntityType);
  }
}",0.8117117117117117
18086,"@Override public void build() throws ODataJPAModelException {
  NavigationProperty navigationProperty=new NavigationProperty();
  JPAEdmEntityTypeView entityTypeView=schemaView.getJPAEdmEntityContainerView().getJPAEdmEntitySetView().getJPAEdmEntityTypeView();
  EntityType<?> jpaEntityType=entityTypeView.getJPAEntityType();
  for (  Attribute<?,?> attribute : jpaEntityType.getAttributes()) {
    PersistentAttributeType attributeType=attribute.getPersistentAttributeType();
switch (attributeType) {
case MANY_TO_MANY:
      break;
case ONE_TO_MANY:
    break;
case MANY_TO_ONE:
  break;
case ONE_TO_ONE:
break;
default :
break;
}
}
}","@Override public void build() throws ODataJPAModelException {
  currentNavigationProperty=new NavigationProperty();
  JPAEdmNameBuilder.build(associationView,propertyView,JPAEdmNavigationProperty.this);
}",0.3218116805721097
18087,"public JPAEdmNavigationProperty(JPAEdmSchemaView view){
  super(view);
  this.schemaView=view;
}","public JPAEdmNavigationProperty(JPAEdmSchemaView schemaView){
  super(schemaView);
  consistentNavigationProperties=new ArrayList<NavigationProperty>();
}",0.64
18088,"@Override public void build() throws ODataJPAModelException {
  JPAEdmBuilder keyViewBuilder=null;
  properties=new ArrayList<Property>();
  Set<?> jpaAttributes=null;
  if (isBuildModeComplexType) {
    jpaAttributes=complexTypeView.getJPAEmbeddableType().getAttributes();
  }
 else {
    jpaAttributes=entityTypeView.getJPAEntityType().getAttributes();
  }
  for (  Object jpaAttribute : jpaAttributes) {
    currentAttribute=(Attribute<?,?>)jpaAttribute;
    PersistentAttributeType attributeType=currentAttribute.getPersistentAttributeType();
switch (attributeType) {
case BASIC:
      currentSimpleProperty=new SimpleProperty();
    JPAEdmNameBuilder.build((JPAEdmPropertyView)JPAEdmProperty.this);
  EdmSimpleTypeKind simpleTypeKind=JPATypeConvertor.convertToEdmSimpleType(currentAttribute.getJavaType());
currentSimpleProperty.setType(simpleTypeKind);
currentSimpleProperty.setFacets(setFacets(currentAttribute));
properties.add(currentSimpleProperty);
if (((SingularAttribute<?,?>)currentAttribute).isId()) {
if (keyView == null) {
keyView=new JPAEdmKey(JPAEdmProperty.this);
keyViewBuilder=keyView.getBuilder();
}
keyViewBuilder.build();
}
break;
case EMBEDDED:
ComplexType complexType=complexTypeView.searchComplexType(currentAttribute.getJavaType().getName());
if (complexType == null) {
JPAEdmComplexTypeView complexTypeViewLocal=new JPAEdmComplexType(schemaView);
complexTypeViewLocal.getBuilder().build();
complexType=complexTypeViewLocal.getEdmComplexType();
complexTypeView.addCompleTypeView(complexTypeViewLocal);
}
if (isBuildModeComplexType == false && entityTypeView.getJPAEntityType().getIdType().getJavaType().equals(currentAttribute.getJavaType())) {
if (keyView == null) keyView=new JPAEdmKey(complexTypeView,JPAEdmProperty.this);
keyView.getBuilder().build();
}
 else {
currentComplexProperty=new ComplexProperty();
JPAEdmNameBuilder.build((JPAEdmComplexPropertyView)JPAEdmProperty.this,JPAEdmProperty.this);
currentComplexProperty.setType(new FullQualifiedName(schemaView.getEdmSchema().getNamespace(),complexType.getName()));
currentComplexProperty.setFacets(setFacets(currentAttribute));
properties.add(currentComplexProperty);
}
break;
case MANY_TO_MANY:
case ONE_TO_MANY:
case ONE_TO_ONE:
case MANY_TO_ONE:
JPAEdmAssociationEndView associationEndView=new JPAEdmAssociationEnd(entityTypeView,JPAEdmProperty.this);
associationEndView.getBuilder().build();
JPAEdmAssociationView associationView=schemaView.getJPAEdmAssociationView();
if (associationView.searchAssociation(associationEndView) == null) {
JPAEdmAssociationView associationViewLocal=new JPAEdmAssociation(associationEndView);
associationViewLocal.getBuilder().build();
associationView.addJPAEdmAssociationView(associationViewLocal);
}
if (false) {
JPAEdmReferentialContraintView refView=new JPAEdmReferentialConstraint(associationView,JPAEdmProperty.this);
refView.getBuilder().build();
associationView.addJPAEdmRefConstraintView(refView);
}
break;
default :
break;
}
}
}","@Override public void build() throws ODataJPAModelException {
  JPAEdmBuilder keyViewBuilder=null;
  properties=new ArrayList<Property>();
  Set<?> jpaAttributes=null;
  if (isBuildModeComplexType) {
    jpaAttributes=complexTypeView.getJPAEmbeddableType().getAttributes();
  }
 else {
    jpaAttributes=entityTypeView.getJPAEntityType().getAttributes();
  }
  for (  Object jpaAttribute : jpaAttributes) {
    currentAttribute=(Attribute<?,?>)jpaAttribute;
    PersistentAttributeType attributeType=currentAttribute.getPersistentAttributeType();
switch (attributeType) {
case BASIC:
      currentSimpleProperty=new SimpleProperty();
    JPAEdmNameBuilder.build((JPAEdmPropertyView)JPAEdmProperty.this);
  EdmSimpleTypeKind simpleTypeKind=JPATypeConvertor.convertToEdmSimpleType(currentAttribute.getJavaType());
currentSimpleProperty.setType(simpleTypeKind);
currentSimpleProperty.setFacets(setFacets(currentAttribute));
properties.add(currentSimpleProperty);
if (((SingularAttribute<?,?>)currentAttribute).isId()) {
if (keyView == null) {
keyView=new JPAEdmKey(JPAEdmProperty.this);
keyViewBuilder=keyView.getBuilder();
}
keyViewBuilder.build();
}
break;
case EMBEDDED:
ComplexType complexType=complexTypeView.searchComplexType(currentAttribute.getJavaType().getName());
if (complexType == null) {
JPAEdmComplexTypeView complexTypeViewLocal=new JPAEdmComplexType(schemaView);
complexTypeViewLocal.getBuilder().build();
complexType=complexTypeViewLocal.getEdmComplexType();
complexTypeView.addCompleTypeView(complexTypeViewLocal);
}
if (isBuildModeComplexType == false && entityTypeView.getJPAEntityType().getIdType().getJavaType().equals(currentAttribute.getJavaType())) {
if (keyView == null) keyView=new JPAEdmKey(complexTypeView,JPAEdmProperty.this);
keyView.getBuilder().build();
}
 else {
currentComplexProperty=new ComplexProperty();
JPAEdmNameBuilder.build((JPAEdmComplexPropertyView)JPAEdmProperty.this,JPAEdmProperty.this);
currentComplexProperty.setType(new FullQualifiedName(schemaView.getEdmSchema().getNamespace(),complexType.getName()));
currentComplexProperty.setFacets(setFacets(currentAttribute));
properties.add(currentComplexProperty);
}
break;
case MANY_TO_MANY:
case ONE_TO_MANY:
case ONE_TO_ONE:
case MANY_TO_ONE:
JPAEdmAssociationEndView associationEndView=new JPAEdmAssociationEnd(entityTypeView,JPAEdmProperty.this);
associationEndView.getBuilder().build();
JPAEdmAssociationView associationView=schemaView.getJPAEdmAssociationView();
if (associationView.searchAssociation(associationEndView) == null) {
JPAEdmAssociationView associationViewLocal=new JPAEdmAssociation(associationEndView);
associationViewLocal.getBuilder().build();
associationView.addJPAEdmAssociationView(associationViewLocal);
}
JPAEdmReferentialContraintView refView=new JPAEdmReferentialConstraint(associationView,JPAEdmProperty.this);
if (navigationPropertyView == null) {
navigationPropertyView=new JPAEdmNavigationProperty(schemaView);
}
JPAEdmNavigationPropertyView localNavigationPropertyView=new JPAEdmNavigationProperty(schemaView,associationView,JPAEdmProperty.this);
localNavigationPropertyView.getBuilder().build();
navigationPropertyView.addJPAEdmNavigationPropertyView(localNavigationPropertyView);
break;
default :
break;
}
}
}",0.8840135505726731
18089,"@Test public void testGetJPAEdmBuilder(){
  ODataJPAFactoryImpl factory=new ODataJPAFactoryImpl();
  JPAEdmBuilder builder=factory.getJPAAccessFactory().getJPAEdmBuilder(odataJpaContext);
  assertEquals(JPAEdmBuilderV2.class,builder.getClass());
}","@Test public void testGetJPAEdmBuilder(){
  ODataJPAFactoryImpl factory=new ODataJPAFactoryImpl();
}",0.5763688760806917
18090,"public static JPAEdmBuilder mockjpaEdmBuilder() throws ODataJPAModelException {
  JPAEdmBuilder builder=EasyMock.createMock(JPAEdmBuilder.class);
  EasyMock.expect(builder.getSchemas()).andReturn(mockSchemas()).times(10);
  EasyMock.replay(builder);
  return builder;
}","public static JPAEdmBuilder mockjpaEdmBuilder() throws ODataJPAModelException {
  JPAEdmBuilder builder=EasyMock.createMock(JPAEdmBuilder.class);
  return builder;
}",0.7603686635944701
18091,"public static void build(JPAEdmAssociationSetView view){
  AssociationSet associationSet=view.getEdmAssociationSet();
  String name=view.getEdmAssociation().getName();
  associationSet.setName(name + ASSOCIATIONSET_SUFFIX);
}","public static void build(JPAEdmAssociationView associationView,JPAEdmPropertyView propertyView,JPAEdmNavigationProperty jpaEdmNavigationProperty){
  NavigationProperty navProp=jpaEdmNavigationProperty.getEdmNavigationProperty();
  String namespace=buildNamespace(associationView.getpUnitName());
  navProp.setRelationship(new FullQualifiedName(namespace,associationView.getEdmAssociation().getName()));
  FullQualifiedName associationEndTypeOne=associationView.getEdmAssociation().getEnd1().getType();
  if (propertyView.getJPAAttribute().getJavaType().getSimpleName().equals(associationEndTypeOne.getName())) {
    navProp.setFromRole(associationView.getEdmAssociation().getEnd2().getRole());
    navProp.setToRole(associationView.getEdmAssociation().getEnd1().getRole());
  }
 else {
    navProp.setToRole(associationView.getEdmAssociation().getEnd2().getRole());
    navProp.setFromRole(associationView.getEdmAssociation().getEnd1().getRole());
  }
  navProp.setName(propertyView.getJPAAttribute().getJavaType().getSimpleName().concat(NAVIGATION_NAME));
}",0.0919719407638347
18092,"@Override public Association searchAssociation(JPAEdmAssociationEndView view){
  for (  Association association : consistentAssociatonList)   if (view.compare(association.getEnd1(),association.getEnd2()))   return association;
  return null;
}","@Override public Association searchAssociation(JPAEdmAssociationEndView view){
  for (  Association association : consistentAssociatonList) {
    if (view.compare(association.getEnd1(),association.getEnd2())) {
      currentAssociation=association;
      return association;
    }
  }
  return null;
}",0.8602941176470589
18093,"@Override public void addJPAEdmAssociationView(JPAEdmAssociationView associationView){
  consistentAssociatonList.add(associationView.getEdmAssociation());
}","@Override public void addJPAEdmAssociationView(JPAEdmAssociationView associationView){
  currentAssociation=associationView.getEdmAssociation();
  consistentAssociatonList.add(currentAssociation);
}",0.8
18094,"@Override public void build() throws ODataJPAModelException {
  Set<javax.persistence.metamodel.EntityType<?>> jpaEntityTypes=metaModel.getEntities();
  if (jpaEntityTypes == null || jpaEntityTypes.isEmpty() == true)   return;
 else   if (consistentEntityTypes == null) {
    consistentEntityTypes=new ArrayList<EntityType>();
  }
  for (  javax.persistence.metamodel.EntityType<?> jpaEntityType : jpaEntityTypes) {
    currentEdmEntityType=new EntityType();
    currentJPAEntityType=jpaEntityType;
    JPAEdmNameBuilder.build(JPAEdmEntityType.this);
    JPAEdmPropertyView propertyView=new JPAEdmProperty(schemaView);
    propertyView.getBuilder().build();
    currentEdmEntityType.setProperties(propertyView.getPropertyList());
    JPAEdmKeyView keyView=propertyView.getJPAEdmKeyView();
    currentEdmEntityType.setKey(keyView.getEdmKey());
    consistentEntityTypes.add(currentEdmEntityType);
  }
}","@Override public void build() throws ODataJPAModelException {
  Set<javax.persistence.metamodel.EntityType<?>> jpaEntityTypes=metaModel.getEntities();
  if (jpaEntityTypes == null || jpaEntityTypes.isEmpty() == true)   return;
 else   if (consistentEntityTypes == null) {
    consistentEntityTypes=new ArrayList<EntityType>();
  }
  for (  javax.persistence.metamodel.EntityType<?> jpaEntityType : jpaEntityTypes) {
    currentEdmEntityType=new EntityType();
    currentJPAEntityType=jpaEntityType;
    JPAEdmNameBuilder.build(JPAEdmEntityType.this);
    JPAEdmPropertyView propertyView=new JPAEdmProperty(schemaView);
    propertyView.getBuilder().build();
    currentEdmEntityType.setProperties(propertyView.getPropertyList());
    if (propertyView.getJPAEdmNavigationPropertyView() != null) {
      JPAEdmNavigationPropertyView navPropView=propertyView.getJPAEdmNavigationPropertyView();
      if (navPropView.getConsistentEdmNavigationProperties() != null && !navPropView.getConsistentEdmNavigationProperties().isEmpty()) {
        currentEdmEntityType.setNavigationProperties(navPropView.getConsistentEdmNavigationProperties());
      }
    }
    JPAEdmKeyView keyView=propertyView.getJPAEdmKeyView();
    currentEdmEntityType.setKey(keyView.getEdmKey());
    consistentEntityTypes.add(currentEdmEntityType);
  }
}",0.8117117117117117
18095,"@Override public void build() throws ODataJPAModelException {
  NavigationProperty navigationProperty=new NavigationProperty();
  JPAEdmEntityTypeView entityTypeView=schemaView.getJPAEdmEntityContainerView().getJPAEdmEntitySetView().getJPAEdmEntityTypeView();
  EntityType<?> jpaEntityType=entityTypeView.getJPAEntityType();
  for (  Attribute<?,?> attribute : jpaEntityType.getAttributes()) {
    PersistentAttributeType attributeType=attribute.getPersistentAttributeType();
switch (attributeType) {
case MANY_TO_MANY:
      break;
case ONE_TO_MANY:
    break;
case MANY_TO_ONE:
  break;
case ONE_TO_ONE:
break;
default :
break;
}
}
}","@Override public void build() throws ODataJPAModelException {
  currentNavigationProperty=new NavigationProperty();
  JPAEdmNameBuilder.build(associationView,propertyView,JPAEdmNavigationProperty.this);
}",0.3218116805721097
18096,"public JPAEdmNavigationProperty(JPAEdmSchemaView view){
  super(view);
  this.schemaView=view;
}","public JPAEdmNavigationProperty(JPAEdmSchemaView schemaView){
  super(schemaView);
  consistentNavigationProperties=new ArrayList<NavigationProperty>();
}",0.64
18097,"@Override public void build() throws ODataJPAModelException {
  JPAEdmBuilder keyViewBuilder=null;
  properties=new ArrayList<Property>();
  Set<?> jpaAttributes=null;
  if (isBuildModeComplexType) {
    jpaAttributes=complexTypeView.getJPAEmbeddableType().getAttributes();
  }
 else {
    jpaAttributes=entityTypeView.getJPAEntityType().getAttributes();
  }
  for (  Object jpaAttribute : jpaAttributes) {
    currentAttribute=(Attribute<?,?>)jpaAttribute;
    PersistentAttributeType attributeType=currentAttribute.getPersistentAttributeType();
switch (attributeType) {
case BASIC:
      currentSimpleProperty=new SimpleProperty();
    JPAEdmNameBuilder.build((JPAEdmPropertyView)JPAEdmProperty.this);
  EdmSimpleTypeKind simpleTypeKind=JPATypeConvertor.convertToEdmSimpleType(currentAttribute.getJavaType());
currentSimpleProperty.setType(simpleTypeKind);
currentSimpleProperty.setFacets(setFacets(currentAttribute));
properties.add(currentSimpleProperty);
if (((SingularAttribute<?,?>)currentAttribute).isId()) {
if (keyView == null) {
keyView=new JPAEdmKey(JPAEdmProperty.this);
keyViewBuilder=keyView.getBuilder();
}
keyViewBuilder.build();
}
break;
case EMBEDDED:
ComplexType complexType=complexTypeView.searchComplexType(currentAttribute.getJavaType().getName());
if (complexType == null) {
JPAEdmComplexTypeView complexTypeViewLocal=new JPAEdmComplexType(schemaView);
complexTypeViewLocal.getBuilder().build();
complexType=complexTypeViewLocal.getEdmComplexType();
complexTypeView.addCompleTypeView(complexTypeViewLocal);
}
if (isBuildModeComplexType == false && entityTypeView.getJPAEntityType().getIdType().getJavaType().equals(currentAttribute.getJavaType())) {
if (keyView == null) keyView=new JPAEdmKey(complexTypeView,JPAEdmProperty.this);
keyView.getBuilder().build();
}
 else {
currentComplexProperty=new ComplexProperty();
JPAEdmNameBuilder.build((JPAEdmComplexPropertyView)JPAEdmProperty.this,JPAEdmProperty.this);
currentComplexProperty.setType(new FullQualifiedName(schemaView.getEdmSchema().getNamespace(),complexType.getName()));
currentComplexProperty.setFacets(setFacets(currentAttribute));
properties.add(currentComplexProperty);
}
break;
case MANY_TO_MANY:
case ONE_TO_MANY:
case ONE_TO_ONE:
case MANY_TO_ONE:
JPAEdmAssociationEndView associationEndView=new JPAEdmAssociationEnd(entityTypeView,JPAEdmProperty.this);
associationEndView.getBuilder().build();
JPAEdmAssociationView associationView=schemaView.getJPAEdmAssociationView();
if (associationView.searchAssociation(associationEndView) == null) {
JPAEdmAssociationView associationViewLocal=new JPAEdmAssociation(associationEndView);
associationViewLocal.getBuilder().build();
associationView.addJPAEdmAssociationView(associationViewLocal);
}
if (false) {
JPAEdmReferentialContraintView refView=new JPAEdmReferentialConstraint(associationView,JPAEdmProperty.this);
refView.getBuilder().build();
associationView.addJPAEdmRefConstraintView(refView);
}
break;
default :
break;
}
}
}","@Override public void build() throws ODataJPAModelException {
  JPAEdmBuilder keyViewBuilder=null;
  properties=new ArrayList<Property>();
  Set<?> jpaAttributes=null;
  if (isBuildModeComplexType) {
    jpaAttributes=complexTypeView.getJPAEmbeddableType().getAttributes();
  }
 else {
    jpaAttributes=entityTypeView.getJPAEntityType().getAttributes();
  }
  for (  Object jpaAttribute : jpaAttributes) {
    currentAttribute=(Attribute<?,?>)jpaAttribute;
    PersistentAttributeType attributeType=currentAttribute.getPersistentAttributeType();
switch (attributeType) {
case BASIC:
      currentSimpleProperty=new SimpleProperty();
    JPAEdmNameBuilder.build((JPAEdmPropertyView)JPAEdmProperty.this);
  EdmSimpleTypeKind simpleTypeKind=JPATypeConvertor.convertToEdmSimpleType(currentAttribute.getJavaType());
currentSimpleProperty.setType(simpleTypeKind);
currentSimpleProperty.setFacets(setFacets(currentAttribute));
properties.add(currentSimpleProperty);
if (((SingularAttribute<?,?>)currentAttribute).isId()) {
if (keyView == null) {
keyView=new JPAEdmKey(JPAEdmProperty.this);
keyViewBuilder=keyView.getBuilder();
}
keyViewBuilder.build();
}
break;
case EMBEDDED:
ComplexType complexType=complexTypeView.searchComplexType(currentAttribute.getJavaType().getName());
if (complexType == null) {
JPAEdmComplexTypeView complexTypeViewLocal=new JPAEdmComplexType(schemaView);
complexTypeViewLocal.getBuilder().build();
complexType=complexTypeViewLocal.getEdmComplexType();
complexTypeView.addCompleTypeView(complexTypeViewLocal);
}
if (isBuildModeComplexType == false && entityTypeView.getJPAEntityType().getIdType().getJavaType().equals(currentAttribute.getJavaType())) {
if (keyView == null) keyView=new JPAEdmKey(complexTypeView,JPAEdmProperty.this);
keyView.getBuilder().build();
}
 else {
currentComplexProperty=new ComplexProperty();
JPAEdmNameBuilder.build((JPAEdmComplexPropertyView)JPAEdmProperty.this,JPAEdmProperty.this);
currentComplexProperty.setType(new FullQualifiedName(schemaView.getEdmSchema().getNamespace(),complexType.getName()));
currentComplexProperty.setFacets(setFacets(currentAttribute));
properties.add(currentComplexProperty);
}
break;
case MANY_TO_MANY:
case ONE_TO_MANY:
case ONE_TO_ONE:
case MANY_TO_ONE:
JPAEdmAssociationEndView associationEndView=new JPAEdmAssociationEnd(entityTypeView,JPAEdmProperty.this);
associationEndView.getBuilder().build();
JPAEdmAssociationView associationView=schemaView.getJPAEdmAssociationView();
if (associationView.searchAssociation(associationEndView) == null) {
JPAEdmAssociationView associationViewLocal=new JPAEdmAssociation(associationEndView);
associationViewLocal.getBuilder().build();
associationView.addJPAEdmAssociationView(associationViewLocal);
}
JPAEdmReferentialContraintView refView=new JPAEdmReferentialConstraint(associationView,JPAEdmProperty.this);
if (navigationPropertyView == null) {
navigationPropertyView=new JPAEdmNavigationProperty(schemaView);
}
JPAEdmNavigationPropertyView localNavigationPropertyView=new JPAEdmNavigationProperty(schemaView,associationView,JPAEdmProperty.this);
localNavigationPropertyView.getBuilder().build();
navigationPropertyView.addJPAEdmNavigationPropertyView(localNavigationPropertyView);
break;
default :
break;
}
}
}",0.8840135505726731
18098,"@Test public void testGetJPAEdmBuilder(){
  ODataJPAFactoryImpl factory=new ODataJPAFactoryImpl();
  JPAEdmBuilder builder=factory.getJPAAccessFactory().getJPAEdmBuilder(odataJpaContext);
  assertEquals(JPAEdmBuilderV2.class,builder.getClass());
}","@Test public void testGetJPAEdmBuilder(){
  ODataJPAFactoryImpl factory=new ODataJPAFactoryImpl();
}",0.5763688760806917
18099,"public static JPAEdmBuilder mockjpaEdmBuilder() throws ODataJPAModelException {
  JPAEdmBuilder builder=EasyMock.createMock(JPAEdmBuilder.class);
  EasyMock.expect(builder.getSchemas()).andReturn(mockSchemas()).times(10);
  EasyMock.replay(builder);
  return builder;
}","public static JPAEdmBuilder mockjpaEdmBuilder() throws ODataJPAModelException {
  JPAEdmBuilder builder=EasyMock.createMock(JPAEdmBuilder.class);
  return builder;
}",0.7603686635944701
18100,"/** 
 * This method evaluated the where expression for read of an entity based on the keys specified in the query.
 * @param keyPredicates
 * @return the evaluated where expression
 */
public static String parseKeyPredicates(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  String literal=null;
  String propertyName=null;
  EdmSimpleType edmSimpleType=null;
  StringBuilder keyFilters=new StringBuilder();
  int i=0;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    if (i > 0) {
      keyFilters.append(SPACE + JPQLStatement.Operator.AND + SPACE);
    }
    i++;
    literal=keyPredicate.getLiteral();
    try {
      propertyName=keyPredicate.getProperty().getName();
      edmSimpleType=(EdmSimpleType)keyPredicate.getProperty().getType();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    literal=evaluateComparingExpression(literal,edmSimpleType);
    keyFilters.append(tableAlias + DOT + propertyName+ SPACE+ JPQLStatement.Operator.EQ+ SPACE+ literal);
  }
  return keyFilters.toString();
}","/** 
 * This method evaluated the where expression for read of an entity based on the keys specified in the query.
 * @param keyPredicates
 * @return the evaluated where expression
 */
public static String parseKeyPredicates(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  String literal=null;
  String propertyName=null;
  EdmSimpleType edmSimpleType=null;
  StringBuilder keyFilters=new StringBuilder();
  int i=0;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    if (i > 0) {
      keyFilters.append(JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.AND + JPQLStatement.DELIMITER.SPACE);
    }
    i++;
    literal=keyPredicate.getLiteral();
    try {
      propertyName=keyPredicate.getProperty().getMapping().getInternalName();
      edmSimpleType=(EdmSimpleType)keyPredicate.getProperty().getType();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    literal=evaluateComparingExpression(literal,edmSimpleType);
    keyFilters.append(tableAlias + JPQLStatement.DELIMITER.PERIOD + propertyName+ JPQLStatement.DELIMITER.SPACE+ JPQLStatement.Operator.EQ+ JPQLStatement.DELIMITER.SPACE+ literal);
  }
  return keyFilters.toString();
}",0.9281098546042004
18101,"public static HashMap<String,String> parseKeyPredicatesToJPAOrderByExpression(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  String propertyName=null;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    try {
      propertyName=keyPredicate.getProperty().getName();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    orderByMap.put(tableAlias + DOT + propertyName,EMPTY);
  }
  return orderByMap;
}","public static HashMap<String,String> parseKeyPredicatesToJPAOrderByExpression(List<KeyPredicate> keyPredicates,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  String propertyName=null;
  for (  KeyPredicate keyPredicate : keyPredicates) {
    try {
      propertyName=keyPredicate.getProperty().getMapping().getInternalName();
    }
 catch (    EdmException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
    }
    orderByMap.put(tableAlias + JPQLStatement.DELIMITER.PERIOD + propertyName,EMPTY);
  }
  return orderByMap;
}",0.961890243902439
18102,"/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + SPACE + JPQLStatement.Operator.AND+ SPACE+ right;
case OR:
return left + SPACE + JPQLStatement.Operator.OR+ SPACE+ right;
case EQ:
return left + SPACE + JPQLStatement.Operator.EQ+ SPACE+ right;
case NE:
return left + SPACE + JPQLStatement.Operator.NE+ SPACE+ right;
case LT:
return left + SPACE + JPQLStatement.Operator.LT+ SPACE+ right;
case LE:
return left + SPACE + JPQLStatement.Operator.LE+ SPACE+ right;
case GT:
return left + SPACE + JPQLStatement.Operator.GT+ SPACE+ right;
case GE:
return left + SPACE + JPQLStatement.Operator.GE+ SPACE+ right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + DOT + ((PropertyExpression)whereExpression).getPropertyName();
return returnStr;
case MEMBER:
final MemberExpression memberExpression=(MemberExpression)whereExpression;
final PropertyExpression propertyExpressionPath=(PropertyExpression)memberExpression.getPath();
return tableAlias + DOT + propertyExpressionPath.getUriLiteral()+ DOT+ memberExpression.getProperty().getUriLiteral();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null,null),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
throw new ODataNotImplementedException();
}
}","/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.AND+ JPQLStatement.DELIMITER.SPACE+ right;
case OR:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.OR+ JPQLStatement.DELIMITER.SPACE+ right;
case EQ:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.EQ+ JPQLStatement.DELIMITER.SPACE+ right;
case NE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.NE+ JPQLStatement.DELIMITER.SPACE+ right;
case LT:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.LT+ JPQLStatement.DELIMITER.SPACE+ right;
case LE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.LE+ JPQLStatement.DELIMITER.SPACE+ right;
case GT:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.GT+ JPQLStatement.DELIMITER.SPACE+ right;
case GE:
return left + JPQLStatement.DELIMITER.SPACE + JPQLStatement.Operator.GE+ JPQLStatement.DELIMITER.SPACE+ right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + JPQLStatement.DELIMITER.PERIOD + ((EdmProperty)((PropertyExpression)whereExpression).getEdmProperty()).getMapping().getInternalName();
return returnStr;
case MEMBER:
String memberExpStr=EMPTY;
int i=0;
MemberExpression member=null;
CommonExpression tempExp=whereExpression;
while (tempExp != null && tempExp.getKind() == ExpressionKind.MEMBER) {
member=(MemberExpression)tempExp;
if (i > 0) {
memberExpStr=JPQLStatement.DELIMITER.PERIOD + memberExpStr;
}
i++;
memberExpStr=((EdmProperty)((PropertyExpression)member.getProperty()).getEdmProperty()).getMapping().getInternalName() + memberExpStr;
tempExp=member.getPath();
}
memberExpStr=((EdmProperty)((PropertyExpression)tempExp).getEdmProperty()).getMapping().getInternalName() + JPQLStatement.DELIMITER.PERIOD + memberExpStr;
return tableAlias + JPQLStatement.DELIMITER.PERIOD + memberExpStr;
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null,literalType.getDefaultType()),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
throw new ODataNotImplementedException();
}
}",0.8085236854208186
18103,"/** 
 * This method parses the order by condition in the query.
 * @param orderByExpression
 * @return
 * @throws ODataJPARuntimeException
 */
public static HashMap<String,String> parseToJPAOrderByExpression(OrderByExpression orderByExpression,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  if (orderByExpression != null && orderByExpression.getOrders() != null) {
    List<OrderExpression> orderBys=orderByExpression.getOrders();
    String orderByField=null;
    String orderByDirection=null;
    for (    OrderExpression orderBy : orderBys) {
      try {
        orderByField=orderBy.getExpression().getEdmType().getName();
        orderByDirection=(orderBy.getSortOrder() == SortOrder.asc) ? EMPTY : ""String_Node_Str"";
        orderByMap.put(tableAlias + DOT + orderByField,orderByDirection);
      }
 catch (      EdmException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
      }
    }
  }
  return orderByMap;
}","/** 
 * This method parses the order by condition in the query.
 * @param orderByExpression
 * @return
 * @throws ODataJPARuntimeException
 */
public static HashMap<String,String> parseToJPAOrderByExpression(OrderByExpression orderByExpression,String tableAlias) throws ODataJPARuntimeException {
  HashMap<String,String> orderByMap=new HashMap<String,String>();
  if (orderByExpression != null && orderByExpression.getOrders() != null) {
    List<OrderExpression> orderBys=orderByExpression.getOrders();
    String orderByField=null;
    String orderByDirection=null;
    for (    OrderExpression orderBy : orderBys) {
      try {
        orderByField=((EdmProperty)((PropertyExpression)orderBy.getExpression()).getEdmProperty()).getMapping().getInternalName();
        orderByDirection=(orderBy.getSortOrder() == SortOrder.asc) ? EMPTY : ""String_Node_Str"";
        orderByMap.put(tableAlias + JPQLStatement.DELIMITER.PERIOD + orderByField,orderByDirection);
      }
 catch (      EdmException e) {
        throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.RUNTIME_EXCEPTION.addContent(e.getMessage()),e);
      }
    }
  }
  return orderByMap;
}",0.9265687583444592
18104,"protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entitySetView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(item.getProperty().getName());
    }
    return selectedFields;
  }
  return null;
}","protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entitySetView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(((EdmProperty)item.getProperty()).getMapping().getInternalName());
    }
    return selectedFields;
  }
  return null;
}",0.9247058823529412
18105,"protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entityView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(item.getProperty().getName());
    }
    return selectedFields;
  }
  return null;
}","protected ArrayList<String> generateSelectFields() throws EdmException {
  List<SelectItem> selectItemList=entityView.getSelect();
  if (selectItemList != null) {
    ArrayList<String> selectedFields=new ArrayList<String>(selectItemList.size());
    for (    SelectItem item : selectItemList) {
      selectedFields.add(((EdmProperty)item.getProperty()).getMapping().getInternalName());
    }
    return selectedFields;
  }
  return null;
}",0.924170616113744
18106,"private String createJPQLQuery() throws ODataJPARuntimeException {
  StringBuilder jpqlQuery=new StringBuilder();
  String tableAlias=context.getJPAEntityAlias();
  String fromClause=context.getJPAEntityName() + JPQLStatement.DELIMITER.SPACE + tableAlias;
  jpqlQuery.append(JPQLStatement.KEYWORD.SELECT).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(tableAlias).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(JPQLStatement.KEYWORD.FROM).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(fromClause);
  if (context.getWhereExpression() != null) {
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.WHERE).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(context.getWhereExpression());
  }
  if (context.getOrderByCollection() != null && context.getOrderByCollection().size() > 0) {
    StringBuilder orderByBuilder=new StringBuilder();
    Iterator<Entry<String,String>> orderItr=context.getOrderByCollection().entrySet().iterator();
    int i=0;
    while (orderItr.hasNext()) {
      if (i != 0) {
        orderByBuilder.append(JPQLStatement.DELIMITER.SPACE).append(JPQLStatement.DELIMITER.COMMA).append(JPQLStatement.DELIMITER.SPACE);
      }
      Entry<String,String> entry=orderItr.next();
      orderByBuilder.append(tableAlias).append(JPQLStatement.DELIMITER.PERIOD).append(entry.getKey()).append(JPQLStatement.DELIMITER.SPACE);
      orderByBuilder.append(entry.getValue());
      i++;
    }
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.ORDERBY).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(orderByBuilder);
  }
  return jpqlQuery.toString();
}","private String createJPQLQuery() throws ODataJPARuntimeException {
  StringBuilder jpqlQuery=new StringBuilder();
  String tableAlias=context.getJPAEntityAlias();
  String fromClause=context.getJPAEntityName() + JPQLStatement.DELIMITER.SPACE + tableAlias;
  jpqlQuery.append(JPQLStatement.KEYWORD.SELECT).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(tableAlias).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(JPQLStatement.KEYWORD.FROM).append(JPQLStatement.DELIMITER.SPACE);
  jpqlQuery.append(fromClause);
  if (context.getWhereExpression() != null) {
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.WHERE).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(context.getWhereExpression());
  }
  if (context.getOrderByCollection() != null && context.getOrderByCollection().size() > 0) {
    StringBuilder orderByBuilder=new StringBuilder();
    Iterator<Entry<String,String>> orderItr=context.getOrderByCollection().entrySet().iterator();
    int i=0;
    while (orderItr.hasNext()) {
      if (i != 0) {
        orderByBuilder.append(JPQLStatement.DELIMITER.SPACE).append(JPQLStatement.DELIMITER.COMMA).append(JPQLStatement.DELIMITER.SPACE);
      }
      Entry<String,String> entry=orderItr.next();
      orderByBuilder.append(entry.getKey()).append(JPQLStatement.DELIMITER.SPACE);
      orderByBuilder.append(entry.getValue());
      i++;
    }
    jpqlQuery.append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(JPQLStatement.KEYWORD.ORDERBY).append(JPQLStatement.DELIMITER.SPACE);
    jpqlQuery.append(orderByBuilder);
  }
  return jpqlQuery.toString();
}",0.9827072152653548
18107,"private EdmSimpleType getEdmSimpleTypeMockedObj(String value) throws EdmException {
  EdmSimpleType edmSimpleType=EasyMock.createMock(EdmSimpleType.class);
  EasyMock.expect(edmSimpleType.getName()).andReturn(value);
  EasyMock.expect(edmSimpleType.getKind()).andReturn(EdmTypeKind.SIMPLE).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,null)).andReturn(value).times(10);
  EasyMock.replay(edmSimpleType);
  return edmSimpleType;
}","private EdmSimpleType getEdmSimpleTypeMockedObj(String value) throws EdmException {
  EdmSimpleType edmSimpleType=EasyMock.createMock(EdmSimpleType.class);
  EasyMock.expect(edmSimpleType.getName()).andReturn(value);
  EasyMock.expect(edmSimpleType.getKind()).andReturn(EdmTypeKind.SIMPLE).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,getEdmFacetsMockedObj(),null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueOfString(value,EdmLiteralKind.URI,null,null)).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,getEdmFacetsMockedObj())).andReturn(value).times(10);
  EasyMock.expect(edmSimpleType.valueToString(value,EdmLiteralKind.DEFAULT,null)).andReturn(value).times(10);
  EasyMock.replay(edmSimpleType);
  return edmSimpleType;
}",0.994011976047904
18108,"/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
LOGGER.error(""String_Node_Str"");
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + SPACE + JPQLStatement.Operator.AND+ SPACE+ right;
case OR:
return left + SPACE + JPQLStatement.Operator.OR+ SPACE+ right;
case EQ:
return left + SPACE + JPQLStatement.Operator.EQ+ SPACE+ right;
case NE:
return left + SPACE + JPQLStatement.Operator.NE+ SPACE+ right;
case LT:
return left + SPACE + JPQLStatement.Operator.LT+ SPACE+ right;
case LE:
return left + SPACE + JPQLStatement.Operator.LE+ SPACE+ right;
case GT:
return left + SPACE + JPQLStatement.Operator.GT+ SPACE+ right;
case GE:
return left + SPACE + JPQLStatement.Operator.GE+ SPACE+ right;
case PROPERTY_ACCESS:
LOGGER.error(""String_Node_Str"");
throw new ODataNotImplementedException();
default :
LOGGER.error(""String_Node_Str"" + binaryExpression.getOperator().name() + ""String_Node_Str"");
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + DOT + ((PropertyExpression)whereExpression).getPropertyName();
return returnStr;
case MEMBER:
final MemberExpression memberExpression=(MemberExpression)whereExpression;
final PropertyExpression propertyExpressionPath=(PropertyExpression)memberExpression.getPath();
return tableAlias + DOT + propertyExpressionPath.getUriLiteral()+ DOT+ memberExpression.getProperty().getUriLiteral();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
LOGGER.error(""String_Node_Str"" + whereExpression.getKind().name() + ""String_Node_Str"");
throw new ODataNotImplementedException();
}
}","/** 
 * This method returns the parsed where condition corresponding to the filter input in the user query.
 * @param whereExpression
 * @return Parsed where condition String
 * @throws ODataException
 */
public static String parseToJPAWhereExpression(final CommonExpression whereExpression,String tableAlias) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseToJPAWhereExpression(unaryExpression.getOperand(),tableAlias);
switch (unaryExpression.getOperator()) {
case NOT:
  return JPQLStatement.Operator.NOT + ""String_Node_Str"" + operand+ ""String_Node_Str"";
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
LOGGER.error(""String_Node_Str"");
throw new ODataNotImplementedException();
}
case FILTER:
return parseToJPAWhereExpression(((FilterExpression)whereExpression).getExpression(),tableAlias);
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final String left=parseToJPAWhereExpression(binaryExpression.getLeftOperand(),tableAlias);
final String right=parseToJPAWhereExpression(binaryExpression.getRightOperand(),tableAlias);
switch (binaryExpression.getOperator()) {
case AND:
return left + SPACE + JPQLStatement.Operator.AND+ SPACE+ right;
case OR:
return left + SPACE + JPQLStatement.Operator.OR+ SPACE+ right;
case EQ:
return left + SPACE + JPQLStatement.Operator.EQ+ SPACE+ right;
case NE:
return left + SPACE + JPQLStatement.Operator.NE+ SPACE+ right;
case LT:
return left + SPACE + JPQLStatement.Operator.LT+ SPACE+ right;
case LE:
return left + SPACE + JPQLStatement.Operator.LE+ SPACE+ right;
case GT:
return left + SPACE + JPQLStatement.Operator.GT+ SPACE+ right;
case GE:
return left + SPACE + JPQLStatement.Operator.GE+ SPACE+ right;
case PROPERTY_ACCESS:
LOGGER.error(""String_Node_Str"");
throw new ODataNotImplementedException();
default :
LOGGER.error(""String_Node_Str"" + binaryExpression.getOperator().name() + ""String_Node_Str"");
throw new ODataNotImplementedException();
}
case PROPERTY:
String returnStr=tableAlias + DOT + ((PropertyExpression)whereExpression).getPropertyName();
return returnStr;
case MEMBER:
final MemberExpression memberExpression=(MemberExpression)whereExpression;
final PropertyExpression propertyExpressionPath=(PropertyExpression)memberExpression.getPath();
return tableAlias + DOT + propertyExpressionPath.getUriLiteral()+ DOT+ memberExpression.getProperty().getUriLiteral();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
String value=literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null,null),EdmLiteralKind.DEFAULT,null);
return evaluateComparingExpression(value,literalType);
default :
LOGGER.error(""String_Node_Str"" + whereExpression.getKind().name() + ""String_Node_Str"");
throw new ODataNotImplementedException();
}
}",0.9991860654403386
18109,"public void generate(){
  this.entityManager.getTransaction().begin();
  int count=0;
  for (int i=0; i < DataGenerator.MAX_SALESORDER; i++) {
    Address ba=new Address((short)i,""String_Node_Str"" + i,""String_Node_Str"" + i,""String_Node_Str"" + i);
    SalesOrderHeader salesOrder=new SalesOrderHeader(i,""String_Node_Str"" + i,ba,""String_Node_Str"" + i,(double)i,((i % 2) == 0) ? true : false);
    for (int j=0; j < DataGenerator.MAX_SALESORDERITEM_PER_SALESORDER; j++) {
      SalesOrderItem salesOrderItem=new SalesOrderItem(""String_Node_Str"" + j,j,(double)((j * 200) / 4));
      salesOrderItem.setSalesOrderItemKey(new SalesOrderItemKey(j * 100));
      salesOrder.getSalesOrderItem().add(salesOrderItem);
      this.entityManager.persist(salesOrderItem);
    }
    Note note=new Note(""String_Node_Str"" + i,new Date(),""String_Node_Str"" + i);
    salesOrder.setNote(note);
    this.entityManager.persist(note);
    this.entityManager.persist(salesOrder);
    count++;
    if ((i == 7) && (count == 8)) {
      i--;
    }
  }
  this.entityManager.getTransaction().commit();
}","public void generate(){
  this.entityManager.getTransaction().begin();
  generatedDataFromFile();
  this.entityManager.getTransaction().commit();
}",0.2309582309582309
18110,"public static ODataResponse build(Object jpaEntity,GetEntityUriInfo resultsView,String contentType,ODataJPAContext oDataJPAContext) throws ODataJPARuntimeException {
  EdmEntityType edmEntityType=null;
  ODataResponse odataResponse=null;
  try {
    edmEntityType=resultsView.getTargetEntitySet().getEntityType();
    Map<String,Object> edmPropertyValueMap=null;
    JPAResultParser jpaResultParser=JPAResultParser.create();
    edmPropertyValueMap=jpaResultParser.parse2EdmPropertyValueMap(jpaEntity,edmEntityType);
    EntityProviderProperties feedProperties=null;
    try {
      feedProperties=EntityProviderProperties.baseUri(oDataJPAContext.getODataContext().getUriInfo().getServiceRoot()).build();
    }
 catch (    ODataException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
    }
    odataResponse=ODataResponse.fromResponse(EntityProvider.create(contentType).writeEntry(resultsView.getTargetEntitySet(),edmPropertyValueMap,feedProperties)).status(HttpStatusCodes.OK).build();
  }
 catch (  EntityProviderException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return odataResponse;
}","public static ODataResponse build(Object jpaEntity,GetEntityUriInfo resultsView,String contentType,ODataJPAContext oDataJPAContext) throws ODataJPARuntimeException {
  EdmEntityType edmEntityType=null;
  ODataResponse odataResponse=null;
  try {
    edmEntityType=resultsView.getTargetEntitySet().getEntityType();
    Map<String,Object> edmPropertyValueMap=null;
    JPAResultParser jpaResultParser=JPAResultParser.create();
    edmPropertyValueMap=jpaResultParser.parse2EdmPropertyValueMap(jpaEntity,edmEntityType);
    EntityProviderProperties feedProperties=null;
    try {
      feedProperties=EntityProviderProperties.baseUri(oDataJPAContext.getODataContext().getPathInfo().getServiceRoot()).build();
    }
 catch (    ODataException e) {
      throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
    }
    odataResponse=ODataResponse.fromResponse(EntityProvider.create(contentType).writeEntry(resultsView.getTargetEntitySet(),edmPropertyValueMap,feedProperties)).status(HttpStatusCodes.OK).build();
  }
 catch (  EntityProviderException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
catch (  EdmException e) {
    throw ODataJPARuntimeException.throwException(ODataJPARuntimeException.GENERAL.addContent(e.getMessage()),e);
  }
  return odataResponse;
}",0.9974883387154646
18111,"public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return left + OdataProcessorConstants.STRING_OPERATOR_EQ + right;
case NE:
return left + OdataProcessorConstants.STRING_OPERATOR_NE + right;
case LT:
return left + OdataProcessorConstants.STRING_OPERATOR_LT + right;
case LE:
return left + OdataProcessorConstants.STRING_OPERATOR_LE + right;
case GT:
return left + OdataProcessorConstants.STRING_OPERATOR_GT + right;
case GE:
return left + OdataProcessorConstants.STRING_OPERATOR_GE + right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
return ((PropertyExpression)whereExpression).getPropertyName();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.getName();
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}","public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return left + JPQLStatement.Operator.EQ + right;
case NE:
return left + JPQLStatement.Operator.NE + right;
case LT:
return left + JPQLStatement.Operator.LT + right;
case LE:
return left + JPQLStatement.Operator.LE + right;
case GT:
return left + JPQLStatement.Operator.GT + right;
case GE:
return left + JPQLStatement.Operator.GE + right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
return ((PropertyExpression)whereExpression).getPropertyName();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.getName();
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}",0.9488030338942878
18112,"public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return Boolean.toString(left.equals(right));
case NE:
return Boolean.toString(!left.equals(right));
case LT:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) < 0);
 else return Boolean.toString(Double.valueOf(left) < Double.valueOf(right));
case LE:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) <= 0);
 else return Boolean.toString(Double.valueOf(left) <= Double.valueOf(right));
case GT:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) > 0);
 else return Boolean.toString(Double.valueOf(left) > Double.valueOf(right));
case GE:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) >= 0);
 else return Boolean.toString(Double.valueOf(left) >= Double.valueOf(right));
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
final EdmProperty property=((PropertyExpression)whereExpression).getEdmProperty();
if (property == null) return ""String_Node_Str"";
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null),EdmLiteralKind.DEFAULT,null);
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}","public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return left + OdataProcessorConstants.STRING_OPERATOR_EQ + right;
case NE:
return left + OdataProcessorConstants.STRING_OPERATOR_NE + right;
case LT:
return left + OdataProcessorConstants.STRING_OPERATOR_LT + right;
case LE:
return left + OdataProcessorConstants.STRING_OPERATOR_LE + right;
case GT:
return left + OdataProcessorConstants.STRING_OPERATOR_GT + right;
case GE:
return left + OdataProcessorConstants.STRING_OPERATOR_GE + right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
return ((PropertyExpression)whereExpression).getPropertyName();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.getName();
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}",0.7327402823438407
18113,"public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return Boolean.toString(left.equals(right));
case NE:
return Boolean.toString(!left.equals(right));
case LT:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) < 0);
 else return Boolean.toString(Double.valueOf(left) < Double.valueOf(right));
case LE:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) <= 0);
 else return Boolean.toString(Double.valueOf(left) <= Double.valueOf(right));
case GT:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) > 0);
 else return Boolean.toString(Double.valueOf(left) > Double.valueOf(right));
case GE:
if (binaryType == EdmSimpleTypeKind.String.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTime.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.DateTimeOffset.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Guid.getEdmSimpleTypeInstance() || binaryType == EdmSimpleTypeKind.Time.getEdmSimpleTypeInstance()) return Boolean.toString(left.compareTo(right) >= 0);
 else return Boolean.toString(Double.valueOf(left) >= Double.valueOf(right));
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
final EdmProperty property=((PropertyExpression)whereExpression).getEdmProperty();
if (property == null) return ""String_Node_Str"";
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.valueToString(literalType.valueOfString(literal.getUriLiteral(),EdmLiteralKind.URI,null),EdmLiteralKind.DEFAULT,null);
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}","public static String parseWhereExpression(final CommonExpression whereExpression) throws ODataException {
switch (whereExpression.getKind()) {
case UNARY:
    final UnaryExpression unaryExpression=(UnaryExpression)whereExpression;
  final String operand=parseWhereExpression(unaryExpression.getOperand());
switch (unaryExpression.getOperator()) {
case NOT:
  return Boolean.toString(!Boolean.parseBoolean(operand));
case MINUS:
if (operand.startsWith(""String_Node_Str"")) return operand.substring(1);
 else return ""String_Node_Str"" + operand;
default :
throw new ODataNotImplementedException();
}
case BINARY:
final BinaryExpression binaryExpression=(BinaryExpression)whereExpression;
final EdmSimpleType binaryType=(EdmSimpleType)binaryExpression.getEdmType();
final String left=parseWhereExpression(binaryExpression.getLeftOperand());
final String right=parseWhereExpression(binaryExpression.getRightOperand());
switch (binaryExpression.getOperator()) {
case ADD:
return Double.toString(Double.valueOf(left) + Double.valueOf(right));
case SUB:
return Double.toString(Double.valueOf(left) - Double.valueOf(right));
case MUL:
return Double.toString(Double.valueOf(left) * Double.valueOf(right));
case DIV:
return Double.toString(Double.valueOf(left) / Double.valueOf(right));
case MODULO:
return Double.toString(Double.valueOf(left) % Double.valueOf(right));
case AND:
return Boolean.toString(left.equals(""String_Node_Str"") && right.equals(""String_Node_Str""));
case OR:
return Boolean.toString(left.equals(""String_Node_Str"") || right.equals(""String_Node_Str""));
case EQ:
return left + OdataProcessorConstants.STRING_OPERATOR_EQ + right;
case NE:
return left + OdataProcessorConstants.STRING_OPERATOR_NE + right;
case LT:
return left + OdataProcessorConstants.STRING_OPERATOR_LT + right;
case LE:
return left + OdataProcessorConstants.STRING_OPERATOR_LE + right;
case GT:
return left + OdataProcessorConstants.STRING_OPERATOR_GT + right;
case GE:
return left + OdataProcessorConstants.STRING_OPERATOR_GE + right;
case PROPERTY_ACCESS:
throw new ODataNotImplementedException();
default :
throw new ODataNotImplementedException();
}
case PROPERTY:
return ((PropertyExpression)whereExpression).getPropertyName();
case LITERAL:
final LiteralExpression literal=(LiteralExpression)whereExpression;
final EdmSimpleType literalType=(EdmSimpleType)literal.getEdmType();
return literalType.getName();
case METHOD:
final MethodExpression methodExpression=(MethodExpression)whereExpression;
final String first=parseWhereExpression(methodExpression.getParameters().get(0));
final String second=methodExpression.getParameterCount() > 1 ? parseWhereExpression(methodExpression.getParameters().get(1)) : null;
final String third=methodExpression.getParameterCount() > 2 ? parseWhereExpression(methodExpression.getParameters().get(2)) : null;
switch (methodExpression.getMethod()) {
case ENDSWITH:
return Boolean.toString(first.endsWith(second));
case INDEXOF:
return Integer.toString(first.indexOf(second));
case STARTSWITH:
return Boolean.toString(first.startsWith(second));
case TOLOWER:
return first.toLowerCase(Locale.ROOT);
case TOUPPER:
return first.toUpperCase(Locale.ROOT);
case TRIM:
return first.trim();
case SUBSTRING:
final int offset=first.indexOf(second);
return first.substring(offset,offset + Integer.parseInt(third));
case SUBSTRINGOF:
return Boolean.toString(first.contains(second));
case CONCAT:
return first + second;
case LENGTH:
return Integer.toString(first.length());
case YEAR:
return String.valueOf(Integer.parseInt(first.substring(0,4)));
case MONTH:
return String.valueOf(Integer.parseInt(first.substring(5,7)));
case DAY:
return String.valueOf(Integer.parseInt(first.substring(8,10)));
case HOUR:
return String.valueOf(Integer.parseInt(first.substring(11,13)));
case MINUTE:
return String.valueOf(Integer.parseInt(first.substring(14,16)));
case SECOND:
return String.valueOf(Integer.parseInt(first.substring(17,19)));
case ROUND:
return Long.toString(Math.round(Double.valueOf(first)));
case FLOOR:
return Long.toString(Math.round(Math.floor(Double.valueOf(first))));
case CEILING:
return Long.toString(Math.round(Math.ceil(Double.valueOf(first))));
default :
throw new ODataNotImplementedException();
}
default :
throw new ODataNotImplementedException();
}
}",0.7327402823438407
18114,"/** 
 * Add given content to message reference.
 */
public MessageReference addContent(Object... content){
  return new SimpleMessageReference(this.key,content);
}","/** 
 * Add given content to message reference.
 */
public MessageReference addContent(Object... content){
  if (this.content == null) {
    return new SimpleMessageReference(this.key,content);
  }
 else {
    List<Object> mergedContent=new ArrayList<Object>(this.content.size() + content.length);
    mergedContent.addAll(this.content);
    mergedContent.addAll(Arrays.asList(content));
    return new SimpleMessageReference(this.key,mergedContent);
  }
}",0.5266558966074314
18115,"@Override public Response toResponse(Exception exception){
  final Response response;
  Exception toHandleException=extractException(exception);
  exception.printStackTrace();
  if (toHandleException instanceof ODataApplicationException) {
    response=buildResponseForApplicationException((ODataApplicationException)toHandleException);
  }
 else   if (toHandleException instanceof ODataHttpException) {
    response=buildResponseForHttpException((ODataHttpException)toHandleException);
  }
 else {
    response=buildResponseForException(exception);
  }
  if (isInternalServerError(response)) {
    ODataExceptionMapperImpl.LOG.error(exception.getMessage(),exception);
  }
  return response;
}","@Override public Response toResponse(Exception exception){
  final Response response;
  Exception toHandleException=extractException(exception);
  if (toHandleException instanceof ODataApplicationException) {
    response=buildResponseForApplicationException((ODataApplicationException)toHandleException);
  }
 else   if (toHandleException instanceof ODataHttpException) {
    response=buildResponseForHttpException((ODataHttpException)toHandleException);
  }
 else {
    response=buildResponseForException(exception);
  }
  if (isInternalServerError(response)) {
    ODataExceptionMapperImpl.LOG.error(exception.getMessage(),exception);
  }
  return response;
}",0.9771217712177122
18116,"@Test public void test500RuntimeError() throws ClientProtocolException, IOException, ODataException {
  HttpGet get=new HttpGet(URI.create(this.getEndpoint().toString()));
  HttpResponse response=this.getHttpClient().execute(get);
  assertEquals(500,response.getStatusLine().getStatusCode());
  this.log.debug(StringHelper.inputStreamToString(response.getEntity().getContent()));
}","@Test public void test500RuntimeError() throws ClientProtocolException, IOException, ODataException {
  disableLogging(ODataExceptionMapperImpl.class);
  HttpGet get=new HttpGet(URI.create(this.getEndpoint().toString()));
  HttpResponse response=this.getHttpClient().execute(get);
  assertEquals(500,response.getStatusLine().getStatusCode());
  this.log.debug(StringHelper.inputStreamToString(response.getEntity().getContent()));
}",0.9384236453201972
18117,"@After public void after(){
  try {
    this.server.stopServer();
  }
  finally {
    FitStaticServiceFactory.setService(null);
  }
}","@After public void after(){
  reEnableLogging();
  try {
    this.server.stopServer();
  }
  finally {
    FitStaticServiceFactory.setService(null);
  }
}",0.926829268292683
18118,"private Response buildResponseForApplicationException(ODataApplicationException exception){
  ResponseBuilder responseBuilder=Response.noContent();
  Status status=extractStatus(exception);
  return responseBuilder.entity(exception.getMessage()).status(status).build();
}","private Response buildResponseForApplicationException(ODataApplicationException exception){
  ResponseBuilder responseBuilder=Response.noContent();
  int statusCode=extractStatus(exception);
  return responseBuilder.entity(exception.getMessage()).status(statusCode).build();
}",0.9140767824497258
18119,"private Status extractStatus(ODataException exception){
  Status extractedStatus=Status.INTERNAL_SERVER_ERROR;
  HttpStatusCodes httpStatus=null;
  if (exception instanceof ODataHttpException) {
    httpStatus=((ODataHttpException)exception).getHttpStatus();
  }
 else   if (exception instanceof ODataApplicationException) {
    httpStatus=((ODataApplicationException)exception).getHttpStatus();
  }
  if (httpStatus != null) {
    try {
      extractedStatus=Status.valueOf(httpStatus.name());
    }
 catch (    IllegalArgumentException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
  return extractedStatus;
}","private int extractStatus(ODataException exception){
  int extractedStatusCode=HttpStatusCodes.INTERNAL_SERVER_ERROR.getStatusCode();
  if (exception instanceof ODataHttpException) {
    extractedStatusCode=((ODataHttpException)exception).getHttpStatus().getStatusCode();
  }
 else   if (exception instanceof ODataApplicationException) {
    extractedStatusCode=((ODataApplicationException)exception).getHttpStatus().getStatusCode();
  }
  return extractedStatusCode;
}",0.1729530818767249
18120,"@Test public void testGenericHttpExceptions() throws ClientProtocolException, IOException, ODataException {
  List<ODataHttpException> toTestExceptions=new ArrayList<ODataHttpException>();
  toTestExceptions.add(new ODataNotFoundException(ODataNotFoundException.ENTITY));
  toTestExceptions.add(new ODataBadRequestException(ODataBadRequestException.COMMON));
  toTestExceptions.add(new ODataForbiddenException(ODataForbiddenException.COMMON));
  int firstKey=1;
  for (  ODataHttpException oDataException : toTestExceptions) {
    String key=String.valueOf(firstKey++);
    Matcher<GetEntityView> match=new EntityKeyMatcher(key);
    when(processor.readEntity(Matchers.argThat(match))).thenThrow(oDataException);
    String uri=getEndpoint().toString() + ""String_Node_Str"" + key+ ""String_Node_Str"";
    HttpGet get=new HttpGet(URI.create(uri));
    HttpResponse response=getHttpClient().execute(get);
    assertEquals(""String_Node_Str"" + oDataException.getClass().getSimpleName() + ""String_Node_Str"",oDataException.getHttpStatus().getStatusCode(),response.getStatusLine().getStatusCode());
    get.releaseConnection();
  }
}","@Test public void testGenericHttpExceptions() throws Exception {
  List<ODataHttpException> toTestExceptions=getHttpExceptionsForTest();
  int firstKey=1;
  for (  ODataHttpException oDataException : toTestExceptions) {
    String key=String.valueOf(firstKey++);
    Matcher<GetEntityView> match=new EntityKeyMatcher(key);
    when(processor.readEntity(Matchers.argThat(match))).thenThrow(oDataException);
    String uri=getEndpoint().toString() + ""String_Node_Str"" + key+ ""String_Node_Str"";
    HttpGet get=new HttpGet(URI.create(uri));
    HttpResponse response=getHttpClient().execute(get);
    assertEquals(""String_Node_Str"" + oDataException.getClass().getSimpleName() + ""String_Node_Str"",oDataException.getHttpStatus().getStatusCode(),response.getStatusLine().getStatusCode());
    get.releaseConnection();
  }
}",0.833590932509016
18121,"public EdmElementImplProv(EdmImplProv edm,String name,FullQualifiedName typeName,EdmFacets edmFacets,EdmMapping edmMapping) throws EdmException {
  super(edm,name,typeName,edmFacets == null || edmFacets.isNullable() ? EdmMultiplicity.ZERO_TO_ONE : EdmMultiplicity.ONE);
}","public EdmElementImplProv(EdmImplProv edm,String name,FullQualifiedName typeName,EdmFacets edmFacets,EdmMapping edmMapping) throws EdmException {
  super(edm,name,typeName,edmFacets == null || edmFacets.isNullable() ? EdmMultiplicity.ZERO_TO_ONE : EdmMultiplicity.ONE);
  this.edmFacets=edmFacets;
  this.edmMapping=edmMapping;
}",0.9033333333333332
18122,"@Override protected EdmEntityContainer createEntityContainer(String name) throws ODataException {
  return new EdmEntityContainerImplProv(this,edmProvider.getEntityContainer(name));
}","@Override protected EdmEntityContainer createEntityContainer(String name) throws ODataException {
  EntityContainerInfo enitityContainerInfo=edmProvider.getEntityContainer(name);
  if (enitityContainerInfo == null) {
    throw new EdmException(EdmException.COMMON);
  }
  return new EdmEntityContainerImplProv(this,enitityContainerInfo);
}",0.5670498084291188
18123,"@Override protected EdmComplexType createComplexType(FullQualifiedName fqName) throws ODataException {
  return new EdmComplexTypeImplProv(this,edmProvider.getComplexType(fqName),fqName.getNamespace());
}","@Override protected EdmComplexType createComplexType(FullQualifiedName fqName) throws ODataException {
  ComplexType complexType=edmProvider.getComplexType(fqName);
  if (complexType == null) {
    throw new EdmException(EdmException.COMMON);
  }
  return new EdmComplexTypeImplProv(this,complexType,fqName.getNamespace());
}",0.6162570888468809
18124,"@Override protected EdmAssociation createAssociation(FullQualifiedName fqName) throws ODataException {
  return new EdmAssociationImplProv(this,edmProvider.getAssociation(fqName),fqName.getNamespace());
}","@Override protected EdmAssociation createAssociation(FullQualifiedName fqName) throws ODataException {
  Association association=edmProvider.getAssociation(fqName);
  if (association == null) {
    throw new EdmException(EdmException.COMMON);
  }
  return new EdmAssociationImplProv(this,association,fqName.getNamespace());
}",0.6238185255198487
18125,"@Override protected EdmEntityType createEntityType(FullQualifiedName fqName) throws ODataException {
  return new EdmEntityTypeImplProv(this,edmProvider.getEntityType(fqName),fqName.getNamespace());
}","@Override protected EdmEntityType createEntityType(FullQualifiedName fqName) throws ODataException {
  EntityType entityType=edmProvider.getEntityType(fqName);
  if (entityType == null) {
    throw new EdmException(EdmException.COMMON);
  }
  return new EdmEntityTypeImplProv(this,entityType,fqName.getNamespace());
}",0.6228239845261122
18126,"private void splitPath(InitParameter param) throws ODataException {
  List<PathSegment> precedingPathSegements;
  List<PathSegment> odataPathSegements;
  if (param.getPathSplit() == 0) {
    precedingPathSegements=Collections.emptyList();
    odataPathSegements=param.getPathSegments();
  }
 else {
    if (param.getPathSegments().size() < param.getPathSplit()) {
      throw new ODataBadRequestException(ODataBadRequestException.URLTOSHORT);
    }
    precedingPathSegements=param.getPathSegments().subList(0,param.getPathSplit());
    int pathSegmentCount=param.getPathSegments().size();
    odataPathSegements=param.getPathSegments().subList(param.getPathSplit(),pathSegmentCount);
  }
  for (  PathSegment ps : odataPathSegements) {
    if (!ps.getMatrixParameters().isEmpty()) {
      throw new ODataNotFoundException(ODataNotFoundException.MATRIX);
    }
  }
  this.context.setODataPathSegment(this.convertPathSegmentList(odataPathSegements));
  this.context.setPrecedingPathSegment(this.convertPathSegmentList(precedingPathSegements));
}","private void splitPath(InitParameter param) throws ODataException {
  List<PathSegment> precedingPathSegements;
  List<PathSegment> odataPathSegements;
  if (param.getPathSplit() == 0) {
    precedingPathSegements=Collections.emptyList();
    odataPathSegements=param.getPathSegments();
  }
 else {
    if (param.getPathSegments().size() < param.getPathSplit()) {
      throw new ODataBadRequestException(ODataBadRequestException.URLTOSHORT);
    }
    precedingPathSegements=param.getPathSegments().subList(0,param.getPathSplit());
    int pathSegmentCount=param.getPathSegments().size();
    odataPathSegements=param.getPathSegments().subList(param.getPathSplit(),pathSegmentCount);
  }
  for (  PathSegment ps : odataPathSegements) {
    if (ps.getMatrixParameters() != null && !ps.getMatrixParameters().isEmpty()) {
      throw new ODataNotFoundException(ODataNotFoundException.MATRIX);
    }
  }
  this.context.setODataPathSegment(this.convertPathSegmentList(odataPathSegements));
  this.context.setPrecedingPathSegment(this.convertPathSegmentList(precedingPathSegements));
}",0.9830508474576272
18127,"@Override public EdmEntitySet getRelatedEntitySet(EdmNavigationProperty navigationProperty) throws EdmException {
  return null;
}","@Override public EdmEntitySet getRelatedEntitySet(EdmNavigationProperty navigationProperty) throws EdmException {
  EdmAssociationSet associationSet=edmEntityContainer.getAssociationSet(edmEntityContainer.getEntitySet(entitySet.getName()),navigationProperty);
  if (associationSet == null)   throw new EdmException();
  EdmAssociationSetEnd toEnd=associationSet.getEnd(navigationProperty.getToRole());
  if (toEnd == null)   throw new EdmException();
  EdmEntitySet targetEntitySet=toEnd.getEntitySet();
  if (targetEntitySet == null)   throw new EdmException();
  return targetEntitySet;
}",0.3472222222222222
18128,"@Override public Collection<String> getKeyPropertyNames() throws EdmException {
  return entityType.getKey().getKeys().keySet();
}","@Override public Collection<String> getKeyPropertyNames() throws EdmException {
  if (entityType.getKey() == null)   return Collections.<String>emptyList();
 else   return entityType.getKey().getKeys().keySet();
}",0.7580174927113703
18129,"@Override public List<EdmProperty> getKeyProperties() throws EdmException {
  if (edmKeyProperties == null) {
    String keyPropertyName;
    EdmProperty edmProperty;
    Collection<String> keyPropertyNames=getKeyPropertyNames();
    for (Iterator<String> iterator=keyPropertyNames.iterator(); iterator.hasNext(); ) {
      keyPropertyName=iterator.next();
      try {
        edmProperty=(EdmProperty)getProperty(keyPropertyName);
      }
 catch (      ClassCastException e) {
        throw new EdmException(e);
      }
      if (edmProperty != null) {
        edmKeyProperties.add(edmProperty);
      }
 else {
        throw new EdmException();
      }
    }
  }
  return edmKeyProperties;
}","@Override public List<EdmProperty> getKeyProperties() throws EdmException {
  if (edmKeyProperties == null) {
    EdmProperty edmProperty;
    edmKeyProperties=new ArrayList<EdmProperty>();
    for (    String keyPropertyName : getKeyPropertyNames()) {
      try {
        edmProperty=(EdmProperty)getProperty(keyPropertyName);
      }
 catch (      ClassCastException e) {
        throw new EdmException(e);
      }
      if (edmProperty != null) {
        edmKeyProperties.add(edmProperty);
      }
 else {
        throw new EdmException();
      }
    }
    if (edmBaseType != null)     edmKeyProperties.addAll(((EdmEntityType)edmBaseType).getKeyProperties());
  }
  return edmKeyProperties;
}",0.7084233261339092
18130,"@Override public EntityType getEntityType(final FullQualifiedName edmFQName) throws ODataRuntimeException, ODataMessageException {
  if (NAMESPACE_1.equals(edmFQName.getNamespace()))   if (ENTITY_TYPE_1_1.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(null,2,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",COMPLEX_TYPE_1,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_DATETIME,getFacets(true,null,null,null),new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationUpdated),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_1,ROLE_1_1,ROLE_1_4,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_2,ROLE_1_1,ROLE_1_2,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_3,ROLE_1_1,ROLE_1_3,null,null));
    return new EntityType(ENTITY_TYPE_1_1.getName(),null,false,properties,null,null,null,true,null,new Key(keyProperty,null),navigationProperties);
  }
 else   if (ENTITY_TYPE_1_BASE.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,""String_Node_Str"",null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    return new EntityType(ENTITY_TYPE_1_BASE.getName(),null,true,properties,null,null,null,false,null,new Key(keyProperty,null),null);
  }
 else   if (ENTITY_TYPE_1_2.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BOOLEAN,getFacets(true,null,null,null),null,null,null,null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_2,ROLE_1_2,ROLE_1_1,null,null));
    return new EntityType(ENTITY_TYPE_1_2.getName(),ENTITY_TYPE_1_BASE,false,properties,null,null,null,false,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_3.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,getFacets(null,null,null,true),null,null,null,null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_3,ROLE_1_3,ROLE_1_1,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_4,ROLE_1_3,ROLE_1_5,null,null));
    return new EntityType(ENTITY_TYPE_1_3.getName(),ENTITY_TYPE_1_BASE,false,properties,null,null,null,false,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_4.equals(edmFQName.getName())) {
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_1,ROLE_1_4,ROLE_1_1,null,null));
    return new EntityType(ENTITY_TYPE_1_4.getName(),ENTITY_TYPE_1_1,false,null,null,null,null,true,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_5.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,null,null,null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_4,ROLE_1_5,ROLE_1_3,null,null));
    return new EntityType(ENTITY_TYPE_1_5.getName(),null,false,properties,null,null,null,false,null,new Key(keyProperty,null),navigationProperties);
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
 else   if (NAMESPACE_2.equals(edmFQName.getNamespace()))   if (ENTITY_TYPE_2_1.equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT32,getFacets(false,null,null,true),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationAuthorUri),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,getFacets(true,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(true,null,null,null),new CustomizableFeedMappings(false,null,""String_Node_Str"",""String_Node_Str"",null,null),null,null,null));
    Map<String,PropertyRef> keyProperties=new HashMap<String,PropertyRef>();
    keyProperties.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    keyProperties.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    return new EntityType(ENTITY_TYPE_2_1.getName(),null,false,properties,null,null,null,true,null,new Key(keyProperties,null),null);
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
 else   throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
}","@Override public EntityType getEntityType(final FullQualifiedName edmFQName) throws ODataRuntimeException, ODataMessageException {
  if (NAMESPACE_1.equals(edmFQName.getNamespace()))   if (ENTITY_TYPE_1_1.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(null,2,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",COMPLEX_TYPE_1,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_DATETIME,getFacets(true,null,null,null),new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationUpdated),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_1,ROLE_1_1,ROLE_1_4,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_2,ROLE_1_1,ROLE_1_2,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_3,ROLE_1_1,ROLE_1_3,null,null));
    return new EntityType(ENTITY_TYPE_1_1.getName(),null,false,properties,null,null,null,true,null,new Key(keyProperty,null),navigationProperties);
  }
 else   if (ENTITY_TYPE_1_BASE.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,""String_Node_Str"",null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    return new EntityType(ENTITY_TYPE_1_BASE.getName(),null,true,properties,null,null,null,false,null,new Key(keyProperty,null),null);
  }
 else   if (ENTITY_TYPE_1_2.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BOOLEAN,getFacets(true,null,null,null),null,null,null,null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_2,ROLE_1_2,ROLE_1_1,null,null));
    return new EntityType(ENTITY_TYPE_1_2.getName(),ENTITY_TYPE_1_BASE,false,properties,null,null,null,false,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_3.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT16,getFacets(null,null,null,true),null,null,null,null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_3,ROLE_1_3,ROLE_1_1,null,null));
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_4,ROLE_1_3,ROLE_1_5,null,null));
    return new EntityType(ENTITY_TYPE_1_3.getName(),ENTITY_TYPE_1_BASE,false,properties,null,null,null,false,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_4.getName().equals(edmFQName.getName())) {
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_1,ROLE_1_4,ROLE_1_1,null,null));
    return new EntityType(ENTITY_TYPE_1_4.getName(),ENTITY_TYPE_1_1,false,null,null,null,null,true,null,null,navigationProperties);
  }
 else   if (ENTITY_TYPE_1_5.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,null,null,null,null,null));
    Map<String,PropertyRef> keyProperty=new HashMap<String,PropertyRef>();
    keyProperty.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    Map<String,NavigationProperty> navigationProperties=new HashMap<String,NavigationProperty>();
    navigationProperties.put(""String_Node_Str"",new NavigationProperty(""String_Node_Str"",ASSOCIATION_1_4,ROLE_1_5,ROLE_1_3,null,null));
    return new EntityType(ENTITY_TYPE_1_5.getName(),null,false,properties,null,null,null,false,null,new Key(keyProperty,null),navigationProperties);
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
 else   if (NAMESPACE_2.equals(edmFQName.getNamespace()))   if (ENTITY_TYPE_2_1.getName().equals(edmFQName.getName())) {
    Map<String,Property> properties=new HashMap<String,Property>();
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_INT32,getFacets(false,null,null,true),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationTitle),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(false,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,null,new CustomizableFeedMappings(null,null,null,null,null,EdmTargetPath.SyndicationAuthorUri),null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,null,null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_BINARY,getFacets(true,null,null,null),null,null,null,null));
    properties.put(""String_Node_Str"",new Property(""String_Node_Str"",EDM_STRING,getFacets(true,null,null,null),new CustomizableFeedMappings(false,null,""String_Node_Str"",""String_Node_Str"",null,null),null,null,null));
    Map<String,PropertyRef> keyProperties=new HashMap<String,PropertyRef>();
    keyProperties.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    keyProperties.put(""String_Node_Str"",new PropertyRef(""String_Node_Str"",null));
    return new EntityType(ENTITY_TYPE_2_1.getName(),null,false,properties,null,null,null,true,null,new Key(keyProperties,null),null);
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
 else   throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
}",0.9956112852664576
18131,"private Integer applySystemQueryOptions(final EdmEntitySet targetEntitySet,List<?> data,final InlineCount inlineCount,final String filter,final String orderBy,final String skipToken,final int skip,final Integer top){
  if (filter != null)   for (  Object element : data)   if (!appliesFilter(element,filter))   data.remove(element);
  final Integer count=inlineCount == InlineCount.ALLPAGES ? data.size() : null;
  if (orderBy != null)   ;
 else   if (skipToken != null || skip != 0 || top != null)   ;
  if (skipToken != null)   ;
  for (int i=0; i < skip; i++)   data.remove(0);
  if (top != null)   while (data.size() > top)   data.remove(top.intValue());
  return count;
}","private Integer applySystemQueryOptions(final EdmEntitySet targetEntitySet,List<?> data,final InlineCount inlineCount,final String filter,final String orderBy,final String skipToken,final int skip,final Integer top) throws ODataException {
  if (filter != null)   for (  Object element : data)   if (!appliesFilter(element,filter))   data.remove(element);
  final Integer count=inlineCount == InlineCount.ALLPAGES ? data.size() : null;
  if (orderBy != null)   ;
 else   if (skipToken != null || skip != 0 || top != null)   if (data instanceof Comparable<?>)   Collections.sort((List<? extends Comparable<Object>>)data);
 else   throw new ODataException();
  if (skipToken != null)   ;
  for (int i=0; i < skip; i++)   data.remove(0);
  if (top != null)   while (data.size() > top)   data.remove(top.intValue());
  return count;
}",0.897742363877822
18132,"@Override public Object readRelatedData(final EdmEntitySet sourceEntitySet,final Object sourceData,final EdmEntitySet targetEntitySet,final Map<String,Object> targetKeys) throws ODataException {
  if (""String_Node_Str"".equals(targetEntitySet.getName())) {
    ArrayList<Object> data=new ArrayList<Object>();
    if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getTeam().getId().equals(((Team)sourceData).getId()))       data.add(employee);
    }
 else     if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getRoom().getId().equals(((Room)sourceData).getId()))       data.add(employee);
    }
 else     if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getManager().getId().equals(((Manager)sourceData).getId()))       data.add(employee);
    }
    if (data.isEmpty())     throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
 else     return data;
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
}","@Override public Object readRelatedData(final EdmEntitySet sourceEntitySet,final Object sourceData,final EdmEntitySet targetEntitySet,final Map<String,Object> targetKeys) throws ODataException {
  if (""String_Node_Str"".equals(targetEntitySet.getName())) {
    ArrayList<Object> data=new ArrayList<Object>();
    if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getTeam().getId().equals(((Team)sourceData).getId()))       data.add(employee);
    }
 else     if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getRoom().getId().equals(((Room)sourceData).getId()))       data.add(employee);
    }
 else     if (""String_Node_Str"".equals(sourceEntitySet.getName())) {
      for (      final Employee employee : dataContainer.getEmployeeSet())       if (employee.getManager().getId().equals(((Manager)sourceData).getId()))       data.add(employee);
    }
    if (data.isEmpty())     throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
 else     return data;
  }
 else   if (""String_Node_Str"".equals(targetEntitySet.getName())) {
    if (((Employee)sourceData).getTeam() == null)     throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
 else     return ((Employee)sourceData).getTeam();
  }
 else   if (""String_Node_Str"".equals(targetEntitySet.getName())) {
    return null;
  }
 else {
    throw new ODataNotFoundException(ODataNotFoundException.ENTITY);
  }
}",0.884277172001407
18133,"private void handleNormalInitialSegment() throws UriParserException, EdmException {
  final Matcher matcher=INITIAL_SEGMENT_PATTERN.matcher(currentPathSegment);
  if (!matcher.matches())   throw new UriParserException(""String_Node_Str"" + currentPathSegment);
  final String entityContainerName=matcher.group(1);
  final String segmentName=matcher.group(2);
  final String keyPredicate=matcher.group(3);
  final String emptyParentheses=matcher.group(4);
  UriParserImpl.LOG.debug(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ entityContainerName+ ""String_Node_Str""+ segmentName+ ""String_Node_Str""+ keyPredicate+ ""String_Node_Str""+ emptyParentheses);
  uriResult.setEntityContainer(entityContainerName == null ? edm.getDefaultEntityContainer() : edm.getEntityContainer(entityContainerName));
  EdmEntitySet entitySet=null;
  EdmFunctionImport functionImport=null;
  try {
    entitySet=uriResult.getEntityContainer().getEntitySet(segmentName);
  }
 catch (  EdmException e) {
    functionImport=uriResult.getEntityContainer().getFunctionImport(segmentName);
  }
  if (entitySet != null) {
    uriResult.setStartEntitySet(entitySet);
    handleEntitySet(entitySet,keyPredicate);
  }
 else {
    uriResult.setFunctionImport(functionImport);
    handleFunctionImport(functionImport,emptyParentheses,keyPredicate);
  }
}","private void handleNormalInitialSegment() throws UriParserException, EdmException {
  final Matcher matcher=INITIAL_SEGMENT_PATTERN.matcher(currentPathSegment);
  if (!matcher.matches())   throw new UriParserException(""String_Node_Str"" + currentPathSegment);
  final String entityContainerName=matcher.group(1);
  final String segmentName=matcher.group(2);
  final String keyPredicate=matcher.group(3);
  final String emptyParentheses=matcher.group(4);
  UriParserImpl.LOG.debug(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ entityContainerName+ ""String_Node_Str""+ segmentName+ ""String_Node_Str""+ keyPredicate+ ""String_Node_Str""+ emptyParentheses);
  uriResult.setEntityContainer(entityContainerName == null ? edm.getDefaultEntityContainer() : edm.getEntityContainer(entityContainerName));
  EdmEntitySet entitySet=null;
  EdmFunctionImport functionImport=null;
  try {
    entitySet=uriResult.getEntityContainer().getEntitySet(segmentName);
  }
 catch (  EdmException e) {
    functionImport=uriResult.getEntityContainer().getFunctionImport(segmentName);
  }
  if (entitySet != null) {
    uriResult.setStartEntitySet(entitySet);
    handleEntitySet(entitySet,keyPredicate);
  }
 else   if (functionImport != null) {
    uriResult.setFunctionImport(functionImport);
    handleFunctionImport(functionImport,emptyParentheses,keyPredicate);
  }
 else {
    throw new UriParserException(""String_Node_Str"" + segmentName);
  }
}",0.9605786618444846
18134,"private void handleFunctionImport(final EdmFunctionImport functionImport,final String emptyParentheses,final String keyPredicate) throws UriParserException, EdmException {
  final EdmTyped returnType=functionImport.getReturnType();
  final EdmType type=returnType.getType();
  final boolean isCollection=returnType.getMultiplicity() == EdmMultiplicity.MANY;
  if (type.getKind() == EdmTypeKind.ENTITY && isCollection) {
    handleEntitySet(functionImport.getEntitySet(),keyPredicate);
    return;
  }
  if (emptyParentheses != null)   throw new UriParserException(""String_Node_Str"");
  this.uriResult.setTargetType(type);
switch (type.getKind()) {
case SIMPLE:
    uriResult.setUriType(isCollection ? UriType.URI13 : UriType.URI14);
  break;
case COMPLEX:
uriResult.setUriType(isCollection ? UriType.URI11 : UriType.URI12);
break;
case ENTITY:
uriResult.setUriType(UriType.URI10);
break;
default :
throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
}
if (!this.pathSegments.isEmpty()) if (this.uriResult.getUriType() == UriType.URI14) {
currentPathSegment=pathSegments.remove(0).getPath();
if (""String_Node_Str"".equals(currentPathSegment)) uriResult.setValue(true);
 else throw new UriParserException(""String_Node_Str"" + currentPathSegment);
}
if (!pathSegments.isEmpty()) throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
}","private void handleFunctionImport(final EdmFunctionImport functionImport,final String emptyParentheses,final String keyPredicate) throws UriParserException, EdmException {
  final EdmTyped returnType=functionImport.getReturnType();
  final EdmType type=returnType.getType();
  final boolean isCollection=returnType.getMultiplicity() == EdmMultiplicity.MANY;
  if (type.getKind() == EdmTypeKind.ENTITY && isCollection) {
    handleEntitySet(functionImport.getEntitySet(),keyPredicate);
    return;
  }
  if (emptyParentheses != null)   throw new UriParserException(""String_Node_Str"");
  uriResult.setTargetType(type);
switch (type.getKind()) {
case SIMPLE:
    uriResult.setUriType(isCollection ? UriType.URI13 : UriType.URI14);
  break;
case COMPLEX:
uriResult.setUriType(isCollection ? UriType.URI11 : UriType.URI12);
break;
case ENTITY:
uriResult.setUriType(UriType.URI10);
break;
default :
throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
}
if (!pathSegments.isEmpty()) if (uriResult.getUriType() == UriType.URI14) {
currentPathSegment=pathSegments.remove(0).getPath();
if (""String_Node_Str"".equals(currentPathSegment)) uriResult.setValue(true);
 else throw new UriParserException(""String_Node_Str"" + currentPathSegment);
}
ensureLastSegment();
}",0.9182481751824818
18135,"private void handleEntitySet(final EdmEntitySet entitySet,final String keyPredicate) throws UriParserException, EdmException {
  final EdmEntityType entityType=entitySet.getEntityType();
  this.uriResult.setTargetType(entityType);
  this.uriResult.setTargetEntitySet(entitySet);
  if (keyPredicate == null) {
    if (this.pathSegments.isEmpty()) {
      this.uriResult.setUriType(UriType.URI1);
    }
 else {
      currentPathSegment=pathSegments.remove(0).getPath();
      checkCount();
      if (uriResult.isCount())       uriResult.setUriType(UriType.URI15);
 else       throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
    }
  }
 else {
    this.uriResult.setKeyPredicates(this.parseKey(keyPredicate,entityType));
    if (this.pathSegments.isEmpty())     this.uriResult.setUriType(UriType.URI2);
 else     handleNavigationPathOptions();
  }
}","private void handleEntitySet(final EdmEntitySet entitySet,final String keyPredicate) throws UriParserException, EdmException {
  final EdmEntityType entityType=entitySet.getEntityType();
  uriResult.setTargetType(entityType);
  uriResult.setTargetEntitySet(entitySet);
  if (keyPredicate == null) {
    if (pathSegments.isEmpty()) {
      uriResult.setUriType(UriType.URI1);
    }
 else {
      currentPathSegment=pathSegments.remove(0).getPath();
      checkCount();
      if (uriResult.isCount())       uriResult.setUriType(UriType.URI15);
 else       throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
    }
  }
 else {
    uriResult.setKeyPredicates(parseKey(keyPredicate,entityType));
    if (pathSegments.isEmpty())     uriResult.setUriType(UriType.URI2);
 else     handleNavigationPathOptions();
  }
}",0.901805869074492
18136,"private ArrayList<KeyPredicate> parseKey(final String keyPredicate,final EdmEntityType entityType) throws UriParserException, EdmException {
  ArrayList<KeyPredicate> keyPredicates=new ArrayList<KeyPredicate>();
  List<EdmProperty> keyProperties=entityType.getKeyProperties();
  final boolean singleKey=keyProperties.size() == 1;
  for (  final String key : keyPredicate.split(""String_Node_Str"")) {
    final Matcher matcher=NAMED_VALUE_PATTERN.matcher(key);
    if (!matcher.matches())     throw new UriParserException(""String_Node_Str"" + key);
    String name=matcher.group(1);
    final String value=matcher.group(2);
    UriParser.LOG.debug(""String_Node_Str"" + keyPredicate + ""String_Node_Str""+ name+ ""String_Node_Str""+ value);
    if (name == null)     if (singleKey)     name=keyProperties.get(0).getName();
 else     throw new UriParserException(""String_Node_Str"" + keyPredicate);
    EdmProperty keyProperty=null;
    for (    EdmProperty testKeyProperty : keyProperties)     if (testKeyProperty.getName().equals(name)) {
      keyProperty=testKeyProperty;
      break;
    }
    if (keyProperty == null)     throw new UriParserException(""String_Node_Str"" + keyPredicate);
    keyProperties.remove(keyProperty);
    final UriLiteral uriLiteral=parseUriLiteral(value);
    if (!isCompatible(uriLiteral,(EdmSimpleType)keyProperty.getType()))     throw new UriParserException(""String_Node_Str"" + value + ""String_Node_Str""+ keyProperty.getName());
    keyPredicates.add(new KeyPredicate(uriLiteral.getLiteral(),keyProperty));
  }
  if (!keyProperties.isEmpty())   throw new UriParserException(""String_Node_Str"" + keyPredicate);
  return keyPredicates;
}","private ArrayList<KeyPredicate> parseKey(final String keyPredicate,final EdmEntityType entityType) throws UriParserException, EdmException {
  final List<EdmProperty> keyProperties=entityType.getKeyProperties();
  ArrayList<EdmProperty> parsedKeyProperties=new ArrayList<EdmProperty>();
  ArrayList<KeyPredicate> keyPredicates=new ArrayList<KeyPredicate>();
  for (  final String key : keyPredicate.split(""String_Node_Str"",-1)) {
    final Matcher matcher=NAMED_VALUE_PATTERN.matcher(key);
    if (!matcher.matches())     throw new UriParserException(""String_Node_Str"" + key);
    String name=matcher.group(1);
    final String value=matcher.group(2);
    UriParser.LOG.debug(""String_Node_Str"" + keyPredicate + ""String_Node_Str""+ name+ ""String_Node_Str""+ value);
    if (name == null)     if (keyProperties.size() == 1)     name=keyProperties.get(0).getName();
 else     throw new UriParserException(""String_Node_Str"" + keyPredicate);
    EdmProperty keyProperty=null;
    for (    final EdmProperty testKeyProperty : keyProperties)     if (testKeyProperty.getName().equals(name)) {
      keyProperty=testKeyProperty;
      break;
    }
    if (keyProperty == null)     throw new UriParserException(name + ""String_Node_Str"");
    if (parsedKeyProperties.contains(keyProperty))     throw new UriParserException(""String_Node_Str"" + keyPredicate);
    parsedKeyProperties.add(keyProperty);
    final UriLiteral uriLiteral=parseUriLiteral(value);
    if (!isCompatible(uriLiteral,(EdmSimpleType)keyProperty.getType()))     throw new UriParserException(""String_Node_Str"" + value + ""String_Node_Str""+ keyProperty.getName());
    keyPredicates.add(new KeyPredicate(uriLiteral.getLiteral(),keyProperty));
  }
  if (parsedKeyProperties.size() != keyProperties.size())   throw new UriParserException(""String_Node_Str"" + keyPredicate);
  return keyPredicates;
}",0.5725691474194469
18137,"private void handlePropertyPath(final EdmProperty property) throws UriParserException, EdmException {
  this.uriResult.addProperty(property);
  final EdmType type=property.getType();
  if (pathSegments.isEmpty()) {
    if (type.getKind() == EdmTypeKind.SIMPLE)     if (this.uriResult.getPropertyPath().size() == 1)     this.uriResult.setUriType(UriType.URI5);
 else     this.uriResult.setUriType(UriType.URI4);
 else     if (type.getKind() == EdmTypeKind.COMPLEX)     this.uriResult.setUriType(UriType.URI3);
 else     throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
    this.uriResult.setTargetType(type);
  }
 else {
    currentPathSegment=pathSegments.remove(0).getPath();
switch (type.getKind()) {
case SIMPLE:
      if (""String_Node_Str"".equals(currentPathSegment))       if (this.pathSegments.isEmpty()) {
        this.uriResult.setValue(true);
        if (this.uriResult.getPropertyPath().size() == 1)         this.uriResult.setUriType(UriType.URI5);
 else         this.uriResult.setUriType(UriType.URI4);
      }
 else {
        throw new UriParserException(""String_Node_Str"");
      }
 else       throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
    this.uriResult.setTargetType(type);
  break;
case COMPLEX:
final EdmProperty nextProperty=(EdmProperty)((EdmComplexType)type).getProperty(currentPathSegment);
handlePropertyPath(nextProperty);
break;
default :
throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
}
}
}","private void handlePropertyPath(final EdmProperty property) throws UriParserException, EdmException {
  this.uriResult.addProperty(property);
  final EdmType type=property.getType();
  if (pathSegments.isEmpty()) {
    if (type.getKind() == EdmTypeKind.SIMPLE)     if (this.uriResult.getPropertyPath().size() == 1)     this.uriResult.setUriType(UriType.URI5);
 else     this.uriResult.setUriType(UriType.URI4);
 else     if (type.getKind() == EdmTypeKind.COMPLEX)     this.uriResult.setUriType(UriType.URI3);
 else     throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
    this.uriResult.setTargetType(type);
  }
 else {
    currentPathSegment=pathSegments.remove(0).getPath();
switch (type.getKind()) {
case SIMPLE:
      if (""String_Node_Str"".equals(currentPathSegment)) {
        ensureLastSegment();
        uriResult.setValue(true);
        if (uriResult.getPropertyPath().size() == 1)         uriResult.setUriType(UriType.URI5);
 else         uriResult.setUriType(UriType.URI4);
      }
 else {
        throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
      }
    uriResult.setTargetType(type);
  break;
case COMPLEX:
final EdmProperty nextProperty=(EdmProperty)((EdmComplexType)type).getProperty(currentPathSegment);
handlePropertyPath(nextProperty);
break;
default :
throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ pathSegments);
}
}
}",0.890038809831824
18138,"/** 
 * Parse the URI part after an OData service root, already splitted into path segments and query parameters.
 * @param pathSegments  the segments of the resource path, already unescaped
 * @param queryParameters  the query parameters, already unescaped
 * @return a {@link UriParserResult} instance containing the parsed information
 * @throws UriParserException
 */
public UriParserResult parse(final List<PathSegment> pathSegments,final Map<String,String> queryParameters) throws UriParserException {
  this.pathSegments=pathSegments;
  systemQueryOptions=new HashMap<SystemQueryOption,String>();
  otherQueryParameters=new HashMap<String,String>();
  uriResult=new UriParserResult();
  preparePathSegments();
  try {
    handleResourcePath();
    distributeQueryParameters(queryParameters);
    checkSystemQueryOptionsCompatibility();
    handleSystemQueryOptions();
    handleFunctionImportParameters();
  }
 catch (  EdmException e) {
    throw new UriParserException(""String_Node_Str"",e);
  }
  uriResult.setCustomQueryOptions(otherQueryParameters);
  UriParser.LOG.debug(uriResult.toString());
  return uriResult;
}","/** 
 * Parse the URI part after an OData service root, already splitted into path segments and query parameters.
 * @param pathSegments  the {@link PathSegment}s of the resource path, already unescaped
 * @param queryParameters  the query parameters, already unescaped
 * @return a {@link UriParserResult} instance containing the parsed information
 * @throws UriParserException
 */
public UriParserResult parse(final List<PathSegment> pathSegments,final Map<String,String> queryParameters) throws UriParserException {
  this.pathSegments=pathSegments;
  systemQueryOptions=new HashMap<SystemQueryOption,String>();
  otherQueryParameters=new HashMap<String,String>();
  uriResult=new UriParserResult();
  preparePathSegments();
  try {
    handleResourcePath();
    distributeQueryParameters(queryParameters);
    checkSystemQueryOptionsCompatibility();
    handleSystemQueryOptions();
    handleFunctionImportParameters();
  }
 catch (  EdmException e) {
    throw new UriParserException(""String_Node_Str"",e);
  }
  uriResult.setCustomQueryOptions(otherQueryParameters);
  UriParser.LOG.debug(uriResult.toString());
  return uriResult;
}",0.9885260370697264
18139,"private void handleNavigationPathOptions() throws UriParserException, EdmException {
  currentPathSegment=pathSegments.remove(0).getPath();
  checkCount();
  if (uriResult.isCount()) {
    uriResult.setUriType(UriType.URI16);
  }
 else   if (""String_Node_Str"".equals(currentPathSegment)) {
    if (uriResult.getTargetEntitySet().getEntityType().hasStream())     if (this.pathSegments.isEmpty()) {
      this.uriResult.setUriType(UriType.URI17);
      this.uriResult.setValue(true);
    }
 else {
      throw new UriParserException(""String_Node_Str"" + currentPathSegment + ""String_Node_Str""+ this.pathSegments);
    }
 else     throw new UriParserException(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(currentPathSegment)) {
    this.uriResult.setLinks(true);
    if (pathSegments.isEmpty())     throw new UriParserException(""String_Node_Str"");
    currentPathSegment=pathSegments.remove(0).getPath();
    handleNavigationProperties();
  }
 else {
    handleNavigationProperties();
  }
}","private void handleNavigationPathOptions() throws UriParserException, EdmException {
  currentPathSegment=pathSegments.remove(0).getPath();
  checkCount();
  if (uriResult.isCount()) {
    uriResult.setUriType(UriType.URI16);
  }
 else   if (""String_Node_Str"".equals(currentPathSegment)) {
    if (uriResult.getTargetEntitySet().getEntityType().hasStream()) {
      ensureLastSegment();
      uriResult.setUriType(UriType.URI17);
      uriResult.setValue(true);
    }
 else     throw new UriParserException(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(currentPathSegment)) {
    this.uriResult.setLinks(true);
    if (pathSegments.isEmpty())     throw new UriParserException(""String_Node_Str"");
    currentPathSegment=pathSegments.remove(0).getPath();
    handleNavigationProperties();
  }
 else {
    handleNavigationProperties();
  }
}",0.6533692722371968
18140,"private void handleResourcePath() throws UriParserException, EdmException {
  UriParser.LOG.debug(""String_Node_Str"" + pathSegments);
  if (pathSegments.isEmpty()) {
    uriResult.setUriType(UriType.URI0);
    return;
  }
  currentPathSegment=pathSegments.remove(0).getPath();
  if (""String_Node_Str"".equals(currentPathSegment))   if (this.pathSegments.isEmpty())   uriResult.setUriType(UriType.URI8);
 else   throw new UriParserException(""String_Node_Str"" + this.pathSegments);
 else   if (""String_Node_Str"".equals(currentPathSegment))   if (this.pathSegments.isEmpty())   uriResult.setUriType(UriType.URI9);
 else   throw new UriParserException(""String_Node_Str"" + this.pathSegments);
 else   handleNormalInitialSegment();
}","private void handleResourcePath() throws UriParserException, EdmException {
  UriParser.LOG.debug(""String_Node_Str"" + pathSegments);
  if (pathSegments.isEmpty()) {
    uriResult.setUriType(UriType.URI0);
  }
 else {
    currentPathSegment=pathSegments.remove(0).getPath();
    if (""String_Node_Str"".equals(currentPathSegment)) {
      ensureLastSegment();
      uriResult.setUriType(UriType.URI8);
    }
 else     if (""String_Node_Str"".equals(currentPathSegment)) {
      ensureLastSegment();
      uriResult.setUriType(UriType.URI9);
    }
 else {
      handleNormalInitialSegment();
    }
  }
}",0.708018154311649
18141,"private void checkQueryParameterCompatibility() throws UriParserException {
  UriParser.LOG.debug(""String_Node_Str"" + odataQueryParameters);
  UriType uriType=uriResult.getUriType();
  for (  SystemQueryOption queryOption : odataQueryParameters.keySet()) {
    if (!uriType.isCompatible(queryOption))     throw new UriParserException(""String_Node_Str"" + queryOption + ""String_Node_Str""+ uriType);
  }
}","private void checkQueryParameterCompatibility() throws UriParserException {
  UriType uriType=uriResult.getUriType();
  for (  SystemQueryOption queryOption : odataQueryParameters.keySet()) {
    if (uriType == UriType.URI4 && queryOption == SystemQueryOption.$format && uriResult.isValue() == true)     throw new UriParserException(""String_Node_Str"" + queryOption + ""String_Node_Str""+ uriType);
    if (uriType == UriType.URI5 && queryOption == SystemQueryOption.$format && uriResult.isValue() == true)     throw new UriParserException(""String_Node_Str"" + queryOption + ""String_Node_Str""+ uriType);
    if (!uriType.isCompatible(queryOption))     throw new UriParserException(""String_Node_Str"" + queryOption + ""String_Node_Str""+ uriType);
  }
}",0.4725370531822144
18142,"private void handleSystemQueryOptionInlineCount(final String inlineCount) throws UriParserException {
  if (""String_Node_Str"".equals(inlineCount))   uriResult.setInlineCount(InlineCount.ALLPAGES);
 else   if (""String_Node_Str"".equals(inlineCount))   uriResult.setInlineCount(InlineCount.NONE);
 else   if (inlineCount != null)   throw new UriParserException(""String_Node_Str"" + inlineCount + ""String_Node_Str"");
}","private void handleSystemQueryOptionInlineCount(final String inlineCount) throws UriParserException {
  if (""String_Node_Str"".equals(inlineCount))   uriResult.setInlineCount(InlineCount.ALLPAGES);
 else   if (""String_Node_Str"".equals(inlineCount))   uriResult.setInlineCount(InlineCount.NONE);
 else   throw new UriParserException(""String_Node_Str"" + inlineCount + ""String_Node_Str"");
}",0.9662077596996246
18143,"private void handleSystemQueryOptionSkip(final String skip) throws UriParserException {
  if (skip != null) {
    try {
      uriResult.setSkip(Integer.valueOf(skip));
    }
 catch (    NumberFormatException e) {
      throw new UriParserException(""String_Node_Str"" + skip + ""String_Node_Str"",e);
    }
    if (uriResult.getSkip() < 0)     throw new UriParserException(""String_Node_Str"");
  }
}","private void handleSystemQueryOptionSkip(final String skip) throws UriParserException {
  try {
    uriResult.setSkip(Integer.valueOf(skip));
  }
 catch (  NumberFormatException e) {
    throw new UriParserException(""String_Node_Str"" + skip + ""String_Node_Str"",e);
  }
  if (uriResult.getSkip() < 0)   throw new UriParserException(""String_Node_Str"");
}",0.935656836461126
18144,"public UriParserResult parse(final List<PathSegment> pathSegments,Map<String,String> queryParameters) throws UriParserException {
  UriParser.LOG.debug(pathSegments.toString());
  this.uriResult=new UriParserResult();
  this.pathSegments=pathSegments;
  handleResourcePath();
  this.odataQueryParameters=new HashMap<SystemQueryOption,String>();
  this.otherQueryParameters=new HashMap<String,String>();
  for (  String queryOptionString : queryParameters.keySet()) {
    try {
      if (queryOptionString.startsWith(""String_Node_Str"")) {
        SystemQueryOption queryOption=SystemQueryOption.valueOf(queryOptionString);
        this.odataQueryParameters.put(queryOption,queryParameters.get(queryOptionString));
      }
 else {
        otherQueryParameters.put(queryOptionString,queryParameters.get(queryOptionString));
      }
    }
 catch (    IllegalArgumentException e) {
      throw new UriParserException(""String_Node_Str"" + queryOptionString);
    }
  }
  checkQueryParameterCompatibility();
  handleQueryParameters();
  return uriResult;
}","public UriParserResult parse(final List<PathSegment> pathSegments,Map<String,String> queryParameters) throws UriParserException {
  UriParser.LOG.debug(pathSegments.toString());
  this.uriResult=new UriParserResult();
  this.pathSegments=pathSegments;
  handleResourcePath();
  this.odataQueryParameters=new HashMap<SystemQueryOption,String>();
  this.otherQueryParameters=new HashMap<String,String>();
  UriParser.LOG.debug(""String_Node_Str"" + queryParameters);
  for (  String queryOptionString : queryParameters.keySet()) {
    try {
      if (queryOptionString.startsWith(""String_Node_Str"")) {
        SystemQueryOption queryOption=SystemQueryOption.valueOf(queryOptionString);
        this.odataQueryParameters.put(queryOption,queryParameters.get(queryOptionString));
      }
 else {
        otherQueryParameters.put(queryOptionString,queryParameters.get(queryOptionString));
      }
    }
 catch (    IllegalArgumentException e) {
      throw new UriParserException(""String_Node_Str"" + queryOptionString);
    }
  }
  checkQueryParameterCompatibility();
  handleQueryParameters();
  return uriResult;
}",0.9721706864564008
18145,"private void handleSystemQueryOptionTop(final String top) throws UriParserException {
  if (top != null) {
    try {
      uriResult.setTop(Integer.valueOf(top));
    }
 catch (    NumberFormatException e) {
      throw new UriParserException(""String_Node_Str"" + top + ""String_Node_Str"",e);
    }
    if (uriResult.getTop() < 0)     throw new UriParserException(""String_Node_Str"");
  }
}","private void handleSystemQueryOptionTop(final String top) throws UriParserException {
  try {
    uriResult.setTop(Integer.valueOf(top));
  }
 catch (  NumberFormatException e) {
    throw new UriParserException(""String_Node_Str"" + top + ""String_Node_Str"",e);
  }
  if (uriResult.getTop() < 0)   throw new UriParserException(""String_Node_Str"");
}",0.9358799454297408
18146,"private void handleSystemQueryOptionFormat(final String format) throws UriParserException {
  if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.ATOM);
 else   if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.JSON);
 else   if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.XML);
 else   if (""String_Node_Str"".equals(format))   throw new UriParserException(""String_Node_Str"");
}","private void handleSystemQueryOptionFormat(final String format) throws UriParserException {
  if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.ATOM);
 else   if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.JSON);
 else   if (""String_Node_Str"".equals(format))   uriResult.setFormat(Format.XML);
 else   throw new UriParserException(""String_Node_Str"" + format + ""String_Node_Str"");
}",0.9185360094451004
18147,"@Test public void parseSystemQueryOptions() throws Exception {
  UriParserResult result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
  assertEquals(InlineCount.ALLPAGES,result.getInlineCount());
  assertEquals(""String_Node_Str"",result.getSkipToken());
  assertEquals(2,result.getSkip());
  assertEquals(1,result.getTop().intValue());
  result=parse(""String_Node_Str"");
  assertEquals(Format.ATOM,result.getFormat());
  assertEquals(InlineCount.NONE,result.getInlineCount());
  assertEquals(0,result.getTop().intValue());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
  assertEquals(InlineCount.NONE,result.getInlineCount());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.ATOM,result.getFormat());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.XML,result.getFormat());
  assertNull(result.getTop());
  result=parse(""String_Node_Str"");
  assertEquals(Format.JSON,result.getFormat());
}","@Test public void parseSystemQueryOptions() throws Exception {
  UriParserResult result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
  assertEquals(InlineCount.ALLPAGES,result.getInlineCount());
  assertEquals(""String_Node_Str"",result.getSkipToken());
  assertEquals(2,result.getSkip());
  assertEquals(1,result.getTop().intValue());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.ATOM,result.getFormat());
  assertEquals(InlineCount.NONE,result.getInlineCount());
  assertEquals(0,result.getTop().intValue());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
  assertEquals(InlineCount.NONE,result.getInlineCount());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.ATOM,result.getFormat());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI1,result.getUriType());
  assertEquals(Format.XML,result.getFormat());
  assertNull(result.getTop());
  result=parse(""String_Node_Str"");
  assertEquals(Format.JSON,result.getFormat());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI4,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
  result=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getTargetEntitySet().getName());
  assertEquals(UriType.URI5,result.getUriType());
  assertEquals(Format.JSON,result.getFormat());
}",0.7203956939191155
18148,"@Test public void parseInCompatibleSystemQueryOptions() throws Exception {
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
}","@Test public void parseInCompatibleSystemQueryOptions() throws Exception {
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
  parseWrongUri(""String_Node_Str"");
}",0.6727272727272727
18149,"/** 
 * Get service for configured key provider <p> This method gets an auth key and so it blocks and shouldn't be called on the main thread.
 * @return bootstrap service
 * @throws IOException
 * @throws AccountsException
 */
public BootstrapService getService(Activity activity) throws IOException, AccountsException {
  return new BootstrapService(keyProvider.getAuthKey(),userAgentProvider);
}","/** 
 * Get service for configured key provider <p> This method gets an auth key and so it blocks and shouldn't be called on the main thread.
 * @return bootstrap service
 * @throws IOException
 * @throws AccountsException
 */
public BootstrapService getService(Activity activity) throws IOException, AccountsException {
  return new BootstrapService(keyProvider.getAuthKey(activity),userAgentProvider);
}",0.9900249376558604
18150,"@Override public void notifyNewActiveMember(final ClusterMember member,final List<ClusterMember> members){
  Runnable task=new Runnable(){
    @Override public void run(){
      for (      ClusterEventListener listener : listeners) {
        listener.onNewInactiveMember(member,members);
      }
    }
  }
;
  eventListenersExecutorService.execute(task);
}","@Override public void notifyNewActiveMember(final ClusterMember member,final List<ClusterMember> members){
  Runnable task=new Runnable(){
    @Override public void run(){
      for (      ClusterEventListener listener : listeners) {
        listener.onNewActiveMember(member,members);
      }
    }
  }
;
  eventListenersExecutorService.execute(task);
}",0.9943661971830986
18151,"private GossipMessage generateMessage(ClusterMember to){
  GossipMessage reply=new GossipMessage(clusterId,memberId,to.getId());
  List<GossipClusterMember> members=new ArrayList<GossipClusterMember>(activeMembers.values());
  GossipClusterMember me=new GossipClusterMember(memberId,host,port,System.currentTimeMillis(),clusterStateHash);
  members.add(me);
  clusterStateHash=hashProvider.hashCluster(members);
  me.setHash(clusterStateHash);
  reply.setMemberInfo(members);
  return reply;
}","private GossipMessage generateMessage(ClusterMember to){
  GossipMessage reply=new GossipMessage(clusterId,memberId,to.getId());
  List<GossipClusterMember> members=new ArrayList<GossipClusterMember>(activeMembers.values());
  GossipClusterMember me=new GossipClusterMember(memberId,host,port,System.currentTimeMillis(),clusterStateHash);
  members.add(me);
  me.setHash(clusterStateHash);
  reply.setMemberInfo(members);
  return reply;
}",0.9184549356223176
18152,"@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str"",""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      rt.exec(new String[]{""String_Node_Str"",""String_Node_Str"",cmd.toString()});
      System.out.println(""String_Node_Str"" + cmd);
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str"",""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cmd);
      rt.exec(new String[]{""String_Node_Str"",""String_Node_Str"",cmd.toString()});
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      e.printStackTrace();
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    e1.printStackTrace();
  }
}",0.9277389277389276
18153,"@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      rt.exec(new String[]{""String_Node_Str"",""String_Node_Str"",cmd.toString()});
      System.out.println(""String_Node_Str"" + cmd);
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cmd);
      rt.exec(new String[]{cmd.toString()});
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      e.printStackTrace();
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    e1.printStackTrace();
  }
}",0.9078630004823928
18154,"@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      rt.exec(new String[]{""String_Node_Str"",""String_Node_Str"",cmd.toString()});
      System.out.println(""String_Node_Str"" + cmd);
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString() + ""String_Node_Str""+ e.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override public void launchLibreOffice(String cmisUrl,String repositoryId,String filePath){
  Runtime rt=Runtime.getRuntime();
  try {
    String params=LibreOfficeLauncherHelper.generateLibreOfficeOpenUrl(cmisUrl,repositoryId,filePath);
    StringBuffer cmd=new StringBuffer();
    try {
      String[] binaryLocations={""String_Node_Str""};
      for (int i=0; i < binaryLocations.length; i++)       cmd.append((i == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + binaryLocations[i] + ""String_Node_Str""+ params+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cmd);
      rt.exec(new String[]{""String_Node_Str"",""String_Node_Str"",cmd.toString()});
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + cmd.toString() + ""String_Node_Str""+ e.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      e.printStackTrace();
    }
  }
 catch (  UnsupportedEncodingException e1) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    e1.printStackTrace();
  }
}",0.928801102434543
18155,"private void createRightLayout(){
  LayoutParams right=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
  right.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  right.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  addView(rightText,right);
}","private void createRightLayout(int width){
  LayoutParams right=new LayoutParams(width,LayoutParams.WRAP_CONTENT);
  right.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  right.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  addView(rightText,right);
}",0.9224652087475148
18156,"private void setupView(Context context){
  setBackgroundResource(android.R.color.transparent);
  createLeftText(context);
  createRightText(context);
  createCenterText(context);
  createLeftLayout();
  createRightLayout();
  createCenterLayout();
}","private void setupView(Context context){
  setBackgroundResource(android.R.color.transparent);
  DisplayMetrics metrics=context.getResources().getDisplayMetrics();
  int maxSize=metrics.widthPixels / 3;
  createLeftText(context);
  createRightText(context);
  createCenterText(context);
  createLeftLayout((int)(metrics.widthPixels * .25));
  createRightLayout((int)(metrics.widthPixels * .25));
  createCenterLayout((int)(metrics.widthPixels * .50));
}",0.7094017094017094
18157,"private void createRightText(Context context){
  rightText=new TextView(context);
  rightText.setText(""String_Node_Str"");
  rightText.setTextSize(18);
  rightText.setTextColor(Color.BLACK);
  rightText.setId(1);
}","private void createRightText(Context context){
  rightText=new TextView(context);
  rightText.setText(""String_Node_Str"");
  rightText.setTextSize(18);
  rightText.setTextColor(Color.BLACK);
  rightText.setId(1);
  rightText.setGravity(Gravity.CENTER);
}",0.9141630901287554
18158,"private void createCenterLayout(){
  LayoutParams right=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
  right.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  right.addRule(RelativeLayout.CENTER_IN_PARENT);
  addView(centerText,right);
}","private void createCenterLayout(int width){
  LayoutParams right=new LayoutParams(width,LayoutParams.WRAP_CONTENT);
  right.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  right.addRule(RelativeLayout.CENTER_IN_PARENT);
  addView(centerText,right);
}",0.9184890656063618
18159,"private void createCenterText(Context context){
  centerText=new TextView(context);
  centerText.setText(""String_Node_Str"");
  centerText.setTextSize(18);
  centerText.setTextColor(Color.BLACK);
  centerText.setId(3);
}","private void createCenterText(Context context){
  centerText=new TextView(context);
  centerText.setText(""String_Node_Str"");
  centerText.setTextSize(18);
  centerText.setTextColor(Color.BLACK);
  centerText.setId(3);
  centerText.setGravity(Gravity.CENTER);
}",0.9144050104384134
18160,"private void createLeftLayout(){
  LayoutParams left=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
  left.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  left.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
  addView(leftText,left);
}","private void createLeftLayout(int width){
  LayoutParams left=new LayoutParams(width,LayoutParams.WRAP_CONTENT);
  left.addRule(RelativeLayout.ALIGN_PARENT_TOP);
  left.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
  addView(leftText,left);
}",0.916155419222904
18161,"private void createLeftText(Context context){
  leftText=new TextView(context);
  leftText.setText(""String_Node_Str"");
  leftText.setTextSize(18);
  leftText.setTextColor(Color.BLACK);
  leftText.setId(2);
}","private void createLeftText(Context context){
  leftText=new TextView(context);
  leftText.setText(""String_Node_Str"");
  leftText.setTextSize(18);
  leftText.setTextColor(Color.BLACK);
  leftText.setId(2);
  leftText.setGravity(Gravity.CENTER);
}",0.913907284768212
18162,"public void clearSelected(){
  setSelected(-1);
}","public void clearSelected(){
  setSelected(NO_VALUE_SELECTED);
}",0.831858407079646
18163,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getAllEntries();
  View view=inflater.inflate(R.layout.list_view,null);
  ListView listView=(ListView)view.findViewById(R.id.listOfAllRecords);
  adapter=new DrivingRecordAdapter(getSherlockActivity(),drivingRecordList);
  listView.setAdapter(adapter);
  listView.setSelector(R.drawable.custom_selector);
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      getSherlockActivity().startActionMode(new EditDeleteActionMode(adapter));
      adapter.setSelected(position);
    }
  }
);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  getAllEntries();
  View view=inflater.inflate(R.layout.list_view,null);
  ListView listView=(ListView)view.findViewById(R.id.listOfAllRecords);
  adapter=new DrivingRecordAdapter(getSherlockActivity(),drivingRecordList);
  listView.setAdapter(adapter);
  listView.setSelector(R.drawable.custom_selector);
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      if (adapter.isIndexSelected(DrivingRecordAdapter.NO_VALUE_SELECTED)) {
        actionMode=getSherlockActivity().startActionMode(new EditDeleteActionMode(adapter));
        adapter.setSelected(position);
      }
 else       if (!adapter.isIndexSelected(position)) {
        adapter.setSelected(position);
      }
 else       if (actionMode != null) {
        actionMode.finish();
        actionMode=null;
      }
    }
  }
);
  return view;
}",0.8188209843158464
18164,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  getSherlockActivity().startActionMode(new EditDeleteActionMode(adapter));
  adapter.setSelected(position);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  if (adapter.isIndexSelected(DrivingRecordAdapter.NO_VALUE_SELECTED)) {
    actionMode=getSherlockActivity().startActionMode(new EditDeleteActionMode(adapter));
    adapter.setSelected(position);
  }
 else   if (!adapter.isIndexSelected(position)) {
    adapter.setSelected(position);
  }
 else   if (actionMode != null) {
    actionMode.finish();
    actionMode=null;
  }
}",0.6003016591251885
18165,"private Constructor<?> findConstructor(Class<?> clazz,Object... args){
  Constructor<?> ctor=null;
  final Constructor<?>[] ctors=clazz.getDeclaredConstructors();
  if (ctors.length == 1 && ctors[0].getParameterTypes().length == args.length) {
    ctor=ctors[0];
  }
  if (ctors.length > 1) {
    for (    Constructor<?> ctor2 : ctors) {
      final Class<?>[] parameterTypes=ctor2.getParameterTypes();
      if (parameterTypes.length != args.length) {
        continue;
      }
      boolean signatureCheckFailed=false;
      for (int i=0; i < parameterTypes.length; i++) {
        if (args[i] != null && !parameterTypes[i].isAssignableFrom(args[i].getClass())) {
          signatureCheckFailed=false;
          break;
        }
      }
      if (!signatureCheckFailed) {
        ctor=ctor2;
        break;
      }
    }
  }
  if (null == ctor) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    for (    Object object : args) {
      sb.append(""String_Node_Str"").append(object.getClass().getName()).append(""String_Node_Str"");
    }
    throw new RuntimeException(sb.toString());
  }
  return ctor;
}","private Constructor<?> findConstructor(Class<?> clazz,Object... args){
  Constructor<?> result=null;
  final Constructor<?>[] ctors=clazz.getDeclaredConstructors();
  if (ctors.length == 1 && ctors[0].getParameterTypes().length == args.length) {
    result=ctors[0];
  }
  if (ctors.length > 1) {
    NEXT_CONSTRUCTOR:     for (    Constructor<?> ctor : ctors) {
      final Class<?>[] parameterTypes=postProcessConstructorParameterTypes(ctor.getParameterTypes());
      if (parameterTypes.length != args.length) {
        continue NEXT_CONSTRUCTOR;
      }
      for (int i=0; i < parameterTypes.length; i++) {
        Class<?> argType=convertToBoxTypeIfPrimitive(args[i].getClass());
        if (args[i] != null && !parameterTypes[i].isAssignableFrom(argType)) {
          continue NEXT_CONSTRUCTOR;
        }
      }
      result=ctor;
      break;
    }
  }
  if (null == result) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    for (    Object object : args) {
      sb.append(""String_Node_Str"").append(object.getClass().getName()).append(""String_Node_Str"");
    }
    throw new RuntimeException(sb.toString());
  }
  return result;
}",0.7665198237885462
18166,"@BeforeClass public static void init() throws ClassNotFoundException, SQLException, FileNotFoundException {
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(""String_Node_Str"");
  em=emf.createEntityManager();
  EntityTransaction trx=em.getTransaction();
  trx.begin();
  Employee e=new Employee();
  e.setName(""String_Node_Str"");
  em.persist(e);
  trx.commit();
  employeeId=e.getId();
}","@BeforeClass public static void init() throws ClassNotFoundException, SQLException, FileNotFoundException {
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(""String_Node_Str"");
  em=emf.createEntityManager();
  EntityTransaction trx=em.getTransaction();
  trx.begin();
  Employee e=new Employee();
  e.setName(""String_Node_Str"");
  em.persist(e);
  trx.commit();
  employeeId=e.getId();
  emplyoeeName=e.getName();
}",0.9665871121718376
18167,"@Test public void listWithJpqlWhenUniqueResult(){
  Query q=em.createQuery(""String_Node_Str"");
  List<Long> list=jpaResultMapper.list(q,Long.class);
  Assert.assertNotNull(list);
  Assert.assertEquals(1,list.size());
  Assert.assertEquals(employeeId,list.get(0).longValue());
}","@Test public void listWithJpqlWhenUniqueResult(){
  Query q=em.createQuery(""String_Node_Str"");
  List<Integer> list=jpaResultMapper.list(q,Integer.class);
  Assert.assertNotNull(list);
  Assert.assertEquals(1,list.size());
  Assert.assertEquals(employeeId,list.get(0).intValue());
}",0.9481216457960644
18168,"private void setupChart(LineChart chart,LineData data,int color){
  ((LineDataSet)data.getDataSetByIndex(0)).setCircleColorHole(color);
  chart.getDescription().setEnabled(false);
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisLeft().setSpaceTop(40);
  chart.getAxisLeft().setSpaceBottom(40);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  ((LineDataSet)data.getDataSetByIndex(0)).setCircleHoleColor(color);
  chart.getDescription().setEnabled(false);
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisLeft().setSpaceTop(40);
  chart.getAxisLeft().setSpaceBottom(40);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}",0.994413407821229
18169,"@Override public DataSet<BarEntry> copy(){
  List<BarEntry> yVals=new ArrayList<BarEntry>();
  yVals.clear();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}","protected void copy(BarDataSet barDataSet){
  super.copy(barDataSet);
  barDataSet.mStackSize=mStackSize;
  barDataSet.mBarShadowColor=mBarShadowColor;
  barDataSet.mBarBorderWidth=mBarBorderWidth;
  barDataSet.mStackLabels=mStackLabels;
  barDataSet.mHighLightAlpha=mHighLightAlpha;
}",0.3704663212435233
18170,"@Override public List<GradientColor> getGradientColors(){
  return gradientColors;
}","@Override public List<GradientColor> getGradientColors(){
  return mGradientColors;
}",0.9822485207100592
18171,"/** 
 * Sets the start and end color for gradient color, ONLY color that should be used for this DataSet.
 * @param startColor
 * @param endColor
 */
public void setGradientColor(int startColor,int endColor){
  gradientColor=new GradientColor(startColor,endColor);
}","/** 
 * Sets the start and end color for gradient color, ONLY color that should be used for this DataSet.
 * @param startColor
 * @param endColor
 */
public void setGradientColor(int startColor,int endColor){
  mGradientColor=new GradientColor(startColor,endColor);
}",0.9943714821763602
18172,"/** 
 * Sets the start and end color for gradient colors, ONLY color that should be used for this DataSet.
 * @param gradientColors
 */
public void setGradientColors(List<GradientColor> gradientColors){
  this.gradientColors=gradientColors;
}","/** 
 * Sets the start and end color for gradient colors, ONLY color that should be used for this DataSet.
 * @param gradientColors
 */
public void setGradientColors(List<GradientColor> gradientColors){
  this.mGradientColors=gradientColors;
}",0.9938144329896909
18173,"@Override public GradientColor getGradientColor(int index){
  return gradientColors.get(index % gradientColors.size());
}","@Override public GradientColor getGradientColor(int index){
  return mGradientColors.get(index % mGradientColors.size());
}",0.9754098360655736
18174,"@Override public DataSet<BubbleEntry> copy(){
  List<BubbleEntry> yVals=new ArrayList<BubbleEntry>();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  BubbleDataSet copied=new BubbleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","protected void copy(BubbleDataSet bubbleDataSet){
  bubbleDataSet.mHighlightCircleWidth=mHighlightCircleWidth;
  bubbleDataSet.mNormalizeSize=mNormalizeSize;
}",0.3170731707317073
18175,"@Override public DataSet<CandleEntry> copy(){
  List<CandleEntry> yVals=new ArrayList<CandleEntry>();
  yVals.clear();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mShowCandleBar=mShowCandleBar;
  copied.mBarSpace=mBarSpace;
  copied.mHighLightColor=mHighLightColor;
  copied.mIncreasingPaintStyle=mIncreasingPaintStyle;
  copied.mDecreasingPaintStyle=mDecreasingPaintStyle;
  copied.mShadowColor=mShadowColor;
  return copied;
}","protected void copy(CandleDataSet candleDataSet){
  super.copy(candleDataSet);
  candleDataSet.mShadowWidth=mShadowWidth;
  candleDataSet.mShowCandleBar=mShowCandleBar;
  candleDataSet.mBarSpace=mBarSpace;
  candleDataSet.mShadowColorSameAsCandle=mShadowColorSameAsCandle;
  candleDataSet.mHighLightColor=mHighLightColor;
  candleDataSet.mIncreasingPaintStyle=mIncreasingPaintStyle;
  candleDataSet.mDecreasingPaintStyle=mDecreasingPaintStyle;
  candleDataSet.mNeutralColor=mNeutralColor;
  candleDataSet.mIncreasingColor=mIncreasingColor;
  candleDataSet.mDecreasingColor=mDecreasingColor;
  candleDataSet.mShadowColor=mShadowColor;
}",0.0340080971659919
18176,"/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet<T> copy();","/** 
 * @param dataSet
 */
protected void copy(DataSet dataSet){
  super.copy(dataSet);
}",0.3942307692307692
18177,"@Override public DataSet<Entry> copy(){
  List<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mMode=mMode;
  copied.mColors=mColors;
  copied.mCircleRadius=mCircleRadius;
  copied.mCircleHoleRadius=mCircleHoleRadius;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCircleHole=mDrawCircleHole;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","protected void copy(LineDataSet lineDataSet){
  super.copy(lineDataSet);
  lineDataSet.mCircleColors=mCircleColors;
  lineDataSet.mCircleHoleColor=mCircleHoleColor;
  lineDataSet.mCircleHoleRadius=mCircleHoleRadius;
  lineDataSet.mCircleRadius=mCircleRadius;
  lineDataSet.mCubicIntensity=mCubicIntensity;
  lineDataSet.mDashPathEffect=mDashPathEffect;
  lineDataSet.mDrawCircleHole=mDrawCircleHole;
  lineDataSet.mDrawCircles=mDrawCircleHole;
  lineDataSet.mFillFormatter=mFillFormatter;
  lineDataSet.mMode=mMode;
}",0.2124542124542124
18178,"@Override public int getCircleHoleColor(){
  return mCircleColorHole;
}","@Override public int getCircleHoleColor(){
  return mCircleHoleColor;
}",0.943661971830986
18179,"protected void calculateLegendOffsets(RectF offsets){
  offsets.left=0.f;
  offsets.right=0.f;
  offsets.top=0.f;
  offsets.bottom=0.f;
  if (mLegend != null && mLegend.isEnabled() && !mLegend.isDrawInsideEnabled()) {
switch (mLegend.getOrientation()) {
case VERTICAL:
switch (mLegend.getHorizontalAlignment()) {
case LEFT:
        offsets.left+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
      break;
case RIGHT:
    offsets.right+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
  break;
case CENTER:
switch (mLegend.getVerticalAlignment()) {
case TOP:
  offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
}
break;
case HORIZONTAL:
switch (mLegend.getVerticalAlignment()) {
case TOP:
offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
if (getXAxis().isEnabled() && getXAxis().isDrawLabelsEnabled()) offsets.top+=getXAxis().mLabelRotatedHeight;
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
if (getXAxis().isEnabled() && getXAxis().isDrawLabelsEnabled()) offsets.bottom+=getXAxis().mLabelRotatedHeight;
break;
default :
break;
}
break;
}
}
}","protected void calculateLegendOffsets(RectF offsets){
  offsets.left=0.f;
  offsets.right=0.f;
  offsets.top=0.f;
  offsets.bottom=0.f;
  if (mLegend != null && mLegend.isEnabled() && !mLegend.isDrawInsideEnabled()) {
switch (mLegend.getOrientation()) {
case VERTICAL:
switch (mLegend.getHorizontalAlignment()) {
case LEFT:
        offsets.left+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
      break;
case RIGHT:
    offsets.right+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
  break;
case CENTER:
switch (mLegend.getVerticalAlignment()) {
case TOP:
  offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
}
break;
case HORIZONTAL:
switch (mLegend.getVerticalAlignment()) {
case TOP:
offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
break;
}
}
}",0.9122349102773246
18180,"@Override public void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    calculateLegendOffsets(mOffsetsBuffer);
    offsetLeft+=mOffsetsBuffer.left;
    offsetTop+=mOffsetsBuffer.top;
    offsetRight+=mOffsetsBuffer.right;
    offsetBottom+=mOffsetsBuffer.bottom;
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xlabelheight=mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    offsetTop+=getExtraTopOffset();
    offsetRight+=getExtraRightOffset();
    offsetBottom+=getExtraBottomOffset();
    offsetLeft+=getExtraLeftOffset();
    float minOffset=Utils.convertDpToPixel(mMinOffset);
    mViewPortHandler.restrainViewPort(Math.max(minOffset,offsetLeft),Math.max(minOffset,offsetTop),Math.max(minOffset,offsetRight),Math.max(minOffset,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override public void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    calculateLegendOffsets(mOffsetsBuffer);
    offsetLeft+=mOffsetsBuffer.left;
    offsetTop+=mOffsetsBuffer.top;
    offsetRight+=mOffsetsBuffer.right;
    offsetBottom+=mOffsetsBuffer.bottom;
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xLabelHeight=mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xLabelHeight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xLabelHeight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xLabelHeight;
        offsetTop+=xLabelHeight;
      }
    }
    offsetTop+=getExtraTopOffset();
    offsetRight+=getExtraRightOffset();
    offsetBottom+=getExtraBottomOffset();
    offsetLeft+=getExtraLeftOffset();
    float minOffset=Utils.convertDpToPixel(mMinOffset);
    mViewPortHandler.restrainViewPort(Math.max(minOffset,offsetLeft),Math.max(minOffset,offsetTop),Math.max(minOffset,offsetRight),Math.max(minOffset,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9944506104328524
18181,"/** 
 * Draws the zero line.
 */
protected void drawZeroLine(Canvas c){
  int clipRestoreCount=c.save();
  mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
  mZeroLineClippingRect.inset(0.f,-mYAxis.getZeroLineWidth() / 2.f);
  c.clipRect(mLimitLineClippingRect);
  MPPointD pos=mTrans.getPixelForValues(0f,0f);
  mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
  mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());
  Path zeroLinePath=mDrawZeroLinePath;
  zeroLinePath.reset();
  zeroLinePath.moveTo(mViewPortHandler.contentLeft(),(float)pos.y - 1);
  zeroLinePath.lineTo(mViewPortHandler.contentRight(),(float)pos.y - 1);
  c.drawPath(zeroLinePath,mZeroLinePaint);
  c.restoreToCount(clipRestoreCount);
}","/** 
 * Draws the zero line.
 */
protected void drawZeroLine(Canvas c){
  int clipRestoreCount=c.save();
  mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
  mZeroLineClippingRect.inset(0.f,-mYAxis.getZeroLineWidth() / 2.f);
  c.clipRect(mZeroLineClippingRect);
  MPPointD pos=mTrans.getPixelForValues(0f,0f);
  mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
  mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());
  Path zeroLinePath=mDrawZeroLinePath;
  zeroLinePath.reset();
  zeroLinePath.moveTo(mViewPortHandler.contentLeft(),(float)pos.y - 1);
  zeroLinePath.lineTo(mViewPortHandler.contentRight(),(float)pos.y - 1);
  c.drawPath(zeroLinePath,mZeroLinePaint);
  c.restoreToCount(clipRestoreCount);
}",0.9938144329896909
18182,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f > Utils.FLOAT_EPSILON) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}",0.9875095036385358
18183,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=mDrawHighlightedRectF;
  highlightedCircleBox.set(0,0,0,0);
  for (int i=0; i < indices.length; i++) {
    int index=(int)indices[i].getX();
    if (index >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
        visibleAngleCount++;
      }
    }
    if (index == 0)     angle=0.f;
 else     angle=absoluteAngles[index - 1] * phaseX;
    final float sliceSpace=visibleAngleCount <= 1 ? 0.f : set.getSliceSpace();
    float sliceAngle=drawAngles[index];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
    mRenderPaint.setColor(set.getColor(index));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (accountForSliceSpacing) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
      if (accountForSliceSpacing) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        if (accountForSliceSpacing) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
  MPPointF.recycleInstance(center);
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=mDrawHighlightedRectF;
  highlightedCircleBox.set(0,0,0,0);
  for (int i=0; i < indices.length; i++) {
    int index=(int)indices[i].getX();
    if (index >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
        visibleAngleCount++;
      }
    }
    if (index == 0)     angle=0.f;
 else     angle=absoluteAngles[index - 1] * phaseX;
    final float sliceSpace=visibleAngleCount <= 1 ? 0.f : set.getSliceSpace();
    float sliceAngle=drawAngles[index];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
    mRenderPaint.setColor(set.getColor(index));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (accountForSliceSpacing) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
      if (accountForSliceSpacing) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f > Utils.FLOAT_EPSILON) {
        if (accountForSliceSpacing) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
  MPPointF.recycleInstance(center);
}",0.985987989705462
18184,"/** 
 * Returns the Description object of the chart.
 * @return
 */
public Description getDescription(){
  return mDescription;
}","/** 
 * Returns the Description object of the chart that is responsible for holding all information related to the description text that is displayed in the bottom right corner of the chart (by default).
 * @return
 */
public Description getDescription(){
  return mDescription;
}",0.6308068459657702
18185,"/** 
 * Sets up the axis values. Computes the desired number of labels between the two given extremes.
 * @return
 */
protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0) {
    mAxis.mEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  if (Double.isInfinite(rawInterval)) {
    rawInterval=range > 0.0 && !Double.isInfinite(range) ? range : 1.0;
  }
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
}","/** 
 * Sets up the axis values. Computes the desired number of labels between the two given extremes.
 * @return
 */
protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {
    mAxis.mEntries=new float[]{};
    mAxis.mCenteredEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
}",0.9612661391087048
18186,"@Override protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0) {
    mAxis.mEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  if (Double.isInfinite(rawInterval)) {
    rawInterval=range > 0.0 && !Double.isInfinite(range) ? range : 1.0;
  }
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    n++;
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
  mAxis.mAxisMinimum=mAxis.mEntries[0];
  mAxis.mAxisMaximum=mAxis.mEntries[n - 1];
  mAxis.mAxisRange=Math.abs(mAxis.mAxisMaximum - mAxis.mAxisMinimum);
}","@Override protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {
    mAxis.mEntries=new float[]{};
    mAxis.mCenteredEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    n++;
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
  mAxis.mAxisMinimum=mAxis.mEntries[0];
  mAxis.mAxisMaximum=mAxis.mEntries[n - 1];
  mAxis.mAxisRange=Math.abs(mAxis.mAxisMaximum - mAxis.mAxisMinimum);
}",0.9621335504885994
18187,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}",0.9598516255727688
18188,"@Override public void drawValues(Canvas c){
  MPPointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawEntryLabels=mChart.isDrawEntryLabelsEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawValues=dataSet.isDrawValuesEnabled();
    if (!drawValues && !drawEntryLabels)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    IValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    final float sliceSpace=getSliceSpace(dataSet);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawValues && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawValues && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight / 2f);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  MPPointF.recycleInstance(center);
  c.restore();
}","@Override public void drawValues(Canvas c){
  MPPointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawEntryLabels=mChart.isDrawEntryLabelsEnabled();
  float angle;
  int xIndex=0;
  c.save();
  float offset=Utils.convertDpToPixel(5.f);
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawValues=dataSet.isDrawValuesEnabled();
    if (!drawValues && !drawEntryLabels)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    IValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    final float sliceSpace=getSliceSpace(dataSet);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawValues && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawValues && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          if (drawXOutside)           mEntryLabelsPaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          if (drawXOutside)           mEntryLabelsPaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight / 2f);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  MPPointF.recycleInstance(center);
  c.restore();
}",0.9797602984363838
18189,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setExtraOffsets(5,10,5,5);
  mChart.setDragDecelerationFrictionCoef(0.95f);
  mChart.setCenterTextTypeface(mTfLight);
  mChart.setCenterText(generateCenterSpannableText());
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColor(Color.WHITE);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setTransparentCircleAlpha(110);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setHighlightPerTapEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  setData(4,100);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuad);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(0f);
  l.setYOffset(0f);
  mChart.setEntryLabelColor(Color.WHITE);
  mChart.setEntryLabelTypeface(mTfRegular);
  mChart.setEntryLabelTextSize(12f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(10);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setExtraOffsets(5,10,5,5);
  mChart.setDragDecelerationFrictionCoef(0.95f);
  mChart.setCenterTextTypeface(mTfLight);
  mChart.setCenterText(generateCenterSpannableText());
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColor(Color.WHITE);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setTransparentCircleAlpha(110);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setHighlightPerTapEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  setData(4,100);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuad);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(0f);
  l.setYOffset(0f);
  mChart.setEntryLabelColor(Color.WHITE);
  mChart.setEntryLabelTypeface(mTfRegular);
  mChart.setEntryLabelTextSize(12f);
}",0.93595166163142
18190,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setTouchEnabled(true);
  mChart.setMaxHighlightDistance(50f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(mTfLight);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setAxisMinValue(0f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(mTfLight);
  xl.setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setTouchEnabled(true);
  mChart.setMaxHighlightDistance(50f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(mTfLight);
  l.setXOffset(5f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setAxisMinValue(0f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(mTfLight);
  xl.setDrawGridLines(false);
}",0.9924012158054712
18191,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param high         - the highlight object
 * @param callListener - call the listener
 */
public void highlightValue(Highlight high,boolean callListener){
  Entry e=null;
  if (high == null)   mIndicesToHighlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null) {
      mIndicesToHighlight=null;
      high=null;
    }
 else {
      mIndicesToHighlight=new Highlight[]{high};
    }
  }
  if (callListener && mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high);
    }
  }
  invalidate();
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param high         - the highlight object
 * @param callListener - call the listener
 */
public void highlightValue(Highlight high,boolean callListener){
  Entry e=null;
  if (high == null)   mIndicesToHighlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null) {
      mIndicesToHighlight=null;
      high=null;
    }
 else {
      mIndicesToHighlight=new Highlight[]{high};
    }
  }
  setLastHighlighted(mIndicesToHighlight);
  if (callListener && mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high);
    }
  }
  invalidate();
}",0.9753015508328546
18192,"/** 
 * Highlights the values at the given indices in the given DataSets. Provide null or an empty array to undo all highlighting. This should be used to programmatically highlight values. This DOES NOT generate a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightValues(Highlight[] highs){
  mIndicesToHighlight=highs;
  if (highs == null || highs.length <= 0 || highs[0] == null) {
    mChartTouchListener.setLastHighlighted(null);
  }
 else {
    mChartTouchListener.setLastHighlighted(highs[0]);
  }
  invalidate();
}","/** 
 * Highlights the values at the given indices in the given DataSets. Provide null or an empty array to undo all highlighting. This should be used to programmatically highlight values. This DOES NOT generate a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightValues(Highlight[] highs){
  mIndicesToHighlight=highs;
  setLastHighlighted(highs);
  invalidate();
}",0.8012486992715921
18193,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseY=mAnimator.getPhaseY();
  float[] circlesBuffer=mCirclesBuffer;
  circlesBuffer[0]=0;
  circlesBuffer[1]=0;
  List<ILineDataSet> dataSets=mChart.getLineData().getDataSets();
  final int dataSetCount=dataSets.size();
  for (int i=0; i < dataSetCount; i++) {
    ILineDataSet dataSet=dataSets.get(i);
    DataSetImageCache imageCache;
    if (mImageCaches.containsKey(dataSet)) {
      imageCache=mImageCaches.get(dataSet);
    }
 else {
      imageCache=new DataSetImageCache();
      mImageCaches.put(dataSet,imageCache);
    }
    imageCache.ensureCircleCache(dataSet.getCircleColorCount());
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    if (mXBoundsBuffer == null) {
      mXBoundsBuffer=getXBounds(mChart,dataSet);
    }
 else {
      mXBoundsBuffer.set(mChart,dataSet);
    }
    XBounds bounds=mXBoundsBuffer;
    float circleRadius=dataSet.getCircleRadius();
    float circleHoleRadius=dataSet.getCircleHoleRadius();
    boolean drawCircleHole=dataSet.isDrawCircleHoleEnabled() && circleHoleRadius < circleRadius && circleHoleRadius > 0.f;
    boolean drawTransparentCircleHole=drawCircleHole && dataSet.getCircleHoleColor() == ColorTemplate.COLOR_NONE;
    int boundsRangeCount=bounds.range + bounds.min;
    for (int j=bounds.min; j <= boundsRangeCount; j++) {
      Entry e=dataSet.getEntryForIndex(j);
      if (e == null)       break;
      circlesBuffer[0]=e.getX();
      circlesBuffer[1]=e.getY() * phaseY;
      trans.pointValuesToPixel(circlesBuffer);
      if (!mViewPortHandler.isInBoundsRight(circlesBuffer[0]))       break;
      if (!mViewPortHandler.isInBoundsLeft(circlesBuffer[0]) || !mViewPortHandler.isInBoundsY(circlesBuffer[1]))       continue;
      final int circleColor=dataSet.getCircleColor(j);
      mRenderPaint.setColor(circleColor);
      Bitmap circleBitmap=null;
      final int dataSetColorCount=imageCache.circleColors.length;
      int colorIndex;
      for (colorIndex=0; colorIndex < dataSetColorCount; colorIndex++) {
        int tempColor=imageCache.circleColors[colorIndex];
        Bitmap tempBitmap=imageCache.circleBitmaps[colorIndex];
        if (tempColor == circleColor) {
          circleBitmap=tempBitmap;
          break;
        }
 else         if (tempBitmap == null) {
          break;
        }
      }
      if (circleBitmap == null) {
        Bitmap.Config conf=Bitmap.Config.ARGB_8888;
        circleBitmap=Bitmap.createBitmap((int)circleRadius * 2,(int)circleRadius * 2,conf);
        Canvas canvas=new Canvas(circleBitmap);
        imageCache.circleBitmaps[colorIndex]=circleBitmap;
        imageCache.circleColors[colorIndex]=circleColor;
        if (drawTransparentCircleHole) {
          mCirclePathBuffer.reset();
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleRadius,Path.Direction.CW);
          mCirclePathBuffer.addCircle(circleHoleRadius,circleHoleRadius,circleHoleRadius,Path.Direction.CCW);
          canvas.drawPath(mCirclePathBuffer,mRenderPaint);
        }
 else {
          canvas.drawCircle(circleRadius,circleRadius,circleRadius,mRenderPaint);
          if (drawCircleHole) {
            canvas.drawCircle(circleRadius,circleRadius,circleHoleRadius,mCirclePaintInner);
          }
        }
      }
      if (circleBitmap != null) {
        c.drawBitmap(circleBitmap,circlesBuffer[0] - circleRadius,circlesBuffer[1] - circleRadius,mRenderPaint);
      }
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseY=mAnimator.getPhaseY();
  float[] circlesBuffer=mCirclesBuffer;
  circlesBuffer[0]=0;
  circlesBuffer[1]=0;
  List<ILineDataSet> dataSets=mChart.getLineData().getDataSets();
  final int dataSetCount=dataSets.size();
  for (int i=0; i < dataSetCount; i++) {
    ILineDataSet dataSet=dataSets.get(i);
    DataSetImageCache imageCache;
    if (mImageCaches.containsKey(dataSet)) {
      imageCache=mImageCaches.get(dataSet);
    }
 else {
      imageCache=new DataSetImageCache();
      mImageCaches.put(dataSet,imageCache);
    }
    imageCache.ensureCircleCache(dataSet.getCircleColorCount());
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    if (mXBoundsBuffer == null) {
      mXBoundsBuffer=getXBounds(mChart,dataSet);
    }
 else {
      mXBoundsBuffer.set(mChart,dataSet);
    }
    XBounds bounds=mXBoundsBuffer;
    float circleRadius=dataSet.getCircleRadius();
    float circleHoleRadius=dataSet.getCircleHoleRadius();
    boolean drawCircleHole=dataSet.isDrawCircleHoleEnabled() && circleHoleRadius < circleRadius && circleHoleRadius > 0.f;
    boolean drawTransparentCircleHole=drawCircleHole && dataSet.getCircleHoleColor() == ColorTemplate.COLOR_NONE;
    int boundsRangeCount=bounds.range + bounds.min;
    for (int j=bounds.min; j <= boundsRangeCount; j++) {
      Entry e=dataSet.getEntryForIndex(j);
      if (e == null)       break;
      circlesBuffer[0]=e.getX();
      circlesBuffer[1]=e.getY() * phaseY;
      trans.pointValuesToPixel(circlesBuffer);
      if (!mViewPortHandler.isInBoundsRight(circlesBuffer[0]))       break;
      if (!mViewPortHandler.isInBoundsLeft(circlesBuffer[0]) || !mViewPortHandler.isInBoundsY(circlesBuffer[1]))       continue;
      final int circleColor=dataSet.getCircleColor(j);
      mRenderPaint.setColor(circleColor);
      Bitmap circleBitmap=null;
      final int dataSetColorCount=imageCache.circleColors.length;
      int colorIndex;
      for (colorIndex=0; colorIndex < dataSetColorCount; colorIndex++) {
        int tempColor=imageCache.circleColors[colorIndex];
        Bitmap tempBitmap=imageCache.circleBitmaps[colorIndex];
        if (tempColor == circleColor) {
          circleBitmap=tempBitmap;
          break;
        }
 else         if (tempBitmap == null) {
          break;
        }
      }
      if (circleBitmap == null) {
        Bitmap.Config conf=Bitmap.Config.ARGB_8888;
        circleBitmap=Bitmap.createBitmap((int)(circleRadius * 2.1),(int)(circleRadius * 2.1),conf);
        Canvas canvas=new Canvas(circleBitmap);
        imageCache.circleBitmaps[colorIndex]=circleBitmap;
        imageCache.circleColors[colorIndex]=circleColor;
        if (drawTransparentCircleHole) {
          mCirclePathBuffer.reset();
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleRadius,Path.Direction.CW);
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleHoleRadius,Path.Direction.CCW);
          canvas.drawPath(mCirclePathBuffer,mRenderPaint);
        }
 else {
          canvas.drawCircle(circleRadius,circleRadius,circleRadius,mRenderPaint);
          if (drawCircleHole) {
            canvas.drawCircle(circleRadius,circleRadius,circleHoleRadius,mCirclePaintInner);
          }
        }
      }
      if (circleBitmap != null) {
        c.drawBitmap(circleBitmap,circlesBuffer[0] - circleRadius,circlesBuffer[1] - circleRadius,mRenderPaint);
      }
    }
  }
}",0.9978201634877384
18194,"/** 
 * Enabled/disable granularity control on axis value intervals. If enabled, the axis interval is not allowed to go below a certain granularity. Default: false
 * @param enabled
 */
public void setGranularityEnabled(boolean enabled){
  mGranularityEnabled=true;
}","/** 
 * Enabled/disable granularity control on axis value intervals. If enabled, the axis interval is not allowed to go below a certain granularity. Default: false
 * @param enabled
 */
public void setGranularityEnabled(boolean enabled){
  mGranularityEnabled=enabled;
}",0.9795158286778398
18195,"/** 
 * Performs all necessary operations needed for dragging.
 * @param event
 */
private void performDrag(MotionEvent event){
  mLastGesture=ChartGesture.DRAG;
  mMatrix.set(mSavedMatrix);
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  float dX, dY;
  if (mChart.isAnyAxisInverted() && mClosestDataSetToTouch != null && mChart.getAxis(mClosestDataSetToTouch.getAxisDependency()).isInverted()) {
    if (mChart instanceof HorizontalBarChart) {
      dX=-(event.getX() - mTouchStartPoint.x);
      dY=event.getY() - mTouchStartPoint.y;
    }
 else {
      dX=event.getX() - mTouchStartPoint.x;
      dY=-(event.getY() - mTouchStartPoint.y);
    }
  }
 else {
    dX=event.getX() - mTouchStartPoint.x;
    dY=event.getY() - mTouchStartPoint.y;
  }
  mMatrix.postTranslate(dX,dY);
  if (l != null)   l.onChartTranslate(event,dX,dY);
}","/** 
 * Performs all necessary operations needed for dragging.
 * @param event
 */
private void performDrag(MotionEvent event){
  mLastGesture=ChartGesture.DRAG;
  mMatrix.set(mSavedMatrix);
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  float dX, dY;
  if (inverted()) {
    if (mChart instanceof HorizontalBarChart) {
      dX=-(event.getX() - mTouchStartPoint.x);
      dY=event.getY() - mTouchStartPoint.y;
    }
 else {
      dX=event.getX() - mTouchStartPoint.x;
      dY=-(event.getY() - mTouchStartPoint.y);
    }
  }
 else {
    dX=event.getX() - mTouchStartPoint.x;
    dY=event.getY() - mTouchStartPoint.y;
  }
  mMatrix.postTranslate(dX,dY);
  if (l != null)   l.onChartTranslate(event,dX,dY);
}",0.3657142857142857
18196,"/** 
 * returns the correct translation depending on the provided x and y touch points
 * @param x
 * @param y
 * @return
 */
public PointF getTrans(float x,float y){
  ViewPortHandler vph=mChart.getViewPortHandler();
  float xTrans=x - vph.offsetLeft();
  float yTrans=0f;
  if (mChart.isAnyAxisInverted() && mClosestDataSetToTouch != null && mChart.isInverted(mClosestDataSetToTouch.getAxisDependency())) {
    yTrans=-(y - vph.offsetTop());
  }
 else {
    yTrans=-(mChart.getMeasuredHeight() - y - vph.offsetBottom());
  }
  return new PointF(xTrans,yTrans);
}","/** 
 * returns the correct translation depending on the provided x and y touch points
 * @param x
 * @param y
 * @return
 */
public PointF getTrans(float x,float y){
  ViewPortHandler vph=mChart.getViewPortHandler();
  float xTrans=x - vph.offsetLeft();
  float yTrans=0f;
  if (inverted()) {
    yTrans=-(y - vph.offsetTop());
  }
 else {
    yTrans=-(mChart.getMeasuredHeight() - y - vph.offsetBottom());
  }
  return new PointF(xTrans,yTrans);
}",0.5903257650542941
18197,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesBubble(IBubbleDataSet data,float phaseY,int from,int to){
  final int count=(int)Math.ceil(to - from) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getY() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesBubble(IBubbleDataSet data,float phaseY,int from,int to){
  final int count=(to - from + 1) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getY() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9852700490998364
18198,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the CANDLESTICKCHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesCandle(ICandleDataSet data,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil((to - from) * phaseX) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    CandleEntry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getHigh() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the CANDLESTICKCHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesCandle(ICandleDataSet data,float phaseX,float phaseY,int from,int to){
  final int count=(int)((to - from) * phaseX + 1) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    CandleEntry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getHigh() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.990023023791251
18199,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(mTfLight);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(false);
  xl.setGridLineWidth(0.3f);
  xl.setGranularity(10f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setAxisMinValue(0f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(mTfLight);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setAxisMinValue(0f);
  setData(12,50);
  mChart.setFitBars(true);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(mTfLight);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(false);
  xl.setGranularity(10f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setAxisMinValue(0f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(mTfLight);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setAxisMinValue(0f);
  setData(12,50);
  mChart.setFitBars(true);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9910077519379844
18200,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  LimitLine llXAxis=new LimitLine(10f,""String_Node_Str"");
  llXAxis.setLineWidth(4f);
  llXAxis.enableDashedLine(10f,10f,0f);
  llXAxis.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  llXAxis.setTextSize(10f);
  XAxis xAxis=mChart.getXAxis();
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.RIGHT_TOP);
  ll1.setTextSize(10f);
  ll1.setTypeface(tf);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  ll2.setTextSize(10f);
  ll2.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.enableGridDashedLine(10f,10f,0f);
  leftAxis.setDrawZeroLine(false);
  leftAxis.setDrawLimitLinesBehindData(true);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  LimitLine llXAxis=new LimitLine(10f,""String_Node_Str"");
  llXAxis.setLineWidth(4f);
  llXAxis.enableDashedLine(10f,10f,0f);
  llXAxis.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  llXAxis.setTextSize(10f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.enableGridDashedLine(10f,10f,0f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.RIGHT_TOP);
  ll1.setTextSize(10f);
  ll1.setTypeface(tf);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  ll2.setTextSize(10f);
  ll2.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.enableGridDashedLine(10f,10f,0f);
  leftAxis.setDrawZeroLine(false);
  leftAxis.setDrawLimitLinesBehindData(true);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.9910333048676344
18201,"/** 
 * Set this to true to make the highlight operation full-bar oriented, false to make it highlight single values (relevant only for stacked). Default: false
 * @param enabled
 */
public void setHighlightFullBarEnabled(boolean enabled){
  mHighlightFullBarEnabled=enabled;
}","/** 
 * Set this to true to make the highlight operation full-bar oriented, false to make it highlight single values (relevant only for stacked). If enabled, highlighting operations will highlight the whole bar, even if only a single stack entry was tapped. Default: false
 * @param enabled
 */
public void setHighlightFullBarEnabled(boolean enabled){
  mHighlightFullBarEnabled=enabled;
}",0.8318318318318318
18202,"/** 
 * Highlights the value at the given x-position in the given DataSet. Provide -1 as the dataSetIndex to undo all highlighting.
 * @param x
 * @param dataSetIndex
 * @param stackIndex the index inside the stack - only relevant for stacked entries
 */
public void highlightValue(float x,int dataSetIndex,int stackIndex){
  highlightValue(new Highlight(x,dataSetIndex,stackIndex),false);
}","/** 
 * Highlights the value at the given x-position in the given DataSet. Provide -1 as the dataSetIndex to undo all highlighting.
 * @param x
 * @param dataSetIndex
 * @param stackIndex   the index inside the stack - only relevant for stacked entries
 */
public void highlightValue(float x,int dataSetIndex,int stackIndex){
  highlightValue(new Highlight(x,dataSetIndex,stackIndex),false);
}",0.9974489795918368
18203,"@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] positions=new float[mXAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i]=mXAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  Path gridLinePath=new Path();
  for (int i=0; i < positions.length; i+=2) {
    float x=positions[i];
    if (x >= mViewPortHandler.offsetLeft() && x <= mViewPortHandler.getChartWidth()) {
      gridLinePath.moveTo(x,mViewPortHandler.contentBottom());
      gridLinePath.lineTo(x,mViewPortHandler.contentTop());
      c.drawPath(gridLinePath,mGridPaint);
    }
    gridLinePath.reset();
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] positions=new float[mXAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i]=mXAxis.mEntries[i / 2];
    positions[i + 1]=mXAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  setupGridPaint();
  Path gridLinePath=new Path();
  for (int i=0; i < positions.length; i+=2) {
    drawGridLine(c,positions[i],positions[i + 1],gridLinePath);
  }
}",0.4147398843930636
18204,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          labels.add(pds.getEntryForIndex(j).getLabel());
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        colors.add(((ICandleDataSet)dataSet).getDecreasingColor());
        colors.add(((ICandleDataSet)dataSet).getIncreasingColor());
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          labels.add(pds.getEntryForIndex(j).getLabel());
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        int decreasingColor=((ICandleDataSet)dataSet).getDecreasingColor();
        colors.add(decreasingColor);
        int increasingColor=((ICandleDataSet)dataSet).getIncreasingColor();
        colors.add(increasingColor);
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.9708302169035152
18205,"/** 
 * Constructor for bubbles.
 * @param xValue
 * @param yValue
 * @param bubbleSize
 */
public RealmDemoData(float xValue,float yValue,float bubbleSize){
  this.xValue=xValue;
  this.yValue=yValue;
  this.bubbleSize=bubbleSize;
}","/** 
 * Constructor for pie chart.
 * @param yValue
 * @param label
 */
public RealmDemoData(float yValue,String label){
  this.yValue=yValue;
  this.label=label;
}",0.7002518891687658
18206,"protected void writeToDBPie(){
  mRealm.beginTransaction();
  mRealm.clear(RealmDemoData.class);
  float value1=15f + (float)(Math.random() * 8f);
  float value2=15f + (float)(Math.random() * 8f);
  float value3=15f + (float)(Math.random() * 8f);
  float value4=15f + (float)(Math.random() * 8f);
  float value5=100f - value1 - value2- value3- value4;
  float[] values=new float[]{value1,value2,value3,value4,value5};
  String[] xValues=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < values.length; i++) {
    RealmDemoData d=new RealmDemoData(i,values[i]);
    mRealm.copyToRealm(d);
  }
  mRealm.commitTransaction();
}","protected void writeToDBPie(){
  mRealm.beginTransaction();
  mRealm.clear(RealmDemoData.class);
  float value1=15f + (float)(Math.random() * 8f);
  float value2=15f + (float)(Math.random() * 8f);
  float value3=15f + (float)(Math.random() * 8f);
  float value4=15f + (float)(Math.random() * 8f);
  float value5=100f - value1 - value2- value3- value4;
  float[] values=new float[]{value1,value2,value3,value4,value5};
  String[] labels=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < values.length; i++) {
    RealmDemoData d=new RealmDemoData(values[i],labels[i]);
    mRealm.copyToRealm(d);
  }
  mRealm.commitTransaction();
}",0.97647897362794
18207,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmPieDataSet<RealmDemoData> set=new RealmPieDataSet<RealmDemoData>(result,""String_Node_Str"");
  set.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set.setLabel(""String_Node_Str"");
  set.setSliceSpace(2);
  PieData data=new PieData(set);
  styleData(data);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(12f);
  mChart.setData(data);
  mChart.animateY(1400);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmPieDataSet<RealmDemoData> set=new RealmPieDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set.setLabel(""String_Node_Str"");
  set.setSliceSpace(2);
  PieData data=new PieData(set);
  styleData(data);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(12f);
  mChart.setData(data);
  mChart.animateY(1400);
}",0.9815573770491804
18208,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart_noseekbar);
  mChart=(RadarChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getYAxis().setEnabled(false);
  mChart.setWebAlpha(180);
  mChart.setWebColorInner(Color.DKGRAY);
  mChart.setWebColor(Color.GRAY);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart_noseekbar);
  mChart=(RadarChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getYAxis().setEnabled(false);
  mChart.getXAxis().setEnabled(false);
  mChart.setWebAlpha(180);
  mChart.setWebColorInner(Color.DKGRAY);
  mChart.setWebColor(Color.GRAY);
}",0.9606458123107972
18209,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realm_wiki);
  lineChart=(LineChart)findViewById(R.id.lineChart);
  barChart=(BarChart)findViewById(R.id.barChart);
  setup(lineChart);
  setup(barChart);
  lineChart.setExtraBottomOffset(5f);
  barChart.setExtraBottomOffset(5f);
  lineChart.getAxisLeft().setDrawGridLines(false);
  lineChart.getXAxis().setDrawGridLines(false);
  barChart.getAxisLeft().setDrawGridLines(false);
  barChart.getXAxis().setDrawGridLines(false);
  barChart.getXAxis().setCenterAxisLabels(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realm_wiki);
  lineChart=(LineChart)findViewById(R.id.lineChart);
  barChart=(BarChart)findViewById(R.id.barChart);
  setup(lineChart);
  setup(barChart);
  lineChart.setExtraBottomOffset(5f);
  barChart.setExtraBottomOffset(5f);
  lineChart.getAxisLeft().setDrawGridLines(false);
  lineChart.getXAxis().setDrawGridLines(false);
  lineChart.getXAxis().setLabelCount(5);
  lineChart.getXAxis().setGranularity(1f);
  barChart.getAxisLeft().setDrawGridLines(false);
  barChart.getXAxis().setDrawGridLines(false);
  barChart.getXAxis().setLabelCount(5);
  barChart.getXAxis().setGranularity(1f);
}",0.8981422165278667
18210,"private void setData(){
  final RealmResults<Score> results=mRealm.allObjects(Score.class);
  AxisValueFormatter formatter=new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return results.get((int)value).getPlayerName();
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
;
  lineChart.getXAxis().setValueFormatter(formatter);
  barChart.getXAxis().setValueFormatter(formatter);
  RealmLineDataSet<Score> lineDataSet=new RealmLineDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  lineDataSet.setDrawCubic(false);
  lineDataSet.setLabel(""String_Node_Str"");
  lineDataSet.setDrawCircleHole(false);
  lineDataSet.setColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setCircleColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setLineWidth(1.8f);
  lineDataSet.setCircleSize(3.6f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(lineDataSet);
  LineData lineData=new LineData(dataSets);
  styleData(lineData);
  lineChart.setData(lineData);
  lineChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
  RealmBarDataSet<Score> barDataSet=new RealmBarDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  barDataSet.setColors(new int[]{ColorTemplate.rgb(""String_Node_Str""),ColorTemplate.rgb(""String_Node_Str"")});
  barDataSet.setLabel(""String_Node_Str"");
  ArrayList<IBarDataSet> barDataSets=new ArrayList<IBarDataSet>();
  barDataSets.add(barDataSet);
  BarData barData=new BarData(barDataSets);
  styleData(barData);
  barChart.setData(barData);
  barChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  final RealmResults<Score> results=mRealm.allObjects(Score.class);
  AxisValueFormatter formatter=new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return results.get((int)value).getPlayerName();
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
;
  lineChart.getXAxis().setValueFormatter(formatter);
  barChart.getXAxis().setValueFormatter(formatter);
  RealmLineDataSet<Score> lineDataSet=new RealmLineDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  lineDataSet.setDrawCubic(false);
  lineDataSet.setLabel(""String_Node_Str"");
  lineDataSet.setDrawCircleHole(false);
  lineDataSet.setColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setCircleColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setLineWidth(1.8f);
  lineDataSet.setCircleSize(3.6f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(lineDataSet);
  LineData lineData=new LineData(dataSets);
  styleData(lineData);
  lineChart.setData(lineData);
  lineChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
  RealmBarDataSet<Score> barDataSet=new RealmBarDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  barDataSet.setColors(new int[]{ColorTemplate.rgb(""String_Node_Str""),ColorTemplate.rgb(""String_Node_Str"")});
  barDataSet.setLabel(""String_Node_Str"");
  ArrayList<IBarDataSet> barDataSets=new ArrayList<IBarDataSet>();
  barDataSets.add(barDataSet);
  BarData barData=new BarData(barDataSets);
  styleData(barData);
  barChart.setData(barData);
  barChart.setFitBars(true);
  barChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9913972115099378
18211,"/** 
 * Constructor that takes the realm RealmResults, sorts & stores them.
 * @param results
 * @param yValuesField
 * @param xIndexField
 */
public RealmLineScatterCandleRadarDataSet(RealmResults<T> results,String yValuesField,String xIndexField){
  super(results,yValuesField,xIndexField);
}","/** 
 * Constructor that takes the realm RealmResults, sorts & stores them.
 * @param results
 * @param xValueField
 * @param yValuesField
 */
public RealmLineScatterCandleRadarDataSet(RealmResults<T> results,String xValueField,String yValuesField){
  super(results,xValueField,yValuesField);
}",0.8197278911564626
18212,"/** 
 * Constructor for creating a LineDataSet with realm data.
 * @param result      the queried results from the realm database
 * @param highField   the name of the field in your data object that represents the ""high"" yValue
 * @param lowField    the name of the field in your data object that represents the ""low"" yValue
 * @param openField   the name of the field in your data object that represents the ""open"" yValue
 * @param closeField  the name of the field in your data object that represents the ""close"" yValue
 * @param xIndexField the name of the field in your data object that represents the xPx-index
 */
public RealmCandleDataSet(RealmResults<T> result,String highField,String lowField,String openField,String closeField,String xIndexField){
  super(result,null,xIndexField);
  this.mHighField=highField;
  this.mLowField=lowField;
  this.mOpenField=openField;
  this.mCloseField=closeField;
  build(this.results);
  calcMinMax();
}","/** 
 * Constructor for creating a LineDataSet with realm data.
 * @param result      the queried results from the realm database
 * @param xValueField the name of the field in your data object that represents the ""x"" value
 * @param highField   the name of the field in your data object that represents the ""high"" value
 * @param lowField    the name of the field in your data object that represents the ""low"" value
 * @param openField   the name of the field in your data object that represents the ""open"" value
 * @param closeField  the name of the field in your data object that represents the ""close"" value
 */
public RealmCandleDataSet(RealmResults<T> result,String xValueField,String highField,String lowField,String openField,String closeField){
  super(result,xValueField,null);
  this.mHighField=highField;
  this.mLowField=lowField;
  this.mOpenField=openField;
  this.mCloseField=closeField;
  build(this.results);
  calcMinMax();
}",0.8255813953488372
18213,"public CandleEntry buildEntryFromResultObject(T realmObject,int xIndex){
  DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
  return new CandleEntry(mXValuesField == null ? xIndex : dynamicObject.getFloat(mXValuesField),dynamicObject.getFloat(mHighField),dynamicObject.getFloat(mLowField),dynamicObject.getFloat(mOpenField),dynamicObject.getFloat(mCloseField));
}","@Override public CandleEntry buildEntryFromResultObject(T realmObject,float x){
  DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
  return new CandleEntry(mXValuesField == null ? x : dynamicObject.getFloat(mXValuesField),dynamicObject.getFloat(mHighField),dynamicObject.getFloat(mLowField),dynamicObject.getFloat(mOpenField),dynamicObject.getFloat(mCloseField));
}",0.961038961038961
18214,"/** 
 * Constructor for creating a PieDataSet with realm data.
 * @param result       the queried results from the realm database
 * @param yValuesField the name of the field in your data object that represents the yPx-yValue
 */
public RealmPieDataSet(RealmResults<T> result,String yValuesField){
  super(result,yValuesField);
  build(this.results);
  calcMinMax();
}","public RealmPieDataSet(RealmResults<T> result,String yValuesField,String labelField){
  super(result,yValuesField);
  this.mLabelField=labelField;
  build(this.results);
  calcMinMax();
}",0.4972972972972973
18215,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawYVals=dataSet.isDrawValuesEnabled();
    if (!drawYVals && !drawXVals)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    ValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpace=dataSet.getSliceSpace();
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawXVals && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawYVals && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawXVals && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawYVals && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount()) {
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight,mValuePaint);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount()) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f,mValuePaint);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount()) {
            c.drawText(entry.getLabel(),x,y + lineHeight,mValuePaint);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount()) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),x,y + lineHeight / 2f,mValuePaint);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  c.restore();
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawYVals=dataSet.isDrawValuesEnabled();
    if (!drawYVals && !drawXVals)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    ValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpace=dataSet.getSliceSpace();
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawXVals && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawYVals && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawXVals && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawYVals && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight,mValuePaint);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f,mValuePaint);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            c.drawText(entry.getLabel(),x,y + lineHeight,mValuePaint);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),x,y + lineHeight / 2f,mValuePaint);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  c.restore();
}",0.9910371318822024
18216,"protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float left=x - barWidthHalf;
  float right=x + barWidthHalf;
  float top=y1;
  float bottom=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float left=x - barWidthHalf;
  float right=x + barWidthHalf;
  float top=y1;
  float bottom=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectToPixelPhase(mBarRect,mAnimator.getPhaseY());
}",0.983108108108108
18217,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      float entryIndex=set.getEntryIndex(e);
      if (e == null || entryIndex > set.getEntryCount() * mAnimator.getPhaseX())       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}",0.9615525448553645
18218,"@Override protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float top=x - barWidthHalf;
  float bottom=x + barWidthHalf;
  float left=y1;
  float right=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","@Override protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float top=x - barWidthHalf;
  float bottom=x + barWidthHalf;
  float left=y1;
  float right=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectToPixelPhaseHorizontal(mBarRect,mAnimator.getPhaseY());
}",0.9678456591639872
18219,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  r.top*=phaseY;
  r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices.
 * @param r
 */
public void rectValueToPixel(RectF r){
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.8107074569789675
18220,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragDecelerationFrictionCoef(0.9f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setHighlightPerDragEnabled(true);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(12f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setDrawGridLines(true);
  leftAxis.setGranularityEnabled(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
  rightAxis.setDrawZeroLine(false);
  rightAxis.setGranularityEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragDecelerationFrictionCoef(0.9f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setHighlightPerDragEnabled(true);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(11f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setDrawGridLines(true);
  leftAxis.setGranularityEnabled(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
  rightAxis.setDrawZeroLine(false);
  rightAxis.setGranularityEnabled(false);
}",0.9995361781076066
18221,"@Override public void notifyDataSetChanged(){
  if (mData == null) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum,mAxisLeft.isInverted());
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum,mAxisRight.isInverted());
  if (mLegend != null)   mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mData == null) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum,mAxisLeft.isInverted());
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum,mAxisRight.isInverted());
  mXAxisRenderer.computeAxis(mXAxis.mAxisMinimum,mXAxis.mAxisMaximum,false);
  if (mLegend != null)   mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9376518218623482
18222,"@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  float yoffset=mXAxis.getYOffset();
  mAxisLabelPaint.setTypeface(mXAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mXAxis.getTextSize());
  mAxisLabelPaint.setColor(mXAxis.getTextColor());
  if (mXAxis.getPosition() == XAxisPosition.TOP) {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.TOP_INSIDE) {
    drawLabels(c,mViewPortHandler.contentTop() + yoffset + mXAxis.mLabelRotatedHeight,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE) {
    drawLabels(c,mViewPortHandler.contentBottom() - yoffset - mXAxis.mLabelRotatedHeight,new PointF(0.5f,0.0f));
  }
 else {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  float yoffset=mXAxis.getYOffset();
  mAxisLabelPaint.setTypeface(mXAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mXAxis.getTextSize());
  mAxisLabelPaint.setColor(mXAxis.getTextColor());
  if (mXAxis.getPosition() == XAxisPosition.TOP) {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,0.9f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.TOP_INSIDE) {
    drawLabels(c,mViewPortHandler.contentTop() + yoffset + mXAxis.mLabelRotatedHeight,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE) {
    drawLabels(c,mViewPortHandler.contentBottom() - yoffset - mXAxis.mLabelRotatedHeight,new PointF(0.5f,0.0f));
  }
 else {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
}",0.9973637961335676
18223,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart_noseekbar);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setExtraTopOffset(-30f);
  mChart.setExtraBottomOffset(10f);
  mChart.setExtraLeftOffset(70f);
  mChart.setExtraRightOffset(70f);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextColor(Color.LTGRAY);
  xAxis.setTextSize(13f);
  YAxis left=mChart.getAxisLeft();
  left.setDrawLabels(false);
  left.setStartAtZero(false);
  left.setSpaceTop(25f);
  left.setSpaceBottom(25f);
  left.setDrawAxisLine(false);
  left.setDrawGridLines(false);
  left.setDrawZeroLine(true);
  left.setZeroLineColor(Color.GRAY);
  left.setZeroLineWidth(0.7f);
  mChart.getAxisRight().setEnabled(false);
  mChart.getLegend().setEnabled(false);
  List<Data> data=new ArrayList<>();
  data.add(new Data(0,-224.1f,""String_Node_Str""));
  data.add(new Data(1,238.5f,""String_Node_Str""));
  data.add(new Data(2,1280.1f,""String_Node_Str""));
  data.add(new Data(3,-442.3f,""String_Node_Str""));
  data.add(new Data(4,-2280.1f,""String_Node_Str""));
  setData(data);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart_noseekbar);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setExtraTopOffset(-30f);
  mChart.setExtraBottomOffset(10f);
  mChart.setExtraLeftOffset(70f);
  mChart.setExtraRightOffset(70f);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextColor(Color.LTGRAY);
  xAxis.setTextSize(13f);
  xAxis.setAxisMinValue(0f);
  xAxis.setAxisMaxValue(5f);
  xAxis.setLabelCount(5);
  xAxis.setCenterAxisLabels(true);
  xAxis.setGranularity(1f);
  YAxis left=mChart.getAxisLeft();
  left.setDrawLabels(false);
  left.setStartAtZero(false);
  left.setSpaceTop(25f);
  left.setSpaceBottom(25f);
  left.setDrawAxisLine(false);
  left.setDrawGridLines(false);
  left.setDrawZeroLine(true);
  left.setZeroLineColor(Color.GRAY);
  left.setZeroLineWidth(0.7f);
  mChart.getAxisRight().setEnabled(false);
  mChart.getLegend().setEnabled(false);
  final List<Data> data=new ArrayList<>();
  data.add(new Data(0.5f,-224.1f,""String_Node_Str""));
  data.add(new Data(1.5f,238.5f,""String_Node_Str""));
  data.add(new Data(2.5f,1280.1f,""String_Node_Str""));
  data.add(new Data(3.5f,-442.3f,""String_Node_Str""));
  data.add(new Data(4.5f,-2280.1f,""String_Node_Str""));
  xAxis.setValueFormatter(new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return data.get(Math.min(Math.max((int)value,0),data.size() - 1)).xAxisValue;
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
);
  setData(data);
}",0.8713235294117647
18224,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      BarBuffer buffer=mBarBuffers[i];
      if (!dataSet.isStacked()) {
        for (int j=0; j < buffer.buffer.length * mAnimator.getPhaseX(); j+=4) {
          float x=(buffer.buffer[j] + buffer.buffer[j + 2]) / 2f;
          if (!mViewPortHandler.isInBoundsRight(x))           break;
          if (!mViewPortHandler.isInBoundsY(buffer.buffer[j + 1]) || !mViewPortHandler.isInBoundsLeft(x))           continue;
          BarEntry entry=dataSet.getEntryForIndex(j / 4);
          float val=entry.getY();
          drawValue(c,dataSet.getValueFormatter(),val,entry,i,x,buffer.buffer[j + 1] + (val >= 0 ? posOffset : negOffset),dataSet.getValueTextColor(j / 4));
        }
      }
 else {
        Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
        int bufferIndex=0;
        int index=0;
        while (index < dataSet.getEntryCount() * mAnimator.getPhaseX()) {
          BarEntry entry=dataSet.getEntryForIndex(index);
          float[] vals=entry.getYVals();
          float x=(buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2f;
          int color=dataSet.getValueTextColor(index);
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(x))             break;
            if (!mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1]) || !mViewPortHandler.isInBoundsLeft(x))             continue;
            drawValue(c,dataSet.getValueFormatter(),entry.getY(),entry,i,x,buffer.buffer[bufferIndex + 1] + (entry.getY() >= 0 ? posOffset : negOffset),color);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-entry.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,dataSet.getValueFormatter(),vals[k / 2],entry,i,x,y,color);
            }
          }
          bufferIndex=vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;
          index++;
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      BarBuffer buffer=mBarBuffers[i];
      if (!dataSet.isStacked()) {
        for (int j=0; j < buffer.buffer.length * mAnimator.getPhaseX(); j+=4) {
          float x=(buffer.buffer[j] + buffer.buffer[j + 2]) / 2f;
          if (!mViewPortHandler.isInBoundsRight(x))           break;
          if (!mViewPortHandler.isInBoundsY(buffer.buffer[j + 1]) || !mViewPortHandler.isInBoundsLeft(x))           continue;
          BarEntry entry=dataSet.getEntryForIndex(j / 4);
          float val=entry.getY();
          drawValue(c,dataSet.getValueFormatter(),val,entry,i,x,val >= 0 ? (buffer.buffer[j + 1] + posOffset) : (buffer.buffer[j + 3] + negOffset),dataSet.getValueTextColor(j / 4));
        }
      }
 else {
        Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
        int bufferIndex=0;
        int index=0;
        while (index < dataSet.getEntryCount() * mAnimator.getPhaseX()) {
          BarEntry entry=dataSet.getEntryForIndex(index);
          float[] vals=entry.getYVals();
          float x=(buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2f;
          int color=dataSet.getValueTextColor(index);
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(x))             break;
            if (!mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1]) || !mViewPortHandler.isInBoundsLeft(x))             continue;
            drawValue(c,dataSet.getValueFormatter(),entry.getY(),entry,i,x,buffer.buffer[bufferIndex + 1] + (entry.getY() >= 0 ? posOffset : negOffset),color);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-entry.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,dataSet.getValueFormatter(),vals[k / 2],entry,i,x,y,color);
            }
          }
          bufferIndex=vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;
          index++;
        }
      }
    }
  }
}",0.9934325157485592
18225,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  int setCount=barData.getDataSetCount();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      int entryIndex=set.getEntryIndex(e);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      int entryIndex=set.getEntryIndex(e);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}",0.9847494553376906
18226,"/** 
 * Returns the lowest xPx-index (yValue on the xPx-axis) that is still visible on the chart.
 * @return
 */
@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.min(mXAxis.mAxisMinimum,pos.x);
}","/** 
 * Returns the lowest xPx-index (yValue on the xPx-axis) that is still visible on the chart.
 * @return
 */
@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.max(mXAxis.mAxisMinimum,pos.x);
}",0.9942528735632185
18227,"@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.min(mXAxis.mAxisMinimum,pos.y);
}","@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.max(mXAxis.mAxisMinimum,pos.y);
}",0.9914893617021276
18228,"public static List<BarEntry> loadBarEntriesFromAssets(AssetManager am,String path){
  List<BarEntry> entries=new ArrayList<BarEntry>();
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(am.open(path),""String_Node_Str""));
    String line=reader.readLine();
    while (line != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new BarEntry(Float.parseFloat(split[1]),Integer.parseInt(split[0])));
      line=reader.readLine();
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        Log.e(LOG,e.toString());
      }
    }
  }
  return entries;
}","public static List<BarEntry> loadBarEntriesFromAssets(AssetManager am,String path){
  List<BarEntry> entries=new ArrayList<BarEntry>();
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(am.open(path),""String_Node_Str""));
    String line=reader.readLine();
    while (line != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new BarEntry(Float.parseFloat(split[1]),Float.parseFloat(split[0])));
      line=reader.readLine();
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        Log.e(LOG,e.toString());
      }
    }
  }
  return entries;
}",0.9798657718120806
18229,"public void renderLegend(Canvas c){
  if (!mLegend.isEnabled())   return;
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float labelLineHeight=Utils.getLineHeight(mLegendLabelPaint);
  float labelLineSpacing=Utils.getLineSpacing(mLegendLabelPaint) + mLegend.getYEntrySpace();
  float formYOffset=labelLineHeight - Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") / 2.f;
  String[] labels=mLegend.getLabels();
  int[] colors=mLegend.getColors();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float xEntrySpace=mLegend.getXEntrySpace();
  Legend.LegendDirection direction=mLegend.getDirection();
  float formSize=mLegend.getFormSize();
  float stackSpace=mLegend.getStackSpace();
  float posX, posY;
  float yoffset=mLegend.getYOffset();
  float xoffset=mLegend.getXOffset();
  Legend.LegendPosition legendPosition=mLegend.getPosition();
switch (legendPosition) {
case BELOW_CHART_LEFT:
case BELOW_CHART_RIGHT:
case BELOW_CHART_CENTER:
case ABOVE_CHART_LEFT:
case ABOVE_CHART_RIGHT:
case ABOVE_CHART_CENTER:
{
      float contentWidth=mViewPortHandler.contentWidth();
      float originPosX;
      if (legendPosition == Legend.LegendPosition.BELOW_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT) {
        originPosX=mViewPortHandler.contentLeft() + xoffset;
        if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)         originPosX+=mLegend.mNeededWidth;
      }
 else       if (legendPosition == Legend.LegendPosition.BELOW_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT) {
        originPosX=mViewPortHandler.contentRight() - xoffset;
        if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)         originPosX-=mLegend.mNeededWidth;
      }
 else       originPosX=mViewPortHandler.contentLeft() + contentWidth / 2.f;
      FSize[] calculatedLineSizes=mLegend.getCalculatedLineSizes();
      FSize[] calculatedLabelSizes=mLegend.getCalculatedLabelSizes();
      Boolean[] calculatedLabelBreakPoints=mLegend.getCalculatedLabelBreakPoints();
      posX=originPosX;
      if (legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_CENTER) {
        posY=0.f;
      }
 else {
        posY=mViewPortHandler.getChartHeight() - yoffset - mLegend.mNeededHeight;
      }
      int lineIndex=0;
      for (int i=0, count=labels.length; i < count; i++) {
        if (i < calculatedLabelBreakPoints.length && calculatedLabelBreakPoints[i]) {
          posX=originPosX;
          posY+=labelLineHeight + labelLineSpacing;
        }
        if (posX == originPosX && legendPosition == Legend.LegendPosition.BELOW_CHART_CENTER && lineIndex < calculatedLineSizes.length) {
          posX+=(direction == Legend.LegendDirection.RIGHT_TO_LEFT ? calculatedLineSizes[lineIndex].width : -calculatedLineSizes[lineIndex].width) / 2.f;
          lineIndex++;
        }
        boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
        boolean isStacked=labels[i] == null;
        if (drawingForm) {
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=formSize;
          drawForm(c,posX,posY + formYOffset,i,mLegend);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=formSize;
        }
        if (!isStacked) {
          if (drawingForm)           posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -formToTextSpace : formToTextSpace;
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=calculatedLabelSizes[i].width;
          drawLabel(c,posX,posY + labelLineHeight,labels[i]);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=calculatedLabelSizes[i].width;
          posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -xEntrySpace : xEntrySpace;
        }
 else         posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -stackSpace : stackSpace;
      }
    }
  break;
case PIECHART_CENTER:
case RIGHT_OF_CHART:
case RIGHT_OF_CHART_CENTER:
case RIGHT_OF_CHART_INSIDE:
case LEFT_OF_CHART:
case LEFT_OF_CHART_CENTER:
case LEFT_OF_CHART_INSIDE:
{
  float stack=0f;
  boolean wasStacked=false;
  if (legendPosition == Legend.LegendPosition.PIECHART_CENTER) {
    posX=mViewPortHandler.getChartWidth() / 2f + (direction == Legend.LegendDirection.LEFT_TO_RIGHT ? -mLegend.mTextWidthMax / 2f : mLegend.mTextWidthMax / 2f);
    posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f + mLegend.getYOffset();
  }
 else {
    boolean isRightAligned=legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_INSIDE;
    if (isRightAligned) {
      posX=mViewPortHandler.getChartWidth() - xoffset;
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       posX-=mLegend.mTextWidthMax;
    }
 else {
      posX=xoffset;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       posX+=mLegend.mTextWidthMax;
    }
    if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.LEFT_OF_CHART) {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
 else     if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.LEFT_OF_CHART_CENTER) {
      posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f;
    }
 else {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
  }
  for (int i=0; i < labels.length; i++) {
    Boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
    float x=posX;
    if (drawingForm) {
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=stack;
 else       x-=formSize - stack;
      drawForm(c,x,posY + formYOffset,i,mLegend);
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=formSize;
    }
    if (labels[i] != null) {
      if (drawingForm && !wasStacked)       x+=direction == Legend.LegendDirection.LEFT_TO_RIGHT ? formToTextSpace : -formToTextSpace;
 else       if (wasStacked)       x=posX;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       x-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
      if (!wasStacked) {
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
 else {
        posY+=labelLineHeight + labelLineSpacing;
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
      posY+=labelLineHeight + labelLineSpacing;
      stack=0f;
    }
 else {
      stack+=formSize + stackSpace;
      wasStacked=true;
    }
  }
}
break;
}
}","public void renderLegend(Canvas c){
  if (!mLegend.isEnabled())   return;
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float labelLineHeight=Utils.getLineHeight(mLegendLabelPaint);
  float labelLineSpacing=Utils.getLineSpacing(mLegendLabelPaint) + mLegend.getYEntrySpace();
  float formYOffset=labelLineHeight - Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") / 2.f;
  String[] labels=mLegend.getLabels();
  int[] colors=mLegend.getColors();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float xEntrySpace=mLegend.getXEntrySpace();
  Legend.LegendDirection direction=mLegend.getDirection();
  float formSize=mLegend.getFormSize();
  float stackSpace=mLegend.getStackSpace();
  float posX, posY;
  float yoffset=mLegend.getYOffset();
  float xoffset=mLegend.getXOffset();
  Legend.LegendPosition legendPosition=mLegend.getPosition();
switch (legendPosition) {
case BELOW_CHART_LEFT:
case BELOW_CHART_RIGHT:
case BELOW_CHART_CENTER:
case ABOVE_CHART_LEFT:
case ABOVE_CHART_RIGHT:
case ABOVE_CHART_CENTER:
{
      float contentWidth=mViewPortHandler.contentWidth();
      float originPosX;
      if (legendPosition == Legend.LegendPosition.BELOW_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT) {
        originPosX=mViewPortHandler.contentLeft() + xoffset;
        if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)         originPosX+=mLegend.mNeededWidth;
      }
 else       if (legendPosition == Legend.LegendPosition.BELOW_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT) {
        originPosX=mViewPortHandler.contentRight() - xoffset;
        if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)         originPosX-=mLegend.mNeededWidth;
      }
 else       originPosX=mViewPortHandler.contentLeft() + contentWidth / 2.f - mLegend.mNeededWidth / 2f;
      FSize[] calculatedLineSizes=mLegend.getCalculatedLineSizes();
      FSize[] calculatedLabelSizes=mLegend.getCalculatedLabelSizes();
      Boolean[] calculatedLabelBreakPoints=mLegend.getCalculatedLabelBreakPoints();
      posX=originPosX;
      if (legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_CENTER) {
        posY=0.f;
      }
 else {
        posY=mViewPortHandler.getChartHeight() - yoffset - mLegend.mNeededHeight;
      }
      int lineIndex=0;
      for (int i=0, count=labels.length; i < count; i++) {
        if (i < calculatedLabelBreakPoints.length && calculatedLabelBreakPoints[i]) {
          posX=originPosX;
          posY+=labelLineHeight + labelLineSpacing;
        }
        if (posX == originPosX && legendPosition == Legend.LegendPosition.BELOW_CHART_CENTER && lineIndex < calculatedLineSizes.length) {
          posX+=(direction == Legend.LegendDirection.RIGHT_TO_LEFT ? calculatedLineSizes[lineIndex].width : -calculatedLineSizes[lineIndex].width) / 2.f;
          lineIndex++;
        }
        boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
        boolean isStacked=labels[i] == null;
        if (drawingForm) {
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=formSize;
          drawForm(c,posX,posY + formYOffset,i,mLegend);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=formSize;
        }
        if (!isStacked) {
          if (drawingForm)           posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -formToTextSpace : formToTextSpace;
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=calculatedLabelSizes[i].width;
          drawLabel(c,posX,posY + labelLineHeight,labels[i]);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=calculatedLabelSizes[i].width;
          posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -xEntrySpace : xEntrySpace;
        }
 else         posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -stackSpace : stackSpace;
      }
    }
  break;
case PIECHART_CENTER:
case RIGHT_OF_CHART:
case RIGHT_OF_CHART_CENTER:
case RIGHT_OF_CHART_INSIDE:
case LEFT_OF_CHART:
case LEFT_OF_CHART_CENTER:
case LEFT_OF_CHART_INSIDE:
{
  float stack=0f;
  boolean wasStacked=false;
  if (legendPosition == Legend.LegendPosition.PIECHART_CENTER) {
    posX=mViewPortHandler.getChartWidth() / 2f + (direction == Legend.LegendDirection.LEFT_TO_RIGHT ? -mLegend.mTextWidthMax / 2f : mLegend.mTextWidthMax / 2f);
    posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f + mLegend.getYOffset();
  }
 else {
    boolean isRightAligned=legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_INSIDE;
    if (isRightAligned) {
      posX=mViewPortHandler.getChartWidth() - xoffset;
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       posX-=mLegend.mTextWidthMax;
    }
 else {
      posX=xoffset;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       posX+=mLegend.mTextWidthMax;
    }
    if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.LEFT_OF_CHART) {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
 else     if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.LEFT_OF_CHART_CENTER) {
      posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f;
    }
 else {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
  }
  for (int i=0; i < labels.length; i++) {
    Boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
    float x=posX;
    if (drawingForm) {
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=stack;
 else       x-=formSize - stack;
      drawForm(c,x,posY + formYOffset,i,mLegend);
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=formSize;
    }
    if (labels[i] != null) {
      if (drawingForm && !wasStacked)       x+=direction == Legend.LegendDirection.LEFT_TO_RIGHT ? formToTextSpace : -formToTextSpace;
 else       if (wasStacked)       x=posX;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       x-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
      if (!wasStacked) {
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
 else {
        posY+=labelLineHeight + labelLineSpacing;
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
      posY+=labelLineHeight + labelLineSpacing;
      stack=0f;
    }
 else {
      stack+=formSize + stackSpace;
      wasStacked=true;
    }
  }
}
break;
}
}",0.99795051968965
18230,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mData == null)   return;
  long starttime=System.currentTimeMillis();
  calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  if (mAutoScaleMinMaxEnabled) {
    final int lowestVisibleXIndex=getLowestVisibleXIndex();
    final int highestVisibleXIndex=getHighestVisibleXIndex();
    if (mAutoScaleLastLowestVisibleXIndex == null || mAutoScaleLastLowestVisibleXIndex != lowestVisibleXIndex || mAutoScaleLastHighestVisibleXIndex == null || mAutoScaleLastHighestVisibleXIndex != highestVisibleXIndex) {
      calcMinMax();
      calculateOffsets();
      mAutoScaleLastLowestVisibleXIndex=lowestVisibleXIndex;
      mAutoScaleLastHighestVisibleXIndex=highestVisibleXIndex;
    }
  }
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHighlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mData == null)   return;
  long starttime=System.currentTimeMillis();
  calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  if (mAutoScaleMinMaxEnabled) {
    final int lowestVisibleXIndex=getLowestVisibleXIndex();
    final int highestVisibleXIndex=getHighestVisibleXIndex();
    if (mAutoScaleLastLowestVisibleXIndex == null || mAutoScaleLastLowestVisibleXIndex != lowestVisibleXIndex || mAutoScaleLastHighestVisibleXIndex == null || mAutoScaleLastHighestVisibleXIndex != highestVisibleXIndex) {
      calcMinMax();
      calculateOffsets();
      mAutoScaleLastLowestVisibleXIndex=lowestVisibleXIndex;
      mAutoScaleLastHighestVisibleXIndex=highestVisibleXIndex;
    }
  }
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHighlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.942412169503803
18231,"@Override protected void calcMinMax(){
  super.calcMinMax();
  calcAngles();
}","@Override protected void calcMinMax(){
  calcAngles();
}",0.835820895522388
18232,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  float[] pts=new float[2];
  if (mKeepPositionOnRotation) {
    pts[0]=mViewPortHandler.contentLeft();
    pts[1]=mViewPortHandler.contentTop();
    getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  }
  super.onSizeChanged(w,h,oldw,oldh);
  if (mKeepPositionOnRotation) {
    getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
    mViewPortHandler.centerViewPort(pts,this);
  }
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  float[] pts=new float[2];
  if (mKeepPositionOnRotation) {
    pts[0]=mViewPortHandler.contentLeft();
    pts[1]=mViewPortHandler.contentTop();
    getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  }
  super.onSizeChanged(w,h,oldw,oldh);
  if (mKeepPositionOnRotation) {
    getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
    mViewPortHandler.centerViewPort(pts,this);
  }
 else {
    mViewPortHandler.refresh(mViewPortHandler.getMatrixTouch(),this,true);
  }
}",0.9151219512195122
18233,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setViewPortOffsets(0,20,0,0);
  mChart.setBackgroundColor(Color.rgb(104,241,175));
  mChart.setDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis x=mChart.getXAxis();
  x.setEnabled(false);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(6,false);
  y.setTextColor(Color.WHITE);
  y.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
  y.setDrawGridLines(false);
  y.setAxisLineColor(Color.WHITE);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.getLegend().setEnabled(false);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setViewPortOffsets(0,0,0,0);
  mChart.setBackgroundColor(Color.rgb(104,241,175));
  mChart.setDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis x=mChart.getXAxis();
  x.setEnabled(false);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(6,false);
  y.setTextColor(Color.WHITE);
  y.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
  y.setDrawGridLines(false);
  y.setAxisLineColor(Color.WHITE);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.getLegend().setEnabled(false);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}",0.9996538594669436
18234,"/** 
 * Draws the provided path in filled mode with the provided color and alpha. Special thanks to Angelo Suzuki (https://github.com/tinsukE) for this.
 * @param c
 * @param filledPath
 * @param fillColor
 * @param fillAlpha
 */
protected void drawFilledPath(Canvas c,Path filledPath,int fillColor,int fillAlpha){
  c.save();
  c.clipPath(filledPath);
  int color=(fillAlpha << 24) | (fillColor & 0xffffff);
  c.drawColor(color);
  c.restore();
}","/** 
 * Draws the provided path in filled mode with the provided color and alpha. Special thanks to Angelo Suzuki (https://github.com/tinsukE) for this.
 * @param c
 * @param filledPath
 * @param fillColor
 * @param fillAlpha
 */
protected void drawFilledPath(Canvas c,Path filledPath,int fillColor,int fillAlpha){
  int color=(fillAlpha << 24) | (fillColor & 0xffffff);
  if (clipPathSupported()) {
    c.save();
    c.clipPath(filledPath);
    c.drawColor(color);
    c.restore();
  }
 else {
    Paint.Style previous=mRenderPaint.getStyle();
    int previousColor=mRenderPaint.getColor();
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setColor(color);
    c.drawPath(filledPath,mRenderPaint);
    mRenderPaint.setColor(previousColor);
    mRenderPaint.setStyle(previous);
  }
}",0.6371681415929203
18235,"public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
}","public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
}",0.8972332015810277
18236,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
    if (mVelocityTracker != null) {
      mVelocityTracker.recycle();
      mVelocityTracker=null;
    }
  }
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    startAction(event);
  stopDeceleration();
saveTouchStart(event);
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
mChart.disableScroll();
saveTouchStart(event);
mSavedXDist=getXDist(event);
mSavedYDist=getYDist(event);
mSavedDist=spacing(event);
if (mSavedDist > 10f) {
if (mChart.isPinchZoomEnabled()) {
  mTouchMode=PINCH_ZOOM;
}
 else {
  if (mSavedXDist > mSavedYDist)   mTouchMode=X_ZOOM;
 else   mTouchMode=Y_ZOOM;
}
}
midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut() && mChart.isDragEnabled()) {
mTouchMode=DRAG;
}
 else {
mLastGesture=ChartGesture.DRAG;
if (mChart.isHighlightPerDragEnabled()) performHighlightDrag(event);
}
}
 else if (mChart.isDragEnabled()) {
mLastGesture=ChartGesture.DRAG;
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
final VelocityTracker velocityTracker=mVelocityTracker;
final int pointerId=event.getPointerId(0);
velocityTracker.computeCurrentVelocity(1000,Utils.getMaximumFlingVelocity());
final float velocityY=velocityTracker.getYVelocity(pointerId);
final float velocityX=velocityTracker.getXVelocity(pointerId);
if (Math.abs(velocityX) > Utils.getMinimumFlingVelocity() || Math.abs(velocityY) > Utils.getMinimumFlingVelocity()) {
if (mTouchMode == DRAG && mChart.isDragDecelerationEnabled()) {
stopDeceleration();
mDecelerationLastTime=AnimationUtils.currentAnimationTimeMillis();
mDecelerationCurrentPoint=new PointF(event.getX(),event.getY());
mDecelerationVelocity=new PointF(velocityX,velocityY);
Utils.postInvalidateOnAnimation(mChart);
}
}
if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM || mTouchMode == POST_ZOOM) {
mChart.calculateOffsets();
mChart.postInvalidate();
}
mTouchMode=NONE;
mChart.enableScroll();
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
endAction(event);
break;
case MotionEvent.ACTION_POINTER_UP:
Utils.velocityTrackerPointerUpCleanUpIfNecessary(event,mVelocityTracker);
mTouchMode=POST_ZOOM;
break;
case MotionEvent.ACTION_CANCEL:
mTouchMode=NONE;
endAction(event);
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
    if (mVelocityTracker != null) {
      mVelocityTracker.recycle();
      mVelocityTracker=null;
    }
  }
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    startAction(event);
  stopDeceleration();
saveTouchStart(event);
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
mChart.disableScroll();
saveTouchStart(event);
mSavedXDist=getXDist(event);
mSavedYDist=getYDist(event);
mSavedDist=spacing(event);
if (mSavedDist > 10f) {
if (mChart.isPinchZoomEnabled()) {
  mTouchMode=PINCH_ZOOM;
}
 else {
  if (mSavedXDist > mSavedYDist)   mTouchMode=X_ZOOM;
 else   mTouchMode=Y_ZOOM;
}
}
midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > mDragTriggerDist) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut() && mChart.isDragEnabled()) {
mTouchMode=DRAG;
}
 else {
mLastGesture=ChartGesture.DRAG;
if (mChart.isHighlightPerDragEnabled()) performHighlightDrag(event);
}
}
 else if (mChart.isDragEnabled()) {
mLastGesture=ChartGesture.DRAG;
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
final VelocityTracker velocityTracker=mVelocityTracker;
final int pointerId=event.getPointerId(0);
velocityTracker.computeCurrentVelocity(1000,Utils.getMaximumFlingVelocity());
final float velocityY=velocityTracker.getYVelocity(pointerId);
final float velocityX=velocityTracker.getXVelocity(pointerId);
if (Math.abs(velocityX) > Utils.getMinimumFlingVelocity() || Math.abs(velocityY) > Utils.getMinimumFlingVelocity()) {
if (mTouchMode == DRAG && mChart.isDragDecelerationEnabled()) {
stopDeceleration();
mDecelerationLastTime=AnimationUtils.currentAnimationTimeMillis();
mDecelerationCurrentPoint=new PointF(event.getX(),event.getY());
mDecelerationVelocity=new PointF(velocityX,velocityY);
Utils.postInvalidateOnAnimation(mChart);
}
}
if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM || mTouchMode == POST_ZOOM) {
mChart.calculateOffsets();
mChart.postInvalidate();
}
mTouchMode=NONE;
mChart.enableScroll();
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
endAction(event);
break;
case MotionEvent.ACTION_POINTER_UP:
Utils.velocityTrackerPointerUpCleanUpIfNecessary(event,mVelocityTracker);
mTouchMode=POST_ZOOM;
break;
case MotionEvent.ACTION_CANCEL:
mTouchMode=NONE;
endAction(event);
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}",0.9972493887530562
18237,"/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    OnChartGestureListener l=mChart.getOnChartGestureListener();
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        mLastGesture=ChartGesture.PINCH_ZOOM;
        float scale=totalDist / mSavedDist;
        boolean isZoomingOut=(scale < 1);
        boolean canZoomMoreX=isZoomingOut ? mChart.getViewPortHandler().canZoomOutMoreX() : mChart.getViewPortHandler().canZoomInMoreX();
        float scaleX=(mChart.isScaleXEnabled()) ? scale : 1f;
        float scaleY=(mChart.isScaleYEnabled()) ? scale : 1f;
        if (mChart.isScaleYEnabled() || canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,scaleY);
        }
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        mLastGesture=ChartGesture.X_ZOOM;
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        boolean isZoomingOut=(scaleX < 1);
        boolean canZoomMoreX=isZoomingOut ? mChart.getViewPortHandler().canZoomOutMoreX() : mChart.getViewPortHandler().canZoomInMoreX();
        if (canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,1f,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,1f);
        }
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        mLastGesture=ChartGesture.Y_ZOOM;
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
        if (l != null)         l.onChartScale(event,1f,scaleY);
      }
    }
  }
}","/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    OnChartGestureListener l=mChart.getOnChartGestureListener();
    float totalDist=spacing(event);
    if (totalDist > mMinScalePointerDistance) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      ViewPortHandler h=mChart.getViewPortHandler();
      if (mTouchMode == PINCH_ZOOM) {
        mLastGesture=ChartGesture.PINCH_ZOOM;
        float scale=totalDist / mSavedDist;
        boolean isZoomingOut=(scale < 1);
        boolean canZoomMoreX=isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();
        boolean canZoomMoreY=isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();
        float scaleX=(mChart.isScaleXEnabled()) ? scale : 1f;
        float scaleY=(mChart.isScaleYEnabled()) ? scale : 1f;
        if (canZoomMoreY || canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,scaleY);
        }
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        mLastGesture=ChartGesture.X_ZOOM;
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        boolean isZoomingOut=(scaleX < 1);
        boolean canZoomMoreX=isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();
        if (canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,1f,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,1f);
        }
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        mLastGesture=ChartGesture.Y_ZOOM;
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        boolean isZoomingOut=(scaleY < 1);
        boolean canZoomMoreY=isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();
        if (canZoomMoreY) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(1f,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,1f,scaleY);
        }
      }
    }
  }
}",0.874909266876361
18238,"public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
}","public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
  this.mMinScalePointerDistance=Utils.convertDpToPixel(3.5f);
}",0.9
18239,"/** 
 * Highlights upon dragging, generates callbacks for the selection-listener.
 * @param e
 */
private void performHighlightDrag(MotionEvent e){
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h != null && !h.equalTo(mLastHighlighted)) {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
}","/** 
 * Highlights upon dragging, generates callbacks for the selection-listener.
 * @param e
 */
private void performHighlightDrag(MotionEvent e){
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h != null && !h.equalTo(mLastHighlighted)) {
    mLastHighlighted=h;
    mChart.highlightValue(h,true);
  }
}",0.9709035222052068
18240,"/** 
 * limits the maximum scale and X translation of the given matrix
 * @param matrix
 */
public void limitTransAndScale(Matrix matrix,RectF content){
  matrix.getValues(matrixBuffer);
  float curTransX=matrixBuffer[Matrix.MTRANS_X];
  float curScaleX=matrixBuffer[Matrix.MSCALE_X];
  float curTransY=matrixBuffer[Matrix.MTRANS_Y];
  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];
  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);
  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);
  float width=0f;
  float height=0f;
  if (content != null) {
    width=content.width();
    height=content.height();
  }
  float maxTransX=-width * (mScaleX - 1f);
  float newTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);
  mTransX=newTransX;
  float maxTransY=height * (mScaleY - 1f);
  float newTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);
  mTransY=newTransY;
  matrixBuffer[Matrix.MTRANS_X]=mTransX;
  matrixBuffer[Matrix.MSCALE_X]=mScaleX;
  matrixBuffer[Matrix.MTRANS_Y]=mTransY;
  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;
  matrix.setValues(matrixBuffer);
}","/** 
 * limits the maximum scale and X translation of the given matrix
 * @param matrix
 */
public void limitTransAndScale(Matrix matrix,RectF content){
  matrix.getValues(matrixBuffer);
  float curTransX=matrixBuffer[Matrix.MTRANS_X];
  float curScaleX=matrixBuffer[Matrix.MSCALE_X];
  float curTransY=matrixBuffer[Matrix.MTRANS_Y];
  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];
  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);
  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);
  float width=0f;
  float height=0f;
  if (content != null) {
    width=content.width();
    height=content.height();
  }
  float maxTransX=-width * (mScaleX - 1f);
  mTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);
  float maxTransY=height * (mScaleY - 1f);
  mTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);
  matrixBuffer[Matrix.MTRANS_X]=mTransX;
  matrixBuffer[Matrix.MSCALE_X]=mScaleX;
  matrixBuffer[Matrix.MTRANS_Y]=mTransY;
  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;
  matrix.setValues(matrixBuffer);
}",0.9720216606498197
18241,"protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  if (mChart.isDrawBarShadowEnabled()) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
    }
  }
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.8320368769806972
18242,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  float sliceSpace=dataSet.getSliceSpace();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final float userInnerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getVal()) > 0.000001)) {
      visibleAngleCount++;
    }
  }
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceOuterAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceOuterAngle) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f == 0.f) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        if (sliceSpace > 0.f) {
          innerRadius=Math.max(innerRadius,calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter));
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (innerRadius > 0.0) {
          final float sliceSpaceInnerAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceInnerAngle / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceInnerAngle) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            mPathBuffer.lineTo(center.x,center.y);
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  float sliceSpace=dataSet.getSliceSpace();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getVal()) > 0.000001)) {
      visibleAngleCount++;
    }
  }
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f == 0.f) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || sliceSpace > 0.f)) {
          if (sliceSpace > 0.f) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (sliceSpace > 0.f) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
}",0.8238361266294227
18243,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final float userInnerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=new RectF();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getVal()) > 0.000001)) {
        visibleAngleCount++;
      }
    }
    if (xIndex == 0)     angle=0.f;
 else     angle=absoluteAngles[xIndex - 1] * phaseX;
    float sliceSpace=set.getSliceSpace();
    float sliceAngle=drawAngles[xIndex];
    final float sliceSpaceOuterAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceOuterAngle) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleOuter,sweepAngleOuter);
    }
    if (sliceSpace > 0.f) {
      innerRadius=Math.max(innerRadius,calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter));
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (innerRadius > 0.0) {
      final float sliceSpaceInnerAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceInnerAngle / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceInnerAngle) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        mPathBuffer.lineTo(center.x,center.y);
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=new RectF();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getVal()) > 0.000001)) {
        visibleAngleCount++;
      }
    }
    if (xIndex == 0)     angle=0.f;
 else     angle=absoluteAngles[xIndex - 1] * phaseX;
    float sliceSpace=set.getSliceSpace();
    float sliceAngle=drawAngles[xIndex];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (sliceSpace > 0.f) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || sliceSpace > 0.f)) {
      if (sliceSpace > 0.f) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        if (sliceSpace > 0.0) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
}",0.4464407550602683
18244,"protected void drawValue(Canvas c,String valueText,float x,float y){
  c.drawText(valueText,x,y,mValuePaint);
}","protected void drawValue(Canvas c,String valueText,float x,float y,int color){
  mValuePaint.setColor(color);
  c.drawText(valueText,x,y,mValuePaint);
}",0.844106463878327
18245,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      float[] valuePoints=getTransformedValues(trans,dataSet,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float val=e.getVal();
          String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,formattedValue,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,formattedValue,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,formattedValue,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      float[] valuePoints=getTransformedValues(trans,dataSet,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float val=e.getVal();
          String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,formattedValue,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight,dataSet.getValueTextColor(j / 2));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,formattedValue,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight,dataSet.getValueTextColor(j / 2));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,formattedValue,x,y + halfTextHeight,dataSet.getValueTextColor(j / 2));
            }
          }
        }
      }
    }
  }
}",0.9899298138541348
18246,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i <= endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    float ymin=yMin(entry);
    float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.991890205864005
18247,"/** 
 * sets the color that is used for filling the line surface
 * @param color
 */
public void setFillColor(int color){
  mFillColor=color;
}","/** 
 * sets the color that is used for filling the line surface
 * @param color
 */
public void setFillColor(int color){
  mFillColor=color;
  mFillDrawable=null;
}",0.9285714285714286
18248,"protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < dataSet.getEntryCount(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=dataSet.getEntryForIndex(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
  final Drawable drawable=dataSet.getFillDrawable();
  if (drawable != null) {
    drawFilledPath(c,surface,drawable);
  }
 else {
    drawFilledPath(c,surface,dataSet.getFillColor(),dataSet.getFillAlpha());
  }
}","protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < dataSet.getEntryCount(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=dataSet.getEntryForIndex(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  final Drawable drawable=dataSet.getFillDrawable();
  if (drawable != null) {
    drawFilledPath(c,surface,drawable);
  }
 else {
    drawFilledPath(c,surface,dataSet.getFillColor(),dataSet.getFillAlpha());
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.8108831400535237
18249,"@Override public boolean onDoubleTap(MotionEvent e){
  mLastGesture=ChartGesture.DOUBLE_TAP;
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  mLastGesture=ChartGesture.DOUBLE_TAP;
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.971379011274935
18250,"public void setFloatValue(Float value){
  this.floatValue=value;
}","public void setFloatValue(float value){
  this.floatValue=value;
}",0.9848484848484848
18251,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","@Override protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}",0.9752431476569408
18252,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        List<String> xVals=data.getXVals();
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        List<String> xVals=data.getXVals();
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        colors.add(((ICandleDataSet)dataSet).getDecreasingColor());
        colors.add(((ICandleDataSet)dataSet).getIncreasingColor());
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.9318136372725456
18253,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_bubblechart_noseekbar);
  mChart=(BubbleChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getXAxis().setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_bubblechart_noseekbar);
  mChart=(BubbleChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getXAxis().setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setPinchZoom(true);
}",0.9084423305588584
18254,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBubbleDataSet<RealmDemoData> set=new RealmBubbleDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setLabel(""String_Node_Str"");
  set.setColors(ColorTemplate.COLORFUL_COLORS);
  ArrayList<IBubbleDataSet> dataSets=new ArrayList<IBubbleDataSet>();
  dataSets.add(set);
  BubbleData data=new BubbleData(result,""String_Node_Str"",dataSets);
  styleData(data);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBubbleDataSet<RealmDemoData> set=new RealmBubbleDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setLabel(""String_Node_Str"");
  set.setColors(ColorTemplate.COLORFUL_COLORS,110);
  ArrayList<IBubbleDataSet> dataSets=new ArrayList<IBubbleDataSet>();
  dataSets.add(set);
  BubbleData data=new BubbleData(result,""String_Node_Str"",dataSets);
  styleData(data);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9966159052453468
18255,"@Override protected void onResume(){
  super.onResume();
  writeToDBBubble(12);
  setData();
}","@Override protected void onResume(){
  super.onResume();
  writeToDBBubble(10);
  setData();
}",0.9893617021276596
18256,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9849056603773584
18257,"@Override public void calcMinMax(int start,int end){
  if (mValues == null)   return;
  if (mValues.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mValues.size() - 1;
 else   endValue=end;
  mYMin=yMin(mValues.get(start));
  mYMax=yMax(mValues.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mValues.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mValues == null)   return;
  if (mValues.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mValues.size())   endValue=mValues.size() - 1;
 else   endValue=end;
  mYMin=yMin(mValues.get(start));
  mYMax=yMax(mValues.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mValues.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9844042420461634
18258,"/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  checkLegal();
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
  calcYValueCount();
  calcXValAverageLength();
}","/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  checkLegal();
  calcMinMax(mLastStart,mLastEnd);
  calcYValueCount();
  calcXValAverageLength();
}",0.9596602972399152
18259,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    T set=mDataSets.get(dataSetIndex);
    if (mYValCount == 0) {
      mYMin=val;
      mYMax=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        mLeftAxisMax=e.getVal();
        mLeftAxisMin=e.getVal();
      }
 else {
        mRightAxisMax=e.getVal();
        mRightAxisMin=e.getVal();
      }
    }
 else {
      if (mYMax < val)       mYMax=val;
      if (mYMin > val)       mYMin=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
    }
    mYValCount+=1;
    mYValueSum+=val;
    handleEmptyAxis(getFirstLeft(),getFirstRight());
    set.addEntry(e);
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    T set=mDataSets.get(dataSetIndex);
    if (mYValCount == 0) {
      mYMin=val;
      mYMax=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        mLeftAxisMax=e.getVal();
        mLeftAxisMin=e.getVal();
      }
 else {
        mRightAxisMax=e.getVal();
        mRightAxisMin=e.getVal();
      }
    }
 else {
      if (mYMax < val)       mYMax=val;
      if (mYMin > val)       mYMin=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
    }
    mYValCount+=1;
    handleEmptyAxis(getFirstLeft(),getFirstRight());
    set.addEntry(e);
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.9915356711003628
18260,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}",0.9838709677419356
18261,"/** 
 * Creates a new DataSet object with the given values it represents. Also, a label that describes the DataSet can be specified. The label can also be used to retrieve the DataSet from a ChartData object.
 * @param yVals
 * @param label
 */
public DataSet(List<T> yVals,String label){
  this.mLabel=label;
  this.mYVals=yVals;
  if (mYVals == null)   mYVals=new ArrayList<T>();
  mColors=new ArrayList<Integer>();
  mColors.add(Color.rgb(140,234,255));
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
}","/** 
 * Creates a new DataSet object with the given values it represents. Also, a label that describes the DataSet can be specified. The label can also be used to retrieve the DataSet from a ChartData object.
 * @param yVals
 * @param label
 */
public DataSet(List<T> yVals,String label){
  this.mLabel=label;
  this.mYVals=yVals;
  if (mYVals == null)   mYVals=new ArrayList<T>();
  mColors=new ArrayList<Integer>();
  mColors.add(Color.rgb(140,234,255));
  calcMinMax(mLastStart,mLastEnd);
}",0.981094527363184
18262,"/** 
 * Removes the first Entry (at index 0) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeFirst(){
  T entry=mYVals.remove(0);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    mYValueSum-=val;
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}","/** 
 * Removes the first Entry (at index 0) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeFirst(){
  T entry=mYVals.remove(0);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}",0.9101283880171184
18263,"/** 
 * Use this method to tell the data set that the underlying data has changed
 */
public void notifyDataSetChanged(){
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
}","/** 
 * Use this method to tell the data set that the underlying data has changed
 */
public void notifyDataSetChanged(){
  calcMinMax(mLastStart,mLastEnd);
}",0.9432835820895522
18264,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to the end of the list. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntry(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to the end of the list. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntry(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYVals.add((T)e);
}",0.9831111111111112
18265,"/** 
 * Removes the last Entry (at index size-1) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeLast(){
  if (mYVals.size() <= 0)   return false;
  T entry=mYVals.remove(mYVals.size() - 1);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    mYValueSum-=val;
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}","/** 
 * Removes the last Entry (at index size-1) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeLast(){
  if (mYVals.size() <= 0)   return false;
  T entry=mYVals.remove(mYVals.size() - 1);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}",0.9744835965978128
18266,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}",0.9881619937694704
18267,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"" + set.getStackSize());
  set.setValueTextSize(9f);
  set.setColors(getColors(set.getStackSize()));
  set.setLabel(""String_Node_Str"");
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  System.out.println(""String_Node_Str"" + set.getStackSize());
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  set.setColors(getColors(set.getStackSize()));
  set.setLabel(""String_Node_Str"");
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9019337016574586
18268,"@Override protected void onResume(){
  super.onResume();
  writeToDBStack(4);
  setData();
}","@Override protected void onResume(){
  super.onResume();
  writeToDBStack(200);
  setData();
}",0.978494623655914
18269,"public RealmFloat(float value){
  this.value=value;
}","public RealmFloat(float floatValue){
  this.floatValue=floatValue;
}",0.8264462809917356
18270,"public RealmBarDataSet(RealmResults<T> results,String yValuesField,String xIndexField){
  super(results,yValuesField,xIndexField);
  mHighLightColor=Color.rgb(0,0,0);
  calcStackSize();
}","/** 
 * Constructor for supporting stacked values.
 * @param results
 * @param yValuesField
 * @param xIndexField
 * @param stackValueFieldName
 */
public RealmBarDataSet(RealmResults<T> results,String yValuesField,String xIndexField,String stackValueFieldName){
  super(results,yValuesField,xIndexField);
  this.mStackValueFieldName=stackValueFieldName;
  mHighLightColor=Color.rgb(0,0,0);
  buildData(this.results);
}",0.5742574257425742
18271,"@Override public void build(RealmResults<T> results){
  for (  T realmObject : results) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
    try {
      float value=dynamicObject.getFloat(mValuesField);
      mValues.add(new BarEntry(value,dynamicObject.getInt(mIndexField)));
    }
 catch (    IllegalArgumentException e) {
      DynamicRealmList list=dynamicObject.getList(mValuesField);
      float[] values=new float[list.size()];
      int i=0;
      for (      DynamicRealmObject o : list) {
        values[i]=o.getFloat(""String_Node_Str"");
        i++;
      }
      mValues.add(new BarEntry(values,dynamicObject.getInt(mIndexField)));
    }
  }
  calcStackSize();
}","@Override public void build(RealmResults<T> results){
}",0.1456953642384106
18272,"/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}","/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)Math.round(pts[0] + 1.0f);
}",0.9819694868238558
18273,"/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}","/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (Math.round(pts[0]) >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)Math.round(pts[0]);
}",0.9703703703703704
18274,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i <= endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9993618379068284
18275,"/** 
 * Returns the first Entry index found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index at the closest x-index. Returns -1 if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public int getEntryIndex(int x){
  int low=0;
  int high=mYVals.size() - 1;
  int closest=-1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      while (m > 0 && mYVals.get(m - 1).getXIndex() == x)       m--;
      return m;
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
    closest=m;
  }
  return closest;
}","/** 
 * Returns the first Entry index found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index as determined by the given rounding mode. Returns -1 if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public int getEntryIndex(int x,Rounding rounding){
  int low=0;
  int high=mYVals.size() - 1;
  int closest=-1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      while (m > 0 && mYVals.get(m - 1).getXIndex() == x)       m--;
      return m;
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
    closest=m;
  }
  if (closest != -1) {
    int closestXIndex=mYVals.get(closest).getXIndex();
    if (rounding == Rounding.UP) {
      if (closestXIndex < x && closest < mYVals.size() - 1) {
        ++closest;
      }
    }
 else     if (rounding == Rounding.DOWN) {
      if (closestXIndex > x && closest > 0) {
        --closest;
      }
    }
  }
  return closest;
}",0.7653276955602537
18276,"/** 
 * Returns the first Entry object found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index at the closest x-index. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public T getEntryForXIndex(int x){
  int index=getEntryIndex(x);
  if (index > -1)   return mYVals.get(index);
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index as determined by the given rounding mode. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public T getEntryForXIndex(int x,Rounding rounding){
  int index=getEntryIndex(x,rounding);
  if (index > -1)   return mYVals.get(index);
  return null;
}",0.9164265129682996
18277,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex());
    if (mYVals.get(closestIndex).getXIndex() < e.getXIndex())     closestIndex++;
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}",0.9256198347107438
18278,"/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int diff=(entryFrom == entryTo) ? 1 : 0;
  int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
  int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}",0.9195516811955168
18279,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int diff=(entryFrom == entryTo) ? 1 : 0;
      int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
      int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        Entry entry=entries.get(j / 2 + minx);
        drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,x,y - valOffset);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        Entry entry=entries.get(j / 2 + minx);
        drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,x,y - valOffset);
      }
    }
  }
}",0.9034109021357986
18280,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int diff=(entryFrom == entryTo) ? 1 : 0;
  int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
  int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9546940681924334
18281,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int diff=(entryFrom == entryTo) ? 1 : 0;
    int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
    int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
    int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9230344827586208
18282,"/** 
 * Returns the index of the DataSet this x-index belongs to.
 * @param xIndex
 * @return
 */
public int getDataSetIndexForIndex(int xIndex){
  List<? extends DataSet<? extends Entry>> dataSets=mData.getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getEntryForXIndex(xIndex) != null)     return i;
  }
  return -1;
}","/** 
 * Returns the index of the DataSet this x-index belongs to.
 * @param xIndex
 * @return
 */
public int getDataSetIndexForIndex(int xIndex){
  List<IPieDataSet> dataSets=mData.getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getEntryForXIndex(xIndex) != null)     return i;
  }
  return -1;
}",0.9343065693430656
18283,"/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mData.getYValCount()];
  mAbsoluteAngles=new float[mData.getYValCount()];
  List<PieDataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    List<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}","/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mData.getYValCount()];
  mAbsoluteAngles=new float[mData.getYValCount()];
  List<IPieDataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    IPieDataSet set=dataSets.get(i);
    List<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}",0.9985358711566618
18284,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    IDataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}",0.9992992291520671
18285,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.actionTogglePercent:
mChart.setUsePercentValues(!mChart.isUsePercentValuesEnabled());
mChart.invalidate();
break;
case R.id.animateX:
{
mChart.animateX(1400);
break;
}
case R.id.animateY:
{
mChart.animateY(1400);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1400,1400);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.actionTogglePercent:
mChart.setUsePercentValues(!mChart.isUsePercentValuesEnabled());
mChart.invalidate();
break;
case R.id.animateX:
{
mChart.animateX(1400);
break;
}
case R.id.animateY:
{
mChart.animateY(1400);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1400,1400);
break;
}
}
return true;
}",0.9995838535164376
18286,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<IRadarDataSet> sets=new ArrayList<IRadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}",0.9990982867448152
18287,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<IRadarDataSet> sets=(ArrayList<IRadarDataSet>)mChart.getData().getDataSets();
for (IRadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}",0.9988186650915536
18288,"/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give great performance boost! default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}","@Override public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}",0.4361370716510903
18289,"@Override public Entry getEntryForXIndex(int x){
  return null;
}","@Override public Entry getEntryForXIndex(int xIndex){
  return null;
}",0.9629629629629628
18290,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  IPieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9992301770592764
18291,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      Entry entry=entries.get(j);
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entry.getVal() / data.getYValueSum() * 100f : entry.getVal();
      ValueFormatter formatter=dataSet.getValueFormatter();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      Entry entry=entries.get(j);
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entry.getVal() / data.getYValueSum() * 100f : entry.getVal();
      ValueFormatter formatter=dataSet.getValueFormatter();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f);
      }
      cnt++;
    }
  }
}",0.9995240361732508
18292,"/** 
 * This gives all pie-slices a rounded edge.
 * @param c
 */
protected void drawRoundedSlices(Canvas c){
  if (!mChart.isDrawRoundedSlicesEnabled())   return;
  PieDataSet dataSet=mChart.getData().getDataSet();
  if (!dataSet.isVisible())   return;
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float circleRadius=(r - (r * mChart.getHoleRadius() / 100f)) / 2f;
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  float angle=mChart.getRotationAngle();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      float x=(float)((r - circleRadius) * Math.cos(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.x);
      float y=(float)((r - circleRadius) * Math.sin(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.y);
      mRenderPaint.setColor(dataSet.getColor(j));
      mBitmapCanvas.drawCircle(x,y,circleRadius,mRenderPaint);
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}","/** 
 * This gives all pie-slices a rounded edge.
 * @param c
 */
protected void drawRoundedSlices(Canvas c){
  if (!mChart.isDrawRoundedSlicesEnabled())   return;
  IPieDataSet dataSet=mChart.getData().getDataSet();
  if (!dataSet.isVisible())   return;
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float circleRadius=(r - (r * mChart.getHoleRadius() / 100f)) / 2f;
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  float angle=mChart.getRotationAngle();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      float x=(float)((r - circleRadius) * Math.cos(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.x);
      float y=(float)((r - circleRadius) * Math.sin(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.y);
      mRenderPaint.setColor(dataSet.getColor(j));
      mBitmapCanvas.drawCircle(x,y,circleRadius,mRenderPaint);
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}",0.9995435874030124
18293,"protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),(angle + sliceSpace / 2f) * mAnimator.getPhaseY(),(newangle - sliceSpace / 2f) * mAnimator.getPhaseY(),true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),(angle + sliceSpace / 2f) * mAnimator.getPhaseY(),(newangle - sliceSpace / 2f) * mAnimator.getPhaseY(),true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}",0.9993485342019544
18294,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees * mAnimator.getPhaseY() - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees * mAnimator.getPhaseY() - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}",0.999553770638108
18295,"@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  IRadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9977116704805492
18296,"protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  List<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}","protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  List<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.9995604395604396
18297,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry entry=entries.get(j);
      PointF p=Utils.getPosition(center,(entry.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,p.x,p.y - yoffset);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    IRadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry entry=entries.get(j);
      PointF p=Utils.getPosition(center,(entry.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,p.x,p.y - yoffset);
    }
  }
}",0.9993861264579496
18298,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryIndex(e);
    float y=(e.getVal() - mChart.getYChartMin());
    if (Float.isNaN(y))     continue;
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,p.y};
    drawHighlightLines(c,pts,set);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    IRadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryIndex(e);
    float y=(e.getVal() - mChart.getYChartMin());
    if (Float.isNaN(y))     continue;
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,p.y};
    drawHighlightLines(c,pts,set);
  }
}",0.9993891264508248
18299,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  leftAxis.setTypeface(tf);
  mChart.getXAxis().setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  leftAxis.setTypeface(tf);
  mChart.getXAxis().setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
}",0.9848812095032398
18300,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmLineDataSet<RealmDemoData> set=new RealmLineDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(set);
  LineData data=new LineData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9564315352697096
18301,"protected static List<String> toXVals(RealmResults<? extends RealmObject> result,String xValuesField){
  List<String> xVals=new ArrayList<>();
  for (  RealmObject object : result) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(object);
    xVals.add(dynamicObject.getString(xValuesField));
  }
  return xVals;
}","/** 
 * Transforms the given Realm-ResultSet into a String array by using the provided xValuesField.
 * @param result
 * @param xValuesField
 * @return
 */
protected static List<String> toXVals(RealmResults<? extends RealmObject> result,String xValuesField){
  List<String> xVals=new ArrayList<>();
  for (  RealmObject object : result) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(object);
    xVals.add(dynamicObject.getString(xValuesField));
  }
  return xVals;
}",0.8074074074074075
18302,"@Override public String[] getStackLabels(){
  return new String[0];
}","@Override public String[] getStackLabels(){
  return null;
}",0.8837209302325582
18303,"/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet.
 * @return
 */
int getStackSize();","/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet. This should return 1 for non stacked bars, and > 1 for stacked bars.
 * @return
 */
int getStackSize();",0.7863777089783281
18304,"@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new BarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new BarBuffer(set.getEntryCount() * 4 * set.getStackSize(),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}","@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new BarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new BarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}",0.7908163265306123
18305,"@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new HorizontalBarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new HorizontalBarBuffer(set.getEntryCount() * 4 * set.getStackSize(),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}","@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new HorizontalBarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new HorizontalBarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}",0.8009708737864077
18306,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val1=(float)(Math.random() * mult) + mult / 3;
    yVals1.add(new BarEntry((int)val1,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"");
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set1.setDrawValues(false);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val1=(float)(Math.random() * mult) + mult / 3;
    yVals1.add(new BarEntry((int)val1,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"");
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set1.setDrawValues(false);
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.998968008255934
18307,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleAutoScaleMinMax:
{
mChart.setAutoScaleMinMaxEnabled(!mChart.isAutoScaleMinMaxEnabled());
mChart.notifyDataSetChanged();
break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleAutoScaleMinMax:
{
mChart.setAutoScaleMinMaxEnabled(!mChart.isAutoScaleMinMaxEnabled());
mChart.notifyDataSetChanged();
break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.998968540484786
18308,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  RealmLineDataSet set1=new RealmLineDataSet();
  ArrayList<RealmLineDataSet> dataSets=new ArrayList<RealmLineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(null,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  RealmLineDataSet set1=new RealmLineDataSet();
  ArrayList<RealmLineDataSet> dataSets=new ArrayList<RealmLineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData();
  mChart.setData(data);
}",0.9887640449438202
18309,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
  mXChartMin=-0.5f;
  mXChartMax=(float)mData.getXValCount() - 0.5f;
  if (mRenderer != null) {
    for (    BubbleDataSet set : mData.getDataSets()) {
      final float xmin=set.getXMin();
      final float xmax=set.getXMax();
      if (xmin < mXChartMin)       mXChartMin=xmin;
      if (xmax > mXChartMax)       mXChartMax=xmax;
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
  mXChartMin=-0.5f;
  mXChartMax=(float)mData.getXValCount() - 0.5f;
  if (mRenderer != null) {
    for (    IBubbleDataSet set : mData.getDataSets()) {
      final float xmin=set.getXMin();
      final float xmax=set.getXMax();
      if (xmin < mXChartMin)       mXChartMin=xmin;
      if (xmax > mXChartMax)       mXChartMax=xmax;
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9990205680705192
18310,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      IBubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9991311902693312
18311,"@Override public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= 0 ? y : 0;
  float right=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}","@Override public RectF getBarBounds(BarEntry e){
  IBarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= 0 ? y : 0;
  float right=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}",0.9990205680705192
18312,"/** 
 * Returns true if this DataSet is stacked (stacksize > 1) or not.
 * @return
 */
public boolean isStacked(){
  return mStackSize > 1 ? true : false;
}","@Override public boolean isStacked(){
  return mStackSize > 1 ? true : false;
}",0.6297872340425532
18313,"/** 
 * Returns the alpha value (transparency) that is used for drawing the highlight indicator.
 * @return
 */
public int getHighLightAlpha(){
  return mHighLightAlpha;
}","@Override public int getHighLightAlpha(){
  return mHighLightAlpha;
}",0.525
18314,"/** 
 * Returns the color used for drawing the bar-shadows. The bar shadows is a surface behind the bar that indicates the maximum value.
 * @return
 */
public int getBarShadowColor(){
  return mBarShadowColor;
}","@Override public int getBarShadowColor(){
  return mBarShadowColor;
}",0.4483985765124555
18315,"/** 
 * returns the space between bars as the actual value (0 - 1.0f)
 * @return
 */
public float getBarSpace(){
  return mBarSpace;
}","@Override public float getBarSpace(){
  return mBarSpace;
}",0.5492227979274611
18316,"/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet.
 * @return
 */
public int getStackSize(){
  return mStackSize;
}","@Override public int getStackSize(){
  return mStackSize;
}",0.4907407407407407
18317,"public float getHighlightCircleWidth(){
  return mHighlightCircleWidth;
}","@Override public float getHighlightCircleWidth(){
  return mHighlightCircleWidth;
}",0.935897435897436
18318,"public float getXMax(){
  return mXMax;
}","@Override public float getXMax(){
  return mXMax;
}",0.8913043478260869
18319,"public float getMaxSize(){
  return mMaxSize;
}","@Override public float getMaxSize(){
  return mMaxSize;
}",0.903846153846154
18320,"public float getXMin(){
  return mXMin;
}","@Override public float getXMin(){
  return mXMin;
}",0.8913043478260869
18321,"/** 
 * Returns the decreasing color.
 * @return
 */
public int getDecreasingColor(){
  return mDecreasingColor;
}","@Override public int getDecreasingColor(){
  return mDecreasingColor;
}",0.7027027027027027
18322,"/** 
 * Is the shadow color same as the candle color?
 * @return
 */
public boolean getShadowColorSameAsCandle(){
  return mShadowColorSameAsCandle;
}","@Override public boolean getShadowColorSameAsCandle(){
  return mShadowColorSameAsCandle;
}",0.6887966804979253
18323,"/** 
 * Returns paint style when open > close
 * @return
 */
public Paint.Style getDecreasingPaintStyle(){
  return mDecreasingPaintStyle;
}","@Override public Paint.Style getDecreasingPaintStyle(){
  return mDecreasingPaintStyle;
}",0.7336244541484717
18324,"/** 
 * Returns paint style when open <= close
 * @return
 */
public Paint.Style getIncreasingPaintStyle(){
  return mIncreasingPaintStyle;
}","@Override public Paint.Style getIncreasingPaintStyle(){
  return mIncreasingPaintStyle;
}",0.7304347826086957
18325,"/** 
 * Returns shadow color for all entries
 * @return
 */
public int getShadowColor(){
  return mShadowColor;
}","@Override public int getShadowColor(){
  return mShadowColor;
}",0.6704545454545454
18326,"/** 
 * Returns the width of the candle-shadow-line in pixels.
 * @return
 */
public float getShadowWidth(){
  return mShadowWidth;
}","@Override public float getShadowWidth(){
  return mShadowWidth;
}",0.5959595959595959
18327,"/** 
 * Returns the increasing color.
 * @return
 */
public int getIncreasingColor(){
  return mIncreasingColor;
}","@Override public int getIncreasingColor(){
  return mIncreasingColor;
}",0.7027027027027027
18328,"/** 
 * Returns the space that is left out on the left and right side of each candle.
 * @return
 */
public float getBodySpace(){
  return mBodySpace;
}","@Override public float getBodySpace(){
  return mBodySpace;
}",0.5446009389671361
18329,"@Override public int getXOffset(){
  return -(getWidth() / 2);
}","@Override public int getXOffset(float xpos){
  return -(getWidth() / 2);
}",0.927536231884058
18330,"@Override public int getYOffset(){
  return -getHeight();
}","@Override public int getYOffset(float ypos){
  return -getHeight();
}",0.921875
18331,"@Override public int getXOffset(){
  return -(getWidth() / 2);
}","@Override public int getXOffset(float xpos){
  return -(getWidth() / 2);
}",0.927536231884058
18332,"@Override public int getYOffset(){
  return -getHeight();
}","@Override public int getYOffset(float ypos){
  return -getHeight();
}",0.921875
18333,"/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @return
 */
public abstract int getXOffset();","/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @param xpos the position on the x-axis in pixels where the marker is drawn
 * @return
 */
public abstract int getXOffset(float xpos);",0.8314176245210728
18334,"/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be any subclass of Entry, like BarEntry or CandleEntry, simply cast it at runtime.
 * @param highlight the highlight object contains information about the highlighted value such as it's dataset-index, the selected range or stack-index (only stacked bar entries).
 */
public abstract void refreshContent(Entry e,Highlight highlight);","/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e         The Entry the MarkerView belongs to. This can also be any subclass of Entry, like BarEntry orCandleEntry, simply cast it at runtime.
 * @param highlight the highlight object contains information about the highlighted value such as it's dataset-index, theselected range or stack-index (only stacked bar entries).
 */
public abstract void refreshContent(Entry e,Highlight highlight);",0.9903100775193798
18335,"/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset();
  posy+=getYOffset();
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}","/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset(posx);
  posy+=getYOffset(posy);
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}",0.987878787878788
18336,"/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @return
 */
public abstract int getYOffset();","/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @param ypos the position on the y-axis in pixels where the marker is drawn
 * @return
 */
public abstract int getYOffset(float ypos);",0.8439716312056738
18337,"@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenterOffsets();
  final List<PieDataSet> dataSets=mData.getDataSets();
  float maxShift=0.f;
  for (int i=0; i < dataSets.size(); i++) {
    final float shift=dataSets.get(i).getSelectionShift();
    if (shift > maxShift)     maxShift=shift;
  }
  final float halfMaxShift=maxShift / 2.f;
  mCircleBox.set(c.x - radius + halfMaxShift,c.y - radius + halfMaxShift,c.x + radius - halfMaxShift,c.y + radius - halfMaxShift);
}","@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenter();
  float shift=mData.getDataSet().getSelectionShift();
  mCircleBox.set(c.x - radius + shift,c.y - radius + shift,c.x + radius - shift,c.y + radius - shift);
}",0.4595744680851064
18338,"@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
 else     if (mLegend.getPosition() == LegendPosition.ABOVE_CHART_LEFT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_RIGHT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendTop=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float minOffset=Utils.convertDpToPixel(mMinOffset);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      minOffset=Math.max(minOffset,x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(minOffset,legendLeft);
  float offsetTop=Math.max(minOffset,legendTop);
  float offsetRight=Math.max(minOffset,legendRight);
  float offsetBottom=Math.max(minOffset,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
 else     if (mLegend.getPosition() == LegendPosition.ABOVE_CHART_LEFT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_RIGHT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendTop=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float minOffset=0f;
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      minOffset=x.mLabelWidth;
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(minOffset,legendLeft);
  float offsetTop=Math.max(minOffset,legendTop);
  float offsetRight=Math.max(minOffset,legendRight);
  float offsetBottom=Math.max(minOffset,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9932934131736528
18339,"private SpannableString generateCenterSpannableText(){
  SpannableString s=new SpannableString(""String_Node_Str"");
  s.setSpan(new RelativeSizeSpan(1.7f),0,14,0);
  return s;
}","private SpannableString generateCenterSpannableText(){
  SpannableString s=new SpannableString(""String_Node_Str"");
  s.setSpan(new RelativeSizeSpan(1.7f),0,14,0);
  s.setSpan(new StyleSpan(Typeface.NORMAL),14,s.length() - 15,0);
  s.setSpan(new ForegroundColorSpan(Color.GRAY),14,s.length() - 15,0);
  s.setSpan(new RelativeSizeSpan(.8f),14,s.length() - 15,0);
  s.setSpan(new StyleSpan(Typeface.ITALIC),s.length() - 14,s.length(),0);
  return s;
}",0.5544871794871795
18340,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  SpannableString centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
    RectF holeRect=mRectBuffer[0];
    holeRect.left=center.x - innerRadius;
    holeRect.top=center.y - innerRadius;
    holeRect.right=center.x + innerRadius;
    holeRect.bottom=center.y + innerRadius;
    RectF boundingRect=mRectBuffer[1];
    boundingRect.set(holeRect);
    float radiusPercent=mChart.getCenterTextRadiusPercent();
    if (radiusPercent > 0.0) {
      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
    }
    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
      mCenterTextLastBounds.set(boundingRect);
      mCenterTextLastValue=centerText;
      float width=mCenterTextLastBounds.width();
      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
    }
    float layoutHeight=mCenterTextLayout.getHeight();
    c.save();
    c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
    mCenterTextLayout.draw(c);
    c.restore();
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  SpannableString centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
    RectF holeRect=mRectBuffer[0];
    holeRect.left=center.x - innerRadius;
    holeRect.top=center.y - innerRadius;
    holeRect.right=center.x + innerRadius;
    holeRect.bottom=center.y + innerRadius;
    RectF boundingRect=mRectBuffer[1];
    boundingRect.set(holeRect);
    float radiusPercent=mChart.getCenterTextRadiusPercent();
    if (radiusPercent > 0.0) {
      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
    }
    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
      mCenterTextLastBounds.set(boundingRect);
      mCenterTextLastValue=centerText;
      float width=mCenterTextLastBounds.width();
      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);
    }
    float layoutHeight=mCenterTextLayout.getHeight();
    c.save();
    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
    mCenterTextLayout.draw(c);
    c.restore();
  }
}",0.9930366333636088
18341,"public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mTransparentCirclePaint.setAlpha(100);
  mCenterTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}","public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mTransparentCirclePaint.setAlpha(100);
  mCenterTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}",0.9699680511182108
18342,"/** 
 * Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart.
 * @param count if count = 1 -> 1 line is skipped in between
 */
public void setSkipWebLineCount(int count){
  if (count < 0)   count=0;
  mWebModulus=count + 1;
}","/** 
 * Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart.
 * @param count if count = 1 -> 1 line is skipped in between
 */
public void setSkipWebLineCount(int count){
  mSkipWebLineCount=Math.max(0,count);
}",0.8807339449541285
18343,"/** 
 * Returns the modulus that is used for skipping web-lines.
 * @return
 */
public int getSkipWebLineCount(){
  return mWebModulus;
}","/** 
 * Returns the modulus that is used for skipping web-lines.
 * @return
 */
public int getSkipWebLineCount(){
  return mSkipWebLineCount;
}",0.9428571428571428
18344,"protected void drawCubicFill(LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=dataSet.getFillFormatter().getFillLinePosition(dataSet,mChart);
  spline.lineTo(to - 1,fillMin);
  spline.lineTo(from,fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawCubicFill(LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  if (to - from <= 1)   return;
  float fillMin=dataSet.getFillFormatter().getFillLinePosition(dataSet,mChart);
  spline.lineTo(to - 1,fillMin);
  spline.lineTo(from,fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.9696969696969696
18345,"protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i+=mChart.getSkipWebLineCount()) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  final int xIncrements=1 + mChart.getSkipWebLineCount();
  for (int i=0; i < mChart.getData().getXValCount(); i+=xIncrements) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9599007854485324
18346,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to * mAnimator.getPhaseY();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to;
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=(y1 > -y2 ? y1 : y1) * mAnimator.getPhaseY();
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.988431281813975
18347,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixelHorizontal(RectF r,float phaseY){
  if (r.left > 0)   r.left*=phaseY;
 else   r.right*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixelHorizontal(RectF r,float phaseY){
  r.left*=phaseY;
  r.right*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.963963963963964
18348,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  if (r.top > 0)   r.top*=phaseY;
 else   r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  r.top*=phaseY;
  r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.9643410852713178
18349,"@Override protected float[] getMarkerPosition(Entry e,Highlight highlight){
  int dataSetIndex=highlight.getDataSetIndex();
  float xPos=e.getXIndex();
  float yPos=e.getVal();
  if (this instanceof BarChart) {
    BarData bd=(BarData)mData;
    float space=bd.getGroupSpace();
    int setCount=mData.getDataSetCount();
    int i=e.getXIndex();
    if (this instanceof HorizontalBarChart) {
      float y=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      yPos=y;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        xPos=highlight.getRange().to;
      }
 else {
        xPos=e.getVal();
      }
    }
 else {
      float x=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      xPos=x;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        yPos=highlight.getRange().to;
      }
 else {
        yPos=e.getVal();
      }
    }
  }
  float[] pts=new float[]{xPos,yPos * mAnimator.getPhaseY()};
  getTransformer(mData.getDataSetByIndex(dataSetIndex).getAxisDependency()).pointValuesToPixel(pts);
  return pts;
}","@Override protected float[] getMarkerPosition(Entry e,Highlight highlight){
  int dataSetIndex=highlight.getDataSetIndex();
  float xPos=e.getXIndex();
  float yPos=e.getVal();
  if (this instanceof BarChart) {
    BarData bd=(BarData)mData;
    float space=bd.getGroupSpace();
    int setCount=mData.getDataSetCount();
    int i=e.getXIndex();
    if (this instanceof HorizontalBarChart) {
      float y=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      yPos=y;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        xPos=highlight.getRange().to;
      }
 else {
        xPos=e.getVal();
      }
      xPos*=mAnimator.getPhaseY();
    }
 else {
      float x=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      xPos=x;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        yPos=highlight.getRange().to;
      }
 else {
        yPos=e.getVal();
      }
      yPos*=mAnimator.getPhaseY();
    }
  }
 else {
    yPos*=mAnimator.getPhaseY();
  }
  float[] pts=new float[]{xPos,yPos};
  getTransformer(mData.getDataSetByIndex(dataSetIndex).getAxisDependency()).pointValuesToPixel(pts);
  return pts;
}",0.9389547650417216
18350,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
 else {
    mXChartMin=0f;
    mXChartMax=mData.getXValCount() - 1;
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.8739770867430442
18351,"@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float boxSize=diameter / 2f;
  PointF c=getCenterOffsets();
  mCircleBox.set(c.x - boxSize,c.y - boxSize,c.x + boxSize,c.y + boxSize);
}","@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenterOffsets();
  final List<PieDataSet> dataSets=mData.getDataSets();
  float maxShift=0.f;
  for (int i=0; i < dataSets.size(); i++) {
    final float shift=dataSets.get(i).getSelectionShift();
    if (shift > maxShift)     maxShift=shift;
  }
  final float halfMaxShift=maxShift / 2.f;
  mCircleBox.set(c.x - radius + halfMaxShift,c.y - radius + halfMaxShift,c.x + radius - halfMaxShift,c.y + radius - halfMaxShift);
}",0.441108545034642
18352,"@Override protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  List<CandleEntry> entries=mYVals;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=mYVals.get(start).getLow();
  mYMax=mYVals.get(start).getHigh();
  for (int i=start + 1; i <= endValue; i++) {
    CandleEntry e=entries.get(i);
    if (e.getLow() < mYMin)     mYMin=e.getLow();
    if (e.getHigh() > mYMax)     mYMax=e.getHigh();
  }
}","@Override protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  List<CandleEntry> entries=mYVals;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=mYVals.get(start).getLow();
  mYMax=mYVals.get(start).getHigh();
  for (int i=start + 1; i <= endValue; i++) {
    CandleEntry e=entries.get(i);
    if (e.getLow() < mYMin)     mYMin=e.getLow();
    if (e.getHigh() > mYMax)     mYMax=e.getHigh();
  }
}",0.9771428571428572
18353,"@Override public void drawData(Canvas c){
  BarData barData=mChart.getBarData();
  for (int i=0; i < barData.getDataSetCount(); i++) {
    BarDataSet set=barData.getDataSetByIndex(i);
    if (set.isVisible()) {
      drawDataSet(c,set,i);
    }
  }
}","@Override public void drawData(Canvas c){
  BarData barData=mChart.getBarData();
  for (int i=0; i < barData.getDataSetCount(); i++) {
    BarDataSet set=barData.getDataSetByIndex(i);
    if (set.isVisible() && set.getEntryCount() > 0) {
      drawDataSet(c,set,i);
    }
  }
}",0.9487666034155596
18354,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.9953366365491112
18355,"@Override public void drawData(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  for (  BubbleDataSet set : bubbleData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  for (  BubbleDataSet set : bubbleData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9370629370629372
18356,"@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}",0.9916098584163608
18357,"@Override public void drawData(Canvas c){
  CandleData candleData=mChart.getCandleData();
  for (  CandleDataSet set : candleData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  CandleData candleData=mChart.getCandleData();
  for (  CandleDataSet set : candleData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9370629370629372
18358,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    if (dataSet.getShadowColorSameAsCandle()) {
      if (e.getOpen() > e.getClose())       mRenderPaint.setColor(dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getDecreasingColor());
 else       if (e.getOpen() < e.getClose())       mRenderPaint.setColor(dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getIncreasingColor());
 else       mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
    mRenderPaint.setStyle(Paint.Style.STROKE);
    c.drawLine(shadowBuffer.buffer[j],shadowBuffer.buffer[j + 1],shadowBuffer.buffer[j + 2],shadowBuffer.buffer[j + 3],mRenderPaint);
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor());
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  int minx=Math.max(mMinX,0);
  int maxx=Math.min(mMaxX + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    if (dataSet.getShadowColorSameAsCandle()) {
      if (e.getOpen() > e.getClose())       mRenderPaint.setColor(dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getDecreasingColor());
 else       if (e.getOpen() < e.getClose())       mRenderPaint.setColor(dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getIncreasingColor());
 else       mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
    mRenderPaint.setStyle(Paint.Style.STROKE);
    c.drawLine(shadowBuffer.buffer[j],shadowBuffer.buffer[j + 1],shadowBuffer.buffer[j + 2],shadowBuffer.buffer[j + 3],mRenderPaint);
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor());
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9721706864564008
18359,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      int minx=Math.max(mMinX,0);
      int maxx=Math.min(mMaxX + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.9058561897702
18360,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}",0.9966237602869804
18361,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.9804205946337926
18362,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9893617021276596
18363,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.978756884343037
18364,"@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9339853300733496
18365,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}",0.9801980198019802
18366,"@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.986277873070326
18367,"@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (mAxisLeft.mAxisMinimum < 0f && mAxisLeft.mAxisMaximum < 0f) {
      mAxisLeft.mAxisMaximum=0f;
    }
 else     if (mAxisLeft.mAxisMinimum >= 0f) {
      mAxisLeft.mAxisMinimum=0f;
    }
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (mAxisRight.mAxisMinimum < 0.0 && mAxisRight.mAxisMaximum < 0.0) {
      mAxisRight.mAxisMaximum=0f;
    }
 else     if (mAxisRight.mAxisMinimum >= 0f) {
      mAxisRight.mAxisMinimum=0f;
    }
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (minLeft < 0.f && maxLeft < 0.f) {
      mAxisLeft.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mAxisLeft.mAxisMaximum=0.f;
    }
 else     if (minLeft >= 0.0) {
      mAxisLeft.mAxisMinimum=0.f;
      mAxisLeft.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
 else {
      mAxisLeft.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mAxisLeft.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
  }
 else {
    mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft);
    mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft);
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (minRight < 0.f && maxRight < 0.f) {
      mAxisRight.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));
      mAxisRight.mAxisMaximum=0.f;
    }
 else     if (minRight >= 0.f) {
      mAxisRight.mAxisMinimum=0.f;
      mAxisRight.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));
    }
 else {
      mAxisRight.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));
      mAxisRight.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));
    }
  }
 else {
    mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight);
    mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight);
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.5679779158040028
18368,"@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredBottomOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredBottomOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9964375247394116
18369,"@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}","@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}",0.8918918918918919
18370,"@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=Math.min(0f,mYAxis.mAxisMinimum);
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  if (mYAxis.isStartAtZeroEnabled()) {
    if (minLeft < 0.f && maxLeft < 0.f) {
      mYAxis.mAxisMinimum=Math.min(0.f,!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mYAxis.mAxisMaximum=0.f;
    }
 else     if (minLeft >= 0.0) {
      mYAxis.mAxisMinimum=0.f;
      mYAxis.mAxisMaximum=Math.max(0.f,!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
 else {
      mYAxis.mAxisMinimum=Math.min(0.f,!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mYAxis.mAxisMaximum=Math.max(0.f,!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
  }
 else {
    mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft);
    mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft);
  }
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}",0.6012412723041117
18371,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(tf);
  mChart.setDrawValueAboveBar(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
    yVals1.add(new BarEntry((float)(Math.random() * range),i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(tf);
  mChart.setData(data);
}",0.7259842519685039
18372,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + e.getXIndex() * dataSetOffset + mDataSetIndex + mGroupSpace * e.getXIndex() + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9919308357348704
18373,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + e.getXIndex() * dataSetOffset + mDataSetIndex + mGroupSpace * e.getXIndex() + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9919401266551524
18374,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    float x=e.getXIndex() + (j / 2 * (setCount - 1)) + dataSet+ space * (j / 2) + space / 2f;
    float y=e.getVal();
    valuePoints[j]=x;
    valuePoints[j + 1]=y * phaseY;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    int i=e.getXIndex();
    float x=e.getXIndex() + i * (setCount - 1) + dataSet + space * i + space / 2f;
    float y=e.getVal();
    valuePoints[j]=x;
    valuePoints[j + 1]=y * phaseY;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9641943734015346
18375,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesHorizontalBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    float x=e.getXIndex() + (j / 2 * (setCount - 1)) + dataSet+ space * (j / 2) + space / 2f;
    float y=e.getVal();
    valuePoints[j]=y * phaseY;
    valuePoints[j + 1]=x;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesHorizontalBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    int i=e.getXIndex();
    float x=e.getXIndex() + i * (setCount - 1) + dataSet + space * i + space / 2f;
    float y=e.getVal();
    valuePoints[j]=y * phaseY;
    valuePoints[j + 1]=x;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9646464646464646
18376,"@Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  BarEntry entry=(BarEntry)e;
  if (entry.isStacked())   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVals()[h.getStackIndex()]);
 else   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVal());
}","@Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  BarEntry entry=(BarEntry)e;
  if (entry.getVals() != null)   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVals()[h.getStackIndex()]);
 else   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVal());
}",0.9548611111111112
18377,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9838662364329716
18378,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.9889916336415676
18379,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleLineValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets()) {
        if (set instanceof LineDataSet)         set.setDrawValues(!set.isDrawValuesEnabled());
      }
      mChart.invalidate();
      break;
    }
case R.id.actionToggleBarValues:
{
    for (    DataSet<?> set : mChart.getData().getDataSets()) {
      if (set instanceof BarDataSet)       set.setDrawValues(!set.isDrawValuesEnabled());
    }
    mChart.invalidate();
    break;
  }
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleLineValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets()) {
        if (set instanceof LineDataSet)         set.setDrawValues(!set.isDrawValuesEnabled());
      }
      mChart.invalidate();
      break;
    }
case R.id.actionToggleBarValues:
{
    CombinedData data=new CombinedData(mMonths);
    data.setData(generateLineData());
    mChart.setData(data);
    mChart.invalidate();
    break;
  }
}
return true;
}",0.7839020122484689
18380,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float allPos=e.getPositiveSum();
      float allNeg=e.getNegativeSum();
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          allPos-=value;
          y=value + allPos;
        }
 else {
          allNeg-=Math.abs(value);
          y=value + allNeg;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= 0 ? y : 0;
          top=y <= 0 ? y : 0;
        }
 else {
          top=y >= 0 ? y : 0;
          bottom=y <= 0 ? y : 0;
        }
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.8744019138755981
18381,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float allPos=e.getPositiveSum();
      float allNeg=e.getNegativeSum();
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          allPos-=value;
          y=value + allPos;
        }
 else {
          allNeg-=Math.abs(value);
          y=value + allNeg;
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= 0 ? y : 0;
          right=y <= 0 ? y : 0;
        }
 else {
          right=y >= 0 ? y : 0;
          left=y <= 0 ? y : 0;
        }
        if (right > 0)         right*=phaseY;
 else         left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.8722388059701492
18382,"@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (mAxisLeft.mAxisMinimum < 0f && mAxisLeft.mAxisMaximum < 0f) {
      mAxisLeft.mAxisMaximum=0f;
    }
 else {
      mAxisLeft.mAxisMinimum=0f;
    }
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (mAxisRight.mAxisMinimum < 0.0 && mAxisRight.mAxisMaximum < 0.0) {
      mAxisRight.mAxisMaximum=0f;
    }
 else {
      mAxisRight.mAxisMinimum=0f;
    }
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.9099548586362556
18383,"/** 
 * calc minimum and maximum y value over all datasets
 */
public void calcMinMax(int start,int end){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mLastStart=start;
    mLastEnd=end;
    mYMin=Float.MAX_VALUE;
    mYMax=-Float.MIN_VALUE;
    for (int i=0; i < mDataSets.size(); i++) {
      mDataSets.get(i).calcMinMax(start,end);
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    if (mYMin == Float.MAX_VALUE) {
      mYMin=0.f;
      mYMax=0.f;
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}","/** 
 * calc minimum and maximum y value over all datasets
 */
public void calcMinMax(int start,int end){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mLastStart=start;
    mLastEnd=end;
    mYMin=Float.MAX_VALUE;
    mYMax=-Float.MAX_VALUE;
    for (int i=0; i < mDataSets.size(); i++) {
      mDataSets.get(i).calcMinMax(start,end);
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    if (mYMin == Float.MAX_VALUE) {
      mYMin=0.f;
      mYMax=0.f;
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}",0.9987677141096736
18384,"/** 
 * calc minimum and maximum y value
 */
protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=Float.MAX_VALUE;
  mYMax=-Float.MIN_VALUE;
  for (int i=start; i <= endValue; i++) {
    Entry e=mYVals.get(i);
    if (e != null && !Float.isNaN(e.getVal())) {
      if (e.getVal() < mYMin)       mYMin=e.getVal();
      if (e.getVal() > mYMax)       mYMax=e.getVal();
    }
  }
  if (mYMin == Float.MAX_VALUE) {
    mYMin=0.f;
    mYMax=0.f;
  }
}","/** 
 * calc minimum and maximum y value
 */
protected void calcMinMax(int start,int end){
  final int yValCount=mYVals.size();
  if (yValCount == 0)   return;
  int endValue;
  if (end == 0 || end >= yValCount)   endValue=yValCount - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=Float.MAX_VALUE;
  mYMax=-Float.MAX_VALUE;
  for (int i=start; i <= endValue; i++) {
    Entry e=mYVals.get(i);
    if (e != null && !Float.isNaN(e.getVal())) {
      if (e.getVal() < mYMin)       mYMin=e.getVal();
      if (e.getVal() > mYMax)       mYMax=e.getVal();
    }
  }
  if (mYMin == Float.MAX_VALUE) {
    mYMin=0.f;
    mYMax=0.f;
  }
}",0.9106719367588932
18385,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float allPos=e.getPositiveSum();
            float allNeg=e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                allPos-=value;
                y=value + allPos;
              }
 else {
                allNeg-=Math.abs(value);
                y=value + allNeg;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.961193165363452
18386,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float allPos=e.getPositiveSum();
            float allNeg=e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                allPos-=value;
                y=value + allPos;
              }
 else {
                allNeg-=Math.abs(value);
                y=value + allNeg;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y);
            }
          }
        }
      }
    }
  }
}",0.9721181856013316
18387,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
protected List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  float[] pts=new float[2];
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    if (!dataSet.isHighlightEnabled())     continue;
    float yVal=dataSet.getYValForXIndex(xIndex);
    pts[1]=yVal;
    getTransformer(dataSet.getAxisDependency()).pointValuesToPixel(pts);
    if (!Float.isNaN(pts[1])) {
      vals.add(new SelectionDetail(pts[1],i,dataSet));
    }
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
protected List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  float[] pts=new float[2];
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    if (!dataSet.isHighlightEnabled())     continue;
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    pts[1]=yVal;
    getTransformer(dataSet.getAxisDependency()).pointValuesToPixel(pts);
    if (!Float.isNaN(pts[1])) {
      vals.add(new SelectionDetail(pts[1],i,dataSet));
    }
  }
  return vals;
}",0.9740474875759249
18388,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    float yVal=dataSet.getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal)) {
      vals.add(new SelectionDetail(yVal,i,dataSet));
    }
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}",0.9386026817219478
18389,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    final float yVal=set.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    float y=yVal * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.992744860943168
18390,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    final float yVal=set.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    float y=yVal * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.992619926199262
18391,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_age_distribution);
  setTitle(""String_Node_Str"");
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.getAxisLeft().setEnabled(false);
  mChart.getAxisRight().setStartAtZero(false);
  mChart.getAxisRight().setAxisMaxValue(25f);
  mChart.getAxisRight().setAxisMinValue(-25f);
  mChart.getAxisRight().setLabelCount(7);
  mChart.getAxisRight().setValueFormatter(new CustomFormatter());
  mChart.getAxisRight().setTextSize(9f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
  ArrayList<BarEntry> yValues=new ArrayList<BarEntry>();
  yValues.add(new BarEntry(new float[]{-10,10},0));
  yValues.add(new BarEntry(new float[]{-12,13},1));
  yValues.add(new BarEntry(new float[]{-15,15},2));
  yValues.add(new BarEntry(new float[]{-17,17},3));
  yValues.add(new BarEntry(new float[]{-19,20},4));
  yValues.add(new BarEntry(new float[]{-19,19},5));
  yValues.add(new BarEntry(new float[]{-16,16},6));
  yValues.add(new BarEntry(new float[]{-13,14},7));
  yValues.add(new BarEntry(new float[]{-10,11},8));
  yValues.add(new BarEntry(new float[]{-5,6},9));
  yValues.add(new BarEntry(new float[]{-1,2},10));
  BarDataSet set=new BarDataSet(yValues,""String_Node_Str"");
  set.setValueFormatter(new CustomFormatter());
  set.setValueTextSize(7f);
  set.setAxisDependency(YAxis.AxisDependency.RIGHT);
  set.setBarSpacePercent(50f);
  set.setColors(new int[]{Color.rgb(67,67,72),Color.rgb(124,181,236)});
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str""});
  String[] xVals=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  BarData data=new BarData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_age_distribution);
  setTitle(""String_Node_Str"");
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.getAxisLeft().setEnabled(false);
  mChart.getAxisRight().setStartAtZero(false);
  mChart.getAxisRight().setAxisMaxValue(25f);
  mChart.getAxisRight().setAxisMinValue(-25f);
  mChart.getAxisRight().setLabelCount(7);
  mChart.getAxisRight().setValueFormatter(new CustomFormatter());
  mChart.getAxisRight().setTextSize(9f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
  ArrayList<BarEntry> yValues=new ArrayList<BarEntry>();
  yValues.add(new BarEntry(new float[]{-10,10},0));
  yValues.add(new BarEntry(new float[]{-12,13},1));
  yValues.add(new BarEntry(new float[]{-15,15},2));
  yValues.add(new BarEntry(new float[]{-17,17},3));
  yValues.add(new BarEntry(new float[]{-19,20},4));
  yValues.add(new BarEntry(new float[]{-19,19},5));
  yValues.add(new BarEntry(new float[]{-16,16},6));
  yValues.add(new BarEntry(new float[]{-13,14},7));
  yValues.add(new BarEntry(new float[]{-10,11},8));
  yValues.add(new BarEntry(new float[]{-5,6},9));
  yValues.add(new BarEntry(new float[]{-1,2},10));
  BarDataSet set=new BarDataSet(yValues,""String_Node_Str"");
  set.setValueFormatter(new CustomFormatter());
  set.setValueTextSize(7f);
  set.setAxisDependency(YAxis.AxisDependency.RIGHT);
  set.setBarSpacePercent(40f);
  set.setColors(new int[]{Color.rgb(67,67,72),Color.rgb(124,181,236)});
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str""});
  String[] xVals=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  BarData data=new BarData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}",0.999607535321821
18392,"/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param set
 * @param xIndex
 * @param dataSetIndex
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(BarDataSet set,int xIndex,int dataSetIndex,double yValue){
  BarEntry entry=set.getEntryForXIndex(xIndex);
  if (entry != null) {
    int stackIndex=getClosestStackIndex(entry,(float)yValue);
    Highlight h=new Highlight(xIndex,dataSetIndex,stackIndex);
    return h;
  }
 else   return null;
}","/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param set
 * @param xIndex
 * @param dataSetIndex
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(BarDataSet set,int xIndex,int dataSetIndex,double yValue){
  BarEntry entry=set.getEntryForXIndex(xIndex);
  if (entry != null) {
    Range[] ranges=getRanges(entry);
    int stackIndex=getClosestStackIndex(ranges,(float)yValue);
    Highlight h=new Highlight(xIndex,dataSetIndex,stackIndex,ranges[stackIndex]);
    return h;
  }
 else   return null;
}",0.9413823272090988
18393,"/** 
 * Returns the index of the closest value inside the values array (for stacked barchart) to the value given as a parameter.
 * @param e
 * @param value
 * @return
 */
protected int getClosestStackIndex(BarEntry e,float value){
  Range[] ranges=getRanges(e);
  int stackIndex=0;
  for (  Range range : ranges) {
    if (range.contains(value))     return stackIndex;
 else     stackIndex++;
  }
  int length=ranges.length - 1;
  return (value > ranges[length].to) ? length : 0;
}","/** 
 * Returns the index of the closest value inside the values array / ranges (stacked barchart) to the value given as a parameter.
 * @param ranges
 * @param value
 * @return
 */
protected int getClosestStackIndex(Range[] ranges,float value){
  int stackIndex=0;
  for (  Range range : ranges) {
    if (range.contains(value))     return stackIndex;
 else     stackIndex++;
  }
  int length=ranges.length - 1;
  return (value > ranges[length].to) ? length : 0;
}",0.9186906019007391
18394,"protected Range[] getRanges(BarEntry entry){
  float[] values=entry.getVals();
  float negRemain=-entry.getNegativeSum();
  float posRemain=0f;
  Range[] ranges=new Range[values.length];
  for (int i=0; i < ranges.length; i++) {
    float value=values[i];
    if (value < 0) {
      ranges[i]=new Range(negRemain,negRemain + Math.abs(value));
      negRemain+=Math.abs(value);
    }
 else {
      ranges[i]=new Range(posRemain,posRemain + value);
      posRemain+=value;
    }
  }
  return ranges;
}","/** 
 * Splits up the stack-values of the given bar-entry into Range objects.
 * @param entry
 * @return
 */
protected Range[] getRanges(BarEntry entry){
  float[] values=entry.getVals();
  if (values == null)   return null;
  float negRemain=-entry.getNegativeSum();
  float posRemain=0f;
  Range[] ranges=new Range[values.length];
  for (int i=0; i < ranges.length; i++) {
    float value=values[i];
    if (value < 0) {
      ranges[i]=new Range(negRemain,negRemain + Math.abs(value));
      negRemain+=Math.abs(value);
    }
 else {
      ranges[i]=new Range(posRemain,posRemain + value);
      posRemain+=value;
    }
  }
  return ranges;
}",0.8723776223776224
18395,"/** 
 * Constructor, only used for stacked-barchart.
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 * @param stackIndex references which value of a stacked-bar entry has beenselected
 */
public Highlight(int x,int dataSet,int stackIndex){
  this(x,dataSet);
  mStackIndex=stackIndex;
}","/** 
 * Constructor, only used for stacked-barchart.
 * @param x the index of the highlighted value on the x-axis
 * @param dataSet the index of the DataSet the highlighted value belongs to
 * @param stackIndex references which value of a stacked-bar entry has beenselected
 * @param range the range the selected stack-value is in
 */
public Highlight(int x,int dataSet,int stackIndex,Range range){
  this(x,dataSet,stackIndex);
  this.mRange=range;
}",0.4457013574660634
18396,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=e.getPositiveSum();
        y2=-e.getNegativeSum();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to * mAnimator.getPhaseY();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9802371541501976
18397,"public YAxis(AxisDependency position){
  super();
  this.mAxisDependency=position;
}","public YAxis(AxisDependency position){
  super();
  this.mAxisDependency=position;
  this.mYOffset=0f;
}",0.8936170212765957
18398,"/** 
 * draws the y-axis labels to the screen
 */
@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  float[] positions=new float[mYAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i + 1]=mYAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
  mAxisLabelPaint.setColor(mYAxis.getTextColor());
  float xoffset=mYAxis.getXOffset();
  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,""String_Node_Str"") / 2.5f;
  AxisDependency dependency=mYAxis.getAxisDependency();
  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();
  float xPos=0f;
  if (dependency == AxisDependency.LEFT) {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.offsetLeft() - xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.offsetLeft() + xoffset;
    }
  }
 else {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.contentRight() + xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.contentRight() - xoffset;
    }
  }
  drawYLabels(c,xPos,positions,yoffset);
}","/** 
 * draws the y-axis labels to the screen
 */
@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  float[] positions=new float[mYAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i + 1]=mYAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
  mAxisLabelPaint.setColor(mYAxis.getTextColor());
  float xoffset=mYAxis.getXOffset();
  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,""String_Node_Str"") / 2.5f + mYAxis.getYOffset();
  AxisDependency dependency=mYAxis.getAxisDependency();
  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();
  float xPos=0f;
  if (dependency == AxisDependency.LEFT) {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.offsetLeft() - xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.offsetLeft() + xoffset;
    }
  }
 else {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.contentRight() + xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.contentRight() - xoffset;
    }
  }
  drawYLabels(c,xPos,positions,yoffset);
}",0.9924085576259488
18399,"@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  Path gridLinePath=new Path();
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      gridLinePath.moveTo(position[0],mViewPortHandler.contentBottom());
      gridLinePath.lineTo(position[0],mViewPortHandler.contentTop());
      c.drawPath(gridLinePath,mGridPaint);
    }
    gridLinePath.reset();
  }
}",0.8763440860215054
18400,"/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspaceHalf the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}",0.9964093357271095
18401,"@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}",0.99038974906567
18402,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
        BarDataSet bds=(BarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof PieDataSet) {
        List<String> xVals=data.getXVals();
        PieDataSet pds=(PieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setColors(colors);
    mLegend.setLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
        BarDataSet bds=(BarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof PieDataSet) {
        List<String> xVals=data.getXVals();
        PieDataSet pds=(PieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.984126984126984
18403,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.986796785304248
18404,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  Entry e=null;
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null || e.getXIndex() != high.getXIndex()) {
      mIndicesToHightlight=null;
      high=null;
    }
 else {
      mIndicesToHightlight=new Highlight[]{high};
    }
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.7667121418826739
18405,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(Canvas canvas){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(canvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(canvas,pos[0],pos[1]);
      }
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(Canvas canvas){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null || e.getXIndex() != mIndicesToHightlight[i].getXIndex())       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(canvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(canvas,pos[0],pos[1]);
      }
    }
  }
}",0.97682119205298
18406,"/** 
 * Returns the value of the Entry object at the given xIndex. Returns Float.NaN if no value is at the given x-index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public float getYValForXIndex(int xIndex){
  Entry e=getEntryForXIndex(xIndex);
  if (e != null)   return e.getVal();
 else   return Float.NaN;
}","/** 
 * Returns the value of the Entry object at the given xIndex. Returns Float.NaN if no value is at the given x-index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public float getYValForXIndex(int xIndex){
  Entry e=getEntryForXIndex(xIndex);
  if (e != null && e.getXIndex() == xIndex)   return e.getVal();
 else   return Float.NaN;
}",0.9678188319427892
18407,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9774774774774776
18408,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BubbleData bubbleData=mChart.getBubbleData();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  for (  Highlight indice : indices) {
    BubbleDataSet dataSet=bubbleData.getDataSetByIndex(indice.getDataSetIndex());
    if (dataSet == null || !dataSet.isHighlightEnabled())     continue;
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
    final BubbleEntry entry=(BubbleEntry)bubbleData.getEntryForHighlight(indice);
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    sizeBuffer[0]=0f;
    sizeBuffer[2]=1f;
    trans.pointValuesToPixel(sizeBuffer);
    final float maxBubbleWidth=Math.abs(sizeBuffer[2] - sizeBuffer[0]);
    final float maxBubbleHeight=Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());
    final float referenceSize=Math.min(maxBubbleHeight,maxBubbleWidth);
    pointBuffer[0]=(float)(entry.getXIndex() - minx) * phaseX + (float)minx;
    pointBuffer[1]=(float)(entry.getVal()) * phaseY;
    trans.pointValuesToPixel(pointBuffer);
    float shapeHalf=getShapeSize(entry.getSize(),dataSet.getMaxSize(),referenceSize) / 2f;
    if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf) || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))     break;
    if (indice.getXIndex() < minx || indice.getXIndex() >= maxx)     continue;
    final int originalColor=dataSet.getColor(entry.getXIndex());
    Color.RGBToHSV(Color.red(originalColor),Color.green(originalColor),Color.blue(originalColor),_hsvBuffer);
    _hsvBuffer[2]*=0.5f;
    final int color=Color.HSVToColor(Color.alpha(originalColor),_hsvBuffer);
    mHighlightPaint.setColor(color);
    mHighlightPaint.setStrokeWidth(dataSet.getHighlightCircleWidth());
    c.drawCircle(pointBuffer[0],pointBuffer[1],shapeHalf,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BubbleData bubbleData=mChart.getBubbleData();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  for (  Highlight indice : indices) {
    BubbleDataSet dataSet=bubbleData.getDataSetByIndex(indice.getDataSetIndex());
    if (dataSet == null || !dataSet.isHighlightEnabled())     continue;
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
    final BubbleEntry entry=(BubbleEntry)bubbleData.getEntryForHighlight(indice);
    if (entry == null || entry.getXIndex() != indice.getXIndex())     continue;
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    sizeBuffer[0]=0f;
    sizeBuffer[2]=1f;
    trans.pointValuesToPixel(sizeBuffer);
    final float maxBubbleWidth=Math.abs(sizeBuffer[2] - sizeBuffer[0]);
    final float maxBubbleHeight=Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());
    final float referenceSize=Math.min(maxBubbleHeight,maxBubbleWidth);
    pointBuffer[0]=(float)(entry.getXIndex() - minx) * phaseX + (float)minx;
    pointBuffer[1]=(float)(entry.getVal()) * phaseY;
    trans.pointValuesToPixel(pointBuffer);
    float shapeHalf=getShapeSize(entry.getSize(),dataSet.getMaxSize(),referenceSize) / 2f;
    if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf) || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))     break;
    if (indice.getXIndex() < minx || indice.getXIndex() >= maxx)     continue;
    final int originalColor=dataSet.getColor(entry.getXIndex());
    Color.RGBToHSV(Color.red(originalColor),Color.green(originalColor),Color.blue(originalColor),_hsvBuffer);
    _hsvBuffer[2]*=0.5f;
    final int color=Color.HSVToColor(Color.alpha(originalColor),_hsvBuffer);
    mHighlightPaint.setColor(color);
    mHighlightPaint.setStrokeWidth(dataSet.getHighlightCircleWidth());
    c.drawCircle(pointBuffer[0],pointBuffer[1],shapeHalf,mHighlightPaint);
  }
}",0.9824945295404814
18409,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}",0.9880266075388028
18410,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.957124842370744
18411,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9662921348314608
18412,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9563543003851092
18413,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setValueFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  l.setYOffset(0f);
  l.setYEntrySpace(0f);
  l.setTextSize(8f);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setValueFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(30f);
  mChart.getAxisRight().setEnabled(false);
}",0.9756956674885524
18414,"@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.9385796545105566
18415,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}",0.990704647676162
18416,"@Override protected void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=getRequiredBottomOffset();
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override protected void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=getRequiredBottomOffset();
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9728485964104924
18417,"@Override protected float getRequiredBaseOffset(){
  return mXAxis.mLabelWidth;
}","@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}",0.7605633802816901
18418,"@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART || mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
        offsetLeft+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART || mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
        offsetLeft+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xlabelheight=mXAxis.mLabelHeight * 2f;
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9693106704438148
18419,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    if (mChart.isCenterTextWordWrapEnabled()) {
      float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
      RectF holeRect=mRectBuffer[0];
      holeRect.left=center.x - innerRadius;
      holeRect.top=center.y - innerRadius;
      holeRect.right=center.x + innerRadius;
      holeRect.bottom=center.y + innerRadius;
      RectF boundingRect=mRectBuffer[1];
      boundingRect.set(holeRect);
      float radiusPercent=mChart.getCenterTextRadiusPercent();
      if (radiusPercent > 0.0) {
        boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
      }
      if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
        mCenterTextLastBounds.set(boundingRect);
        mCenterTextLastValue=centerText;
        mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(mCenterTextLastBounds.width()),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
      }
      float layoutWidth=Utils.getStaticLayoutMaxWidth(mCenterTextLayout), layoutHeight=mCenterTextLayout.getHeight();
      c.save();
      c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
      mCenterTextLayout.draw(c);
      c.restore();
    }
 else {
      String[] lines=centerText.split(""String_Node_Str"");
      float maxlineheight=0f;
      for (      String line : lines) {
        float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
        if (curHeight > maxlineheight)         maxlineheight=curHeight;
      }
      float linespacing=maxlineheight * 0.25f;
      float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
      int cnt=lines.length;
      float y=center.y;
      for (int i=0; i < lines.length; i++) {
        String line=lines[lines.length - i - 1];
        c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
        cnt--;
        y-=linespacing;
      }
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    if (mChart.isCenterTextWordWrapEnabled()) {
      float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
      RectF holeRect=mRectBuffer[0];
      holeRect.left=center.x - innerRadius;
      holeRect.top=center.y - innerRadius;
      holeRect.right=center.x + innerRadius;
      holeRect.bottom=center.y + innerRadius;
      RectF boundingRect=mRectBuffer[1];
      boundingRect.set(holeRect);
      float radiusPercent=mChart.getCenterTextRadiusPercent();
      if (radiusPercent > 0.0) {
        boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
      }
      if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
        mCenterTextLastBounds.set(boundingRect);
        mCenterTextLastValue=centerText;
        mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(mCenterTextLastBounds.width()),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
      }
      float layoutHeight=mCenterTextLayout.getHeight();
      c.save();
      c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
      mCenterTextLayout.draw(c);
      c.restore();
    }
 else {
      String[] lines=centerText.split(""String_Node_Str"");
      float maxlineheight=0f;
      for (      String line : lines) {
        float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
        if (curHeight > maxlineheight)         maxlineheight=curHeight;
      }
      float linespacing=maxlineheight * 0.25f;
      float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
      int cnt=lines.length;
      float y=center.y;
      for (int i=0; i < lines.length; i++) {
        String line=lines[lines.length - i - 1];
        c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
        cnt--;
        y-=linespacing;
      }
    }
  }
}",0.9874188311688312
18420,"/** 
 * Calculates the total number of y-values across all DataSets the ChartData represents.
 * @return
 */
protected void calcYValueCount(List<? extends DataSet<?>> dataSets){
  mYValCount=0;
  if (dataSets == null)   return;
  int count=0;
  for (int i=0; i < dataSets.size(); i++) {
    count+=dataSets.get(i).getEntryCount();
  }
  mYValCount=count;
}","/** 
 * Calculates the total number of y-values across all DataSets the ChartData represents.
 * @return
 */
protected void calcYValueCount(){
  mYValCount=0;
  if (mDataSets == null)   return;
  int count=0;
  for (int i=0; i < mDataSets.size(); i++) {
    count+=mDataSets.get(i).getEntryCount();
  }
  mYValCount=count;
}",0.9352941176470588
18421,"/** 
 * Call this method to let the CartData know that the underlying data has changed.
 */
public void notifyDataChanged(){
  init(mDataSets);
}","/** 
 * Call this method to let the CartData know that the underlying data has changed.
 */
public void notifyDataChanged(){
  init();
}",0.9679715302491104
18422,"/** 
 * calc minimum and maximum y value over all datasets
 */
protected void calcMinMax(List<? extends DataSet<?>> dataSets){
  if (dataSets == null || dataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mYMin=dataSets.get(0).getYMin();
    mYMax=dataSets.get(0).getYMax();
    for (int i=0; i < dataSets.size(); i++) {
      if (dataSets.get(i).getYMin() < mYMin)       mYMin=dataSets.get(i).getYMin();
      if (dataSets.get(i).getYMax() > mYMax)       mYMax=dataSets.get(i).getYMax();
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : dataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : dataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}","/** 
 * calc minimum and maximum y value over all datasets
 */
protected void calcMinMax(){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mYMin=mDataSets.get(0).getYMin();
    mYMax=mDataSets.get(0).getYMax();
    for (int i=0; i < mDataSets.size(); i++) {
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}",0.6168918918918919
18423,"/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(List<? extends DataSet<?>> dataSets){
  isLegal(dataSets);
  calcMinMax(dataSets);
  calcYValueSum(dataSets);
  calcYValueCount(dataSets);
  calcXValAverageLength();
}","/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  isLegal();
  calcMinMax();
  calcYValueSum();
  calcYValueCount();
  calcXValAverageLength();
}",0.7641325536062378
18424,"/** 
 * constructor that takes string array instead of List string
 * @param xVals The values describing the x-axis. Must be at least as longas the highest xIndex in the Entry objects across all DataSets.
 * @param sets the dataset array
 */
public ChartData(String[] xVals,List<T> sets){
  this.mXVals=arrayToList(xVals);
  this.mDataSets=sets;
  init(mDataSets);
}","/** 
 * constructor that takes string array instead of List string
 * @param xVals The values describing the x-axis. Must be at least as longas the highest xIndex in the Entry objects across all DataSets.
 * @param sets the dataset array
 */
public ChartData(String[] xVals,List<T> sets){
  this.mXVals=arrayToList(xVals);
  this.mDataSets=sets;
  init();
}",0.9875518672199172
18425,"/** 
 * Checks if the combination of x-values array and DataSet array is legal or not.
 * @param dataSets
 */
private void isLegal(List<? extends DataSet<?>> dataSets){
  if (dataSets == null)   return;
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getYVals().size() > mXVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","/** 
 * Checks if the combination of x-values array and DataSet array is legal or not.
 */
private void isLegal(){
  if (mDataSets == null)   return;
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > mXVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.8547249647390691
18426,"/** 
 * calculates the sum of all y-values in all datasets
 */
protected void calcYValueSum(List<? extends DataSet<?>> dataSets){
  mYValueSum=0;
  if (dataSets == null)   return;
  for (int i=0; i < dataSets.size(); i++) {
    mYValueSum+=Math.abs(dataSets.get(i).getYValueSum());
  }
}","/** 
 * calculates the sum of all y-values in all datasets
 */
protected void calcYValueSum(){
  mYValueSum=0;
  if (mDataSets == null)   return;
  for (int i=0; i < mDataSets.size(); i++) {
    mYValueSum+=Math.abs(mDataSets.get(i).getYValueSum());
  }
}",0.6605166051660517
18427,"public void setData(BubbleData data){
  mBubbleData=data;
  mDataSets.addAll(data.getDataSets());
  init(data.getDataSets());
}","public void setData(BubbleData data){
  mBubbleData=data;
  mDataSets.addAll(data.getDataSets());
  init();
}",0.923728813559322
18428,"/** 
 * Sets the PieDataSet this data object should represent.
 * @param dataSet
 */
public void setDataSet(PieDataSet dataSet){
  mDataSets.clear();
  mDataSets.add(dataSet);
  init(mDataSets);
}","/** 
 * Sets the PieDataSet this data object should represent.
 * @param dataSet
 */
public void setDataSet(PieDataSet dataSet){
  mDataSets.clear();
  mDataSets.add(dataSet);
  init();
}",0.9765013054830288
18429,"/** 
 * Resets all zooming and dragging and makes the chart fit exactly it's bounds.
 */
public Matrix fitScreen(){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  float[] vals=new float[9];
  save.getValues(vals);
  vals[Matrix.MTRANS_X]=0f;
  vals[Matrix.MTRANS_Y]=0f;
  vals[Matrix.MSCALE_X]=1f;
  vals[Matrix.MSCALE_Y]=1f;
  save.setValues(vals);
  return save;
}","/** 
 * Resets all zooming and dragging and makes the chart fit exactly it's bounds.
 */
public Matrix fitScreen(){
  mMinScaleX=1f;
  mMinScaleY=1f;
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  float[] vals=new float[9];
  save.getValues(vals);
  vals[Matrix.MTRANS_X]=0f;
  vals[Matrix.MTRANS_Y]=0f;
  vals[Matrix.MSCALE_X]=1f;
  vals[Matrix.MSCALE_Y]=1f;
  save.setValues(vals);
  return save;
}",0.9566326530612244
18430,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realtime_linechart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  LineData data=new LineData();
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  xl.setAvoidFirstLastClipping(true);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setAxisMaxValue(120f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realtime_linechart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  LineData data=new LineData();
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  xl.setAvoidFirstLastClipping(true);
  xl.setSpaceBetweenLabels(5);
  xl.setEnabled(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setAxisMaxValue(100f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setStartAtZero(false);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setEnabled(false);
}",0.9566122874002084
18431,"private void addEntry(){
  LineData data=mChart.getData();
  if (data != null) {
    LineDataSet set=data.getDataSetByIndex(0);
    if (set == null) {
      set=createSet();
      data.addDataSet(set);
    }
    data.addXValue(mMonths[data.getXValCount() % 12] + ""String_Node_Str"" + (year + data.getXValCount() / 12));
    data.addEntry(new Entry((float)(Math.random() * 40) + 40f,set.getEntryCount()),0);
    mChart.notifyDataSetChanged();
    mChart.setVisibleXRange(6);
    mChart.moveViewToX(data.getXValCount() - 7);
  }
}","private void addEntry(){
  LineData data=mChart.getData();
  if (data != null) {
    LineDataSet set=data.getDataSetByIndex(0);
    if (set == null) {
      set=createSet();
      data.addDataSet(set);
    }
    data.addXValue(mMonths[data.getXValCount() % 12] + ""String_Node_Str"" + (year + data.getXValCount() / 12));
    data.addEntry(new Entry((float)(Math.random() * 40) + 30f,set.getEntryCount()),0);
    mChart.notifyDataSetChanged();
    mChart.setVisibleXRange(120);
    mChart.moveViewToX(data.getXValCount() - 121);
  }
}",0.9905482041587902
18432,"private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setAxisDependency(AxisDependency.LEFT);
  set.setColor(ColorTemplate.getHoloBlue());
  set.setCircleColor(ColorTemplate.getHoloBlue());
  set.setLineWidth(2f);
  set.setCircleSize(4f);
  set.setFillAlpha(65);
  set.setFillColor(ColorTemplate.getHoloBlue());
  set.setHighLightColor(Color.rgb(244,117,117));
  set.setValueTextColor(Color.WHITE);
  set.setValueTextSize(10f);
  return set;
}","private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setAxisDependency(AxisDependency.LEFT);
  set.setColor(ColorTemplate.getHoloBlue());
  set.setCircleColor(Color.WHITE);
  set.setLineWidth(2f);
  set.setCircleSize(4f);
  set.setFillAlpha(65);
  set.setFillColor(ColorTemplate.getHoloBlue());
  set.setHighLightColor(Color.rgb(244,117,117));
  set.setValueTextColor(Color.WHITE);
  set.setValueTextSize(9f);
  set.setDrawValues(false);
  return set;
}",0.9421319796954316
18433,"/** 
 * Adds a new x-value to the chart data.
 * @param xVal
 */
public void addXValue(String xVal){
  mXVals.add(xVal);
}","/** 
 * Adds a new x-value to the chart data.
 * @param xVal
 */
public void addXValue(String xVal){
  mXValAverageLength=(mXValAverageLength + xVal.length()) / 2f;
  mXVals.add(xVal);
}",0.7922077922077922
18434,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9523510971786834
18435,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.997812613926358
18436,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.9957476966690292
18437,"/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}",0.9969024264326276
18438,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      if (minx < 0)       minx=0;
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9859906604402936
18439,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9981406879454602
18440,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9965075669383004
18441,"@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && (!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.9956709956709956
18442,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.BUBBLE,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.BUBBLE,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9782833505687694
18443,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param entries
 * @return
 */
public float[] generateTransformedValuesBubble(List<? extends Entry> entries,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil((to - from) * phaseX) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=entries.get(j / 2 + from);
    if (e != null) {
      valuePoints[j]=(float)(e.getXIndex() - from) * phaseX + from;
      valuePoints[j + 1]=e.getVal() * phaseY;
    }
  }
  pointValuesToPixel(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param entries
 * @return
 */
public float[] generateTransformedValuesBubble(List<? extends Entry> entries,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil(to - from) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=entries.get(j / 2 + from);
    if (e != null) {
      valuePoints[j]=(float)(e.getXIndex() - from) * phaseX + from;
      valuePoints[j + 1]=e.getVal() * phaseY;
    }
  }
  pointValuesToPixel(valuePoints);
  return valuePoints;
}",0.9916855631141346
18444,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null || (mPathBitmap.getWidth() != (int)mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != (int)mViewPortHandler.getChartHeight())) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.6918918918918919
18445,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != (int)mViewPortHandler.getChartWidth()) || (mDrawBitmap.getHeight() != (int)mViewPortHandler.getChartHeight())) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_8888);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.7228306655433867
18446,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.992399565689468
18447,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.992399565689468
18448,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null || mPathBitmap.getWidth() != mViewPortHandler.getChartWidth() || mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.8875
18449,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || mDrawBitmap.getWidth() != mViewPortHandler.getChartWidth() || mDrawBitmap.getHeight() != mViewPortHandler.getChartHeight()) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.8858695652173914
18450,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9645336836179396
18451,"public boolean isInBoundsRight(float x){
  return mContentRect.right >= x ? true : false;
}","public boolean isInBoundsRight(float x){
  x=(float)((int)(x * 100.f)) / 100.f;
  return mContentRect.right >= x ? true : false;
}",0.8235294117647058
18452,"public boolean isInBoundsBottom(float y){
  return mContentRect.bottom >= y ? true : false;
}","public boolean isInBoundsBottom(float y){
  y=(float)((int)(y * 100.f)) / 100.f;
  return mContentRect.bottom >= y ? true : false;
}",0.8266666666666667
18453,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  set1.setDrawFilled(true);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}",0.984036488027366
18454,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 4) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get((entries.size() > 2) ? 2 : 1);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9863665187064046
18455,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get((entries.size() > 2) ? 2 : 1);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9945269741985928
18456,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius && mAnimator.getPhaseX() >= 1f && mAnimator.getPhaseY() >= 1f) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}",0.9616336633663366
18457,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}",0.9977924944812362
18458,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9808008776741636
18459,"/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}","/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}",0.98567335243553
18460,"/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}","/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}",0.9871134020618556
18461,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9738313576381122
18462,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.9938375350140056
18463,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9959970887918488
18464,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{0,low,mChart.getXChartMax(),low,0,high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}",0.9793427230046948
18465,public abstract void initBuffers();,"/** 
 * Initializes the buffers used for rendering with a new size. Since this method performs memory allocations, it should only be called if necessary.
 */
public abstract void initBuffers();",0.3070175438596491
18466,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}",0.9905090595340812
18467,"protected void drawDataSet(Canvas c,LineDataSet dataSet){
  List<Entry> entries=dataSet.getYVals();
  if (entries.size() < 1)   return;
  calcXBounds(mChart.getTransformer(dataSet.getAxisDependency()));
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
  if (dataSet.isDrawCubicEnabled()) {
    drawCubic(c,dataSet,entries);
  }
 else {
    drawLinear(c,dataSet,entries);
  }
  mRenderPaint.setPathEffect(null);
}","protected void drawDataSet(Canvas c,LineDataSet dataSet){
  List<Entry> entries=dataSet.getYVals();
  if (entries.size() < 1)   return;
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
  if (dataSet.isDrawCubicEnabled()) {
    drawCubic(c,dataSet,entries);
  }
 else {
    drawLinear(c,dataSet,entries);
  }
  mRenderPaint.setPathEffect(null);
}",0.9244644870349492
18468,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9847222222222224
18469,"/** 
 * Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
 * @param trans
 */
protected void calcXBounds(Transformer trans){
  double minx=trans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),0).x;
  double maxx=trans.getValuesByTouchPoint(mViewPortHandler.contentRight(),0).x;
  if (!Double.isInfinite(minx))   mMinX=(int)minx;
  if (!Double.isInfinite(maxx))   mMaxX=(int)Math.ceil(maxx);
}","/** 
 * Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
 * @param chart
 * @param modulus
 */
public void calcXBounds(BarLineScatterCandleDataProvider chart,int xAxisModulus){
  int low=chart.getLowestVisibleXIndex();
  int high=chart.getHighestVisibleXIndex();
  int subLow=(low % xAxisModulus == 0) ? xAxisModulus : 0;
  mMinX=Math.max((low / xAxisModulus) * (xAxisModulus) - subLow,0);
  mMaxX=Math.min((high / xAxisModulus) * (xAxisModulus) + xAxisModulus,(int)chart.getXChartMax());
}",0.3410230692076229
18470,"protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}","protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}",0.9959588537839824
18471,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx >= mXAxis.getValues().size())   maxx=mXAxis.getValues().size() - 1;
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisLabelPaint);
    }
  }
}",0.9128953771289536
18472,"@Override public void renderAxisLine(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}","@Override public void renderAxisLine(Canvas c){
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}",0.9870276367738297
18473,"@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal());
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal() * phaseY);
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8521462639109698
18474,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f)   maxLeft=maxLeft + 1f;
  if (rightRange == 0f)   maxRight=maxRight + 1f;
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.956083916083916
18475,"/** 
 * Sets the one and ONLY color that should be used for this DataSet when open <= close. Internally, this recreates the colors array and adds the specified color.
 * @param color
 */
public void setIncreasingColor(int color){
  mIncreasingColor=color;
}","/** 
 * Sets the one and ONLY color that should be used for this DataSet when open <= close. 
 * @param color
 */
public void setIncreasingColor(int color){
  mIncreasingColor=color;
}",0.8344671201814059
18476,"/** 
 * Sets the one and ONLY color that should be used for this DataSet when open > close. Internally, this recreates the colors array and adds the specified color.
 * @param color
 */
public void setDecreasingColor(int color){
  mDecreasingColor=color;
}","/** 
 * Sets the one and ONLY color that should be used for this DataSet when open > close. 
 * @param color
 */
public void setDecreasingColor(int color){
  mDecreasingColor=color;
}",0.8337129840546698
18477,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setHoleColorTransparent(true);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setCenterText(""String_Node_Str"");
  setData(3,100);
  mChart.animateXY(1500,1500,EasingFunction.EaseInOutQuad,EasingFunction.EaseInOutQuad);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColorTransparent(true);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setCenterText(""String_Node_Str"");
  setData(3,100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.8517850703209521
18478,"private void setData(int count,float range){
  float mult=range;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count + 1; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 5,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count + 1; i++)   xVals.add(mParties[i % mParties.length]);
  PieDataSet dataSet=new PieDataSet(yVals1,""String_Node_Str"");
  dataSet.setSliceSpace(3f);
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (  int c : ColorTemplate.VORDIPLOM_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.JOYFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.COLORFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.LIBERTY_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.PASTEL_COLORS)   colors.add(c);
  colors.add(ColorTemplate.getHoloBlue());
  dataSet.setColors(colors);
  PieData data=new PieData(xVals,dataSet);
  data.setValueFormatter(new PercentFormatter());
  data.setValueTextSize(11f);
  data.setValueTextColor(Color.WHITE);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}","private void setData(int count,float range){
  float mult=range;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count + 1; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 5,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count + 1; i++)   xVals.add(mParties[i % mParties.length]);
  PieDataSet dataSet=new PieDataSet(yVals1,""String_Node_Str"");
  dataSet.setSliceSpace(3f);
  dataSet.setSelectionShift(5f);
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (  int c : ColorTemplate.VORDIPLOM_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.JOYFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.COLORFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.LIBERTY_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.PASTEL_COLORS)   colors.add(c);
  colors.add(ColorTemplate.getHoloBlue());
  dataSet.setColors(colors);
  PieData data=new PieData(xVals,dataSet);
  data.setValueFormatter(new PercentFormatter());
  data.setValueTextSize(11f);
  data.setValueTextColor(Color.WHITE);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}",0.986081822016027
18479,"/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(null);
  }
}","/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    ((PieChartRenderer)mRenderer).getPaintHole().setColor(0xFFFFFFFF);
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
  }
 else {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(null);
  }
}",0.908489525909592
18480,"public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mCenterTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}","public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mCenterTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}",0.8556390977443609
18481,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || ((int)mViewPortHandler.getChartHeight() != mDrawBitmap.getHeight())) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_8888);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.8753738783649053
18482,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}",0.7226666666666667
18483,"@Override public void drawExtras(Canvas c){
  drawHole(c);
  drawCenterText(c);
}","@Override public void drawExtras(Canvas c){
  drawHole(c);
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
  drawCenterText(c);
}",0.7788461538461539
18484,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      float lineHeight=Utils.calcTextHeight(mValuePaint,val) + Utils.convertDpToPixel(4f);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y + lineHeight / 2f,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9410618606916707
18485,"@Override public void feed(List<CandleEntry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    CandleEntry e=entries.get(i);
    addBody(e.getXIndex() - 0.5f + mBodySpace,e.getClose() * phaseY,e.getXIndex() + 0.5f - mBodySpace,e.getOpen() * phaseY);
  }
  reset();
}","@Override public void feed(List<CandleEntry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    CandleEntry e=entries.get(i);
    addBody(e.getXIndex() - 0.5f + mBodySpace,e.getClose() * phaseY,e.getXIndex() + 0.5f - mBodySpace,e.getOpen() * phaseY);
  }
  reset();
}",0.8070175438596491
18486,"@Override public void feed(List<CandleEntry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    CandleEntry e=entries.get(i);
    addShadow(e.getXIndex(),e.getHigh() * phaseY,e.getXIndex(),e.getLow() * phaseY);
  }
  reset();
}","@Override public void feed(List<CandleEntry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    CandleEntry e=entries.get(i);
    addShadow(e.getXIndex(),e.getHigh() * phaseY,e.getXIndex(),e.getLow() * phaseY);
  }
  reset();
}",0.7787934186471663
18487,"@Override public void feed(List<Entry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    Entry e=entries.get(i);
    addCircle(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    Entry e=entries.get(i);
    addCircle(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8653421633554084
18488,"@Override public void feed(List<Entry> entries){
  moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
  float size=entries.size() * phaseX;
  for (int i=1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal());
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8713550600343053
18489,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  int range=(mMaxX - mMinX + 1) * 4;
  int from=mMinX * 4;
  int to=mMaxX + 1;
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,from,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < bodyBuffer.size(); j+=4) {
    CandleEntry e=entries.get(j / 4);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int from=minx * 4;
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.884438881935753
18490,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseY());
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.8809710258418167
18491,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
  for (  LineDataSet set : sets) {
    if (set.isDrawFilledEnabled())     set.setDrawFilled(false);
 else     set.setDrawFilled(true);
  }
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
  if (set.isDrawCirclesEnabled())   set.setDrawCircles(false);
 else   set.setDrawCircles(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleCubic:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
if (set.isDrawCubicEnabled()) set.setDrawCubic(false);
 else set.setDrawCubic(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.actionTogglePinch:
{
if (mChart.isPinchZoomEnabled()) mChart.setPinchZoom(false);
 else mChart.setPinchZoom(true);
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,35);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
  for (  LineDataSet set : sets) {
    if (set.isDrawFilledEnabled())     set.setDrawFilled(false);
 else     set.setDrawFilled(true);
  }
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
  if (set.isDrawCirclesEnabled())   set.setDrawCircles(false);
 else   set.setDrawCircles(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleCubic:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
if (set.isDrawCubicEnabled()) set.setDrawCubic(false);
 else set.setDrawCubic(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.actionTogglePinch:
{
if (mChart.isPinchZoomEnabled()) mChart.setPinchZoom(false);
 else mChart.setPinchZoom(true);
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000,EasingFunction.EaseInCubic);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,35);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.9949008498583568
18492,"/** 
 * limits the drawing on the x-axis 
 */
public void limitFrom(int from){
  mFrom=from;
}","/** 
 * limits the drawing on the x-axis 
 */
public void limitFrom(int from){
  if (from < 0)   from=0;
  mFrom=from;
}",0.8785046728971962
18493,"/** 
 * limits the drawing on the x-axis 
 */
public void limitTo(int to){
  mTo=to;
}","/** 
 * limits the drawing on the x-axis 
 */
public void limitTo(int to){
  if (to < 0)   to=0;
  mTo=to;
}",0.8865979381443299
18494,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      if (minx < 0)       minx=0;
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9886135298057602
18495,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3 + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}",0.997489014438167
18496,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    if (mDrawBitmap != null)     mDrawBitmap.recycle();
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.948339483394834
18497,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9979296066252588
18498,"protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}","protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}",0.9970642201834864
18499,"/** 
 * Moves the left side of the current viewport to the specified x-index.
 * @param xIndex
 */
public void moveViewToX(int xIndex){
  float[] pts=new float[]{xIndex,0f};
  getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * Moves the left side of the current viewport to the specified x-index.
 * @param xIndex
 */
public void moveViewToX(float xIndex){
  Runnable job=new MoveViewJob(mViewPortHandler,xIndex,0f,getTransformer(AxisDependency.LEFT),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.6353322528363047
18500,"/** 
 * Centers the viewport to the specified y-value on the y-axis.
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewToY(float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  float[] pts=new float[]{0f,yValue + valsInView / 2f};
  getTransformer(axis).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * Centers the viewport to the specified y-value on the y-axis.
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewToY(float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  Runnable job=new MoveViewJob(mViewPortHandler,0f,yValue + valsInView / 2f,getTransformer(axis),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.6537216828478964
18501,"/** 
 * This will move the left side of the current viewport to the specified x-index on the x-axis, and center the viewport to the specified y-value on the y-axis.
 * @param xIndex
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewTo(int xIndex,float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  float[] pts=new float[]{xIndex,yValue + valsInView / 2f};
  getTransformer(axis).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * This will move the left side of the current viewport to the specified x-index on the x-axis, and center the viewport to the specified y-value on the y-axis.
 * @param xIndex
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewTo(float xIndex,float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  Runnable job=new MoveViewJob(mViewPortHandler,xIndex,yValue + valsInView / 2f,getTransformer(axis),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.7675401521555367
18502,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.9213011542497376
18503,"/** 
 * Centers the viewport around the specified position (x-index and y-value) in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method.
 * @param pts the position to center view viewport to
 * @param chart
 * @return save
 */
public synchronized void centerViewPort(final float[] transformedPts,final Chart<?> chart){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  final float x=transformedPts[0] - offsetLeft();
  final float y=transformedPts[1] - offsetTop();
  save.postTranslate(-x,-y);
  refresh(save,chart,false);
}","/** 
 * Centers the viewport around the specified position (x-index and y-value) in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method.
 * @param pts the position to center view viewport to
 * @param chart
 * @return save
 */
public synchronized void centerViewPort(final float[] transformedPts,final View view){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  final float x=transformedPts[0] - offsetLeft();
  final float y=transformedPts[1] - offsetTop();
  Log.i(""String_Node_Str"",""String_Node_Str"" + x + ""String_Node_Str""+ y);
  save.postTranslate(-x,-y);
  refresh(save,view,false);
}",0.9208741522230596
18504,"/** 
 * call this method to refresh the graph with a given matrix
 * @param newMatrix
 * @return
 */
public Matrix refresh(Matrix newMatrix,Chart<?> chart,boolean invalidate){
  mMatrixTouch.set(newMatrix);
  limitTransAndScale(mMatrixTouch,mContentRect);
  chart.invalidate();
  newMatrix.set(mMatrixTouch);
  return newMatrix;
}","/** 
 * call this method to refresh the graph with a given matrix
 * @param newMatrix
 * @return
 */
public Matrix refresh(Matrix newMatrix,View chart,boolean invalidate){
  mMatrixTouch.set(newMatrix);
  limitTransAndScale(mMatrixTouch,mContentRect);
  chart.invalidate();
  newMatrix.set(mMatrixTouch);
  return newMatrix;
}",0.9817073170731708
18505,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generatePieData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(tf);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setCenterTextTypeface(tf);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  mChart.setData(generatePieData());
  return v;
}",0.8744460856720827
18506,"/** 
 * generates less data (1 DataSet, 4 values)
 * @return
 */
protected PieData generatePieData(){
  int count=4;
  ArrayList<Entry> entries1=new ArrayList<Entry>();
  ArrayList<String> xVals=new ArrayList<String>();
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  for (int i=0; i < count; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
    entries1.add(new Entry((float)(Math.random() * 60) + 40,i));
  }
  PieDataSet ds1=new PieDataSet(entries1,""String_Node_Str"");
  ds1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  ds1.setSliceSpace(2f);
  PieData d=new PieData(xVals,ds1);
  d.setValueTypeface(tf);
  return d;
}","/** 
 * generates less data (1 DataSet, 4 values)
 * @return
 */
protected PieData generatePieData(){
  int count=4;
  ArrayList<Entry> entries1=new ArrayList<Entry>();
  ArrayList<String> xVals=new ArrayList<String>();
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  for (int i=0; i < count; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
    entries1.add(new Entry((float)(Math.random() * 60) + 40,i));
  }
  PieDataSet ds1=new PieDataSet(entries1,""String_Node_Str"");
  ds1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  ds1.setSliceSpace(2f);
  ds1.setValueTextColor(Color.WHITE);
  ds1.setValueTextSize(12f);
  PieData d=new PieData(xVals,ds1);
  d.setValueTypeface(tf);
  return d;
}",0.9546377792823292
18507,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    String[] lines=centerText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]);
    float linespacing=lineHeight * 0.2f;
    float totalheight=lineHeight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=center.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      c.drawText(line,center.x,y + lineHeight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    String[] lines=centerText.split(""String_Node_Str"");
    float maxlineheight=0f;
    for (    String line : lines) {
      float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
      if (curHeight > maxlineheight)       maxlineheight=curHeight;
    }
    float linespacing=maxlineheight * 0.25f;
    float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=center.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}",0.8310401761144744
18508,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData data=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  data.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  data.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(data);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData data=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  data.setValueTypeface(mTf);
  data.setValueTextColor(Color.BLACK);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(data);
  holder.chart.animateY(700);
  return convertView;
}",0.9647058823529412
18509,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null || data.getYValCount() <= 0) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9763912310286678
18510,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  List<String> labels=new ArrayList<String>();
  List<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < data.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
    List<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      List<String> xVals=data.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=data.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  mLegend.setColors(colors);
  mLegend.setLabels(labels);
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  List<String> labels=new ArrayList<String>();
  List<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < data.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
    List<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      List<String> xVals=data.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=data.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  mLegend.setColors(colors);
  mLegend.setLabels(labels);
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint);
}",0.994778785380599
18511,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  List<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    limitLinePath.moveTo(pts[0],pts[1]);
    limitLinePath.lineTo(pts[2],pts[3]);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  List<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[2];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setStyle(Paint.Style.STROKE);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    pts[1]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    limitLinePath.moveTo(mViewPortHandler.contentLeft(),pts[1]);
    limitLinePath.lineTo(mViewPortHandler.contentRight(),pts[1]);
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.8050058207217695
18512,"public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisLabelPaint.setColor(Color.BLACK);
  mAxisLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
}","public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisLabelPaint.setColor(Color.BLACK);
  mAxisLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}",0.9869375907111756
18513,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  rightAxis.setSpaceTop(15f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  rightAxis.setSpaceTop(15f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}",0.9980732177263968
18514,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(mTf);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count - 1; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  yVals1.add(new BarEntry(-20f,count - 1));
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(mTf);
  mChart.setData(data);
}",0.965665236051502
18515,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float all=e.getVal();
      for (int k=0; k < vals.length; k++) {
        all-=vals[k];
        y=vals[k] + all;
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (mInverted) {
      if (!mContainsStacks || vals == null) {
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom=y >= 0 ? y : 0;
        float top=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
 else {
        float all=e.getVal();
        for (int k=0; k < vals.length; k++) {
          all-=vals[k];
          y=vals[k] + all;
          float left=x - barWidth + barSpaceHalf;
          float right=x + barWidth - barSpaceHalf;
          float bottom=y >= 0 ? y : 0;
          float top=y <= 0 ? y : 0;
          if (top > 0)           top*=phaseY;
 else           bottom*=phaseY;
          addBar(left,top,right,bottom);
        }
      }
    }
 else {
      if (!mContainsStacks || vals == null) {
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
 else {
        float all=e.getVal();
        for (int k=0; k < vals.length; k++) {
          all-=vals[k];
          y=vals[k] + all;
          float left=x - barWidth + barSpaceHalf;
          float right=x + barWidth - barSpaceHalf;
          float top=y >= 0 ? y : 0;
          float bottom=y <= 0 ? y : 0;
          if (top > 0)           top*=phaseY;
 else           bottom*=phaseY;
          addBar(left,top,right,bottom);
        }
      }
    }
  }
  reset();
}",0.7015931372549019
18516,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9955290611028316
18517,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.9801249290176036
18518,"/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspace,float from,Transformer trans){
  float barWidth=0.5f;
  float spaceHalf=barspace / 2f;
  float left=x - barWidth + spaceHalf;
  float right=x + barWidth - spaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}",0.8879082082965578
18519,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,set.getBarSpace(),from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9781232009211284
18520,"@Override protected void prepareBarHighlight(float x,float y,float barspace,float from,Transformer trans){
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= from ? y : from;
  float right=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","@Override protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float top=x - 0.5f + barspaceHalf;
  float bottom=x + 0.5f - barspaceHalf;
  float left=y >= from ? y : from;
  float right=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixelHorizontal(mBarRect,mAnimator.getPhaseY());
}",0.92904953145917
18521,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled()) {
        yMin=(float)Math.min(p1.y,p2.y);
      }
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      yMin=(float)p1.y;
      yMax=(float)p2.y;
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8326797385620915
18522,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),mViewPortHandler.contentTop());
    if (!mYAxis.isInverted()) {
      yMin=(float)p1.x;
      yMax=(float)p2.x;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.x,p2.x);
 else       yMin=0;
      yMax=(float)Math.max(p1.x,p2.x);
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),mViewPortHandler.contentTop());
    if (!mYAxis.isInverted()) {
      yMin=(float)p1.x;
      yMax=(float)p2.x;
    }
 else {
      yMin=(float)p2.x;
      yMax=(float)p1.x;
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8403693931398417
18523,"@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
}","@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet || mData == null || mData.getYValCount() <= 0) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
}",0.9542743538767396
18524,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null || data.getYValCount() <= 0) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9763912310286678
18525,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}",0.9187547456340168
18526,"@Override public void run(){
  mViewPortHandler.restrainViewPort(left,top,right,bottom);
}","@Override public void run(){
  mViewPortHandler.restrainViewPort(left,top,right,bottom);
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.7792207792207793
18527,"/** 
 * Sets custom offsets for the current ViewPort (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use resetViewPortOffsets() to undo this.
 * @param left
 * @param top
 * @param right
 * @param bottom
 */
public void setViewPortOffsets(final float left,final float top,final float right,final float bottom){
  mCustomViewPortEnabled=true;
  post(new Runnable(){
    @Override public void run(){
      mViewPortHandler.restrainViewPort(left,top,right,bottom);
    }
  }
);
}","/** 
 * Sets custom offsets for the current ViewPort (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use resetViewPortOffsets() to undo this.
 * @param left
 * @param top
 * @param right
 * @param bottom
 */
public void setViewPortOffsets(final float left,final float top,final float right,final float bottom){
  mCustomViewPortEnabled=true;
  post(new Runnable(){
    @Override public void run(){
      mViewPortHandler.restrainViewPort(left,top,right,bottom);
      prepareOffsetMatrix();
      prepareValuePxMatrix();
    }
  }
);
}",0.9502948609941028
18528,"/** 
 * Sets the size of the area (range on the x-axis) that should be maximum visible at once. If this is e.g. set to 10, no more than 10 values on the x-axis can be viewed at once without scrolling.
 * @param xRange
 */
public void setVisibleXRange(float xRange){
  float xScale=mDeltaX / (xRange + 0.01f);
  mViewPortHandler.setMinimumScaleX(xScale);
}","/** 
 * Sets the size of the area (range on the x-axis) that should be maximum visible at once. If this is e.g. set to 10, no more than 10 values on the x-axis can be viewed at once without scrolling.
 * @param xRange
 */
public void setVisibleXRange(float xRange){
  float xScale=mDeltaX / (xRange);
  mViewPortHandler.setMinimumScaleX(xScale);
}",0.9886039886039886
18529,"/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float xChartMin,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.getChartWidth() - mViewPortHandler.offsetRight() - mViewPortHandler.offsetLeft()) / deltaX);
  float scaleY=(float)((mViewPortHandler.getChartHeight() - mViewPortHandler.offsetTop() - mViewPortHandler.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(-xChartMin,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}","/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float xChartMin,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.contentWidth()) / deltaX);
  float scaleY=(float)((mViewPortHandler.contentHeight()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(-xChartMin,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}",0.8534031413612565
18530,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  yl.setInverted(true);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setInverted(true);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9851668726823238
18531,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9685916919959472
18532,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}",0.8975526465566306
18533,"/** 
 * callback when a DataSet has been drawn (when lifting the finger) 
 */
@Override public void onDrawFinished(DataSet<?> dataSet){
  Log.i(Chart.LOG_TAG,""String_Node_Str"" + dataSet.toSimpleString());
  mChart.getLegendRenderer().computeLegend(mChart.getData(),mChart.getLegend());
}","/** 
 * callback when a DataSet has been drawn (when lifting the finger) 
 */
@Override public void onDrawFinished(DataSet<?> dataSet){
  Log.i(Chart.LOG_TAG,""String_Node_Str"" + dataSet.toSimpleString());
  mChart.getLegendRenderer().computeLegend(mChart.getData());
}",0.9657657657657658
18534,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  if (mAxisLeft.needsDefaultFormatter())   mAxisLeft.setValueFormatter(mDefaultFormatter);
  if (mAxisRight.needsDefaultFormatter())   mAxisRight.setValueFormatter(mDefaultFormatter);
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  if (mAxisLeft.needsDefaultFormatter())   mAxisLeft.setValueFormatter(mDefaultFormatter);
  if (mAxisRight.needsDefaultFormatter())   mAxisRight.setValueFormatter(mDefaultFormatter);
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9896907216494846
18535,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.99761620977354
18536,"/** 
 * initialize all paints and stuff
 */
protected void init(){
  setWillNotDraw(false);
  if (android.os.Build.VERSION.SDK_INT < 11)   mAnimator=new ChartAnimator();
 else   mAnimator=new ChartAnimator(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  Utils.init(getContext().getResources());
  mDefaultFormatter=new DefaultValueFormatter(1);
  mViewPortHandler=new ViewPortHandler();
  mLegend=new Legend();
  mLegendRenderer=new LegendRenderer(mViewPortHandler);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mDrawPaint=new Paint(Paint.DITHER_FLAG);
  if (mLogEnabled)   Log.i(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * initialize all paints and stuff
 */
protected void init(){
  setWillNotDraw(false);
  if (android.os.Build.VERSION.SDK_INT < 11)   mAnimator=new ChartAnimator();
 else   mAnimator=new ChartAnimator(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  Utils.init(getContext().getResources());
  mDefaultFormatter=new DefaultValueFormatter(1);
  mViewPortHandler=new ViewPortHandler();
  mLegend=new Legend();
  mLegendRenderer=new LegendRenderer(mViewPortHandler,mLegend);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mDrawPaint=new Paint(Paint.DITHER_FLAG);
  if (mLogEnabled)   Log.i(""String_Node_Str"",""String_Node_Str"");
}",0.9964507542147294
18537,"/** 
 * Returns the Legend object of the chart. This method can be used to customize the automatically generated Legend. IMPORTANT: Since the Legend is generated from data provided by the user (via setData(...) method), this will return NULL if no data has been set for the chart. You need to set data for the chart before calling this method.
 * @return
 */
public Legend getLegend(){
  return mLegend;
}","/** 
 * Returns the Legend object of the chart. This method can be used to get an instance of the legend in order to customize the automatically generated Legend.
 * @return
 */
public Legend getLegend(){
  return mLegend;
}",0.5786963434022258
18538,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawDescription(canvas);
}",0.9892761394101875
18539,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9506172839506172
18540,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(canvas);
  if (mDrawWeb)   mRenderer.drawExtras(canvas);
  mYAxisRenderer.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
  drawMarkers(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(canvas);
  if (mDrawWeb)   mRenderer.drawExtras(canvas);
  mYAxisRenderer.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawDescription(canvas);
  drawMarkers(canvas);
}",0.9926062846580408
18541,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9255583126550868
18542,"/** 
 * draws the description text in the bottom right corner of the chart
 */
protected void drawDescription(Canvas c){
  c.drawText(mDescription,getWidth() - mViewPortHandler.offsetRight() - 10,getHeight() - mViewPortHandler.offsetBottom() - 10,mDescPaint);
}","/** 
 * draws the description text in the bottom right corner of the chart
 */
protected void drawDescription(Canvas c){
  if (!mDescription.equals(""String_Node_Str"")) {
    c.drawText(mDescription,getWidth() - mViewPortHandler.offsetRight() - 10,getHeight() - mViewPortHandler.offsetBottom() - 10,mDescPaint);
  }
}",0.9046793760831888
18543,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=5; i < count - 5; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9965792474344356
18544,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(Color.WHITE);
  set1.setLineWidth(2f);
  set1.setCircleSize(3f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setDrawCircleHole(false);
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.WHITE);
  set2.setLineWidth(2f);
  set2.setCircleSize(3f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setDrawCircleHole(false);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}",0.7393822393822393
18545,"public LineBuffer(int size){
  super(size);
}","public LineBuffer(int size){
  super((size < 4) ? 4 : size);
}",0.8411214953271028
18546,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.9514767932489452
18547,"protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}",0.9437837837837838
18548,"@Override public void initBuffers(){
  LineData lineData=mChart.getLineData();
  mLineBuffers=new LineBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mLineBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    int size=lineData.getXValCount() * 4 - 4;
    if (size < 4)     size=4;
    mLineBuffers[i]=new LineBuffer(size);
  }
  mCircleBuffers=new CircleBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mCircleBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    mCircleBuffers[i]=new CircleBuffer(set.getEntryCount() * 2);
  }
}","@Override public void initBuffers(){
  LineData lineData=mChart.getLineData();
  mLineBuffers=new LineBuffer[lineData.getDataSetCount()];
  mCircleBuffers=new CircleBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mLineBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    mLineBuffers[i]=new LineBuffer(set.getEntryCount() * 4 - 4);
    mCircleBuffers[i]=new CircleBuffer(set.getEntryCount() * 2);
  }
}",0.5447470817120622
18549,"protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9189366590088612
18550,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9270833333333334
18551,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx >= mXAxis.getValues().size())   maxx=mXAxis.getValues().size() - 1;
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.9976841130152848
18552,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=5; i < count - 5; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9965792474344356
18553,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=10; i < count - 10; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9979946524064172
18554,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawData(canvas);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}",0.920424403183024
18555,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))     continue;
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))     break;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.7687411598302687
18556,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mPathCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.9888888888888888
18557,"protected void drawCubicFill(Canvas c,LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  spline.lineTo(entryTo.getXIndex(),fillMin);
  spline.lineTo(entryFrom.getXIndex(),fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mPathCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawCubicFill(Canvas c,LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX + 1);
  spline.lineTo(entryTo.getXIndex(),fillMin);
  spline.lineTo(entryFrom.getXIndex(),fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.9901547116736992
18558,"protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mPathCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mPathCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9968866749688668
18559,"@Override public void drawData(Canvas c){
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.4166666666666667
18560,"protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  int cnt=0;
  ArrayList<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[cnt];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        c.drawArc(mChart.getCircleBox(),angle + sliceSpace / 2f,newangle * mAnimator.getPhaseY() - sliceSpace / 2f,true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
    cnt++;
  }
}","protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  int cnt=0;
  ArrayList<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[cnt];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),angle + sliceSpace / 2f,newangle * mAnimator.getPhaseY() - sliceSpace / 2f,true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
    cnt++;
  }
}",0.9908376963350786
18561,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    c.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      c.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}",0.980309423347398
18562,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 2f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  ArrayList<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  ArrayList<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9994946942900454
18563,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    c.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}",0.9934024505183788
18564,"public YAxisRendererHorizontalBarChart(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,yAxis,trans);
}","public YAxisRendererHorizontalBarChart(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,yAxis,trans);
  mLimitLinePaint.setTextAlign(Align.LEFT);
}",0.8658536585365854
18565,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9230313795145056
18566,"public boolean isUsePercentValuesEnabled(){
  return mUsePercentValues;
}","/** 
 * Returns true if using percentage values is enabled for the chart.
 * @return
 */
public boolean isUsePercentValuesEnabled(){
  return mUsePercentValues;
}",0.6212765957446809
18567,"/** 
 * Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values. Returns true if a DataSet was removed, false if no DataSet could be removed.
 * @param index
 */
public boolean removeDataSet(int index){
  if (mDataSets == null || index >= mDataSets.size() || index < 0)   return false;
  T set=mDataSets.get(index);
  return removeDataSet(set);
}","/** 
 * Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values. Returns true if a DataSet was removed, false if no DataSet could be removed.
 * @param index
 */
public boolean removeDataSet(int index){
  if (index >= mDataSets.size() || index < 0)   return false;
  T set=mDataSets.get(index);
  return removeDataSet(set);
}",0.9159561510353228
18568,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param entry
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    if (mDataSets == null)     mDataSets=new ArrayList<T>();
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      handleEmptyAxis(getFirstLeft(),getFirstRight());
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param entry
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      handleEmptyAxis(getFirstLeft(),getFirstRight());
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.9432692307692307
18569,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
  if (d.getAxisDependency() == AxisDependency.LEFT) {
    if (mLeftAxisMax < d.getYMax())     mLeftAxisMax=d.getYMax();
    if (mLeftAxisMin > d.getYMin())     mLeftAxisMin=d.getYMin();
  }
 else {
    if (mRightAxisMax < d.getYMax())     mRightAxisMax=d.getYMax();
    if (mRightAxisMin > d.getYMin())     mRightAxisMin=d.getYMin();
  }
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}",0.6278392545136867
18570,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return super.onSingleTapUp(e);
}","@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  performHighlight(e);
  return super.onSingleTapUp(e);
}",0.5449189985272459
18571,"@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.9672650475184794
18572,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  drawCircles(c);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.982213438735178
18573,"@Override public void drawExtras(Canvas c){
}","@Override public void drawExtras(Canvas c){
  drawCircles(c);
}",0.8333333333333334
18574,"@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}",0.9817893903404592
18575,"@Override public void renderAxisLine(Canvas c){
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}","@Override public void renderAxisLine(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}",0.9870276367738297
18576,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartGestureListener(this);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9782833505687694
18577,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  performHighlight(e);
  return super.onSingleTapUp(e);
}","@Override public boolean onSingleTapUp(MotionEvent e){
  performHighlight(e);
  return super.onSingleTapUp(e);
}",0.6588235294117647
18578,"@Override public boolean onSingleTapConfirmed(MotionEvent e){
  return super.onSingleTapConfirmed(e);
}","@Override public boolean onSingleTapConfirmed(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  return super.onSingleTapConfirmed(e);
}",0.5527950310559007
18579,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE,DrawOrder.CANDLE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9905817174515236
18580,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  drawCircles(c);
}",0.982213438735178
18581,"@Override public void drawExtras(Canvas c){
  drawCircles(c);
}","@Override public void drawExtras(Canvas c){
}",0.8333333333333334
18582,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.946969696969697
18583,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=10; i < count - 10; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9979946524064172
18584,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(false);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(true);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}",0.9951757408683668
18585,"/** 
 * Set this to true to enable scaling (zooming in and out by gesture) for the chart (this does not effect dragging).
 * @param enabled
 */
public void setScaleEnabled(boolean enabled){
  this.mScaleEnabled=enabled;
}","/** 
 * Set this to true to enable scaling (zooming in and out by gesture) for the chart (this does not effect dragging) on both X- and Y-Axis.
 * @param enabled
 */
public void setScaleEnabled(boolean enabled){
  this.mScaleXEnabled=enabled;
  this.mScaleYEnabled=enabled;
}",0.8911290322580645
18586,"/** 
 * Setting this to true will set the layer-type HARDWARE for the view, false will set layer-type SOFTWARE.
 * @param enabled
 */
public void setHardwareAccelerationEnabled(boolean enabled){
  if (enabled)   setLayerType(View.LAYER_TYPE_HARDWARE,null);
 else   setLayerType(View.LAYER_TYPE_SOFTWARE,null);
}","/** 
 * Setting this to true will set the layer-type HARDWARE for the view, false will set layer-type SOFTWARE.
 * @param enabled
 */
public void setHardwareAccelerationEnabled(boolean enabled){
  if (android.os.Build.VERSION.SDK_INT >= 11) {
    if (enabled)     setLayerType(View.LAYER_TYPE_HARDWARE,null);
 else     setLayerType(View.LAYER_TYPE_SOFTWARE,null);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"");
  }
}",0.8301369863013699
18587,"/** 
 * If set to true, the linechart lines are drawn in cubic-style instead of linear. Default: false
 * @param enabled
 */
public void setDrawCubic(boolean enabled){
  mDrawCubic=enabled;
}","/** 
 * If set to true, the linechart lines are drawn in cubic-style instead of linear. This affects performance! Default: false
 * @param enabled
 */
public void setDrawCubic(boolean enabled){
  mDrawCubic=enabled;
}",0.9362745098039216
18588,"/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give up to 20% performance boost on large datasets, default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}","/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give great performance boost! default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}",0.9296875
18589,"/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        float scale=totalDist / mSavedDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scale,scale,t.x,t.y);
      }
 else       if (mTouchMode == X_ZOOM) {
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scaleX,1f,t.x,t.y);
      }
 else       if (mTouchMode == Y_ZOOM) {
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
      }
    }
  }
}","/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        float scale=totalDist / mSavedDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale((mChart.isScaleXEnabled()) ? scale : 1f,(mChart.isScaleYEnabled()) ? scale : 1f,t.x,t.y);
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scaleX,1f,t.x,t.y);
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
      }
    }
  }
}",0.9253886010362694
18590,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}",0.9762565525747764
18591,"protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size() - 3; j+=2) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 2));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    int from=mMinX * 4;
    int range=(mMaxX * 4 - mMinX) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}","protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}",0.9195751138088012
18592,"protected void drawLinearFill(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries,Transformer trans){
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  Path filled=generateFilledPath(entries,mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin()),mMinX,mMaxX + 1);
  trans.pathValueToPixel(filled);
  c.drawPath(filled,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawLinearFill(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries,Transformer trans){
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX - 2);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX + 2);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=dataSet.getEntryPosition(entryTo);
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  Path filled=generateFilledPath(entries,mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin()),minx,maxx);
  trans.pathValueToPixel(filled);
  c.drawPath(filled,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.8186195826645265
18593,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}",0.973115137346581
18594,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_performance_linechart);
  mTvCount=(TextView)findViewById(R.id.tvValueCount);
  mSeekBarValues=(SeekBar)findViewById(R.id.seekbarValues);
  mTvCount.setText(""String_Node_Str"");
  mSeekBarValues.setProgress(500);
  mSeekBarValues.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(false);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.getXAxis().setDrawGridLines(false);
  mChart.getXAxis().setDrawAxisLine(false);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_performance_linechart);
  mTvCount=(TextView)findViewById(R.id.tvValueCount);
  mSeekBarValues=(SeekBar)findViewById(R.id.seekbarValues);
  mTvCount.setText(""String_Node_Str"");
  mSeekBarValues.setProgress(500);
  mSeekBarValues.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(false);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.getXAxis().setDrawGridLines(true);
  mChart.getXAxis().setDrawAxisLine(false);
  mChart.invalidate();
}",0.996831145314622
18595,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(true);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(false);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}",0.9951757408683668
18596,"@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}","@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mBorderPaint=new Paint();
  mBorderPaint.setStyle(Style.STROKE);
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(Utils.convertDpToPixel(1f));
}",0.9027283511269276
18597,"/** 
 * draws the grid background
 */
protected void drawGridBackground(Canvas c){
  if (!mDrawGridBackground)   return;
  c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);
}","/** 
 * draws the grid background
 */
protected void drawGridBackground(Canvas c){
  if (mDrawGridBackground) {
    c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);
  }
  if (mDrawBorders) {
    c.drawRect(mViewPortHandler.getContentRect(),mBorderPaint);
  }
}",0.7176220806794055
18598,"@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.isEnabled()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getAxisPaint());
    }
    if (mAxisRight.isEnabled()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getAxisPaint());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getAxisPaint());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getAxisPaint());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.989310529128808
18599,"/** 
 * Removes all DataSets (and thereby Entries) from the chart. Does not remove the x-values.
 */
public void clearValues(){
  mData.clearValues();
  invalidate();
}","/** 
 * Removes all DataSets (and thereby Entries) from the chart. Does not remove the x-values. Also refreshes the chart by calling invalidate().
 */
public void clearValues(){
  mData.clearValues();
  invalidate();
}",0.8704663212435233
18600,"@Override protected void calculateOffsets(){
  float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      offsetBottom+=mLegend.mTextHeightMax * 3f;
    }
  }
  if (mAxisLeft.isEnabled()) {
    offsetTop+=mAxisLeft.getRequiredHeightSpace(mAxisRendererLeft.getAxisPaint());
  }
  if (mAxisRight.isEnabled()) {
    offsetBottom+=mAxisRight.getRequiredHeightSpace(mAxisRendererRight.getAxisPaint());
  }
  float xlabelwidth=mXAxis.mLabelWidth;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
      offsetLeft+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.TOP) {
      offsetRight+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
      offsetLeft+=xlabelwidth;
      offsetRight+=xlabelwidth;
    }
  }
  float min=Utils.convertDpToPixel(10f);
  mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      offsetBottom+=mLegend.mTextHeightMax * 3f;
    }
  }
  if (mAxisLeft.needsOffset()) {
    offsetTop+=mAxisLeft.getRequiredHeightSpace(mAxisRendererLeft.getAxisPaint());
  }
  if (mAxisRight.needsOffset()) {
    offsetBottom+=mAxisRight.getRequiredHeightSpace(mAxisRendererRight.getAxisPaint());
  }
  float xlabelwidth=mXAxis.mLabelWidth;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
      offsetLeft+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.TOP) {
      offsetRight+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
      offsetLeft+=xlabelwidth;
      offsetRight+=xlabelwidth;
    }
  }
  float min=Utils.convertDpToPixel(10f);
  mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9886169607285143
18601,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX + 1;
  int minx=mMinX - 1;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i < maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.995835261453031
18602,"@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() - 0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  float div=(float)step + (step > 1 ? bd.getGroupSpace() : 0f);
  float min=(float)mMinX / div;
  float max=(float)mMaxX / div;
  for (int i=(int)min; i <= max; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() - 0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}",0.8782722513089005
18603,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9887417218543046
18604,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.995550281815485
18605,"/** 
 * Adds a new LimitLine to this axis.
 * @param l
 */
public void addLimitLine(LimitLine l){
  mLimitLines.add(l);
}","/** 
 * Adds a new LimitLine to this axis.
 * @param l
 */
public void addLimitLine(LimitLine l){
  mLimitLines.add(l);
  if (mLimitLines.size() > 6) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.7423312883435583
18606,"/** 
 * Removes all LimitLines from the axis.
 */
public void removeAllLimitLines(){
  mLimitLines=new ArrayList<LimitLine>();
}","/** 
 * Removes all LimitLines from the axis.
 */
public void removeAllLimitLines(){
  mLimitLines.clear();
}",0.8860759493670886
18607,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    limitLinePath.moveTo(pts[0],pts[1]);
    limitLinePath.lineTo(pts[2],pts[3]);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.9479519556513704
18608,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9734653465346534
18609,"/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param xIndex
 * @param dataSet
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(int xIndex,int dataSet,double yValue){
  BarEntry entry=mData.getDataSetByIndex(dataSet).getEntryForXIndex(xIndex);
  int stackIndex=entry.getClosestIndexAbove((float)yValue);
  Highlight h=new Highlight(xIndex,dataSet,stackIndex);
  return h;
}","/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param xIndex
 * @param dataSet
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(int xIndex,int dataSet,double yValue){
  BarEntry entry=mData.getDataSetByIndex(dataSet).getEntryForXIndex(xIndex);
  if (entry != null) {
    int stackIndex=entry.getClosestIndexAbove((float)yValue);
    Highlight h=new Highlight(xIndex,dataSet,stackIndex);
    return h;
  }
 else   return null;
}",0.9461077844311376
18610,"/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSet=0;
    int xIndex=(int)Math.round(xPosition);
    if (!mData.getDataSetByIndex(dataSet).isStacked())     return new Highlight(xIndex,dataSet);
 else     return getStackedHighlight(xIndex,dataSet,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}","/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSetIndex=0;
    int xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}",0.9123311296349526
18611,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.9544715447154472
18612,"/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSetIndex=0;
    int xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}","/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  int dataSetIndex=0;
  int xIndex=0;
  if (!mData.isGrouped()) {
    xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
    }
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    dataSetIndex=(int)baseNoSpace % setCount;
    xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
  }
  if (!mData.getDataSetByIndex(dataSetIndex).isStacked())   return new Highlight(xIndex,dataSetIndex);
 else   return getStackedHighlight(xIndex,dataSetIndex,yPosition);
}",0.8741258741258742
18613,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.9839326702371844
18614,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(c,vals[k / 2],valuePoints[j],transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset),formatter);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,vals[k / 2],x,y,formatter);
            }
          }
        }
      }
    }
  }
}",0.8891280947255114
18615,"@Override protected void drawValue(Canvas c,float val,float xPos,float yPos,ValueFormatter formatter){
  super.drawValue(c,val,xPos + xOffset,yPos + yOffset,formatter);
}","@Override protected void drawValue(Canvas c,float val,float xPos,float yPos,ValueFormatter formatter){
  super.drawValue(c,val,xPos,yPos + mYOffset,formatter);
}",0.9607250755287008
18616,"public HorizontalBarChartRenderer(BarDataProvider chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(chart,animator,viewPortHandler);
  mValuePaint.setTextAlign(Align.LEFT);
  yOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
  xOffset=Utils.convertDpToPixel(4f);
}","public HorizontalBarChartRenderer(BarDataProvider chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(chart,animator,viewPortHandler);
  mValuePaint.setTextAlign(Align.LEFT);
}",0.7942973523421588
18617,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(c,vals[k / 2],transformed[k],valuePoints[j + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset),formatter);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    negOffset=drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.convertDpToPixel(5);
    posOffset=drawValueAboveBar ? Utils.convertDpToPixel(5) : -Utils.convertDpToPixel(5);
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1],formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            drawValue(c,e.getVal(),valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1],formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=transformed[k] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,vals[k / 2],x,y,formatter);
            }
          }
        }
      }
    }
  }
}",0.723404255319149
18618,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.9922789539227896
18619,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9855513307984792
18620,"public float getBelowSum(int stackIndex){
  if (mVals == null)   return 0;
  float remainder=0f;
  int index=mVals.length - 1;
  while (index > stackIndex) {
    remainder+=mVals[index];
    index--;
  }
  return remainder;
}","public float getBelowSum(int stackIndex){
  if (mVals == null)   return 0;
  float remainder=0f;
  int index=mVals.length - 1;
  while (index > stackIndex && index >= 0) {
    remainder+=mVals[index];
    index--;
  }
  return remainder;
}",0.9698275862068966
18621,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=h.getStackIndex() < 0 ? e.getVal() : e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex());
      prepareBar(x,y,set.getBarSpace(),trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,set.getBarSpace(),from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.940713853599516
18622,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxisLabels(mDrawCanvas);
  mXAxisRenderer.renderAxisLine(mDrawCanvas);
  mAxisRendererLeft.renderAxisLabels(mDrawCanvas);
  mAxisRendererRight.renderAxisLabels(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9811097992916176
18623,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}",0.9902597402597404
18624,"/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be anysubclass of Entry, like BarEntry or CandleEntry.
 * @param dataSetIndex the index of the DataSet the selected value is in
 */
public abstract void refreshContent(Entry e,int dataSetIndex);","/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be anysubclass of Entry, like BarEntry or CandleEntry, simply cast it at runtime.
 * @param dataSetIndex the index of the DataSet the selected value is in
 */
public abstract void refreshContent(Entry e,int dataSetIndex);",0.9652509652509652
18625,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(12f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setStartAtZero(false);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
}",0.9514255543822596
18626,"public float getRequiredHeightSpace(Paint p){
  String label=getLongestLabel();
  return (float)Utils.calcTextHeight(p,label) + getYOffset() * 2f;
}","public float getRequiredHeightSpace(Paint p){
  p.setTextSize(mTextSize);
  String label=getLongestLabel();
  return (float)Utils.calcTextHeight(p,label) + getYOffset() * 2f;
}",0.9135802469135802
18627,"public float getRequiredWidthSpace(Paint p){
  String label=getLongestLabel();
  return (float)Utils.calcTextWidth(p,label) + getXOffset() * 2f;
}","public float getRequiredWidthSpace(Paint p){
  p.setTextSize(mTextSize);
  String label=getLongestLabel();
  return (float)Utils.calcTextWidth(p,label) + getXOffset() * 2f;
}",0.9125
18628,"/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}","/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this. Do not forget to call setStartAtZero(false) if you use this method. Otherwise, the axis-minimum value will still be forced to 0.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}",0.7993779160186625
18629,"public void computeAxis(float xValAverageLength,ArrayList<String> xValues){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(xValAverageLength + mXAxis.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXAxis.mLabelWidth=Utils.calcTextWidth(mAxisPaint,a.toString());
  mXAxis.mLabelHeight=Utils.calcTextHeight(mAxisPaint,""String_Node_Str"");
  mXAxis.setValues(xValues);
}","public void computeAxis(float xValAverageLength,ArrayList<String> xValues){
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(xValAverageLength + mXAxis.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXAxis.mLabelWidth=Utils.calcTextWidth(mAxisPaint,a.toString());
  mXAxis.mLabelHeight=Utils.calcTextHeight(mAxisPaint,""String_Node_Str"");
  mXAxis.setValues(xValues);
}",0.9
18630,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YAxis yl=mChart.getYAxis();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(9f);
  YAxis yAxis=mChart.getYAxis();
  yAxis.setTypeface(tf);
  yAxis.setLabelCount(5);
  yAxis.setTextSize(9f);
  yAxis.setStartAtZero(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.966373512674599
18631,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  mChart.setData(data);
  mChart.invalidate();
}",0.986378581493659
18632,"@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=0f;
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=0f;
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}",0.950483779169038
18633,"/** 
 * Returns the factor that is needed to transform values into pixels.
 * @return
 */
public float getFactor(){
  RectF content=mViewPortHandler.getContentRect();
  return (float)Math.min(content.width() / 2f,content.height() / 2f) / mYAxis.mAxisMaximum;
}","/** 
 * Returns the factor that is needed to transform values into pixels.
 * @return
 */
public float getFactor(){
  RectF content=mViewPortHandler.getContentRect();
  return (float)Math.min(content.width() / 2f,content.height() / 2f) / mYAxis.mAxisRange;
}",0.9768339768339768
18634,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(0f,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}",0.9739130434782608
18635,"protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  ArrayList<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,e.getVal() * factor,sliceangle * j + mChart.getRotationAngle());
    if (j == 0)     surface.moveTo(p.x,p.y);
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}","protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  ArrayList<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (j == 0)     surface.moveTo(p.x,p.y);
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.9871031746031746
18636,"protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i++) {
    PointF p=Utils.getPosition(center,mChart.getYChartMax() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=mChart.getYAxis().mEntries[j] * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i++) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9830361026533276
18637,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,e.getVal() * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}",0.971938775510204
18638,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=e.getVal();
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9841075794621028
18639,"@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  mAxisPaint.setColor(mXAxis.getTextColor());
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < mXAxis.getValues().size(); i++) {
    String text=mXAxis.getValues().get(i);
    float angle=(sliceangle * i + mChart.getRotationAngle()) % 360f;
    PointF p=Utils.getPosition(center,mChart.getYChartMax() * factor + mXAxis.mLabelWidth / 2f,angle);
    c.drawText(text,p.x,p.y + mXAxis.mLabelHeight / 2f,mAxisPaint);
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  mAxisPaint.setColor(mXAxis.getTextColor());
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < mXAxis.getValues().size(); i++) {
    String text=mXAxis.getValues().get(i);
    float angle=(sliceangle * i + mChart.getRotationAngle()) % 360f;
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor + mXAxis.mLabelWidth / 2f,angle);
    c.drawText(text,p.x,p.y + mXAxis.mLabelHeight / 2f,mAxisPaint);
  }
}",0.9910158949550796
18640,"@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mYAxis.getTypeface());
  mAxisPaint.setTextSize(mYAxis.getTextSize());
  mAxisPaint.setColor(mYAxis.getTextColor());
  PointF center=mChart.getCenterOffsets();
  float factor=mChart.getFactor();
  int labelCount=mYAxis.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    if (j == labelCount - 1 && mYAxis.isDrawTopYLabelEntryEnabled() == false)     break;
    float r=mYAxis.mEntries[j] * factor;
    PointF p=Utils.getPosition(center,r,mChart.getRotationAngle());
    String label=mYAxis.getFormattedLabel(j);
    c.drawText(label,p.x + 10,p.y,mAxisPaint);
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mYAxis.getTypeface());
  mAxisPaint.setTextSize(mYAxis.getTextSize());
  mAxisPaint.setColor(mYAxis.getTextColor());
  PointF center=mChart.getCenterOffsets();
  float factor=mChart.getFactor();
  int labelCount=mYAxis.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    if (j == labelCount - 1 && mYAxis.isDrawTopYLabelEntryEnabled() == false)     break;
    float r=(mYAxis.mEntries[j] - mYAxis.mAxisMinimum) * factor;
    PointF p=Utils.getPosition(center,r,mChart.getRotationAngle());
    String label=mYAxis.getFormattedLabel(j);
    c.drawText(label,p.x + 10,p.y,mAxisPaint);
  }
}",0.9834254143646408
18641,"@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}","@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=(l.getLimit() - mChart.getYChartMin()) * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}",0.9733629300776916
18642,"protected boolean passesCheck(){
  return mChart.getBarData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleY();
}","@Override protected boolean passesCheck(){
  return mChart.getBarData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleY();
}",0.9655172413793104
18643,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawFilled(true);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTypeface(tf);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawFilled(true);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9682713347921226
18644,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(true);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.979226589964845
18645,"@SuppressLint(""String_Node_Str"") @Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  if (e == null)   return;
  RectF bounds=mChart.getBarBounds((BarEntry)e);
  PointF position=mChart.getPosition(e,AxisDependency.LEFT);
  Log.i(""String_Node_Str"",bounds.toString());
  Log.i(""String_Node_Str"",position.toString());
}","@SuppressLint(""String_Node_Str"") @Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  if (e == null)   return;
  RectF bounds=mChart.getBarBounds((BarEntry)e);
  PointF position=mChart.getPosition(e,mChart.getData().getDataSetByIndex(dataSetIndex).getAxisDependency());
  Log.i(""String_Node_Str"",bounds.toString());
  Log.i(""String_Node_Str"",position.toString());
}",0.7967257844474761
18646,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextSize(10f);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9896265560165975
18647,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}",0.990419557317476
18648,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}",0.9867398262459992
18649,"/** 
 * Returns the bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
 * @param e
 * @param dataSetIndex
 * @return
 */
public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float left=x - 0.5f + spaceHalf;
  float right=x + 0.5f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}","/** 
 * Returns the bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
 * @param e
 * @param dataSetIndex
 * @return
 */
public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float barWidth=0.5f;
  float spaceHalf=barspace / 2f;
  float left=x - barWidth + spaceHalf;
  float right=x + barWidth - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}",0.9670175438596492
18650,"/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}","/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}",0.8308026030368764
18651,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.9839523154516276
18652,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}",0.9892833221701272
18653,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.9845474613686536
18654,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  MyValueFormatter customFormatter=new MyValueFormatter();
  mChart.setValueFormatter(customFormatter);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setFormatter(customFormatter);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  MyValueFormatter customFormatter=new MyValueFormatter();
  mChart.setValueFormatter(customFormatter);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setFormatter(customFormatter);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9861888764464352
18655,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.9840109639104614
18656,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    if (mXAxis.isCenterXLabelsEnabled())     position[0]+=0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.3828282828282828
18657,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
@Override protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f - 0.5f;
    if (mXAxis.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
@Override protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f;
    if (step > 1) {
      position[0]+=((float)step - 1f) / 2f;
    }
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.9549071618037136
18658,"/** 
 * Generates an automatically prepared legend depending on the DataSets in the chart and their colors.
 */
public void prepareLegend(){
  ArrayList<String> labels=new ArrayList<String>();
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=mData.getDataSetByIndex(i);
    ArrayList<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < entryCount && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      ArrayList<String> xVals=mData.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=mData.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  Legend l=new Legend(colors,labels);
  if (mLegend != null) {
    l.apply(mLegend);
  }
  mLegend=l;
}","/** 
 * Generates an automatically prepared legend depending on the DataSets in the chart and their colors.
 */
public void prepareLegend(){
  ArrayList<String> labels=new ArrayList<String>();
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=mData.getDataSetByIndex(i);
    ArrayList<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      ArrayList<String> xVals=mData.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=mData.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  Legend l=new Legend(colors,labels);
  if (mLegend != null) {
    l.apply(mLegend);
  }
  mLegend=l;
}",0.9945255474452556
18659,"@Override public void notifyDataSetChanged(){
  super.notifyDataSetChanged();
  mYAxisRenderer.computeAxis(0f,mData.getYMax());
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
}","@Override public void notifyDataSetChanged(){
  super.notifyDataSetChanged();
  if (mData != null) {
    mYAxisRenderer.computeAxis(0f,mData.getYMax());
    mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  }
}",0.9300225733634312
18660,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.getAxisRight().setDrawGridLines(false);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.945019404915912
18661,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.8625772705658583
18662,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}",0.9738625363020328
18663,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.8919585594474593
18664,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setDrawGridLines(false);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}",0.9066232356134636
18665,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(52f);
  holder.chart.setTransparentCircleRadius(57f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setValueTextSize(11f);
  holder.chart.setValueFormatter(new PercentFormatter(holder.chart));
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}",0.9393617021276596
18666,"@Override public void notifyDataSetChanged(){
  prepare();
  mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaYRight,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaYLeft,mAxisLeft.mAxisMinimum);
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(false);
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.1357370095440085
18667,"@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
}","@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
  mAxisLeft.mAxisMaximum=maxLeft;
  mAxisRight.mAxisMaximum=maxRight;
  mAxisLeft.mAxisMinimum=minLeft;
  mAxisRight.mAxisMinimum=minRight;
}",0.8507462686567164
18668,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9944444444444444
18669,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  prepare();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.9714889123548046
18670,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  prepare();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9681978798586572
18671,"@Override public void notifyDataSetChanged(){
  prepare();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}",0.6060606060606061
18672,"@Override protected void calculateOffsets(){
  super.calculateOffsets();
  float offset=mData.getGreatestShapeSize() / 2f;
  mViewPortHandler.restrainViewPort(mViewPortHandler.offsetLeft() - offset,mViewPortHandler.offsetTop(),mViewPortHandler.offsetRight() - offset,mViewPortHandler.offsetBottom());
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  super.calculateOffsets();
  float offset=mData.getGreatestShapeSize() / 2f;
  mViewPortHandler.restrainViewPort(mViewPortHandler.offsetLeft() - offset,mViewPortHandler.offsetTop(),mViewPortHandler.offsetRight() - offset,mViewPortHandler.offsetBottom());
  prepareOffsetMatrix();
}",0.9907407407407408
18673,"public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}","/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}",0.39375
18674,"public void resetAxisMaxValue(){
  mCustomAxisMax=Float.NaN;
}","/** 
 * By calling this method, any custom maximum value that has been previously set is reseted, and the calculation is done automatically.
 */
public void resetAxisMaxValue(){
  mCustomAxisMax=Float.NaN;
}",0.4609665427509293
18675,"public void setAxisMaxValue(float max){
  mCustomAxisMax=max;
}","/** 
 * Set a custom maximum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMaxValue() to undo this.
 * @param max
 */
public void setAxisMaxValue(float max){
  mCustomAxisMax=max;
}",0.39375
18676,"public void resetAxisMinValue(){
  mCustomAxisMin=Float.NaN;
}","/** 
 * By calling this method, any custom minimum value that has been previously set is reseted, and the calculation is done automatically.
 */
public void resetAxisMinValue(){
  mCustomAxisMin=Float.NaN;
}",0.4609665427509293
18677,"@Override public void drawValues(Canvas c){
  if (mChart.getData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<ScatterDataSet> dataSets=mChart.getData().getDataSets();
    for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesLineScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && !mViewPortHandler.isInBoundsLeft(positions[j - 1]) && !mViewPortHandler.isInBoundsY(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<ScatterDataSet> dataSets=mChart.getData().getDataSets();
    for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesLineScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && !mViewPortHandler.isInBoundsLeft(positions[j - 1]) && !mViewPortHandler.isInBoundsY(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.9733700642791552
18678,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  mYAxis.mAxisMaximum=yMax;
  mYAxis.mAxisMinimum=yMin;
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  computeAxisValues(yMin,yMax);
}",0.9496402877697842
18679,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.9907735982966644
18680,"/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(ViewPortHandler viewport,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((viewport.getChartWidth() - viewport.offsetRight() - viewport.offsetLeft()) / deltaX);
  float scaleY=(float)((viewport.getChartHeight() - viewport.offsetTop() - viewport.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}","/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.getChartWidth() - mViewPortHandler.offsetRight() - mViewPortHandler.offsetLeft()) / deltaX);
  float scaleY=(float)((mViewPortHandler.getChartHeight() - mViewPortHandler.offsetTop() - mViewPortHandler.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}",0.8896265560165975
18681,"/** 
 * Prepares the matrix that contains all offsets.
 * @param chart
 */
public void prepareMatrixOffset(ViewPortHandler viewport,boolean inverted){
  mMatrixOffset.reset();
  if (!inverted)   mMatrixOffset.postTranslate(viewport.offsetLeft(),viewport.getChartHeight() - viewport.offsetBottom());
 else {
    mMatrixOffset.setTranslate(viewport.offsetLeft(),-viewport.offsetTop());
    mMatrixOffset.postScale(1.0f,-1.0f);
  }
}","/** 
 * Prepares the matrix that contains all offsets.
 * @param chart
 */
public void prepareMatrixOffset(boolean inverted){
  mMatrixOffset.reset();
  if (!inverted)   mMatrixOffset.postTranslate(mViewPortHandler.offsetLeft(),mViewPortHandler.getChartHeight() - mViewPortHandler.offsetBottom());
 else {
    mMatrixOffset.setTranslate(mViewPortHandler.offsetLeft(),-mViewPortHandler.offsetTop());
    mMatrixOffset.postScale(1.0f,-1.0f);
  }
}",0.656
18682,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setDrawValue(true);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setDrawValue(true);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  mChart.getAxisLeft().addLimitLine(ll1);
  mChart.getAxisLeft().addLimitLine(ll2);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.8831562974203339
18683,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9902498476538696
18684,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas,mValueFormatter);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}",0.9862306368330463
18685,"/** 
 * Constructor with limit.
 * @param limit
 */
public LimitLine(float limit){
  mLimit=limit;
}","/** 
 * Constructor with limit and label.
 * @param limit - the position (the value) on the y-axis where this lineshould appear
 * @param label - provide """" if no label is required
 */
public LimitLine(float limit,String label){
  mLimit=limit;
  mLabel=label;
}",0.5524861878453039
18686,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(1f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.8996205588133839
18687,"public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisPaint.setColor(Color.BLACK);
  mAxisPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}","public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisPaint.setColor(Color.BLACK);
  mAxisPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
}",0.9865470852017936
18688,"@Override public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}","@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}",0.9833887043189368
18689,"private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  return set;
}","private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  set.setAxisDependency(AxisDependency.LEFT);
  return set;
}",0.926751592356688
18690,"private LineData getData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float val=(float)(Math.random() * range) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.75f);
  set1.setCircleSize(3f);
  set1.setColor(Color.WHITE);
  set1.setCircleColor(Color.WHITE);
  set1.setHighLightColor(Color.WHITE);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  return data;
}","private LineData getData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float val=(float)(Math.random() * range) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.75f);
  set1.setCircleSize(3f);
  set1.setColor(Color.WHITE);
  set1.setCircleColor(Color.WHITE);
  set1.setHighLightColor(Color.WHITE);
  set1.setDrawValues(false);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  return data;
}",0.9799307958477508
18691,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis leftAxis=chart.getAxisLeft();
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(4);
  leftAxis.setDrawGridLines(false);
  chart.getAxisRight().setEnabled(false);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}",0.9365962180200222
18692,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  Log.i(LOG_TAG,""String_Node_Str"" + minLeft + ""String_Node_Str""+ maxLeft);
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.9765844520761786
18693,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  float val=e.getVal();
  mYValCount+=1;
  mYValueSum+=val;
  if (mYMax < val)   mYMax=val;
  if (mYMin > val)   mYMin=val;
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex) {
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    if (mDataSets == null)     mDataSets=new ArrayList<T>();
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.6069651741293532
18694,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
  if (d.getAxisDependency() == AxisDependency.LEFT) {
    if (mLeftAxisMax < d.getYMax())     mLeftAxisMax=d.getYMax();
    if (mLeftAxisMin > d.getYMin())     mLeftAxisMin=d.getYMin();
  }
 else {
    if (mRightAxisMax < d.getYMax())     mRightAxisMax=d.getYMax();
    if (mRightAxisMin > d.getYMin())     mRightAxisMin=d.getYMin();
  }
}",0.65439672801636
18695,"public void setAxisDependency(AxisDependency dependency){
  mAxisDependency=dependency;
}","/** 
 * Set the y-axis this DataSet should be plotted against (either LEFT or RIGHT). Default: LEFT
 * @param dependency
 */
public void setAxisDependency(AxisDependency dependency){
  mAxisDependency=dependency;
}",0.5874587458745875
18696,"public AxisDependency getAxisDependency(){
  return mAxisDependency;
}","/** 
 * Returns the axis this DataSet should be plotted against.
 * @return
 */
public AxisDependency getAxisDependency(){
  return mAxisDependency;
}",0.6363636363636364
18697,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX++;
  mDeltaX*=mData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}",0.9635036496350364
18698,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(false);
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.6089906700593724
18699,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  if (mDrawXLabels) {
    mXAxisRenderer.renderAxis(mDrawCanvas);
  }
  if (mDrawYAxis) {
    mAxisRendererLeft.renderAxis(mDrawCanvas);
    mAxisRendererRight.renderAxis(mDrawCanvas);
  }
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawBorder();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  if (mDrawXLabels) {
    mXAxisRenderer.renderAxis(mDrawCanvas);
  }
  if (mDrawYAxis) {
    mAxisRendererLeft.renderAxis(mDrawCanvas);
    mAxisRendererRight.renderAxis(mDrawCanvas);
  }
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawBorder();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.8792243767313019
18700,"@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
  mAxisLeft.mAxisMaximum=maxLeft;
  mAxisRight.mAxisMaximum=maxRight;
  mAxisLeft.mAxisMinimum=minLeft;
  mAxisRight.mAxisMinimum=minRight;
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=minRight - bottomSpaceRight;
  mDeltaYLeft=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mDeltaYRight=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.4571062740076824
18701,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX++;
}",0.8333333333333334
18702,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected abstract void calcMinMax(boolean fixedValues);","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected abstract void calcMinMax();",0.9266409266409268
18703,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}",0.8913043478260869
18704,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  calcAngles();
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  calcAngles();
}",0.8387096774193549
18705,"@Override protected void calcMinMax(boolean fixedValues){
  mDeltaX=mData.getXVals().size() - 1;
}","@Override protected void calcMinMax(){
  mDeltaX=mData.getXVals().size() - 1;
}",0.8926553672316384
18706,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareLegend();
  calculateOffsets();
}",0.981549815498155
18707,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mYAxis.mAxisMaximum <= 0)   mYAxis.mAxisMaximum=1f;
  mYAxis.mAxisMinimum=0;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mYAxis.mAxisMaximum <= 0)   mYAxis.mAxisMaximum=1f;
  mYAxis.mAxisMinimum=0;
}",0.90625
18708,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}",0.8913043478260869
18709,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
  }
  computeAxisValues(yMin,yMax);
}",0.9295639674173456
18710,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(tf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9936183790682832
18711,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.987977369165488
18712,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(1f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.980980980980981
18713,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private PieData generateDataPie(int cnt){
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int i=0; i < 4; i++) {
    entries.add(new Entry((int)(Math.random() * 70) + 30,i));
  }
  PieDataSet d=new PieDataSet(entries,""String_Node_Str"");
  d.setSliceSpace(5f);
  d.setColors(ColorTemplate.VORDIPLOM_COLORS);
  PieData cd=new PieData(getQuarters(),d);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private PieData generateDataPie(int cnt){
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int i=0; i < 4; i++) {
    entries.add(new Entry((int)(Math.random() * 70) + 30,i));
  }
  PieDataSet d=new PieDataSet(entries,""String_Node_Str"");
  d.setSliceSpace(2f);
  d.setColors(ColorTemplate.VORDIPLOM_COLORS);
  PieData cd=new PieData(getQuarters(),d);
  return cd;
}",0.9978021978021978
18714,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.7804627249357327
18715,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  return v;
}",0.8282168517308949
18716,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(generateScatterData(3,10000,150));
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(generateScatterData(3,10000,150));
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setDrawGridLines(false);
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}",0.8547763666482606
18717,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(generateLineData());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(generateLineData());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setStartAtZero(false);
  leftAxis.setAxisMaxValue(1.2f);
  leftAxis.setAxisMinValue(-1.2f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  return v;
}",0.8670731707317073
18718,"public BarChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public BarChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9880478087649402
18719,"public ChartItem(ChartData cd){
  this.mChartData=cd;
}","public ChartItem(ChartData<?> cd){
  this.mChartData=cd;
}",0.9734513274336284
18720,"public LineChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public LineChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9881422924901184
18721,"public PieChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public PieChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9880478087649402
18722,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mAxisLeft.isEnabled()) {
    String label=mAxisLeft.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
  }
  if (mAxisRight.isEnabled()) {
    String label=mAxisRight.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mAxisLeft.isEnabled()) {
    String label=mAxisLeft.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
  }
  if (mAxisRight.isEnabled()) {
    String label=mAxisRight.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.995446584938704
18723,"@Override protected void init(){
  super.init();
  setDrawXLabels(false);
}","@Override protected void init(){
  super.init();
}",0.8
18724,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart);
return true;
}",0.9996848408446264
18725,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(2.5f);
  d1.setCircleSize(4.5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(2.5f);
  d2.setCircleSize(4.5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}",0.9943609022556392
18726,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawAxisLabels(!mChart.isDrawAxisLabelsEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.animateX:
{
mChart.animateX(1800);
break;
}
case R.id.animateY:
{
mChart.animateY(1800);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1800,1800);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.animateX:
{
mChart.animateX(1800);
break;
}
case R.id.animateY:
{
mChart.animateY(1800);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1800,1800);
break;
}
}
return true;
}",0.9842300556586272
18727,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
if (mChart.isDrawXLabelsEnabled()) mChart.setDrawXLabels(false);
 else mChart.setDrawXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360);
break;
}
}
return true;
}",0.9585112873703476
18728,"/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  if (axis == AxisDependency.LEFT)   mLeftAxisTransformer.pointValuesToPixel(vals);
 else   mRightAxisTransformer.pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}","/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}",0.8964927288280582
18729,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=getEntryByDataSetIndex(high.getXIndex(),high.getDataSetIndex());
      mSelectionListener.onValueSelected(e,high.getDataSetIndex());
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex());
    }
  }
}",0.8451882845188284
18730,"@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
  if (mDrawBitmap == null || mDrawCanvas == null) {
    mDrawBitmap=Bitmap.createBitmap(getWidth(),getHeight(),Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
}","@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
  if (mDrawCanvas == null) {
    mDrawCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
}",0.9081163859111792
18731,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.983490566037736
18732,"/** 
 * Clears the chart from all data and refreshes it (by calling invalidate()).
 */
public void clear(){
  mData=null;
  mData=null;
  mDataNotSet=true;
  invalidate();
}","/** 
 * Clears the chart from all data and refreshes it (by calling invalidate()).
 */
public void clear(){
  mData=null;
  mDataNotSet=true;
  invalidate();
}",0.9578313253012049
18733,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}",0.9676044330775788
18734,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
  yl.setAxisMaxValue(300);
  yl.setAxisMinValue(-100f);
}",0.9833035181872392
18735,"private void prepareValuePxMatrix(){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mDeltaYLeft + ""String_Node_Str""+ mDeltaYRight);
  mRightAxisTransformer.prepareMatrixValuePx(mDeltaX,mDeltaYRight,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mDeltaX,mDeltaYLeft,mAxisLeft.mAxisMinimum);
}","private void prepareValuePxMatrix(){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mAxisLeft.mAxisRange + ""String_Node_Str""+ mAxisRight.mAxisRange);
  mRightAxisTransformer.prepareMatrixValuePx(mDeltaX,mAxisRight.mAxisRange,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mDeltaX,mAxisLeft.mAxisRange,mAxisLeft.mAxisMinimum);
}",0.8529411764705882
18736,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=minRight - bottomSpaceRight;
  mDeltaYLeft=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mDeltaYRight=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.8477157360406091
18737,"/** 
 * Returns the delta-y value (y-value range) of the specified axis.
 * @param axis
 * @return
 */
public float getDeltaY(AxisDependency axis){
  if (axis == AxisDependency.LEFT)   return mDeltaYLeft;
 else   return mDeltaYRight;
}","/** 
 * Returns the delta-y value (y-value range) of the specified axis.
 * @param axis
 * @return
 */
public float getDeltaY(AxisDependency axis){
  if (axis == AxisDependency.LEFT)   return mAxisLeft.mAxisRange;
 else   return mAxisRight.mAxisRange;
}",0.9139344262295082
18738,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8694690265486725
18739,"@Override protected void init(){
  super.init();
  mXAxisRenderer=new XAxisRendererBarChart(mViewPortHandler,mXAxis,mLeftAxisTransformer,this);
}","@Override protected void init(){
  super.init();
  mRenderer=new BarChartRenderer(this,mAnimator,mViewPortHandler);
  mXAxisRenderer=new XAxisRendererBarChart(mViewPortHandler,mXAxis,mLeftAxisTransformer,this);
}",0.8123249299719888
18740,"/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(mFixedYValues);
  mAxisRendererLeft.computeAxis(this);
  mAxisRendererRight.computeAxis(this);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}","/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(mFixedYValues);
  mAxisRendererLeft.computeAxis(this);
  mAxisRendererRight.computeAxis(this);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.8350951374207188
18741,"@Override protected void init(){
  super.init();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}","@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}",0.9347319347319348
18742,"@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
    mRightAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
    mLeftAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  }
 else {
    calcMinMax(mFixedYValues);
  }
}","@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
    mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
    mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  }
 else {
    calcMinMax(mFixedYValues);
  }
}",0.5491525423728814
18743,"/** 
 * Sets up all the matrices that will be used for scaling the coordinates to the display. Offset and Value-px.
 */
protected void prepareMatrix(){
  mRightAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  mLeftAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  mRightAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisRight.isInverted());
  mLeftAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisLeft.isInverted());
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets up all the matrices that will be used for scaling the coordinates to the display. Offset and Value-px.
 */
protected void prepareMatrix(){
  mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  mRightAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisRight.isInverted());
  mLeftAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisLeft.isInverted());
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9423791821561338
18744,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  String label=mAxisLeft.getLongestLabel();
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth;
    }
    if (mAxisRight.isEnabled()) {
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareMatrix();
}",0.9095031173247684
18745,"/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mViewPortHandler.getMatrixTouch().getValues(values);
  mXAxis.mXAxisLabelModulus=(int)Math.ceil((mData.getXValCount() * mXAxis.mLabelWidth) / (mViewPortHandler.contentWidth() * values[Matrix.MSCALE_X]));
}","/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mViewPortHandler.getMatrixTouch().getValues(values);
  mXAxis.mAxisLabelModulus=(int)Math.ceil((mData.getXValCount() * mXAxis.mLabelWidth) / (mViewPortHandler.contentWidth() * values[Matrix.MSCALE_X]));
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mXAxis.mAxisLabelModulus + ""String_Node_Str""+ mXAxis.mLabelWidth+ ""String_Node_Str""+ mViewPortHandler.contentWidth());
}",0.787363304981774
18746,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  data.setData(generateScatterData());
  data.setData(generateCandleData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  data.setData(generateCandleData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9718411552346572
18747,"private LineData generateLineData(){
  LineData d=new LineData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  LineDataSet set=new LineDataSet(entries,""String_Node_Str"");
  set.setColor(Color.RED);
  set.setLineWidth(2.5f);
  set.setCircleColor(Color.RED);
  set.setCircleSize(5f);
  set.setFillColor(Color.RED);
  set.setDrawCubic(true);
  d.addDataSet(set);
  return d;
}","private LineData generateLineData(){
  LineData d=new LineData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  LineDataSet set=new LineDataSet(entries,""String_Node_Str"");
  set.setColor(Color.RED);
  set.setLineWidth(2.5f);
  set.setCircleColor(Color.RED);
  set.setCircleSize(5f);
  set.setFillColor(Color.RED);
  set.setDrawCubic(true);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.971311475409836
18748,"private CandleData generateCandleData(){
  CandleData d=new CandleData();
  ArrayList<CandleEntry> entries=new ArrayList<CandleEntry>();
  for (int index=0; index < itemcount; index++)   entries.add(new CandleEntry(index,25f,10f,12f,22f));
  CandleDataSet set=new CandleDataSet(entries,""String_Node_Str"");
  set.setColor(Color.rgb(80,80,80));
  d.addDataSet(set);
  return d;
}","private CandleData generateCandleData(){
  CandleData d=new CandleData();
  ArrayList<CandleEntry> entries=new ArrayList<CandleEntry>();
  for (int index=0; index < itemcount; index++)   entries.add(new CandleEntry(index,20f,10f,13f,17f));
  CandleDataSet set=new CandleDataSet(entries,""String_Node_Str"");
  set.setColor(Color.rgb(80,80,80));
  set.setBodySpace(0.3f);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.8589108910891089
18749,"private ScatterData generateScatterData(){
  ScatterData d=new ScatterData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  ScatterDataSet set=new ScatterDataSet(entries,""String_Node_Str"");
  set.setColor(Color.GREEN);
  set.setScatterShapeSize(7.5f);
  d.addDataSet(set);
  return d;
}","private ScatterData generateScatterData(){
  ScatterData d=new ScatterData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  ScatterDataSet set=new ScatterDataSet(entries,""String_Node_Str"");
  set.setColor(Color.GREEN);
  set.setScatterShapeSize(7.5f);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.905
18750,"@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mXChartMax+=0.5f;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9145299145299144
18751,"@Override public void drawValues(Canvas c){
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      if (!dataSet.isDrawValuesEnabled())       continue;
      ArrayList<CandleEntry> entries=dataSet.getYVals();
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseY());
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.0771869639794168
18752,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.929055580659738
18753,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.getAxisRight().setDrawGridLines(false);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9474402730375426
18754,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}",0.9396110542476972
18755,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(7);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(7);
  yLabels.setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}",0.9669724770642202
18756,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawBorder(false);
  mChart.setDrawLegend(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  XAxis x=mChart.getXAxis();
  x.setTypeface(tf);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(5);
  setData(45,100);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawBorder(false);
  mChart.setDrawLegend(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  XAxis x=mChart.getXAxis();
  x.setTypeface(tf);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(5);
  y.setDrawGridLines(false);
  setData(45,100);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}",0.9742589703588144
18757,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9746535991889153
18758,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setDrawGridLines(false);
}",0.9393023894534468
18759,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range / 10);
    float val=(float)(Math.random() * mult) + 500;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}",0.9853091902972326
18760,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawVerticalGrid(false);
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}",0.9617422012948792
18761,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.9619196661450182
18762,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9459884635553224
18763,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}",0.9310113864701942
18764,"/** 
 * Sets the offsets from the border of the view to the actual chart in every direction manually. Provide density pixels -> they are then rendered to pixels inside the chart
 * @param left
 * @param right
 * @param top
 * @param bottom
 */
public void setOffsets(float left,float top,float right,float bottom){
  mOffsetBottom=Utils.convertDpToPixel(bottom);
  mOffsetLeft=Utils.convertDpToPixel(left);
  mOffsetRight=Utils.convertDpToPixel(right);
  mOffsetTop=Utils.convertDpToPixel(top);
}","/** 
 * Sets the offsets from the border of the view to the actual chart in every direction manually. This method needs to be recalled everytime a new data object is set for the chart. Provide density pixels -> they are then rendered to pixels inside the chart.
 * @param left
 * @param right
 * @param top
 * @param bottom
 */
public void setOffsets(float left,float top,float right,float bottom){
  mOffsetBottom=Utils.convertDpToPixel(bottom);
  mOffsetLeft=Utils.convertDpToPixel(left);
  mOffsetRight=Utils.convertDpToPixel(right);
  mOffsetTop=Utils.convertDpToPixel(top);
  mTrans.prepareMatrixValuePx(this);
  mTrans.prepareMatrixOffset(this);
  prepareContentRect();
}",0.8456947996589941
18765,"/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}","/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
@Override public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}",0.979591836734694
18766,"/** 
 * sets the size of the description text in pixels, min 7f, max 14f
 * @param size
 */
public void setDescriptionTextSize(float size){
  if (size > 14f)   size=14f;
  if (size < 7f)   size=7f;
  mInfoPaint.setTextSize(Utils.convertDpToPixel(size));
}","/** 
 * sets the size of the description text in pixels, min 6f, max 16f
 * @param size
 */
public void setDescriptionTextSize(float size){
  if (size > 16f)   size=16f;
  if (size < 6f)   size=6f;
  mDescPaint.setTextSize(Utils.convertDpToPixel(size));
}",0.9607843137254902
18767,"/** 
 * Returns the DataSet object with the given label. Search can be case sensitive or not. IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.
 * @param label
 * @param ignorecase
 * @return
 */
public T getDataSetByLabel(String label,boolean ignorecase){
  int index=getDataSetIndexByLabel(mDataSets,label,ignorecase);
  if (index <= 0 || index >= mDataSets.size())   return null;
 else   return mDataSets.get(index);
}","/** 
 * Returns the DataSet object with the given label. Search can be case sensitive or not. IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.
 * @param label
 * @param ignorecase
 * @return
 */
public T getDataSetByLabel(String label,boolean ignorecase){
  int index=getDataSetIndexByLabel(mDataSets,label,ignorecase);
  if (index < 0 || index >= mDataSets.size())   return null;
 else   return mDataSets.get(index);
}",0.9989440337909188
18768,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}",0.9768998995647808
18769,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.97623148467103
18770,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.977235235895744
18771,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}",0.9884213499011578
18772,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  mChart.setDrawYValues(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  setData();
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  yl.setDrawUnitsInYLabel(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  mChart.setDrawYValues(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  yl.setDrawUnitsInYLabel(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9702970297029704
18773,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9669381887877336
18774,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDrawYValues(false);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setData(generateScatterData(3,10000,150));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDrawYValues(false);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setData(generateScatterData(3,10000,150));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}",0.9634727368978296
18775,"/** 
 * set a description text that appears in the bottom right corner of the chart, size = Y-legend text size
 * @param desc
 */
public void setDescription(String desc){
  this.mDescription=desc;
}","/** 
 * set a description text that appears in the bottom right corner of the chart, size = Y-legend text size
 * @param desc
 */
public void setDescription(String desc){
  if (desc == null)   desc=""String_Node_Str"";
  this.mDescription=desc;
}",0.8959276018099548
18776,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (pos[0] < mOffsetLeft || pos[0] > getWidth() - mOffsetRight || pos[1] < mOffsetTop || pos[1] > getHeight() - mOffsetBottom)       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (pos[0] < mOffsetLeft || pos[0] > getWidth() - mOffsetRight || pos[1] < mOffsetTop || pos[1] > getHeight() - mOffsetBottom)       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}",0.9167397020157756
18777,"/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/wogg
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    mHolePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    mHolePaint.setXfermode(null);
  }
}","/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    mHolePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    mHolePaint.setXfermode(null);
  }
}",0.9784172661870504
18778,"/** 
 * returns the x-offset that is set for the MarkerView
 * @return
 */
public float getXOffset(){
  return mXOffset;
}","/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @return
 */
public abstract int getXOffset();",0.4070796460176991
18779,"/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=mXOffset;
  posy+=mYOffset;
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}","/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset();
  posy+=getYOffset();
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}",0.9813664596273292
18780,"/** 
 * returns the y-offset that is set for the MarkerView
 * @return
 */
public float getYOffset(){
  return mYOffset;
}","/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @return
 */
public abstract int getYOffset();",0.3777777777777777
18781,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    if (entries.size() < 1)     continue;
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}",0.994328922495274
18782,"/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=0f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}","/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=1f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}",0.9970414201183432
18783,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9883830455259026
18784,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9959514170040484
18785,"@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=((BarData)mCurrentData).getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValuesBarChart(entries,i);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(mValueFormatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mValueFormatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mValueFormatter.getFormattedValue(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=((BarData)mCurrentData).getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    if (mDrawValueAboveBar) {
      posOffset=-Utils.convertDpToPixel(5);
      negOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    }
 else {
      posOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
      negOffset=-Utils.convertDpToPixel(5);
    }
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValuesBarChart(entries,i);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(vals[k / 2],valuePoints[j],transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset));
            }
          }
        }
      }
    }
  }
}",0.898084965881576
18786,"/** 
 * Draws a value at the specified x and y position.
 * @param value
 * @param xPos
 * @param yPos
 */
private void drawValue(String val,float xPos,float yPos){
  if (mDrawUnitInChart) {
    mDrawCanvas.drawText(val + mUnit,xPos,yPos,mValuePaint);
  }
 else {
    mDrawCanvas.drawText(val,xPos,yPos,mValuePaint);
  }
}","/** 
 * Draws a value at the specified x and y position.
 * @param value
 * @param xPos
 * @param yPos
 */
private void drawValue(float val,float xPos,float yPos){
  String value=mValueFormatter.getFormattedValue(val);
  if (mDrawUnitInChart) {
    mDrawCanvas.drawText(value + mUnit,xPos,yPos,mValuePaint);
  }
 else {
    mDrawCanvas.drawText(value,xPos,yPos,mValuePaint);
  }
}",0.8490028490028491
18787,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}",0.9358129923802144
18788,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.9877227722772276
18789,"/** 
 * calculates the required number of digits for the values that might be drawn in the chart (if enabled)
 */
protected void calcFormats(){
  if (!mUseCustomFormatter) {
    float reference=0f;
    if (mOriginalData == null || mOriginalData.getXValCount() < 2) {
      reference=Math.max(Math.abs(mYChartMin),Math.abs(mYChartMax));
    }
 else {
      reference=mDeltaY;
    }
    int digits=Utils.getFormatDigits(reference);
    StringBuffer b=new StringBuffer();
    for (int i=0; i < digits; i++) {
      if (i == 0)       b.append(""String_Node_Str"");
      b.append(""String_Node_Str"");
    }
    mValueFormat=new DecimalFormat(""String_Node_Str"" + b.toString());
  }
}","/** 
 * calculates the required number of digits for the values that might be drawn in the chart (if enabled)
 */
protected void calcFormats(){
  if (!mUseCustomFormatter) {
    float reference=0f;
    if (mOriginalData == null || mOriginalData.getXValCount() < 2) {
      reference=Math.max(Math.abs(mYChartMin),Math.abs(mYChartMax));
    }
 else {
      reference=mDeltaY;
    }
    int digits=Utils.getDecimals(reference);
    StringBuffer b=new StringBuffer();
    for (int i=0; i < digits; i++) {
      if (i == 0)       b.append(""String_Node_Str"");
      b.append(""String_Node_Str"");
    }
    mValueFormat=new DecimalFormat(""String_Node_Str"" + b.toString());
  }
}",0.9881129271916792
18790,"@Override protected void drawValues(){
  if (!mDrawXVals && !mDrawYValues)   return;
  PointF center=getCenterCircleBox();
  float r=getRadius();
  float off=r / 2f;
  if (mDrawHole) {
    off=(r - (r / 100f * mHoleRadiusPercent)) / 2f;
  }
  r-=off;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      float offset=mDrawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.y);
      String val=""String_Node_Str"";
      float value=entries.get(j).getVal();
      if (mUsePercentValues)       val=mValueFormat.format(getPercentOfTotal(value)) + ""String_Node_Str"";
 else       val=mValueFormat.format(value);
      if (mDrawUnitInChart)       val=val + mUnit;
      if (mDrawXVals && mDrawYValues) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        mDrawCanvas.drawText(val,x,y,mValuePaint);
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (mDrawXVals && !mDrawYValues) {
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!mDrawXVals && mDrawYValues) {
        mDrawCanvas.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override protected void drawValues(){
  if (!mDrawXVals && !mDrawYValues)   return;
  PointF center=getCenterCircleBox();
  float r=getRadius();
  float off=r / 2f;
  if (mDrawHole) {
    off=(r - (r / 100f * mHoleRadiusPercent)) / 2f;
  }
  r-=off;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      float offset=mDrawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.y);
      String val=""String_Node_Str"";
      float value=entries.get(j).getVal();
      if (mUsePercentValues)       val=mValueFormat.format(Math.abs(getPercentOfTotal(value))) + ""String_Node_Str"";
 else       val=mValueFormat.format(value);
      if (mDrawUnitInChart)       val=val + mUnit;
      if (mDrawXVals && mDrawYValues) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        mDrawCanvas.drawText(val,x,y,mValuePaint);
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (mDrawXVals && !mDrawYValues) {
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!mDrawXVals && mDrawYValues) {
        mDrawCanvas.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9969915764139592
18791,"@Override protected void drawData(){
  float angle=mRotationAngle;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      float newangle=mDrawAngles[cnt];
      float sliceSpace=dataSet.getSliceSpace();
      if (!needsHighlight(entries.get(j).getXIndex(),i)) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawArc(mCircleBox,angle + sliceSpace / 2f,newangle * mPhaseY - sliceSpace / 2f,true,mRenderPaint);
      }
      angle+=newangle * mPhaseX;
      cnt++;
    }
  }
}","@Override protected void drawData(){
  float angle=mRotationAngle;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      float newangle=mDrawAngles[cnt];
      float sliceSpace=dataSet.getSliceSpace();
      Entry e=entries.get(j);
      if ((Math.abs(e.getVal()) > 0.000001)) {
        if (!needsHighlight(e.getXIndex(),i)) {
          mRenderPaint.setColor(dataSet.getColor(j));
          mDrawCanvas.drawArc(mCircleBox,angle + sliceSpace / 2f,newangle * mPhaseY - sliceSpace / 2f,true,mRenderPaint);
        }
      }
      angle+=newangle * mPhaseX;
      cnt++;
    }
  }
}",0.92998678996037
18792,"/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mCurrentData.getYValCount()];
  mAbsoluteAngles=new float[mCurrentData.getYValCount()];
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    ArrayList<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(entries.get(j).getVal());
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}","/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mCurrentData.getYValCount()];
  mAbsoluteAngles=new float[mCurrentData.getYValCount()];
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    ArrayList<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}",0.993006993006993
18793,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9959514170040484
18794,"public MyMarkerView(Context context,int layoutResource){
  super(context,layoutResource);
  tvContent=(TextView)findViewById(R.id.tvContent);
}","public MyMarkerView(Context context,int layoutResource){
  super(context,layoutResource);
  tvContent=(TextView)findViewById(R.id.tvContent);
  setOnClickListener(this);
}",0.910828025477707
18795,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mListener == null || mDataNotSet)   return false;
  if (!mTouchEnabled)   return false;
 else   return mListener.onTouch(this,event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  super.onTouchEvent(event);
  if (mListener == null || mDataNotSet)   return false;
  if (!mTouchEnabled)   return false;
 else   return mListener.onTouch(this,event);
}",0.9320843091334896
18796,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
  mDrawCanvas=new Canvas(mDrawBitmap);
  prepareContentRect();
  prepare();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.6111111111111112
18797,"@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    mOffsetTop=min;
    mOffsetRight=Math.max(min,legendRight);
    mOffsetBottom=Math.max(min,legendBottom);
    applyCalculatedOffsets();
  }
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend) {
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float min=Utils.convertDpToPixel(11f);
  mLegend.setOffsetTop(min);
  mLegend.setOffsetLeft(min);
  mOffsetLeft=min;
  mOffsetTop=min;
  mOffsetRight=Math.max(min,legendRight);
  mOffsetBottom=Math.max(min,legendBottom);
  applyCalculatedOffsets();
}",0.920306168392616
18798,"@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(8f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing+ mXLabels.mLabelWidth;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
    mOffsetRight=Math.max(legendRight,min);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
    mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
    mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    applyCalculatedOffsets();
  }
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend) {
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(8f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing+ mXLabels.mLabelWidth;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float min=Utils.convertDpToPixel(11f);
  mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
  mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
  mOffsetRight=Math.max(legendRight,min);
  mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
  mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
  mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
  mLegend.setOffsetTop(min);
  mLegend.setOffsetLeft(min);
  applyCalculatedOffsets();
}",0.9383921863260706
18799,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return true;
}","@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return super.onSingleTapUp(e);
}",0.9705882352941176
18800,"/** 
 * set if the user should be allowed to draw onto the chart
 * @param drawingEnabled
 */
public void setDrawingEnabled(boolean drawingEnabled){
  if (mListener instanceof BarLineChartTouchListener) {
    ((BarLineChartTouchListener)mListener).setDrawingEnabled(drawingEnabled);
  }
}","/** 
 * set if the user should be allowed to draw onto the chart
 * @param drawingEnabled
 */
public void setDrawingEnabled(boolean drawingEnabled){
  if (mListener instanceof BarLineChartTouchListener) {
    ((BarLineChartTouchListener<?>)mListener).setDrawingEnabled(drawingEnabled);
  }
}",0.9948186528497408
18801,"@Override public DataSet copy(){
  ArrayList<BarEntry> yVals=new ArrayList<BarEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((BarEntry)mYVals.get(i)).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarSpace=mBarSpace;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}","@Override public DataSet<BarEntry> copy(){
  ArrayList<BarEntry> yVals=new ArrayList<BarEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((BarEntry)mYVals.get(i)).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarSpace=mBarSpace;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}",0.9901960784313726
18802,"@Override public DataSet copy(){
  ArrayList<CandleEntry> yVals=new ArrayList<CandleEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((CandleEntry)mYVals.get(i)).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mBodySpace=mBodySpace;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<CandleEntry> copy(){
  ArrayList<CandleEntry> yVals=new ArrayList<CandleEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((CandleEntry)mYVals.get(i)).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mBodySpace=mBodySpace;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9842424242424244
18803,"/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet copy();","/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet<T> copy();",0.9872340425531916
18804,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mCircleSize=mCircleSize;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCubic=mDrawCubic;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mCircleSize=mCircleSize;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCubic=mDrawCubic;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9928934010152284
18805,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  PieDataSet copied=new PieDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mSliceSpace=mSliceSpace;
  copied.mShift=mShift;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  PieDataSet copied=new PieDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mSliceSpace=mSliceSpace;
  copied.mShift=mShift;
  return copied;
}",0.8998459167950693
18806,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  RadarDataSet copied=new RadarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  RadarDataSet copied=new RadarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.896
18807,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  ScatterDataSet copied=new ScatterDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShapeSize=mShapeSize;
  copied.mScatterShape=mScatterShape;
  copied.mCustomScatterPath=mCustomScatterPath;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  ScatterDataSet copied=new ScatterDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShapeSize=mShapeSize;
  copied.mScatterShape=mScatterShape;
  copied.mCustomScatterPath=mCustomScatterPath;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9252013808975834
18808,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.9709206627894216
18809,"/** 
 * enable this to force the y-axis labels to always start at zero
 * @param enabled
 */
public void setStartAtZero(boolean enabled){
  this.mStartAtZero=enabled;
  prepare();
  prepareMatrix();
  calculateOffsets();
}","/** 
 * enable this to force the y-axis labels to always start at zero
 * @param enabled
 */
public void setStartAtZero(boolean enabled){
  this.mStartAtZero=enabled;
  prepare();
  prepareMatrix();
}",0.9478672985781992
18810,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 4f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  applyCalculatedOffsets();
}","@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(7f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    mOffsetTop=Math.max(mLegend.getFullHeight(mLegendLabelPaint),min);
    applyCalculatedOffsets();
  }
}",0.5968008825151683
18811,"@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
}","@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}",0.9035087719298246
18812,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 5.5f);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,mOffsetBottom);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,mOffsetTop);
    mOffsetRight=Math.max(mXLabels.mLabelWidth,mOffsetRight);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,mOffsetLeft);
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  applyCalculatedOffsets();
}","@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(7f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
    mOffsetRight=Math.max(mXLabels.mLabelWidth,min);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
    mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
    mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    applyCalculatedOffsets();
  }
}",0.5071151358344114
18813,"/** 
 * calculates the full width the fully drawn legend will use in pixels
 * @return
 */
public float getFullWidth(Paint labelpaint){
  float width=0f;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      if (mColors[i] != -1)       width+=mFormSize + mFormToTextSpace;
      width+=Utils.calcTextWidth(labelpaint,mLegendLabels[i]) + mXEntrySpace;
    }
 else {
      width+=mFormSize + mStackSpace;
    }
  }
  return width;
}","/** 
 * calculates the full width the fully drawn legend will use in pixels
 * @return
 */
public float getFullWidth(Paint labelpaint){
  float width=0f;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      if (mColors[i] != -2)       width+=mFormSize + mFormToTextSpace;
      width+=Utils.calcTextWidth(labelpaint,mLegendLabels[i]) + mXEntrySpace;
    }
 else {
      width+=mFormSize + mStackSpace;
    }
  }
  return width;
}",0.9978586723768736
18814,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9340256566890652
18815,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9967585089141004
18816,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.9918985558295176
18817,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setLabelCount(7);
  yLabels.setPosition(YLabelPosition.RIGHT_INSIDE);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setLabelCount(7);
  yLabels.setPosition(YLabelPosition.LEFT);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}",0.9940425531914894
18818,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  String[] xVals=new String[30];
  for (int i=0; i < 30; i++)   xVals[i]=""String_Node_Str"" + i;
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < 10; i++)   yVals.add(new Entry((float)(Math.random() * 50) + 50f,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  mData=new LineData(xVals,set);
  mChart.setData(mData);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  String[] xVals=new String[30];
  for (int i=0; i < 30; i++)   xVals[i]=""String_Node_Str"" + i;
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < 10; i++)   yVals.add(new Entry((float)(Math.random() * 50) + 50f,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  LineData data=new LineData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}",0.9860911270983214
18819,"private void removeDataSet(){
  mData.removeDataSet(mData.getDataSetByIndex(mData.getDataSetCount() - 1));
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void removeDataSet(){
  LineData data=mChart.getDataOriginal();
  data.removeDataSet(data.getDataSetByIndex(data.getDataSetCount() - 1));
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.7629427792915532
18820,"private void addEntry(){
  LineDataSet set=mData.getDataSetByIndex(0);
  mData.addEntry(new Entry((float)(Math.random() * 50) + 50f,set.getEntryCount()),0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void addEntry(){
  LineData data=mChart.getDataOriginal();
  LineDataSet set=data.getDataSetByIndex(0);
  data.addEntry(new Entry((float)(Math.random() * 50) + 50f,set.getEntryCount()),0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.8974358974358975
18821,"private void removeLastEntry(){
  LineDataSet set=mData.getDataSetByIndex(0);
  Entry e=set.getEntryForXIndex(set.getEntryCount() - 1);
  mData.removeEntry(e,0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void removeLastEntry(){
  LineData data=mChart.getDataOriginal();
  LineDataSet set=data.getDataSetByIndex(0);
  Entry e=set.getEntryForXIndex(set.getEntryCount() - 1);
  data.removeEntry(e,0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.899581589958159
18822,"private void addDataSet(){
  int count=(mData.getDataSetCount() + 1);
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mData.getXValCount(); i++)   yVals.add(new Entry((float)(Math.random() * 50f) + 50f * count,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"" + count);
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  int color=getResources().getColor(mColors[count % mColors.length]);
  set.setColor(color);
  set.setCircleColor(color);
  set.setHighLightColor(color);
  mData.addDataSet(set);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void addDataSet(){
  LineData data=mChart.getDataOriginal();
  int count=(data.getDataSetCount() + 1);
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < data.getXValCount(); i++)   yVals.add(new Entry((float)(Math.random() * 50f) + 50f * count,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"" + count);
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  int color=getResources().getColor(mColors[count % mColors.length]);
  set.setColor(color);
  set.setCircleColor(color);
  set.setHighLightColor(color);
  data.addDataSet(set);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.876734693877551
18823,"@Override protected void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  BarData bd=(BarData)mCurrentData;
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}","@Override protected void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * mOriginalData.getGroupSpace() + mOriginalData.getGroupSpace() / 2f;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.9237918215613384
18824,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * mOriginalData.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.894973436861463
18825,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mOriginalData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mOriginalData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mOriginalData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=((BarData)mOriginalData).getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mOriginalData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mOriginalData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mOriginalData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mOriginalData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}",0.988133764832794
18826,"@Override protected void drawHighlights(){
  BarData bd=(BarData)mOriginalData;
  int setCount=mOriginalData.getDataSetCount();
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      if (e == null)       continue;
      float x=index * setCount + dataSetIndex + bd.getGroupSpace() / 2f + bd.getGroupSpace() * index;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  int setCount=mOriginalData.getDataSetCount();
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      if (e == null)       continue;
      float x=index * setCount + dataSetIndex + mOriginalData.getGroupSpace() / 2f + mOriginalData.getGroupSpace() * index;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.974201001155179
18827,"@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=bd.getDataSets();
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<BarDataSet> dataSets=mOriginalData.getDataSets();
  int setCount=mOriginalData.getDataSetCount();
  float space=mOriginalData.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}",0.976733029503478
18828,"@Override protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  BarData bd=(BarData)mCurrentData;
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace();
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}","@Override protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * mOriginalData.getGroupSpace();
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}",0.9545049063336308
18829,"/** 
 * returns the filtered ChartData object depending on approximator settings, current scale level and x- and y-axis ratio
 * @return
 */
private ChartData<? extends DataSet<? extends Entry>> getFilteredData(){
  return null;
}","/** 
 * returns the filtered ChartData object depending on approximator settings, current scale level and x- and y-axis ratio
 * @return
 */
private T getFilteredData(){
  return null;
}",0.8894230769230769
18830,"/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleRadarData<? extends DataSet<? extends Entry>>)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}","/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=mOriginalData.getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}",0.9366351056081572
18831,"@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=((CandleData)mCurrentData).getDataSets();
  float[] shadowPoints=new float[4];
  float[] bodyPoints=new float[4];
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mDrawCanvas.drawRect(leftBody,close,rightBody,open,mRenderPaint);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
        mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=mCurrentData.getDataSets();
  float[] shadowPoints=new float[4];
  float[] bodyPoints=new float[4];
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mDrawCanvas.drawRect(leftBody,close,rightBody,open,mRenderPaint);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
        mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
      }
    }
  }
}",0.9893692416725728
18832,"@Override protected void drawHighlights(){
  CandleData cd=(CandleData)mCurrentData;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    CandleDataSet set=cd.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mPhaseY;
    float high=e.getHigh() * mPhaseY;
    float[] vertPts=new float[]{xIndex,mYChartMax,xIndex,mYChartMin,xIndex + 1f,mYChartMax,xIndex + 1f,mYChartMin};
    float[] horPts=new float[]{0,low,mDeltaX,low,0,high,mDeltaX,high};
    transformPointArray(vertPts);
    transformPointArray(horPts);
    mDrawCanvas.drawLines(vertPts,mHighlightPaint);
    mDrawCanvas.drawLines(horPts,mHighlightPaint);
  }
}","@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    CandleDataSet set=mOriginalData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mPhaseY;
    float high=e.getHigh() * mPhaseY;
    float[] vertPts=new float[]{xIndex,mYChartMax,xIndex,mYChartMin,xIndex + 1f,mYChartMax,xIndex + 1f,mYChartMin};
    float[] horPts=new float[]{0,low,mDeltaX,low,0,high,mDeltaX,high};
    transformPointArray(vertPts);
    transformPointArray(horPts);
    mDrawCanvas.drawLines(vertPts,mHighlightPaint);
    mDrawCanvas.drawLines(horPts,mHighlightPaint);
  }
}",0.9659701492537314
18833,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}",0.936515997968512
18834,"/** 
 * sets up the content rect that restricts the chart surface
 */
protected void prepareContentRect(){
  mContentRect.set((int)mOffsetLeft,(int)mOffsetTop,getMeasuredWidth() - (int)mOffsetRight,getMeasuredHeight() - (int)mOffsetBottom + 1);
}","/** 
 * sets up the content rect that restricts the chart surface
 */
protected void prepareContentRect(){
  mContentRect.set((int)mOffsetLeft - 1,(int)mOffsetTop,getMeasuredWidth() - (int)mOffsetRight + 1,getMeasuredHeight() - (int)mOffsetBottom + 1);
}",0.984
18835,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_colored_lines);
  mCharts[0]=(LineChart)findViewById(R.id.chart1);
  mCharts[1]=(LineChart)findViewById(R.id.chart2);
  mCharts[2]=(LineChart)findViewById(R.id.chart3);
  mCharts[3]=(LineChart)findViewById(R.id.chart4);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LineData data=getData(36,100);
  for (int i=0; i < mCharts.length; i++)   setupChart(mCharts[i],data,mColors[i % mColors.length] & 0x90FFFFFF);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_colored_lines);
  mCharts[0]=(LineChart)findViewById(R.id.chart1);
  mCharts[1]=(LineChart)findViewById(R.id.chart2);
  mCharts[2]=(LineChart)findViewById(R.id.chart3);
  mCharts[3]=(LineChart)findViewById(R.id.chart4);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LineData data=getData(36,100);
  for (int i=0; i < mCharts.length; i++)   setupChart(mCharts[i],data,mColors[i % mColors.length]);
}",0.9902912621359224
18836,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_CENTER);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9933035714285714
18837,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9901960784313726
18838,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the Line-, Scatter-, or CandleStick-Chart.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset)   return null;
  if (this instanceof CandleStickChart)   base-=0.5;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (xTouchVal - base > 0.5) {
    xIndex=(int)base + 1;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=Utils.getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the Line-, Scatter-, or CandleStick-Chart.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset)   return null;
  if (this instanceof CandleStickChart)   base-=0.5;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (xTouchVal - base > 0.5) {
    xIndex=(int)base + 1;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=Utils.getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9904686258935664
18839,"/** 
 * Returns the actual position in pixels of the MarkerView for the given Entry in the given DataSet.
 * @param xIndex
 * @param dataSetIndex
 * @return
 */
private float[] getMarkerPosition(Entry e,int dataSetIndex){
  float xPos=(float)e.getXIndex();
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
 else   if (this instanceof RadarChart) {
    RadarChart rc=(RadarChart)this;
    float angle=rc.getSliceAngle() * e.getXIndex() + rc.getRotationAngle();
    float val=e.getVal() * rc.getFactor();
    PointF c=getCenter();
    PointF p=new PointF((float)(c.x + val * Math.cos(Math.toRadians(angle))),(float)(c.y + val * Math.sin(Math.toRadians(angle))));
    return new float[]{p.x,p.y};
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  return pts;
}","/** 
 * Returns the actual position in pixels of the MarkerView for the given Entry in the given DataSet.
 * @param xIndex
 * @param dataSetIndex
 * @return
 */
private float[] getMarkerPosition(Entry e,int dataSetIndex){
  float xPos=(float)e.getXIndex();
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
 else   if (this instanceof RadarChart) {
    RadarChart rc=(RadarChart)this;
    float angle=rc.getSliceAngle() * e.getXIndex() + rc.getRotationAngle();
    float val=e.getVal() * rc.getFactor();
    PointF c=getCenterOffsets();
    PointF p=new PointF((float)(c.x + val * Math.cos(Math.toRadians(angle))),(float)(c.y + val * Math.sin(Math.toRadians(angle))));
    return new float[]{p.x,p.y};
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  return pts;
}",0.9968623935454952
18840,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=mLegend.getStackSpace();
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -2)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -2) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -2) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
case BELOW_CHART_CENTER:
float fullSize=mLegend.getFullWidth(mLegendLabelPaint);
posX=getWidth() / 2f - fullSize / 2f;
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (mLegend.getColors()[i] != -2) posX+=formTextSpaceAndForm;
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
}
 else {
posX+=formSize + stackSpace;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=mLegend.getStackSpace();
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -2)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -2) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -2) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
case BELOW_CHART_CENTER:
float fullSize=mLegend.getFullWidth(mLegendLabelPaint);
posX=getWidth() / 2f - fullSize / 2f;
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (mLegend.getColors()[i] != -2) posX+=formTextSpaceAndForm;
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
}
 else {
posX+=formSize + stackSpace;
}
}
Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.bottom + ""String_Node_Str""+ getHeight()+ ""String_Node_Str""+ posY+ ""String_Node_Str""+ formSize);
break;
}
}",0.9762744469381212
18841,"/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}","/** 
 * Returns the center point of the chart (the whole View) in pixels.
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}",0.9386503067484664
18842,"/** 
 * returns the center of the chart taking offsets under consideration
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.left + mContentRect.width() / 2,mContentRect.top + mContentRect.height() / 2);
}","/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}",0.7295597484276729
18843,"@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}","@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float boxSize=diameter / 2f;
  PointF c=getCenterOffsets();
  mCircleBox.set(c.x - boxSize,c.y - boxSize,c.x + boxSize,c.y + boxSize);
}",0.4533678756476684
18844,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  drawHighlights();
  drawData();
  drawAdditional();
  drawValues();
  drawLegend();
  drawDescription();
  drawCenterText();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
  PointF c1=getCenter();
  PointF c2=getCenterCircleBox();
  Log.i(LOG_TAG,""String_Node_Str"" + c1.x + ""String_Node_Str""+ c1.y);
  Log.i(LOG_TAG,""String_Node_Str"" + c2.x + ""String_Node_Str""+ c2.y);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  drawHighlights();
  drawData();
  drawAdditional();
  drawValues();
  drawLegend();
  drawDescription();
  drawCenterText();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.8107588856868396
18845,"/** 
 * returns the angle relative to the chart center for the given point on the chart in degrees. The angle is always between 0 and 360°, 0° is NORTH, 90° is EAST, ...
 * @param x
 * @param y
 * @return
 */
public float getAngleForPoint(float x,float y){
  PointF c=getCenter();
  double tx=x - c.x, ty=y - c.y;
  double length=Math.sqrt(tx * tx + ty * ty);
  double r=Math.acos(ty / length);
  float angle=(float)Math.toDegrees(r);
  if (x > c.x)   angle=360f - angle;
  angle=angle + 90f;
  if (angle > 360f)   angle=angle - 360f;
  return angle;
}","/** 
 * returns the angle relative to the chart center for the given point on the chart in degrees. The angle is always between 0 and 360°, 0° is NORTH, 90° is EAST, ...
 * @param x
 * @param y
 * @return
 */
public float getAngleForPoint(float x,float y){
  PointF c=getCenterOffsets();
  double tx=x - c.x, ty=y - c.y;
  double length=Math.sqrt(tx * tx + ty * ty);
  double r=Math.acos(ty / length);
  float angle=(float)Math.toDegrees(r);
  if (x > c.x)   angle=360f - angle;
  angle=angle + 90f;
  if (angle > 360f)   angle=angle - 360f;
  return angle;
}",0.9936993699369936
18846,"/** 
 * Returns the distance of a certain point on the chart to the center of the chart.
 * @param x
 * @param y
 * @return
 */
public float distanceToCenter(float x,float y){
  PointF c=getCenter();
  float dist=0f;
  float xDist=0f;
  float yDist=0f;
  if (x > c.x) {
    xDist=x - c.x;
  }
 else {
    xDist=c.x - x;
  }
  if (y > c.y) {
    yDist=y - c.y;
  }
 else {
    yDist=c.y - y;
  }
  dist=(float)Math.sqrt(Math.pow(xDist,2.0) + Math.pow(yDist,2.0));
  return dist;
}","/** 
 * Returns the distance of a certain point on the chart to the center of the chart.
 * @param x
 * @param y
 * @return
 */
public float distanceToCenter(float x,float y){
  PointF c=getCenterOffsets();
  float dist=0f;
  float xDist=0f;
  float yDist=0f;
  if (x > c.x) {
    xDist=x - c.x;
  }
 else {
    xDist=c.x - x;
  }
  if (y > c.y) {
    yDist=y - c.y;
  }
 else {
    yDist=c.y - y;
  }
  dist=(float)Math.sqrt(Math.pow(xDist,2.0) + Math.pow(yDist,2.0));
  return dist;
}",0.9927461139896372
18847,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (this instanceof RadarChart)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 5.5f);
 else     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 4f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9553536151718688
18848,"@Override protected void drawValues(){
  if (mDrawYValues) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenter();
    float yoffset=Utils.convertDpToPixel(5f);
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      DataSet dataSet=mCurrentData.getDataSetByIndex(i);
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      for (int j=0; j < entries.size(); j++) {
        Entry e=entries.get(j);
        PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
        mDrawCanvas.drawText(Utils.formatNumber(e.getVal(),mValueFormatDigits,mSeparateTousands),p.x,p.y - yoffset,mValuePaint);
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenterOffsets();
    float yoffset=Utils.convertDpToPixel(5f);
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      DataSet dataSet=mCurrentData.getDataSetByIndex(i);
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      for (int j=0; j < entries.size(); j++) {
        Entry e=entries.get(j);
        PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
        mDrawCanvas.drawText(Utils.formatNumber(e.getVal(),mValueFormatDigits,mSeparateTousands),p.x,p.y - yoffset,mValuePaint);
      }
    }
  }
}",0.9949676491732566
18849,"/** 
 * Draws the x-labels of the chart.
 */
private void drawXLabels(){
  if (!mDrawXLabels)   return;
  mXLabelPaint.setTypeface(mXLabels.getTypeface());
  mXLabelPaint.setTextSize(mXLabels.getTextSize());
  mXLabelPaint.setColor(mXLabels.getTextColor());
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    String text=mCurrentData.getXVals().get(i);
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawText(text,p.x,p.y,mXLabelPaint);
  }
}","/** 
 * Draws the x-labels of the chart.
 */
private void drawXLabels(){
  if (!mDrawXLabels)   return;
  mXLabelPaint.setTypeface(mXLabels.getTypeface());
  mXLabelPaint.setTextSize(mXLabels.getTextSize());
  mXLabelPaint.setColor(mXLabels.getTextColor());
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    String text=mCurrentData.getXVals().get(i);
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawText(text,p.x,p.y,mXLabelPaint);
  }
}",0.9940928270042194
18850,"/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenter();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mSeparateTousands),p.x + 10,p.y - 5,mYLabelPaint);
  }
}","/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mSeparateTousands),p.x + 10,p.y - 5,mYLabelPaint);
  }
}",0.994413407821229
18851,"/** 
 * setup the x-axis labels
 */
private void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}","/** 
 * setup the x-axis labels
 */
private void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
  Log.i(LOG_TAG,""String_Node_Str"" + mXLabels.mLabelWidth);
}",0.8914549653579676
18852,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenter();
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      RadarDataSet set=(RadarDataSet)mCurrentData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      mHighlightPaint.setColor(set.getHighLightColor());
      int xIndex=mIndicesToHightlight[i].getXIndex();
      Entry e=set.getEntryForXIndex(xIndex);
      int j=set.getEntryPosition(e);
      float y=e.getVal();
      PointF p=getPosition(c,y * factor,sliceangle * j + mRotationAngle);
      float[] pts=new float[]{p.x,0,p.x,getHeight(),0,p.y,getWidth(),p.y};
      mDrawCanvas.drawLines(pts,mHighlightPaint);
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenterOffsets();
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      RadarDataSet set=(RadarDataSet)mCurrentData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      mHighlightPaint.setColor(set.getHighLightColor());
      int xIndex=mIndicesToHightlight[i].getXIndex();
      Entry e=set.getEntryForXIndex(xIndex);
      int j=set.getEntryPosition(e);
      float y=e.getVal();
      PointF p=getPosition(c,y * factor,sliceangle * j + mRotationAngle);
      float[] pts=new float[]{p.x,0,p.x,getHeight(),0,p.y,getWidth(),p.y};
      mDrawCanvas.drawLines(pts,mHighlightPaint);
    }
  }
}",0.9955668144395188
18853,"@Override protected void drawData(){
  ArrayList<RadarDataSet> dataSets=(ArrayList<RadarDataSet>)mCurrentData.getDataSets();
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    RadarDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    Path surface=new Path();
    for (int j=0; j < entries.size(); j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      Entry e=entries.get(j);
      PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
      if (j == 0)       surface.moveTo(p.x,p.y);
 else       surface.lineTo(p.x,p.y);
    }
    surface.close();
    if (dataSet.isDrawFilledEnabled()) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      mDrawCanvas.drawPath(surface,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setStyle(Paint.Style.STROKE);
    if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)     mDrawCanvas.drawPath(surface,mRenderPaint);
  }
}","@Override protected void drawData(){
  ArrayList<RadarDataSet> dataSets=(ArrayList<RadarDataSet>)mCurrentData.getDataSets();
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    RadarDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    Path surface=new Path();
    for (int j=0; j < entries.size(); j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      Entry e=entries.get(j);
      PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
      if (j == 0)       surface.moveTo(p.x,p.y);
 else       surface.lineTo(p.x,p.y);
    }
    surface.close();
    if (dataSet.isDrawFilledEnabled()) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      mDrawCanvas.drawPath(surface,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setStyle(Paint.Style.STROKE);
    if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)     mDrawCanvas.drawPath(surface,mRenderPaint);
  }
}",0.9970501474926252
18854,"/** 
 * Draws the spider web.
 */
private void drawWeb(){
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  mWebPaint.setStrokeWidth(mWebLineWidth);
  mWebPaint.setColor(mWebColor);
  mWebPaint.setAlpha(mWebAlpha);
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawLine(c.x,c.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mInnerWebLineWidth);
  mWebPaint.setColor(mWebColorInner);
  mWebPaint.setAlpha(mWebAlpha);
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mCurrentData.getXValCount(); i++) {
      float r=((mYChartMax / labelCount) * (j + 1)) * factor;
      PointF p1=getPosition(c,r,sliceangle * i + mRotationAngle);
      PointF p2=getPosition(c,r,sliceangle * (i + 1) + mRotationAngle);
      mDrawCanvas.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","/** 
 * Draws the spider web.
 */
private void drawWeb(){
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  mWebPaint.setStrokeWidth(mWebLineWidth);
  mWebPaint.setColor(mWebColor);
  mWebPaint.setAlpha(mWebAlpha);
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawLine(c.x,c.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mInnerWebLineWidth);
  mWebPaint.setColor(mWebColorInner);
  mWebPaint.setAlpha(mWebAlpha);
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mCurrentData.getXValCount(); i++) {
      float r=((mYChartMax / labelCount) * (j + 1)) * factor;
      PointF p1=getPosition(c,r,sliceangle * i + mRotationAngle);
      PointF p2=getPosition(c,r,sliceangle * (i + 1) + mRotationAngle);
      mDrawCanvas.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9964194373401536
18855,"/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mYLabels.isSeparateThousandsEnabled()),p.x + 10,p.y - 5,mYLabelPaint);
  }
}","/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    float val=r / factor;
    String label=Utils.formatNumber(val,mYLabels.mDecimals,mYLabels.isSeparateThousandsEnabled());
    mDrawCanvas.drawText(label,p.x + 10,p.y - 5,mYLabelPaint);
  }
}",0.8384214445271779
18856,"/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  return new String(out);
}","/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}",0.970425739356516
18857,"/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}","/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero) {
    out[ind--]='0';
    charCount+=1;
  }
  if (neg) {
    out[ind--]='-';
    charCount+=1;
  }
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}",0.97871008140263
18858,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=CANCEL;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.993123336291038
18859,"/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size();
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size() - 1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}",0.9965217391304348
18860,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor(i));
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        spline.lineTo((entries.size() - 1) * mPhaseX,mYChartMin);
        spline.lineTo(0,mYChartMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      float[] valuePoints=generateTransformedValues(entries,0f);
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        Path filled=generateFilledPath(entries);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor(i));
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      float[] valuePoints=generateTransformedValues(entries,0f);
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
  }
}",0.9641133896260556
18861,"/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<? extends Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}","/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<? extends Entry> entries,float fillMin){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),fillMin);
  filled.lineTo(entries.get(0).getXIndex(),fillMin);
  filled.close();
  return filled;
}",0.969747899159664
18862,"/** 
 * This method converts device specific pixels to density independent pixels. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param px A value in px (pixels) unit. Which we need to convert into db
 * @return A float value to represent dp equivalent to px value
 */
public static float convertPixelsToDp(float px){
  if (mRes == null)   throw new IllegalStateException(""String_Node_Str"");
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float dp=px / (metrics.densityDpi / 160f);
  return dp;
}","/** 
 * This method converts device specific pixels to density independent pixels. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param px A value in px (pixels) unit. Which we need to convert into db
 * @return A float value to represent dp equivalent to px value
 */
public static float convertPixelsToDp(float px){
  if (mRes == null) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return px;
  }
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float dp=px / (metrics.densityDpi / 160f);
  return dp;
}",0.9226248775710088
18863,"/** 
 * This method converts dp unit to equivalent pixels, depending on device density. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param dp A value in dp (density independent pixels) unit. Which we needto convert into pixels
 * @return A float value to represent px equivalent to dp depending ondevice density
 */
public static float convertDpToPixel(float dp){
  if (mRes == null)   throw new IllegalStateException(""String_Node_Str"");
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float px=dp * (metrics.densityDpi / 160f);
  return px;
}","/** 
 * This method converts dp unit to equivalent pixels, depending on device density. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param dp A value in dp (density independent pixels) unit. Which we needto convert into pixels
 * @return A float value to represent px equivalent to dp depending ondevice density
 */
public static float convertDpToPixel(float dp){
  if (mRes == null) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return dp;
  }
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float px=dp * (metrics.densityDpi / 160f);
  return px;
}",0.9292748433303492
18864,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  mChart.setValueTypeface(tf);
}",0.9375233819678264
18865,"@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)bd.getDataSets();
  int setCount=bd.getDataSetCount();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=(ArrayList<BarEntry>)dataSet.getYVals();
    float spaceSum=bd.getGroupSpace() / 2f;
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + spaceSum;
      float y=e.getVal();
      spaceSum+=bd.getGroupSpace();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}","@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)bd.getDataSets();
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=(ArrayList<BarEntry>)dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}",0.9687791239515378
18866,"/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}","/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}",0.7828863346104725
18867,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(false);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9976019184652278
18868,"@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      float x=index * mOriginalData.getDataSetCount() + dataSetIndex;
      prepareBar(x,e.getVal(),ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        float y=e.getVal();
        Path arrow=new Path();
        arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(index + 0.2f,y + offsetY);
        arrow.lineTo(index + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      float x=index * mOriginalData.getDataSetCount() + dataSetIndex;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9393278044522044
18869,"/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float spaceHalf=space / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}","/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 */
private void prepareBar(float x,float y,float barspace){
  float spaceHalf=barspace / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}",0.9927007299270072
18870,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  if (this instanceof BarChart) {
    xIndex/=mOriginalData.getDataSetCount();
  }
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  if (this instanceof BarChart) {
    dataSetIndex=((int)base) % mOriginalData.getDataSetCount();
  }
 else {
    dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  }
  if (dataSetIndex == -1)   return null;
  Toast.makeText(getContext(),""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex,Toast.LENGTH_SHORT).show();
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  if (this instanceof BarChart) {
    xIndex/=mOriginalData.getDataSetCount();
  }
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  if (this instanceof BarChart) {
    dataSetIndex=((int)base) % mOriginalData.getDataSetCount();
  }
 else {
    dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  }
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9431992631255756
18871,"/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=1;
  if (this instanceof BarChart)   step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.9805375347544022
18872,"/** 
 * draws the vertical grid
 */
protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}","/** 
 * draws the vertical grid
 */
protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=1;
  if (this instanceof BarChart)   step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}",0.962432915921288
18873,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9886963074604372
18874,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(2f);
  mChart.setWebLineWidthInner(0.75f);
  setData();
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(2f);
  mChart.setWebLineWidthInner(0.75f);
  setData();
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9195876288659792
18875,"public void setData(){
  float mult=100;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < 6; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < 6; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 6; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(getResources().getColor(R.color.vordiplom_1));
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(getResources().getColor(R.color.vordiplom_5));
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < 6; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < 6; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 6; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(getResources().getColor(R.color.vordiplom_1));
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(getResources().getColor(R.color.vordiplom_5));
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}",0.999
18876,"@Override protected void init(){
  super.init();
  mListener=new BarLineChartTouchListener(this,mMatrixTouch);
  mXLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mXLabelPaint.setColor(Color.BLACK);
  mXLabelPaint.setTextAlign(Align.CENTER);
  mXLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mYLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mYLabelPaint.setColor(Color.BLACK);
  mYLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mGridPaint=new Paint();
  mGridPaint.setColor(Color.GRAY);
  mGridPaint.setStrokeWidth(mGridWidth);
  mGridPaint.setStyle(Style.STROKE);
  mGridPaint.setAlpha(90);
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}","@Override protected void init(){
  super.init();
  mListener=new BarLineChartTouchListener(this,mMatrixTouch);
  mXLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mXLabelPaint.setColor(Color.BLACK);
  mXLabelPaint.setTextAlign(Align.CENTER);
  mXLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mYLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mYLabelPaint.setColor(Color.BLACK);
  mYLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mGridPaint=new Paint();
  mGridPaint.setColor(Color.GRAY);
  mGridPaint.setStrokeWidth(mGridWidth);
  mGridPaint.setStyle(Style.STROKE);
  mGridPaint.setAlpha(90);
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}",0.8968036529680365
18877,"/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleData)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}","/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleRadarData)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}",0.9963369963369964
18878,"/** 
 * initialize all paints and stuff
 */
protected void init(){
  Utils.init(getContext().getResources());
  mOffsetBottom=(int)Utils.convertDpToPixel(mOffsetBottom);
  mOffsetLeft=(int)Utils.convertDpToPixel(mOffsetLeft);
  mOffsetRight=(int)Utils.convertDpToPixel(mOffsetRight);
  mOffsetTop=(int)Utils.convertDpToPixel(mOffsetTop);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDrawPaint=new Paint();
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mValuePaint.setColor(Color.rgb(63,63,63));
  mValuePaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(9f));
  mLegendFormPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendFormPaint.setStyle(Paint.Style.FILL);
  mLegendFormPaint.setStrokeWidth(3f);
  mLegendLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendLabelPaint.setTextSize(Utils.convertDpToPixel(9f));
}","/** 
 * initialize all paints and stuff
 */
protected void init(){
  Utils.init(getContext().getResources());
  mOffsetBottom=(int)Utils.convertDpToPixel(mOffsetBottom);
  mOffsetLeft=(int)Utils.convertDpToPixel(mOffsetLeft);
  mOffsetRight=(int)Utils.convertDpToPixel(mOffsetRight);
  mOffsetTop=(int)Utils.convertDpToPixel(mOffsetTop);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDrawPaint=new Paint();
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mValuePaint.setColor(Color.rgb(63,63,63));
  mValuePaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(9f));
  mLegendFormPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendFormPaint.setStyle(Paint.Style.FILL);
  mLegendFormPaint.setStrokeWidth(3f);
  mLegendLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendLabelPaint.setTextSize(Utils.convertDpToPixel(9f));
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.9299410029498524
18879,"/** 
 * Returns the rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
 * @return
 */
public Rect getContentRect(){
  return mContentRect;
}","/** 
 * Returns the rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
 * @return
 */
public RectF getContentRect(){
  return mContentRect;
}",0.9974160206718348
18880,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
    }
  }
}",0.6623616236162362
18881,"/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2,getHeight() / 2);
}","/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}",0.9934640522875816
18882,"@Override protected void init(){
  super.init();
  mFilledPaint=new Paint();
  mFilledPaint.setStyle(Paint.Style.FILL);
  mFilledPaint.setColor(mColorDarkBlue);
  mFilledPaint.setAlpha(130);
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}","@Override protected void init(){
  super.init();
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.8442982456140351
18883,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setColor(dataSet.getFillColor());
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9801801801801802
18884,"@Override protected void prepareContentRect(){
  super.prepareContentRect();
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}","@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}",0.9698857736240912
18885,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  mRenderPaint.setStyle(Paint.Style.FILL);
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (dataSet.isDrawCirclesEnabled()) {
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getCircleColor(j));
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize(),mRenderPaint);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize() / 2,mCirclePaintInner);
      }
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  mRenderPaint.setStyle(Paint.Style.FILL);
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (dataSet.isDrawCirclesEnabled()) {
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize(),mRenderPaint);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize() / 2,mCirclePaintInner);
      }
    }
  }
}",0.9980601357904948
18886,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(30);
  mSeekBarY.setProgress(100);
}",0.9547432550043516
18887,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<CandleEntry> yVals1=new ArrayList<CandleEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.sin(i) * mult) + 100f;
    yVals1.add(new CandleEntry(i,val + 7,val - 7,val + 4,val - 4));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"" + mChart.getUnit());
  }
  CandleDataSet set1=new CandleDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.createColors(getApplicationContext(),ColorTemplate.VORDIPLOM_COLORS));
  CandleData data=new CandleData(xVals,set1);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<CandleEntry> yVals1=new ArrayList<CandleEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.sin(i) * mult) + 400f;
    boolean even=i % 2 == 0;
    yVals1.add(new CandleEntry(i,even ? val + 10 : val - 10,even ? val - 10 : val + 10,even ? val + 5 : val - 5,even ? val - 5 : val + 5));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
  }
  CandleDataSet set1=new CandleDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.createColors(getApplicationContext(),ColorTemplate.VORDIPLOM_COLORS));
  CandleData data=new CandleData(xVals,set1);
  mChart.setData(data);
  mChart.invalidate();
}",0.9059656218402428
18888,"/** 
 * setup the x-axis labels
 */
protected void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  for (int i=0; i < mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels(); i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mXLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mXLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}","/** 
 * setup the x-axis labels
 */
protected void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}",0.7892156862745098
18889,"/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mMatrixTouch.getValues(values);
  mXLabels.mXAxisLabelModulus=(int)Math.ceil((mCurrentData.getXValCount() * mXLabels.mXLabelWidth) / (mContentRect.width() * values[Matrix.MSCALE_X]));
}","/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mMatrixTouch.getValues(values);
  mXLabels.mXAxisLabelModulus=(int)Math.ceil((mCurrentData.getXValCount() * mXLabels.mLabelWidth) / (mContentRect.width() * values[Matrix.MSCALE_X]));
}",0.9983579638752051
18890,"@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.FILL);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=(ArrayList<CandleEntry>)dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    float[] shadowPoints=new float[4];
    float[] bodyPoints=new float[4];
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=(ArrayList<CandleEntry>)dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    float[] shadowPoints=new float[4];
    float[] bodyPoints=new float[4];
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close)       mRenderPaint.setStyle(Paint.Style.FILL);
 else       mRenderPaint.setStyle(Paint.Style.STROKE);
      mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.1891378655526016
18891,"/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  int sum=0;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / mXVals.size();
}","/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=0f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}",0.978978978978979
18892,"/** 
 * returns the average length (in characters) across all values in the x-vals array
 * @return
 */
public int getXValAverageLength(){
  return mXValAverageLength;
}","/** 
 * returns the average length (in characters) across all values in the x-vals array
 * @return
 */
public float getXValAverageLength(){
  return mXValAverageLength;
}",0.9823529411764704
18893,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_draw_chart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setOnDrawListener(this);
  mChart.setDrawingEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setAutoFinish(false);
  mChart.setDrawLegend(false);
  initWithDummyData();
  mChart.setYRange(-40f,40f,true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_draw_chart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setOnDrawListener(this);
  mChart.setDrawingEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setAutoFinish(false);
  mChart.setDrawLegend(false);
  initWithDummyData();
  mChart.setYRange(-40f,40f,true);
}",0.9961210240496507
18894,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(false);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9958819492107068
18895,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9982499124956248
18896,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(false);
  mSeekBarX.setProgress(20);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(false);
  mSeekBarX.setProgress(20);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.9973219068023568
18897,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.9974424552429668
18898,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.i(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.i(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9938338774029742
18899,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex < mCurrentData.getXVals().size() && xIndex < mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}",0.9566236811254396
18900,"/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null)   return;
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}","/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}",0.9937205651491364
18901,"/** 
 * Returns the first Entry object found at the given xIndex. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size();
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}",0.7584830339321357
18902,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  LineData data=null;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  LineData data=null;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.9994490358126722
18903,"@Override public boolean onSingleTapUp(MotionEvent e){
  float distance=mChart.distanceToCenter(e.getX(),e.getY());
  if (distance < mChart.getRadius() / 2 || distance > mChart.getRadius()) {
    mChart.highlightValues(null);
    mLastHighlight=null;
  }
 else {
    int index=mChart.getIndexForAngle(mChart.getAngleForPoint(e.getX(),e.getY()));
    int dataSetIndex=mChart.getDataSetIndexForIndex(index);
    Highlight h=new Highlight(index,0f,dataSetIndex);
    if (h.equalTo(mLastHighlight)) {
      mChart.highlightTouch(null);
      mLastHighlight=null;
    }
 else {
      mChart.highlightTouch(h);
      mLastHighlight=h;
    }
  }
  return true;
}","@Override public boolean onSingleTapUp(MotionEvent e){
  float distance=mChart.distanceToCenter(e.getX(),e.getY());
  if (distance < mChart.getRadius() / 2 || distance > mChart.getRadius()) {
    mChart.highlightValues(null);
    mLastHighlight=null;
  }
 else {
    int index=mChart.getIndexForAngle(mChart.getAngleForPoint(e.getX(),e.getY()));
    int dataSetIndex=mChart.getDataSetIndexForIndex(index);
    Highlight h=new Highlight(index,dataSetIndex);
    if (h.equalTo(mLastHighlight)) {
      mChart.highlightTouch(null);
      mLastHighlight=null;
    }
 else {
      mChart.highlightTouch(h);
      mLastHighlight=h;
    }
  }
  return true;
}",0.9671002295332825
18904,"/** 
 * constructor
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 */
public Highlight(int x,float val,int dataSet){
  this.mXIndex=x;
  this.mVal=val;
  this.mDataSetIndex=dataSet;
}","/** 
 * constructor
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 */
public Highlight(int x,int dataSet){
  this.mXIndex=x;
  this.mDataSetIndex=dataSet;
}",0.8976377952755905
18905,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9746121297602256
18906,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.5f);
  set1.setCircleSize(4f);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i % 30) + ""String_Node_Str"" + (i % 12)+ ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.5f);
  set1.setCircleSize(4f);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
}",0.9657594381035997
18907,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9876256767208044
18908,"/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=0.5f;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      mDrawCanvas.drawText(mCurrentData.getXVals().get(i),position[0],yPos,mXLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=0.5f;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.659297789336801
18909,"@Override protected void drawData(){
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
      mRenderPaint.setColor(dataSet.getColor(j / 2));
      if (isOffContentRight(valuePoints[j]))       break;
      if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))       continue;
      mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
    }
  }
}",0.085201793721973
18910,"@Override public boolean onTouchEvent(MotionEvent event){
  return mListener.onTouch(this,event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mTouchEnabled && mListener != null)   return mListener.onTouch(this,event);
 else   return super.onTouchEvent(event);
}",0.7021276595744681
18911,"@Override protected void init(){
  super.init();
  mFilledPaint=new Paint();
  mFilledPaint.setStyle(Paint.Style.FILL);
  mFilledPaint.setColor(mColorDarkBlue);
  mFilledPaint.setAlpha(130);
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}","@Override protected void init(){
  super.init();
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.8442982456140351
18912,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setColor(dataSet.getFillColor());
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9801801801801802
18913,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(true);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(50);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(50);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9901697944593388
18914,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new Entry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new Entry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.9959607616849394
18915,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (!mStartAtZero && getYMin() >= 0f) {
    mYChartMin=getYMin();
    mDeltaY=Math.abs(mYChartMax - mYChartMin);
  }
  mDeltaX++;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}",0.6382978723404256
18916,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      Highlight h=mIndicesToHightlight[i];
      int index=h.getXIndex();
      int dataSetIndex=h.getDataSetIndex();
      BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
      if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
        mHighlightPaint.setAlpha(120);
        Entry e=getEntryByDataSetIndex(index,dataSetIndex);
        float y=e.getSum() * mPhaseY;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        float left=index + ds.getBarSpace() / 2f;
        float right=index + 1f - ds.getBarSpace() / 2f;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      Highlight h=mIndicesToHightlight[i];
      int index=h.getXIndex();
      int dataSetIndex=h.getDataSetIndex();
      BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
      if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
        mHighlightPaint.setAlpha(120);
        Entry e=getEntryByDataSetIndex(index,dataSetIndex);
        prepareBar(e.getXIndex(),e.getSum(),ds.getBarSpace());
        mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      }
    }
  }
}",0.6452554744525547
18917,"/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float left=x + space / 2f;
  float right=x + 1f - space / 2f;
  float top=(y >= 0 ? y : 0) * mPhaseY;
  float bottom=(y <= 0 ? y : 0) * mPhaseY;
  mBarRect.set(left,top,right,bottom);
  transformRect(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}","/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float spaceHalf=space / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}",0.8538398018166804
18918,"/** 
 * draws the y-labels on the specified x-position
 * @param xPos
 * @param positions
 */
private void drawYLabels(float xPos,float[] positions){
  for (int i=0; i < mYLabels.mEntryCount; i++) {
    String text=Utils.formatNumber(mYLabels.mEntries[i],mYLabels.mDecimals,mSeparateTousands);
    if (!mYLabels.isDrawTopYLabelEntryEnabled() && i >= mYLabels.mEntryCount - 1)     return;
    if (mYLabels.isDrawUnitsInYLabelEnabled()) {
      mDrawCanvas.drawText(text + mUnit,xPos,positions[i * 2 + 1],mYLabelPaint);
    }
 else {
      mDrawCanvas.drawText(text,xPos,positions[i * 2 + 1],mYLabelPaint);
    }
  }
}","/** 
 * draws the y-labels on the specified x-position
 * @param xPos
 * @param positions
 */
private void drawYLabels(float xPos,float[] positions,float yOffset){
  for (int i=0; i < mYLabels.mEntryCount; i++) {
    String text=Utils.formatNumber(mYLabels.mEntries[i],mYLabels.mDecimals,mSeparateTousands);
    if (!mYLabels.isDrawTopYLabelEntryEnabled() && i >= mYLabels.mEntryCount - 1)     return;
    if (mYLabels.isDrawUnitsInYLabelEnabled()) {
      mDrawCanvas.drawText(text + mUnit,xPos,positions[i * 2 + 1] + yOffset,mYLabelPaint);
    }
 else {
      mDrawCanvas.drawText(text,xPos,positions[i * 2 + 1] + yOffset,mYLabelPaint);
    }
  }
}",0.9731437598736176
18919,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=mDeltaY / 100f * 15f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    mYChartMin=mYChartMin - space;
  }
  mYChartMax=mYChartMax + space;
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=Math.abs(mDeltaY / 100f * 15f);
  if (mStartAtZero) {
    if (mYChartMax < 0) {
      mYChartMax=0;
      mYChartMin=mYChartMin - space;
    }
 else {
      mYChartMin=0;
      mYChartMax=mYChartMax + space;
    }
  }
 else {
    mYChartMin=mYChartMin - space / 2f;
    mYChartMax=mYChartMax + space / 2f;
  }
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}",0.662269129287599
18920,"private Path generateFilledPath(ArrayList<Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}","/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}",0.9130028063610852
18921,"@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<ScatterDataSet> dataSets=(ArrayList<ScatterDataSet>)mCurrentData.getDataSets();
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length; j+=2) {
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        if (mDrawUnitInChart) {
          mDrawCanvas.drawText(mFormatValue.format(val) + mUnit,positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
 else {
          mDrawCanvas.drawText(mFormatValue.format(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<ScatterDataSet> dataSets=(ArrayList<ScatterDataSet>)mCurrentData.getDataSets();
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        if (mDrawUnitInChart) {
          mDrawCanvas.drawText(mFormatValue.format(val) + mUnit,positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
 else {
          mDrawCanvas.drawText(mFormatValue.format(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
      }
    }
  }
}",0.9954586739327884
18922,"@Override public Fragment getItem(int pos){
  Fragment f=null;
switch (pos) {
case 0:
    f=LineChartFrag.newInstance();
  break;
case 1:
f=BarChartFrag.newInstance();
break;
case 2:
f=ScatterChartFrag.newInstance();
break;
case 3:
f=PieChartFrag.newInstance();
break;
}
return f;
}","@Override public Fragment getItem(int pos){
  Fragment f=null;
switch (pos) {
case 0:
    f=SineCosineFragment.newInstance();
  break;
case 1:
f=ComplexityFragment.newInstance();
break;
case 2:
f=BarChartFrag.newInstance();
break;
case 3:
f=ScatterChartFrag.newInstance();
break;
case 4:
f=PieChartFrag.newInstance();
break;
}
return f;
}",0.6451612903225806
18923,"@Override public int getCount(){
  return 4;
}","@Override public int getCount(){
  return 5;
}",0.9782608695652174
18924,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9989440337909188
18925,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.99115670321896
18926,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}",0.8460575719649562
18927,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_listview_chart);
  ListView lv=(ListView)findViewById(R.id.listView1);
  ArrayList<ChartData> list=new ArrayList<ChartData>();
  for (int i=0; i < 20; i++) {
    list.add(generateData(i + 1));
  }
  ChartDataAdapter cda=new ChartDataAdapter(getApplicationContext(),list);
  lv.setAdapter(cda);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_listview_chart);
  ListView lv=(ListView)findViewById(R.id.listView1);
  ArrayList<BarData> list=new ArrayList<BarData>();
  for (int i=0; i < 20; i++) {
    list.add(generateData(i + 1));
  }
  ChartDataAdapter cda=new ChartDataAdapter(getApplicationContext(),list);
  lv.setAdapter(cda);
}",0.9851576994434136
18928,"public ChartDataAdapter(Context context,List<ChartData> objects){
  super(context,0,objects);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
}","public ChartDataAdapter(Context context,List<BarData> objects){
  super(context,0,objects);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
}",0.9872611464968152
18929,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ChartData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.995880535530381
18930,"protected ChartData generateBarData(int dataSets,float range,int count){
  ArrayList<BarDataSet> sets=new ArrayList<BarDataSet>();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    BarDataSet ds=new BarDataSet(entries,getLabel(i));
    ds.setColors(ColorTemplate.VORDIPLOM_COLORS,getActivity());
    sets.add(ds);
  }
  BarData d=new BarData(ChartData.generateXVals(0,count),sets);
  return d;
}","protected BarData generateBarData(int dataSets,float range,int count){
  ArrayList<BarDataSet> sets=new ArrayList<BarDataSet>();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    BarDataSet ds=new BarDataSet(entries,getLabel(i));
    ds.setColors(ColorTemplate.VORDIPLOM_COLORS,getActivity());
    sets.add(ds);
  }
  BarData d=new BarData(ChartData.generateXVals(0,count),sets);
  return d;
}",0.9928057553956836
18931,"protected ChartData generateScatterData(int dataSets,float range,int count){
  ArrayList<ScatterDataSet> sets=new ArrayList<ScatterDataSet>();
  ScatterShape[] shapes=ScatterChart.getAllPossibleShapes();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    ScatterDataSet ds=new ScatterDataSet(entries,getLabel(i));
    ds.setScatterShapeSize(12f);
    ds.setScatterShape(shapes[i % shapes.length]);
    ds.setColors(ColorTemplate.COLORFUL_COLORS,getActivity());
    ds.setScatterShapeSize(9f);
    sets.add(ds);
  }
  ScatterData d=new ScatterData(ChartData.generateXVals(0,count),sets);
  return d;
}","protected ScatterData generateScatterData(int dataSets,float range,int count){
  ArrayList<ScatterDataSet> sets=new ArrayList<ScatterDataSet>();
  ScatterShape[] shapes=ScatterChart.getAllPossibleShapes();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    ScatterDataSet ds=new ScatterDataSet(entries,getLabel(i));
    ds.setScatterShapeSize(12f);
    ds.setScatterShape(shapes[i % shapes.length]);
    ds.setColors(ColorTemplate.COLORFUL_COLORS,getActivity());
    ds.setScatterShapeSize(9f);
    sets.add(ds);
  }
  ScatterData d=new ScatterData(ChartData.generateXVals(0,count),sets);
  return d;
}",0.9921259842519684
18932,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.9951482479784368
18933,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDrawYValues(false);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(mChartData);
  holder.chart.animateX(1000);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDrawYValues(false);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}",0.9943883277216612
18934,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setDrawXValues(false);
  holder.chart.setUsePercentValues(true);
  holder.chart.setData(mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setDrawXValues(false);
  holder.chart.setUsePercentValues(true);
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}",0.9953198127925116
18935,"@Override protected void drawValues(){
  long starttime=System.currentTimeMillis();
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)mCurrentData.getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValues(entries,0.5f);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getSum();
          drawValue(mFormatValue.format(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]))           continue;
          Entry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mFormatValue.format(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getSum();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mFormatValue.format(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void drawValues(){
  long starttime=System.currentTimeMillis();
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)mCurrentData.getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValues(entries,0.5f);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getSum();
          drawValue(mFormatValue.format(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          Entry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mFormatValue.format(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getSum();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mFormatValue.format(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9633484162895928
18936,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  if (!mInvertYAxis)   offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
 else {
    offset.setTranslate(mOffsetLeft,-getOffsetTop());
    offset.postScale(1.0f,-1.0f);
  }
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  if (!mInvertYAxis)   offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
 else {
    offset.setTranslate(mOffsetLeft,-getOffsetTop());
    offset.postScale(1.0f,-1.0f);
  }
  mMatrixOffset.set(offset);
}",0.9953271028037384
18937,"/** 
 * Sets a new ChartData object for the chart.
 * @param data
 */
public void setData(ChartData data){
  if (data == null || !data.isValid()) {
    Log.e(LOG_TAG,""String_Node_Str"");
    mDataNotSet=true;
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mCurrentData=data;
  mOriginalData=data;
  prepare();
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new ChartData object for the chart.
 * @param data
 */
protected void setData(ChartData data){
  if (data == null || !data.isValid()) {
    Log.e(LOG_TAG,""String_Node_Str"");
    mDataNotSet=true;
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mCurrentData=data;
  mOriginalData=data;
  prepare();
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9850340136054422
18938,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal+ ""String_Node_Str""+ touchOffset);
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}",0.9260089686098656
18939,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setYEntrySpace(3f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9494869771112864
18940,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.957776590058792
18941,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  yLabels.setLabelCount(5);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  yLabels.setLabelCount(5);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9857747020376778
18942,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9848568281938326
18943,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace() + formSize;
  float xEntrySpace=mLegend.getXEntrySpace() + formSize;
  float yEntrySpace=mLegend.getYEntrySpace() + formSize;
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -1)     posX+=formToTextSpace;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + xEntrySpace;
  }
 else {
    posX+=xEntrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mLegend.getOffsetRight() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -1) posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=xEntrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mLegend.getOffsetRight() + Utils.convertDpToPixel(9f);
posY=mLegend.getOffsetTop();
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
posY=Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") * 1.5f;
}
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -1) x+=formToTextSpace;
mLegend.drawLabel(mDrawCanvas,x,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textSize + formSize+ mLegend.getYEntrySpace(),mLegendLabelPaint,i);
posY+=yEntrySpace;
}
posY+=mLegend.getYEntrySpace() + textSize;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=Utils.convertDpToPixel(3f);
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -1)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -1) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -1) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
}
}",0.7935816164817749
18944,"/** 
 * returns the maximum length in pixels over all legend labels + their forms
 * @param p the paint object used for rendering the text
 * @return
 */
public int getMaximumEntryLength(Paint p){
  int max=0;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      int length=Utils.calcTextWidth(p,mLegendLabels[i]);
      if (length > max)       max=length;
    }
  }
  return max + (int)mFormSize * 4;
}","/** 
 * returns the maximum length in pixels over all legend labels + their forms
 * @param p the paint object used for rendering the text
 * @return
 */
public int getMaximumEntryLength(Paint p){
  int max=0;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      int length=Utils.calcTextWidth(p,mLegendLabels[i]);
      if (length > max)       max=length;
    }
  }
  return max + (int)mFormSize;
}",0.9954441913439636
18945,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setUsePercentValues(true);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(23f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generateLessData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setUsePercentValues(true);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generateLessData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}",0.9987546699875468
18946,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float entrySpace=mLegend.getEntrySpace();
  float textSize=Utils.convertPixelsToDp(mLegendLabelPaint.getTextSize());
  float textDrop=(textSize + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mOffsetLeft;
  posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  posX+=formToTextSpace;
  if (labels[i] != null) {
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + entrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mOffsetRight;
posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=entrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mOffsetRight + formSize;
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
}
posY=mOffsetTop;
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
mLegend.drawLabel(mDrawCanvas,posX + formToTextSpace,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop + entrySpace,mLegendLabelPaint,i);
posY+=entrySpace;
}
posY+=entrySpace;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float entrySpace=mLegend.getEntrySpace();
  float textSize=Utils.convertPixelsToDp(mLegendLabelPaint.getTextSize());
  float textDrop=(textSize + formSize) / 2f + textSize / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mOffsetLeft;
  posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  posX+=formToTextSpace;
  if (labels[i] != null) {
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + entrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mOffsetRight;
posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=entrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mOffsetRight + formSize;
posY=mOffsetTop;
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
posY=Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") * 1.5f;
}
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
mLegend.drawLabel(mDrawCanvas,posX + formToTextSpace,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop + entrySpace,mLegendLabelPaint,i);
posY+=entrySpace;
}
posY+=entrySpace;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}",0.97146899316199
18947,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<DataSet> dataSets;
  dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    Paint paint=mRenderPaint;
    if (mDrawSpline) {
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      paint.setColor(colors.get(i % colors.size()));
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,paint);
    }
 else {
      for (int j=0; j < valuePoints.length - 2; j+=2) {
        paint.setColor(colors.get(j % colors.size()));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],paint);
      }
    }
    if (mDrawFilled && entries.size() > 0) {
      paint.setAlpha(85);
      Path filled=new Path();
      filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size(); x++) {
        filled.lineTo(entries.get(x).getXIndex(),entries.get(x).getVal());
      }
      filled.lineTo(entries.get(entries.size() - 1).getXIndex(),mYChartMin);
      filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
      filled.close();
      transformPath(filled);
      mDrawCanvas.drawPath(filled,paint);
      paint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<DataSet> dataSets;
  dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    Paint paint=mRenderPaint;
    if (mDrawCubic) {
      paint.setColor(colors.get(i % colors.size()));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,paint);
    }
 else {
      for (int j=0; j < valuePoints.length - 2; j+=2) {
        paint.setColor(colors.get(j % colors.size()));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],paint);
      }
    }
    if (mDrawFilled && entries.size() > 0) {
      paint.setAlpha(85);
      Path filled=new Path();
      filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size(); x++) {
        filled.lineTo(entries.get(x).getXIndex(),entries.get(x).getVal());
      }
      filled.lineTo(entries.get(entries.size() - 1).getXIndex(),mYChartMin);
      filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
      filled.close();
      transformPath(filled);
      mDrawCanvas.drawPath(filled,paint);
      paint.setAlpha(255);
    }
  }
}",0.9700569166048008
18948,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
private void drawCenterText(){
  if (mDrawCenterText) {
    PointF c=getCenterCircleBox();
    String[] lines=mCenterText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]) * 1.2f;
    float totalheight=lineHeight * lines.length;
    int cnt=lines.length;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      mDrawCanvas.drawText(line,c.x,c.y + lineHeight * cnt - lineHeight / 2 - totalheight * 0.45f,mCenterTextPaint);
      cnt--;
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
private void drawCenterText(){
  if (mDrawCenterText) {
    PointF c=getCenterCircleBox();
    String[] lines=mCenterText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]);
    float linespacing=lineHeight * 0.2f;
    float totalheight=lineHeight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=c.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      mDrawCanvas.drawText(line,c.x,y + lineHeight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}",0.783744557329463
18949,"@Override public void calculateOffsets(){
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    mOffsetBottom=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override public void calculateOffsets(){
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegendLabelPaint.setTextAlign(Align.LEFT);
    mOffsetTop=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    mOffsetBottom=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9621951219512196
18950,"@Override protected void drawData(){
  ArrayList<DataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] pos=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ScatterShape shape=mScatterShapes[i % mScatterShapes.length];
    for (int j=0; j < pos.length; j+=2) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      if (isOffContentRight(pos[j]))       break;
      float shapeHalf=mShapeSize / 2f;
      if (j != 0 && isOffContentLeft(pos[j - 1]) && isOffContentTop(pos[j + 1]) && isOffContentBottom(pos[j + 1]))       continue;
      if (shape == ScatterShape.SQUARE) {
        mDrawCanvas.drawRect(pos[j] - shapeHalf,pos[j + 1] - shapeHalf,pos[j] + shapeHalf,pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.CIRCLE) {
        mDrawCanvas.drawCircle(pos[j],pos[j + 1],mShapeSize / 2f,mRenderPaint);
      }
 else       if (shape == ScatterShape.CROSS) {
        mDrawCanvas.drawLine(pos[j] - shapeHalf,pos[j + 1],pos[j] + shapeHalf,pos[j + 1],mRenderPaint);
        mDrawCanvas.drawLine(pos[j],pos[j + 1] - shapeHalf,pos[j],pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.TRIANGLE) {
        Path tri=new Path();
        tri.moveTo(pos[j],pos[j + 1] - shapeHalf);
        tri.lineTo(pos[j] + shapeHalf,pos[j + 1] + shapeHalf);
        tri.lineTo(pos[j] - shapeHalf,pos[j + 1] + shapeHalf);
        tri.close();
        mDrawCanvas.drawPath(tri,mRenderPaint);
      }
 else       if (shape == ScatterShape.CUSTOM) {
        if (mCustomScatterPath == null)         return;
        transformPath(mCustomScatterPath);
        mDrawCanvas.drawPath(mCustomScatterPath,mRenderPaint);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<DataSet> dataSets=mCurrentData.getDataSets();
  float shapeHalf=mShapeSize / 2f;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] pos=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ScatterShape shape=mScatterShapes[i % mScatterShapes.length];
    for (int j=0; j < pos.length; j+=2) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      if (isOffContentRight(pos[j]))       break;
      if (j != 0 && isOffContentLeft(pos[j - 1]) && isOffContentTop(pos[j + 1]) && isOffContentBottom(pos[j + 1]))       continue;
      if (shape == ScatterShape.SQUARE) {
        mDrawCanvas.drawRect(pos[j] - shapeHalf,pos[j + 1] - shapeHalf,pos[j] + shapeHalf,pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.CIRCLE) {
        mDrawCanvas.drawCircle(pos[j],pos[j + 1],mShapeSize / 2f,mRenderPaint);
      }
 else       if (shape == ScatterShape.CROSS) {
        mDrawCanvas.drawLine(pos[j] - shapeHalf,pos[j + 1],pos[j] + shapeHalf,pos[j + 1],mRenderPaint);
        mDrawCanvas.drawLine(pos[j],pos[j + 1] - shapeHalf,pos[j],pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.TRIANGLE) {
        Path tri=new Path();
        tri.moveTo(pos[j],pos[j + 1] - shapeHalf);
        tri.lineTo(pos[j] + shapeHalf,pos[j + 1] + shapeHalf);
        tri.lineTo(pos[j] - shapeHalf,pos[j + 1] + shapeHalf);
        tri.close();
        mDrawCanvas.drawPath(tri,mRenderPaint);
      }
 else       if (shape == ScatterShape.CUSTOM) {
        if (mCustomScatterPath == null)         return;
        transformPath(mCustomScatterPath);
        mDrawCanvas.drawPath(mCustomScatterPath,mRenderPaint);
      }
    }
  }
}",0.9805263157894736
18951,"/** 
 * Loads a DataSet from a textfile from the sd-card. Textfile syntax is: labelstring<linebreak>500.99#0<linebreak>350.80#1<linebreak>and so on...
 * @param path the name of the file on the sd card (path if needed)
 * @return
 */
public static DataSet dataSetFromFile(String path){
  File sdcard=Environment.getExternalStorageDirectory();
  File file=new File(sdcard,path);
  ArrayList<Entry> entries=new ArrayList<Entry>();
  String label=""String_Node_Str"";
  try {
    @SuppressWarnings(""String_Node_Str"") BufferedReader br=new BufferedReader(new FileReader(file));
    String line=br.readLine();
    label=line;
    while ((line=br.readLine()) != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new Entry(Float.valueOf(split[0]),Integer.valueOf(split[1])));
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
  DataSet ds=new DataSet(entries,label);
  return ds;
}","/** 
 * Loads a DataSet from a textfile from the sd-card. Textfile syntax is: labelstring<linebreak>500.99#0<linebreak>350.80#1<linebreak>and so on...
 * @param path the name of the file on the sd card (path if needed)
 * @return
 */
public static DataSet dataSetFromFile(String path){
  File sdcard=Environment.getExternalStorageDirectory();
  File file=new File(sdcard,path);
  ArrayList<Entry> entries=new ArrayList<Entry>();
  String label=""String_Node_Str"";
  try {
    @SuppressWarnings(""String_Node_Str"") BufferedReader br=new BufferedReader(new FileReader(file));
    String line=br.readLine();
    label=line;
    while ((line=br.readLine()) != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new Entry(Float.parseFloat(split[0]),Integer.parseInt(split[1])));
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
  DataSet ds=new DataSet(entries,label);
  return ds;
}",0.982646420824295
18952,"@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}","@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouch(save);
}",0.9853658536585366
18953,"/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}","/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. First set the scale minima, then center the viewport. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouch(save);
    }
  }
);
}",0.9667673716012084
18954,"private boolean alreadyCounted(ArrayList<String> countedLabels,String label){
  for (int i=0; i < countedLabels.size(); i++) {
    if (countedLabels.get(i).equals(label))     return true;
  }
  return false;
}","private boolean alreadyCounted(ArrayList<String> countedLabels,String label){
  if (label == null)   return true;
  for (int i=0; i < countedLabels.size(); i++) {
    if (countedLabels.get(i).equals(label))     return true;
  }
  return false;
}",0.920704845814978
18955,"/** 
 * Does all necessary calculations, if the underlying data has changed
 */
private void doCalculations(){
  calcTypes();
  calcMinMax();
  calcYValueSum();
}","/** 
 * Does all necessary calculations, if the underlying data has changed
 */
private void doCalculations(){
  calcMinMax();
  calcYValueSum();
}",0.9514563106796116
18956,"private void init(ArrayList<String> xVals,ArrayList<DataSet> dataSets){
  this.mXVals=xVals;
  this.mDataSets=dataSets;
  calcTypes();
  calcMinMax();
  calcYValueSum();
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > xVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","private void init(ArrayList<String> xVals,ArrayList<DataSet> dataSets){
  this.mXVals=xVals;
  this.mDataSets=dataSets;
  calcMinMax();
  calcYValueSum();
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > xVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.9779735682819384
18957,"/** 
 * Call this method to create a new drawing DataSet
 * @param type the type of the new DataSet
 */
public void createNewDrawingDataSet(ChartData chartData){
  if (mCurrentDrawingDataSet != null && mCurrentDrawingEntries != null) {
    finishNewDrawingEntry(chartData);
  }
  if (!chartData.getLabels().contains(mLastDrawnDataSetIndex)) {
    chartData.getLabels().add(""String_Node_Str"" + mLastDrawnDataSetIndex);
  }
  mCurrentDrawingEntries=new ArrayList<Entry>();
  this.mCurrentDrawingDataSet=new DataSet(mCurrentDrawingEntries,""String_Node_Str"" + mLastDrawnDataSetIndex);
  chartData.getDataSets().add(mCurrentDrawingDataSet);
}","/** 
 * Call this method to create a new drawing DataSet
 * @param type the type of the new DataSet
 */
public void createNewDrawingDataSet(ChartData chartData){
  if (mCurrentDrawingDataSet != null && mCurrentDrawingEntries != null) {
    finishNewDrawingEntry(chartData);
  }
  mCurrentDrawingEntries=new ArrayList<Entry>();
  this.mCurrentDrawingDataSet=new DataSet(mCurrentDrawingEntries,""String_Node_Str"" + mLastDrawnDataSetIndex);
  chartData.getDataSets().add(mCurrentDrawingDataSet);
}",0.5823008849557522
18958,"/** 
 * calculates the approximate width of a text, depending on a demo text avoid repeated calls (e.g. inside drawing methods)
 * @param paint
 * @param demoText
 * @return
 */
public static int calcTextWidth(Paint paint,String demoText){
  Rect r=new Rect();
  paint.getTextBounds(demoText,0,demoText.length(),r);
  return r.width();
}","/** 
 * calculates the approximate width of a text, depending on a demo text avoid repeated calls (e.g. inside drawing methods)
 * @param paint
 * @param demoText
 * @return
 */
public static int calcTextWidth(Paint paint,String demoText){
  return (int)paint.measureText(demoText);
}",0.7922705314009661
18959,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(new int[]{R.color.colorful_1},this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setColorTemplate(ct);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(1f);
  mChart.setCircleSize(4f);
  mChart.setDrawBorder(true);
  mChart.setBorderStyles(new BorderStyle[]{BorderStyle.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setYLabelCount(6);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.enableDashedLine(10f,5f,0f);
  setData(45,100);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(new int[]{R.color.colorful_1},this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setColorTemplate(ct);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(1f);
  mChart.setCircleSize(4f);
  mChart.setDrawBorder(true);
  mChart.setBorderStyles(new BorderStyle[]{BorderStyle.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setYLabelCount(6);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.enableDashedLine(10f,5f,0f);
  setData(45,100);
  mChart.setScaleMinima(3f,3f);
  mChart.centerViewPort(10,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9802590993214064
18960,"@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] + getOffsetBottom();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}","@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}",0.9868263473053892
18961,"/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] + getOffsetBottom();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}","/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}",0.9943502824858758
18962,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  prepareContentRect();
  Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.width() + ""String_Node_Str""+ mContentRect.height());
  if (this instanceof BarLineChartBase) {
    if (!((BarLineChartBase)this).hasFixedYValues())     prepareMatrix();
  }
 else {
    prepareMatrix();
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  prepareContentRect();
  Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.width() + ""String_Node_Str""+ mContentRect.height());
  if (this instanceof BarLineChartBase) {
    BarLineChartBase b=(BarLineChartBase)this;
    if (!b.hasFixedYValues() && !mMatrixOnLayoutPrepared) {
      prepareMatrix();
      mMatrixOnLayoutPrepared=true;
    }
  }
 else {
    prepareMatrix();
  }
}",0.8076923076923077
18963,"/** 
 * setup all the matrices that will be used for scaling the coordinates to the display
 */
protected void prepareMatrix(){
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-mYChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
  mMatrixOffset.reset();
  mMatrixOffset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
}","/** 
 * setup all the matrices that will be used for scaling the coordinates to the display
 */
protected void prepareMatrix(){
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-mYChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
  mMatrixOffset.reset();
  mMatrixOffset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9655172413793104
18964,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (!mStartAtZero && getYMin() >= 0f) {
    mYChartMin=getYMin();
    mDeltaY=Math.abs(mYChartMax - mYChartMin);
  }
  mDeltaX++;
}",0.6382978723404256
18965,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float spaceTop=(mData.getYMax() - mYChartMin) / 100f * 10f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    float spaceBottom=(mData.getYMax() - mYChartMin) / 100f * 10f;
    mYChartMin=mYChartMin - spaceBottom;
  }
  mDeltaY=(mData.getYMax() + spaceTop) - mYChartMin;
  mYChartMax=mYChartMin + mDeltaY;
  Log.i(LOG_TAG,""String_Node_Str"" + mDeltaX + ""String_Node_Str""+ mDeltaY);
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=mDeltaY / 100f * 10f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    mYChartMin=mYChartMin - space;
  }
  mYChartMax=mYChartMax + space;
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}",0.313624678663239
18966,"/** 
 * setup the Y legend
 */
protected void prepareYLegend(){
  ArrayList<Float> yLegend=new ArrayList<Float>();
  if (mRoundedYLegend) {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    double log10=Math.log10(interval);
    int exp=(int)Math.floor(log10);
    double tenPowExp=POW_10[exp + 5];
    double multi=Math.round(interval / tenPowExp);
    if (multi >= 1) {
      if (multi > 2 && multi < 5) {
        multi=5;
      }
 else       if (multi > 5 && multi < 10) {
        multi=10;
      }
    }
    float step=(float)(multi * tenPowExp);
    float val=0;
    if (step >= 1f)     val=(int)(mYChartMin / step) * step;
 else {
      val=mYChartMin;
    }
    while (val <= mDeltaY + step + mYChartMin) {
      yLegend.add(val);
      val=val + step;
    }
    if (step >= 1f)     mYChartMin=(int)(mYChartMin / step) * step;
    mDeltaY=val - step - mYChartMin;
    mYChartMax=yLegend.get(yLegend.size() - 1);
  }
 else {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    yLegend.add(mYChartMin);
    for (int i=1; i < mYLegendCount - 1; i++) {
      yLegend.add(mYChartMin + ((float)i * interval));
    }
    yLegend.add(mDeltaY + mYChartMin);
  }
  mYLegend=yLegend.toArray(new Float[0]);
}","/** 
 * setup the Y legend
 */
protected void prepareYLegend(){
  ArrayList<Float> yLegend=new ArrayList<Float>();
  if (mRoundedYLegend) {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    double log10=Math.log10(interval);
    int exp=(int)Math.floor(log10);
    double tenPowExp=POW_10[exp + 5];
    double multi=Math.round(interval / tenPowExp);
    if (multi >= 1) {
      if (multi > 2 && multi < 5) {
        multi=5;
      }
 else       if (multi > 5 && multi < 10) {
        multi=10;
      }
    }
    float step=(float)(multi * tenPowExp);
    float min=mYChartMin;
    float val=0;
    if (step >= 1f) {
      val=(int)(mYChartMin / step) - step;
      mYChartMin=val;
    }
 else {
      val=mYChartMin;
    }
    if (mStartAtZero) {
      val=0;
      mYChartMin=0;
    }
 else {
      if (getYMin() >= 0 && this instanceof BarChart) {
        val=0;
        mYChartMin=0;
      }
    }
    while (val <= mDeltaY + step + min) {
      yLegend.add(val);
      val=val + step;
    }
    mDeltaY=val - step - mYChartMin;
  }
 else {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    yLegend.add(mYChartMin);
    for (int i=1; i < mYLegendCount - 1; i++) {
      yLegend.add(mYChartMin + ((float)i * interval));
    }
    yLegend.add(mDeltaY + mYChartMin);
  }
  mYChartMax=yLegend.get(yLegend.size() - 1);
  mYLegend=yLegend.toArray(new Float[0]);
  Log.i(LOG_TAG,""String_Node_Str"" + mDeltaX + ""String_Node_Str""+ mDeltaY);
  Log.i(LOG_TAG,""String_Node_Str"" + mYChartMax + ""String_Node_Str""+ mYChartMin);
  Log.i(LOG_TAG,""String_Node_Str"" + getYMax() + ""String_Node_Str""+ getYMin());
}",0.5212765957446809
18967,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mData.getYMax();
  }
  mDeltaY=Math.abs(mData.getYMax() - mData.getYMin());
  mDeltaX=mData.getXVals().size() - 1;
}",0.8666666666666667
18968,"/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override protected void prepare(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareXLegend();
  prepareYLegend();
  calcFormats();
  prepareMatrix();
}","/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareXLegend();
  prepareYLegend();
  calcFormats();
  prepareMatrix();
}",0.9760589318600368
18969,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}",0.9984051036682616
18970,"private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 25; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 25; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRange(10,40,0);
  mChart.invalidate();
}",0.9666283084004604
18971,"private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 148; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRange(10f,40f);
  mChart.invalidate();
}","private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 148; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRangeFixed(false);
  mChart.setYRange(-40f,40f);
  mChart.invalidate();
}",0.960342979635584
18972,"@Override public void notifyDataSetChanged(){
  calcMinMax(mFixedYValues);
}","@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
  }
 else {
    calcMinMax(mFixedYValues);
  }
}",0.7272727272727273
18973,"/** 
 * sets the effective range of y-values the chart can display
 * @param minY
 * @param maxY
 */
public void setYRange(float minY,float maxY){
  mFixedYValues=true;
  mYChartMin=minY;
  mYChartMax=maxY;
  mDeltaY=mYChartMax - mYChartMin;
  calcFormats();
  prepareMatrix();
  invalidate();
}","/** 
 * sets the effective range of y-values the chart can display
 * @param minY
 * @param maxY
 */
public void setYRange(float minY,float maxY){
  mYChartMin=minY;
  mYChartMax=maxY;
  if (minY < 0) {
    mStartAtZero=false;
  }
  mDeltaY=mYChartMax - mYChartMin;
  calcFormats();
  prepareMatrix();
  invalidate();
}",0.5211726384364821
18974,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals1=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals1.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set1=new DataSet(yVals1,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.996956786366403
18975,"@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      Paint paint=mDrawPaints[j % mDrawPaints.length];
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,paint);
      if (m3DEnabled) {
        int c=paint.getColor();
        paint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),paint);
        paint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),paint);
        paint.setColor(c);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    Paint paint=mDrawPaints[i % mDrawPaints.length];
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      if (mData.getDataSetCount() == 1)       paint=mDrawPaints[j % mDrawPaints.length];
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,paint);
      if (m3DEnabled) {
        int c=paint.getColor();
        paint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),paint);
        paint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),paint);
        paint.setColor(c);
      }
    }
  }
}",0.978844056706652
18976,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index < mData.getYValCount() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=getYValue(index);
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index < mData.getYValCount() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=getYValueByDataSetIndex(index,mIndicesToHightlight[i].getDataSetIndex());
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}",0.9724770642201837
18977,"/** 
 * returns the Highlight object (x index and DataSet index) of the selected value at the given touch point
 * @param x
 * @param y
 * @return
 */
public Highlight getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if (this instanceof LineChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int yIndex=0;
  if (this instanceof LineChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<Float> valsAtIndex=getYValsAtIndex(xIndex);
  yIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (yIndex == -1)   return null;
  return new Highlight(xIndex,yIndex);
}","/** 
 * returns the Highlight object (x index and DataSet index) of the selected value at the given touch point
 * @param x
 * @param y
 * @return
 */
public Highlight getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if (this instanceof LineChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int yIndex=0;
  if (this instanceof LineChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  yIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (yIndex == -1)   return null;
  return new Highlight(xIndex,yIndex);
}",0.9947183098591548
18978,"/** 
 * returns the index DataSet that contains the closest value    
 * @param valsAtIndex
 * @return
 */
private int getClosestDataSetIndex(ArrayList<Float> valsAtIndex,float val){
  int index=-1;
  float distance=Float.MAX_VALUE;
  for (int c=0; c < valsAtIndex.size(); c++) {
    float cdistance=Math.abs((float)valsAtIndex.get(c) - val);
    if (cdistance < distance) {
      index=c;
      distance=cdistance;
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + index);
  return index;
}","/** 
 * returns the index DataSet that contains the closest value    
 * @param valsAtIndex
 * @return
 */
private int getClosestDataSetIndex(ArrayList<SelInfo> valsAtIndex,float val){
  int index=-1;
  float distance=Float.MAX_VALUE;
  for (int i=0; i < valsAtIndex.size(); i++) {
    float cdistance=Math.abs((float)valsAtIndex.get(i).val - val);
    if (cdistance < distance) {
      index=valsAtIndex.get(i).dataSetIndex;
      distance=cdistance;
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + index);
  return index;
}",0.9425742574257424
18979,"/** 
 * returns the y-value for the given x-index and DataSet index
 * @param index
 * @param dataSet
 * @return
 */
public float getYValueByDataSetIndex(int index,int dataSet){
  DataSet set=mData.getDataSetByIndex(dataSet);
  return set.getYVals().get(index).getVal();
}","/** 
 * returns the y-value for the given x-index and DataSet index
 * @param index
 * @param dataSet
 * @return
 */
public float getYValueByDataSetIndex(int xIndex,int dataSet){
  DataSet set=mData.getDataSetByIndex(dataSet);
  return set.getYValForXIndex(xIndex);
}",0.927643784786642
18980,"/** 
 * Get the y-values from the Series object at the given index across all DataSets. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public ArrayList<Float> getYValsAtIndex(int xIndex){
  ArrayList<Float> vals=new ArrayList<Float>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    float yVal=mData.getDataSetByIndex(i).getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal))     vals.add(yVal);
  }
  return vals;
}","/** 
 * Returns an array of SelInfo objects for the given x-index. The SelInfo objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
protected ArrayList<SelInfo> getYValsAtIndex(int xIndex){
  ArrayList<SelInfo> vals=new ArrayList<SelInfo>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    float yVal=mData.getDataSetByIndex(i).getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal)) {
      vals.add(new SelInfo(yVal,i));
    }
  }
  return vals;
}",0.7715030408340573
18981,"/** 
 * Returns the Series object at the given xIndex. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Series getSeriesForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}","/** 
 * Returns the Series object at the given xIndex. Returns null if no Series object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Series getSeriesForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}",0.9395465994962215
18982,"public int getType(){
  return mType;
}","/** 
 * returns the type of the DataSet, specified via constructor
 * @return
 */
public int getType(){
  return mType;
}",0.4875
18983,"public float getYMax(){
  return mYMax;
}","/** 
 * returns the maximum y-value this DataSet holds
 * @return
 */
public float getYMax(){
  return mYMax;
}",0.5394736842105263
18984,"public float getYMin(){
  return mYMin;
}","/** 
 * returns the minimum y-value this DataSet holds
 * @return
 */
public float getYMin(){
  return mYMin;
}",0.5394736842105263
18985,"public ArrayList<Series> getYVals(){
  return mYVals;
}","/** 
 * returns the DataSets Series array
 * @return
 */
public ArrayList<Series> getYVals(){
  return mYVals;
}",0.6586826347305389
18986,"public float getYValueSum(){
  return mYValueSum;
}","/** 
 * gets the sum of all y-values
 * @return
 */
public float getYValueSum(){
  return mYValueSum;
}",0.6623376623376623
18987,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  ct.addDataSetColors(new int[]{R.color.liberty_2},this);
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  ct.addDataSetColors(new int[]{R.color.liberty_2},this);
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mChart.setDescription(""String_Node_Str"");
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9786407766990292
18988,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  ct.addDataSetColors(ColorTemplate.LIBERTY_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(false);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(false);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}",0.9955357142857144
18989,"@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      if (m3DEnabled) {
        int c=mRenderPaint.getColor();
        mRenderPaint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),mRenderPaint);
        mRenderPaint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),mRenderPaint);
        mRenderPaint.setColor(c);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  ArrayList<DataSet> dataSets=mData.getDataSets();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      for (int j=0; j < series.size(); j++) {
        float x=series.get(j).getXIndex();
        float y=series.get(j).getVal();
        float left=x + mBarSpace / 2f;
        float right=x + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        Path topPath=new Path();
        topPath.moveTo(left,top);
        topPath.lineTo(left + mSkew,top + depth);
        topPath.lineTo(right + mSkew,top + depth);
        topPath.lineTo(right,top);
        topPaths.add(topPath);
        Path sidePath=new Path();
        sidePath.moveTo(right,top);
        sidePath.lineTo(right + mSkew,top + depth);
        sidePath.lineTo(right + mSkew,depth);
        sidePath.lineTo(right,0);
        sidePaths.add(sidePath);
      }
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ArrayList<Integer> colors3DTop=mTopColors.get(i % mCt.getColors().size());
    ArrayList<Integer> colors3DSide=mSideColors.get(i % mCt.getColors().size());
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      if (isOffContentRight(mBarRect.left))       break;
      if (isOffContentLeft(mBarRect.right)) {
        cnt++;
        continue;
      }
      mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      if (m3DEnabled) {
        mRenderPaint.setColor(colors3DTop.get(j % colors3DTop.size()));
        mDrawCanvas.drawPath(topPaths.get(cnt),mRenderPaint);
        mRenderPaint.setColor(colors3DSide.get(j % colors3DSide.size()));
        mDrawCanvas.drawPath(sidePaths.get(cnt),mRenderPaint);
      }
      cnt++;
    }
  }
}",0.4344526655283627
18990,"/** 
 * Sets a colortemplate for the chart that defindes the colors used for drawing. If more values need to be drawn than provided colors available in the colortemplate, colors are repeated.
 * @param ct
 */
public void setColorTemplate(ColorTemplate ct){
  this.mCt=ct;
  prepareDataPaints(ct);
}","/** 
 * Sets a colortemplate for the chart that defindes the colors used for drawing. If more values need to be drawn than provided colors available in the colortemplate, colors are repeated.
 * @param ct
 */
public void setColorTemplate(ColorTemplate ct){
  this.mCt=ct;
}",0.956217162872154
18991,"/** 
 * returns the color value at the given index from the DataSet at the given index
 * @param dataSetIndex
 * @param colorIndex
 * @return
 */
public int getDataSetColor(int dataSetIndex,int colorIndex){
  return mDataSetColors.get(dataSetIndex).get(colorIndex);
}","/** 
 * Returns the color value at the given index from the DataSet at the given index. If index is outofbounds, it restart at lower indices.
 * @param dataSetIndex
 * @param colorIndex
 * @return
 */
public int getDataSetColor(int dataSetIndex,int colorIndex){
  return mDataSetColors.get(dataSetIndex).get(colorIndex % mDataSetColors.get(dataSetIndex).size());
}",0.8431061806656102
18992,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float angle=0f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index >= mDrawAngles.length || index > mDeltaX)       continue;
      if (index == 0)       angle=mChartAngle;
 else       angle=mChartAngle + mAbsoluteAngles[index - 1];
      float sliceDegrees=mDrawAngles[index];
      float shiftangle=(float)Math.toRadians(angle + sliceDegrees / 2f);
      float xShift=mShift * (float)Math.cos(shiftangle);
      float yShift=mShift * (float)Math.sin(shiftangle);
      RectF highlighted=new RectF(mCircleBox.left + xShift,mCircleBox.top + yShift,mCircleBox.right + xShift,mCircleBox.bottom + yShift);
      ArrayList<Integer> colors=mCt.getDataSetColors(mIndicesToHightlight[i].getDataSetIndex());
      mRenderPaint.setColor(colors.get(index % colors.size()));
      mDrawCanvas.drawArc(highlighted,angle,sliceDegrees,true,mRenderPaint);
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float angle=0f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int xIndex=mIndicesToHightlight[i].getXIndex();
      if (xIndex >= mDrawAngles.length || xIndex > mDeltaX)       continue;
      if (xIndex == 0)       angle=mChartAngle;
 else       angle=mChartAngle + mAbsoluteAngles[xIndex - 1];
      float sliceDegrees=mDrawAngles[xIndex];
      float shiftangle=(float)Math.toRadians(angle + sliceDegrees / 2f);
      float xShift=mShift * (float)Math.cos(shiftangle);
      float yShift=mShift * (float)Math.sin(shiftangle);
      RectF highlighted=new RectF(mCircleBox.left + xShift,mCircleBox.top + yShift,mCircleBox.right + xShift,mCircleBox.bottom + yShift);
      DataSet set=mData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      int color=mCt.getDataSetColor(mIndicesToHightlight[i].getDataSetIndex(),set.getIndexInSeries(xIndex));
      mRenderPaint.setColor(color);
      mDrawCanvas.drawArc(highlighted,angle,sliceDegrees,true,mRenderPaint);
    }
  }
}",0.908662900188324
18993,"@Override protected void drawData(){
  float angle=mChartAngle;
  ArrayList<DataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < series.size(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      float newangle=mDrawAngles[cnt];
      if (!needsHighlight(series.get(j).getXIndex(),i)) {
        mDrawCanvas.drawArc(mCircleBox,angle,newangle,true,mRenderPaint);
      }
      angle+=newangle;
      cnt++;
    }
  }
}","@Override protected void drawData(){
  float angle=mChartAngle;
  ArrayList<DataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < series.size(); j++) {
      float newangle=mDrawAngles[cnt];
      if (!needsHighlight(series.get(j).getXIndex(),i)) {
        mRenderPaint.setColor(colors.get(j % colors.size()));
        mDrawCanvas.drawArc(mCircleBox,angle,newangle,true,mRenderPaint);
      }
      angle+=newangle;
      cnt++;
    }
  }
}",0.9098966026587888
18994,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9796782387806944
18995,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.998780487804878
18996,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size()) {
        mHighlightPaint.setAlpha(120);
        float y=mYVals.get(index).getVal();
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=mYVals.get(index).getVal();
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}",0.9933078393881452
18997,"/** 
 * returns the index of the value (on the x-axis) for the given touch point
 * @param x
 * @param y
 * @return
 */
public int getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double touchPointIndex=pts[0];
  double base=Math.floor(touchPointIndex);
  int index=(int)base;
  if (this instanceof LineChart) {
    if (touchPointIndex - base > 0.5) {
      index=(int)base + 1;
    }
  }
  return index;
}","/** 
 * returns the index of the value (on the x-axis) for the given touch point
 * @param x
 * @param y
 * @return
 */
public int getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double touchPointIndex=pts[0];
  double base=Math.floor(touchPointIndex);
  if (touchPointIndex < 0 || touchPointIndex > getValueCount() - 1)   return -1;
  int index=(int)base;
  if (this instanceof LineChart) {
    if (touchPointIndex - base > 0.5) {
      index=(int)base + 1;
    }
  }
  return index;
}",0.9397769516728623
18998,"/** 
 * returns the x-value at the given index
 * @param index
 * @return
 */
public String getXValue(int index){
  if (mXVals == null || mXVals.size() >= index)   return null;
 else   return mXVals.get(index);
}","/** 
 * returns the x-value at the given index
 * @param index
 * @return
 */
public String getXValue(int index){
  if (mXVals == null || mXVals.size() <= index)   return null;
 else   return mXVals.get(index);
}",0.9952830188679244
18999,"/** 
 * returns true if there are values to highlight, false if there are not checks if the highlight array is null, has a length of zero or contains -1
 * @return
 */
public boolean valuesToHighlight(){
  return mIndicesToHightlight == null || mIndicesToHightlight.length == 0 || mIndicesToHightlight[0] == -1 ? false : true;
}","/** 
 * returns true if there are values to highlight, false if there are not checks if the highlight array is null, has a length of zero or contains -1
 * @return
 */
public boolean valuesToHighlight(){
  return mIndicesToHightlight == null || mIndicesToHightlight.length == 0 || mIndicesToHightlight[0] < 0 ? false : true;
}",0.9877675840978594
19000,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size()) {
        float[] pts=new float[]{index,mYChartMax,index,mYChartMin,0,mYVals.get(index).getVal(),mDeltaX,mYVals.get(index).getVal()};
        transformPointArray(pts);
        mDrawCanvas.drawLines(pts,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size() && index >= 0) {
        float[] pts=new float[]{index,mYChartMax,index,mYChartMin,0,mYVals.get(index).getVal(),mDeltaX,mYVals.get(index).getVal()};
        transformPointArray(pts);
        mDrawCanvas.drawLines(pts,mHighlightPaint);
      }
    }
  }
}",0.9851380042462844
