record_number,buggy_code,fixed_code,code_similarity
43001,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
43002,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
43003,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
43004,"void updatePlugged(){
  Intent powerIntent=mContext.registerReceiver(null,mBatteryStatusFilter);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}","void updatePlugged(Intent powerIntent){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}",0.8507223113964687
43005,"/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);
  intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  context.registerReceiver(mPowerReceiver,intentFilter);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged();
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}","/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged(context.registerReceiver(null,mBatteryStatusFilter));
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}",0.9222109972579016
43006,"public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateKeepScreenOn();
  updateOrientationListenerLp();
}","public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  boolean watchBattery=mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
  if (watchBattery != mRegisteredBatteryReceiver) {
    mRegisteredBatteryReceiver=watchBattery;
    if (watchBattery) {
      updatePlugged(mContext.registerReceiver(mBatteryReceiver,mBatteryStatusFilter));
    }
 else {
      mContext.unregisterReceiver(mBatteryReceiver);
    }
  }
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateDockKeepingScreenOn();
  updateOrientationListenerLp();
}",0.5944134078212291
43007,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
43008,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
43009,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
43010,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
43011,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
43012,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
43013,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
43014,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
43015,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
43016,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
43017,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
43018,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
43019,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
43020,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
43021,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
43022,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
43023,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}",0.9545454545454546
43024,"public void destroy(){
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}",0.7799227799227799
43025,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
  mMessageThread=new MessageThread(this);
  mMessageThread.start();
}",0.8785714285714286
43026,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
43027,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
43028,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
43029,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}",0.9545454545454546
43030,"@Override public void handleMessage(Message msg){
synchronized (this) {
    updateKeyguardLocked();
    Log.d(TAG,""String_Node_Str"" + mDockState);
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}","@Override public void handleMessage(Message msg){
synchronized (this) {
    Log.i(TAG,""String_Node_Str"" + mDockState);
    if (Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) == 0) {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}",0.7976539589442815
43031,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
43032,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
43033,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
43034,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
43035,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
43036,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
43037,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
43038,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
43039,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
43040,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
43041,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9701114488348532
43042,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}",0.952144188937228
43043,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}",0.9529151291512916
43044,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
43045,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
43046,"public void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}","public synchronized void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}",0.9930145083288554
43047,"/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  sThumbFiles.clear();
}","/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  for (  MiniThumbFile file : sThumbFiles.values()) {
    file.deactivate();
  }
  sThumbFiles.clear();
}",0.8318890814558059
43048,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9946035699460356
43049,"public long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}","public synchronized long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}",0.9915198956294846
43050,"/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}","/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}",0.994316282179873
43051,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isMusicActive();
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.9435509303058972
43052,"/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivity(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}","/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivityLocked(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}",0.997
43053,"private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
  }
  return true;
}","private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}",0.9796610169491524
43054,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
43055,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
43056,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
43057,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
43058,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
43059,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
43060,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
43061,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
43062,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
43063,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
43064,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
43065,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
43066,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
43067,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
43068,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
43069,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
43070,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
43071,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
43072,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
43073,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
43074,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9701114488348532
43075,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}",0.952144188937228
43076,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}",0.9529151291512916
43077,"/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volumeNOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volume.The volume value is a raw scalar so UI controls should be scaled logarithmically. If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used. NOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}",0.90443864229765
43078,"private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      float v=(float)volume / 1000.0f;
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],v,v,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}","private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    float volFloat;
    if (volume < 0) {
      float dBPerStep=(float)((0.5 * 100) / MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      int musicVolIndex=(mStreamStates[AudioSystem.STREAM_MUSIC].mIndex + 5) / 10;
      float musicVoldB=dBPerStep * (musicVolIndex - MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      volFloat=(float)Math.pow(10,(musicVoldB - 3) / 20);
    }
 else {
      volFloat=(float)volume / 1000.0f;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],volFloat,volFloat,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setVolume(volFloat,volFloat);
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}",0.8465063001145475
43079,"/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}","/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    if (mSoundPool != null) {
      return true;
    }
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}",0.9777598059037608
43080,"/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}","/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  loadSoundEffects();
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}",0.9551020408163264
43081,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
43082,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
43083,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  if (immediate) {
    doDie();
  }
 else {
    sendEmptyMessage(DIE);
  }
}",0.2217700915564598
43084,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
43085,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
43086,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mTextPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}",0.993377028928314
43087,"/** 
 * Called when the system is mostly done booting to dentermine whether the system should go into safe mode.
 */
public boolean detectSafeMode();","/** 
 * Called when the system is mostly done booting to determine whether the system should go into safe mode.
 */
public boolean detectSafeMode();",0.9966329966329966
43088,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
43089,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}",0.9991184249191888
43090,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9948186528497408
43091,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}",0.9940366972477064
43092,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}",0.989010989010989
43093,"Element(){
  super(null);
  mID=0;
  mSize=0;
}","Element(RenderScript rs,int count){
  super(rs);
  mSize=0;
  mEntries=new Entry[count];
}",0.4963503649635036
43094,"public Element create(){
  Element e=new Element();
  e.mEntries=new Entry[mEntryCount];
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init(mRS);
  return e;
}","public Element create(){
  Element e=new Element(mRS,mEntryCount);
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init();
  return e;
}",0.9037900874635568
43095,"void init(RenderScript rs){
  mRS=rs;
  internalCreate(mRS,this);
}","void init(){
  internalCreate(mRS,this);
}",0.7706422018348624
43096,"static void initPredefined(RenderScript rs){
  USER_U8.mEntries=new Entry[1];
  USER_U8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,8,null);
  USER_U8.init(rs);
  USER_I8.mEntries=new Entry[1];
  USER_I8.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,8,null);
  USER_I8.init(rs);
  USER_U16.mEntries=new Entry[1];
  USER_U16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,16,null);
  USER_U16.init(rs);
  USER_I16.mEntries=new Entry[1];
  USER_I16.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,16,null);
  USER_I16.init(rs);
  USER_U32.mEntries=new Entry[1];
  USER_U32.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,32,null);
  USER_U32.init(rs);
  USER_I32.mEntries=new Entry[1];
  USER_I32.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,32,null);
  USER_I32.init(rs);
  USER_FLOAT.mEntries=new Entry[1];
  USER_FLOAT.mEntries[0]=new Entry(DataType.FLOAT,DataKind.USER,false,32,null);
  USER_FLOAT.init(rs);
  A_8.mEntries=new Entry[1];
  A_8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  A_8.init(rs);
  RGB_565.mEntries=new Entry[3];
  RGB_565.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGB_565.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,6,""String_Node_Str"");
  RGB_565.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGB_565.init(rs);
  RGB_888.mEntries=new Entry[3];
  RGB_888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGB_888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGB_888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGB_888.init(rs);
  RGBA_5551.mEntries=new Entry[4];
  RGBA_5551.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,1,""String_Node_Str"");
  RGBA_5551.init(rs);
  RGBA_4444.mEntries=new Entry[4];
  RGBA_4444.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,4,""String_Node_Str"");
  RGBA_4444.init(rs);
  RGBA_8888.mEntries=new Entry[4];
  RGBA_8888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  RGBA_8888.init(rs);
  INDEX_16.mEntries=new Entry[1];
  INDEX_16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.INDEX,false,16,""String_Node_Str"");
  INDEX_16.init(rs);
  XY_F32.mEntries=new Entry[2];
  XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XY_F32.init(rs);
  XYZ_F32.mEntries=new Entry[3];
  XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  XYZ_F32.init(rs);
  ST_XY_F32.mEntries=new Entry[4];
  ST_XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XY_F32.init(rs);
  ST_XYZ_F32.mEntries=new Entry[5];
  ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  ST_XYZ_F32.init(rs);
  NORM_XYZ_F32.mEntries=new Entry[6];
  NORM_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_XYZ_F32.init(rs);
  NORM_ST_XYZ_F32.mEntries=new Entry[8];
  NORM_ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[6]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[7]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.init(rs);
  rs.nInitElements(A_8.mID,RGBA_4444.mID,RGBA_8888.mID,RGB_565.mID);
}","static void initPredefined(RenderScript rs){
  rs.nInitElements(A_8(rs).mID,RGBA_4444(rs).mID,RGBA_8888(rs).mID,RGB_565(rs).mID);
}",0.0363866476823287
43097,"public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_FLOAT,48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}","public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_F32(rs),48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}",0.9854651162790696
43098,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  if (!mElementsInitialized) {
    Element.initPredefined(this);
    mElementsInitialized=true;
  }
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}",0.8392857142857143
43099,"public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16,mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}","public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16(mRS),mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}",0.9971148297749568
43100,"public void add(Dimension d,int value){
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}","public void add(Dimension d,int value){
  if (value < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}",0.8876712328767123
43101,"public Builder(RenderScript rs,Element e){
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}","public Builder(RenderScript rs,Element e){
  if (e.mID == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}",0.6914498141263941
43102,"private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferIDs.length);
  Element ie=Element.RGB_565;
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}","private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferIDs.length);
  Element ie=Element.RGB_565(mRS);
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}",0.9957310565635006
43103,"private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}","private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}",0.973747016706444
43104,"private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32,mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_FLOAT,mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}","private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32(mRS),mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_F32(mRS),mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}",0.8991416309012875
43105,"private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32,mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32,mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32,mLabels.length);
    Element ie8888=Element.RGBA_8888;
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}","private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32(mRS),mLabels.length);
    Element ie8888=Element.RGBA_8888(mRS);
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}",0.9983133749367517
43106,"private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32,mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}","private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}",0.995766299745978
43107,"Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888,true);
}","Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888(mRS),true);
}",0.9924812030075189
43108,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}",0.9991184249191888
43109,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9948186528497408
43110,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}",0.9940366972477064
43111,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}",0.989010989010989
43112,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
43113,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  if (!c.isNull(HEADER_PRESENCE_STATUS_COLUMN_INDEX)) {
    int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
    mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
    mPresenceView.setVisibility(View.VISIBLE);
  }
 else {
    mPresenceView.setVisibility(View.GONE);
  }
}",0.9005186232909005
43114,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
43115,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        ViewManager wm=a.getWindowManager();
        View decor=r.window.getDecorView();
        wm.updateViewLayout(decor,l);
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && !a.mStartedActivity && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.9825508932280848
43116,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}",0.8310387984981227
43117,"public PackageInfo(ActivityThread activityThread,String name,Context systemContext){
  mActivityThread=activityThread;
  mApplicationInfo=new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}","public PackageInfo(ActivityThread activityThread,String name,Context systemContext,ApplicationInfo info){
  mActivityThread=activityThread;
  mApplicationInfo=info != null ? info : new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}",0.9617777777777776
43118,"public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}","public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context,null);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}",0.9945474372955287
43119,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
    mSystemThread.installSystemApplicationInfo(info);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9801762114537445
43120,"/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,false,recycle);
  return miniThumbnail;
}","/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,true,recycle);
  return miniThumbnail;
}",0.9941520467836256
43121,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || TextUtils.isEmpty(from.getString()) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}",0.9944021817137936
43122,"private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < 3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}","private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < -3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}",0.9994334277620396
43123,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}",0.8310387984981227
43124,"private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 0) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}","private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 1) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}",0.9991961414790996
43125,"/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}","/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}",0.999275887038378
43126,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
try {
int addressType=checkAddressType(addr[i].getString());
temp=EncodedStringValue.copy(addr[i]);
if (PDU_PHONE_NUMBER_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_PHONE_NUMBER_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV4_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV4_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV6_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV6_ADDRESS_TYPE.getBytes());
}
}
 catch (NullPointerException e) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
appendEncodedString(from);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}",0.8260211800302572
43127,"/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + getHeight());
}","/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta,int height){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + height);
}",0.9638242894056848
43128,"/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0);
}","/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0,getHeight());
}",0.967741935483871
43129,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  final int maxJump=mBottom - mTop;
  if (isWithinDeltaOfScreen(currentFocused,maxJump)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  if (isWithinDeltaOfScreen(currentFocused,0,oldh)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}",0.9506545820745216
43130,"/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump)) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}","/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump,getHeight())) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}",0.996468510888758
43131,"/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getStringExtra(SearchManager.COMPONENT_NAME_KEY));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}","/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getComponent().flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}",0.9779179810725552
43132,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}",0.979214780600462
43133,"public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    Uri data=null;
    String action=null;
    if (i > 0) {
      data=Uri.parse(uri.substring(0,i));
    }
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action,data);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}","public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    String action=null;
    final int intentFragmentStart=i;
    boolean isIntentFragment=false;
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      isIntentFragment=true;
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      isIntentFragment=true;
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      isIntentFragment=true;
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      isIntentFragment=true;
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (isIntentFragment) {
intent.mData=Uri.parse(uri.substring(0,intentFragmentStart));
}
 else {
intent.mData=Uri.parse(uri);
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}",0.9292929292929292
43134,"/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}","/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or{@link #URI_INTENT_SCHEME}.
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}",0.8587474056891711
43135,"void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}","void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
    intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}",0.9919627749576988
43136,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}",0.979214780600462
43137,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9151039890896692
43138,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (nextNonPwCharIndex > (currPwIndex + 1)) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}",0.9727272727272728
43139,"boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ (newParent != parent)+ ""String_Node_Str""+ wasConnectingInOrOut+ ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}","boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ newParent);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + wasConnectingInOrOut + ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}",0.4408924408924409
43140,"/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}",0.999194198227236
43141,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}",0.9272237196765498
43142,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.9748520710059172
43143,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}",0.3651771956856702
43144,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}",0.8708133971291866
43145,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}",0.9783783783783784
43146,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.97503671071953
43147,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}",0.3315217391304347
43148,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}",0.7892416225749559
43149,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}",0.9272237196765498
43150,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.9748520710059172
43151,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}",0.3651771956856702
43152,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}",0.8708133971291866
43153,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}",0.9783783783783784
43154,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.97503671071953
43155,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}",0.3315217391304347
43156,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}",0.7892416225749559
43157,"boolean isInProximity(double latitude,double longitude){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= mRadius;
}","boolean isInProximity(double latitude,double longitude,float accuracy){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= Math.max(mRadius,accuracy);
}",0.9330708661417324
43158,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}",0.9918256130790192
43159,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}",0.9814656401482748
43160,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
43161,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
43162,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
43163,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
43164,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
43165,"protected void onLooperPrepared(){
  mDidSetup=true;
  mLooperTid=Process.myTid();
}","protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
    mDidSetup=true;
    mLooperTid=Process.myTid();
    HandlerThreadTest.this.notify();
  }
}",0.6640316205533597
43166,"@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
      mDidSetup=true;
      mLooperTid=Process.myTid();
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
  assertNotSame(Process.myTid(),mLooperTid);
  assertTrue(mDidSetup);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}","@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
        mDidSetup=true;
        mLooperTid=Process.myTid();
        HandlerThreadTest.this.notify();
      }
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
synchronized (this) {
    while (!mDidSetup) {
      try {
        wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  assertNotSame(-1,mLooperTid);
  assertNotSame(Process.myTid(),mLooperTid);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}",0.8679073990013618
43167,"public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
switch (view.getId()) {
case R.id.star:
{
      final ContentValues values=new ContentValues(1);
      values.put(Contacts.STARRED,mStarredView.isChecked());
      mContentResolver.update(mContactUri,values,null,null);
      break;
    }
case R.id.photo:
{
    final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,mContactUri);
    final Rect target=getTargetRect(view);
    intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
    intent.putExtra(Intents.EXTRA_MODE,Intents.MODE_SMALL);
    if (mExcludeMimes != null) {
      intent.putExtra(Intents.EXTRA_EXCLUDE_MIMES,mExcludeMimes);
    }
    mContext.startActivity(intent);
    break;
  }
}
}","public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
  if (view.getId() == R.id.star) {
    final ContentValues values=new ContentValues(1);
    values.put(Contacts.STARRED,mStarredView.isChecked());
    mContentResolver.update(mContactUri,values,null,null);
  }
}",0.5318940137389597
43168,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}",0.642570281124498
43169,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(number,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,number),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.6896551724137931
43170,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(Email.CONTENT_FILTER_EMAIL_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(emailAddress,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.6977848101265823
43171,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(ImageView)findViewById(R.id.photo);
  mPhotoView.setOnClickListener(this);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(FasttrackBadgeWidget)findViewById(R.id.photo);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}",0.9287598944591028
43172,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (token == TOKEN_CONTACT_INFO) {
      bindContactInfo(cursor);
      invalidate();
    }
 else     if (token == TOKEN_SOCIAL) {
      bindSocial(cursor);
      invalidate();
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.1929110981987216
43173,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}",0.9814656401482748
43174,"/** 
 * Sets the setting for when the vibrate type should vibrate.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the setting for when the vibrate type should vibrate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8982698961937716
43175,"/** 
 * Adjusts the volume of a particular stream by one step in a direction.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9113924050632912
43176,"/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9270471464019852
43177,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9165247018739352
43178,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9166193987521272
43179,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8457502623294858
43180,"/** 
 * Sets the microphone mute on or off.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}","/** 
 * Sets the microphone mute on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}",0.7461139896373057
43181,"/** 
 * Sets the audio mode.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6325503355704698
43182,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the speakerphone on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8196319018404908
43183,"protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}","protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        if (Phone.DEBUG_PHONE) {
          log(""String_Node_Str"" + pendingMO + dc);
        }
        newRinging=checkMtFindNewRinging(dc,i);
        if (newRinging == null) {
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      if (conn.isIncoming != dc.isMT) {
        if (dc.isMT == true) {
          droppedDuringPoll.add(conn);
          newRinging=checkMtFindNewRinging(dc,i);
          if (newRinging == null) {
            unknownConnectionAppeared=true;
          }
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + dc);
        }
      }
 else {
        boolean changed;
        changed=conn.update(dc);
        hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
      }
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}",0.7794102745972237
43184,"private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}","private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (Phone.DEBUG_PHONE) {
    log(""String_Node_Str"" + oldState + state);
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}",0.944206008583691
43185,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
43186,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
43187,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
43188,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
43189,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
43190,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
43191,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
43192,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
43193,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
43194,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
43195,"@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
}
return true;
}",0.9746835443037974
43196,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}",0.99774954125264
43197,"/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}",0.9357638888888888
43198,"/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}",0.9127358490566038
43199,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}",0.9985805097821392
43200,"public void onTerminate(){
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","public void onTerminate(){
  mOnTerminateIsCalled=true;
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.967741935483871
43201,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(mVCardAttributeCharset);
        builder.append(VCARD_DATA_SEPARATOR);
      }
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}",0.9869356945855712
43202,"private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}","private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
case Email.TYPE_MOBILE:
builder.append(Constants.ATTR_TYPE_CELL);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}",0.9655497876356772
43203,"@Override protected void handleAgent(String propertyValue) throws VCardException {
  throw new VCardException(""String_Node_Str"");
}","@Override protected void handleAgent(String propertyValue){
  if (!mEmittedAgentWarning) {
    Log.w(LOG_TAG,""String_Node_Str"");
    mEmittedAgentWarning=true;
  }
}",0.6283783783783784
43204,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (localLOGV)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.appInfo.processName == r.info.processName) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"");
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}",0.926161369193154
43205,"private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        Log.i(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}","private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        if (DEBUG_SERVICE)         Log.v(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}",0.8642845697804838
43206,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.2893606870229007
43207,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.clear();
    mCreated=false;
  }
}","void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9934569247546348
43208,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.9920472619859124
43209,private native void release();,"/** 
 * Release the local reference to the server-side surface. @hide 
 */
public native void release();",0.373134328358209
43210,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.clear();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}",0.993103448275862
43211,"void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.clear();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}","void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.release();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}",0.9856801909307876
43212,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
43213,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
43214,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
43215,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
43216,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
43217,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
43218,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
43219,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
43220,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
43221,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
43222,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
43223,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
43224,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
43225,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
43226,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
43227,"Globals(){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.5280665280665281
43228,"static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals();
    }
  }
}","static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals(looper);
    }
  }
}",0.9777777777777776
43229,"InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}","InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurMethodId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}",0.9971098265895952
43230,"public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurToken);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
        if (mCurClient != null) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mCurClient);
          executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
        }
      }
    }
  }
}","public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurToken == null) {
        Log.w(TAG,""String_Node_Str"");
        unbindCurrentMethodLocked(false);
        return;
      }
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurClient);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
      }
    }
  }
}",0.9057627118644068
43231,"boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}","boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  if (!mSystemReady) {
    return false;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}",0.9744172825469016
43232,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mSystemReady + ""String_Node_Str""+ mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}",0.992842105263158
43233,"public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      startInputInnerLocked();
    }
  }
}","public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}",0.7
43234,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
43235,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
43236,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
43237,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
43238,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
43239,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
43240,"public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  if (!mCT.foregroundCall.isIdle()) {
    FeatureCode fc=FeatureCode.newFromDialString(newDialString,this);
    if (fc != null) {
      fc.processCode();
      return null;
    }
  }
  return mCT.dial(newDialString);
}","public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  return mCT.dial(newDialString);
}",0.655367231638418
43241,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}",0.9572649572649572
43242,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  int result=0;
  if (unreadConversations != null) {
    result=unreadConversations < 0 ? 0 : unreadConversations;
  }
  return result;
}",0.6792963464140731
43243,"/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !""String_Node_Str"".equals(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}","/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !TextUtils.isEmpty(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}",0.9818342933097032
43244,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
phone.getIccCard().broadcastIccStateChangedIntent(IccCard.INTENT_VALUE_ICC_IMSI,null);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.9909591603450068
43245,"/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
    }
  }
}","/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
      refreshProgress(R.id.progress,mProgress,false);
    }
  }
}",0.9409190371991248
43246,"public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  mTarget.onAccessibilityEvent(event);
event.recycle();
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  if (event != null) {
    mTarget.onAccessibilityEvent(event);
    event.recycle();
  }
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}",0.9659442724458204
43247,public abstract Handler getHandler();,"public Handler getHandler(){
  return this;
}",0.6829268292682927
43248,"/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
}","/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,CommandsInterface ci,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  mCM=ci;
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
  mCM.setOnCallRing(this,EVENT_CALL_RING,null);
  mDoesRilSendMultipleCallRing=SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING,true);
  Log.d(LOG_TAG,""String_Node_Str"" + mDoesRilSendMultipleCallRing);
  mCallRingDelay=SystemProperties.getInt(TelephonyProperties.PROPERTY_CALL_RING_DELAY,3000);
  Log.d(LOG_TAG,""String_Node_Str"" + mCallRingDelay);
}",0.7592592592592593
43249,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9924465438944798
43250,"boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && !w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}","boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}",0.997564866907381
43251,"void commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
}","boolean commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return false;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
  return true;
}",0.9541547277936964
43252,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
43253,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
43254,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
43255,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
43256,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
43257,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
43258,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
43259,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
43260,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
43261,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
43262,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
43263,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
43264,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
43265,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
43266,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
43267,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
43268,"@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}","@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
if (mPattern.isEmpty()) return false;
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}",0.9951456310679612
43269,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9987568488420278
43270,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
43271,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
43272,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
43273,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
43274,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
43275,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
43276,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
43277,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
43278,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
43279,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
43280,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
43281,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
43282,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
43283,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
43284,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
43285,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
43286,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
43287,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
43288,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
43289,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
43290,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
43291,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
43292,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
43293,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
43294,"@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
    int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
    int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
    int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize)+ Math.abs(d - mDepthSize)+ Math.abs(s - mStencilSize);
    if (distance < closestDistance) {
      closestDistance=distance;
      closestConfig=config;
    }
  }
  return closestConfig;
}","@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    if (d >= mDepthSize && s >= mStencilSize) {
      int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
      int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
      int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
      int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
      int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize);
      if (distance < closestDistance) {
        closestDistance=distance;
        closestConfig=config;
      }
    }
  }
  return closestConfig;
}",0.6745435016111708
43295,"/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeForLocale(Locale.getDefault()));
    }
  }
  return dialStr;
}","/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in
 * @param dialStr the original dial string
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns. This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      String currIso=SystemProperties.get(PROPERTY_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      String defaultIso=SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
        return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeFromCountryCode(currIso),getFormatTypeFromCountryCode(defaultIso));
      }
    }
  }
  return dialStr;
}",0.8132357620108177
43296,"/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+NANP or +1NANP,remove +, 2)+non-NANP Numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isNanp(newStr) || isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}","/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+1NANP,remove +, 2)other than +1NANP, any + numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}",0.952317880794702
43297,"/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  int length=NANP_COUNTRIES.length;
  for (int i=0; i < length; i++) {
    if (NANP_COUNTRIES[i].equals(country)) {
      return FORMAT_NANP;
    }
  }
  if (locale.equals(Locale.JAPAN)) {
    return FORMAT_JAPAN;
  }
  return FORMAT_UNKNOWN;
}","/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  return getFormatTypeFromCountryCode(country);
}",0.7311004784688995
43298,"/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+NANP or +1NANP,remove +, e.g. +8475797000 is converted to 8475797000, +18475797000 is converted to 18475797000, 2)+non-NANP Numbers,replace + with the current NANP IDP, e.g, +11875767800 is converted to 01111875767800 3)+NANP in post dial string(s), e.g. 8475797000;+8475231753 is converted to 8475797000;8475231753 This function returns the original dial string if locale/numbering plan aren't supported.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int numFormat){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    String postDialStr=null;
    String tempDialStr=dialStr;
    retStr=null;
    if (DBG)     log(""String_Node_Str"" + dialStr);
    do {
      String networkDialStr;
      if (numFormat != FORMAT_NANP) {
        Log.e(""String_Node_Str"",dialStr);
        return dialStr;
      }
 else {
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
      }
      if (!TextUtils.isEmpty(networkDialStr)) {
        if (retStr == null) {
          retStr=networkDialStr;
        }
 else {
          retStr=retStr.concat(networkDialStr);
        }
      }
 else {
        Log.e(""String_Node_Str"",networkDialStr);
        return dialStr;
      }
      postDialStr=extractPostDialPortion(tempDialStr);
      if (!TextUtils.isEmpty(postDialStr)) {
        int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
        if (dialableIndex >= 1) {
          retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
          tempDialStr=postDialStr.substring(dialableIndex);
        }
 else {
          if (dialableIndex < 0) {
            postDialStr=""String_Node_Str"";
          }
          Log.e(""String_Node_Str"",postDialStr);
        }
      }
      if (DBG)       log(""String_Node_Str"" + postDialStr);
    }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
  }
  return retStr;
}","/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+1NANP,remove +, e.g. +18475797000 is converted to 18475797000, 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g, +8475797000 is converted to 0118475797000, +11875767800 is converted to 01111875767800 3)+1NANP in post dial string(s), e.g. 8475797000;+18475231753 is converted to 8475797000;18475231753
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int currFormat,int defaultFormt){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    if ((currFormat == defaultFormt) && (currFormat == FORMAT_NANP)) {
      String postDialStr=null;
      String tempDialStr=dialStr;
      retStr=null;
      if (DBG)       log(""String_Node_Str"" + dialStr);
      do {
        String networkDialStr;
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
        if (!TextUtils.isEmpty(networkDialStr)) {
          if (retStr == null) {
            retStr=networkDialStr;
          }
 else {
            retStr=retStr.concat(networkDialStr);
          }
        }
 else {
          Log.e(""String_Node_Str"",networkDialStr);
          return dialStr;
        }
        postDialStr=extractPostDialPortion(tempDialStr);
        if (!TextUtils.isEmpty(postDialStr)) {
          int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
          if (dialableIndex >= 1) {
            retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
            tempDialStr=postDialStr.substring(dialableIndex);
          }
 else {
            if (dialableIndex < 0) {
              postDialStr=""String_Node_Str"";
            }
            Log.e(""String_Node_Str"",postDialStr);
          }
        }
        if (DBG)         log(""String_Node_Str"" + postDialStr);
      }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
    }
 else {
      Log.e(""String_Node_Str"",dialStr);
    }
  }
  return retStr;
}",0.7802929427430093
43299,"@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
}","@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_NANP));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN,PhoneNumberUtils.FORMAT_UNKNOWN));
}",0.8096141682479443
43300,"/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (mInterfaceName != null && hostAddress != -1) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress));
    }
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}","/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress) + ""String_Node_Str""+ mApnType+ ""String_Node_Str""+ mInterfaceName+ ""String_Node_Str"");
  }
  if (mInterfaceName != null && hostAddress != -1) {
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}",0.8449367088607594
43301,"public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (mInterfaceName == null && state == Phone.DataState.CONNECTED) {
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
 else           if (state == Phone.DataState.DISCONNECTED) {
            mInterfaceName=null;
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    mInterfaceName=null;
  mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}","public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    if (DBG)     Log.d(TAG,""String_Node_Str"" + mApnType + ""String_Node_Str"");
  mInterfaceName=null;
mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}",0.7243090007087172
43302,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}",0.9781871061560834
43303,"private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  return numConnectedNets;
}","private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"" + numConnectedNets);
  return numConnectedNets;
}",0.8098591549295775
43304,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting() || newNet.isTeardownRequested()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}",0.9949109414758268
43305,"public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if (ni.isConnectedOrConnecting() == true) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}","public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if ((ni.isConnectedOrConnecting() == true) && !network.isTeardownRequested()) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}",0.9931921331316188
43306,"protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
    }
 else {
      enabledCount--;
    }
    if (enabledCount == 0) {
      setPrivateDataEnabled(false);
    }
 else     if (enabledCount == 1) {
      setPrivateDataEnabled(true);
    }
  }
}","protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
      if (enabledCount == 1) {
        setPrivateDataEnabled(true);
      }
    }
 else {
      enabledCount--;
      if (enabledCount == 0) {
        setPrivateDataEnabled(false);
      }
    }
  }
}",0.7991071428571429
43307,"private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
if (keyIndex != mRepeatKeyIndex) {
mHandler.removeMessages(MSG_REPEAT);
mRepeatKeyIndex=NOT_A_KEY;
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}",0.9729539866526168
43308,"@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}","@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
      if (me.getAction() == MotionEvent.ACTION_UP) {
        result=onModifiedTouchEvent(me);
      }
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}",0.9420454545454544
43309,"public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}","public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}",0.9787535410764872
43310,"public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}","public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation == null ? mContext : mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}",0.958963282937365
43311,"/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index > SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index > HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}","/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index >= SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index >= HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}",0.99269717624148
43312,"public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
    userActivity(milliseconds,false);
  }
}","public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
synchronized (mLocks) {
      boolean savedActivityAllowed=mUserActivityAllowed;
      mUserActivityAllowed=true;
      userActivity(milliseconds,false);
      mUserActivityAllowed=savedActivityAllowed;
    }
  }
}",0.7116357504215851
43313,"/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @result Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @return Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.99672131147541
43314,"/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@linke #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}","/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@link #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}",0.9996538594669436
43315,"MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[i + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}","MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}",0.9993810604497628
43316,"public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0])                 ms.mNextNumPointers++;
                if (ms.mDown[1])                 ms.mNextNumPointers++;
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
                if (ms.mDown[1]) {
                  System.arraycopy(di.curTouchVals,MotionEvent.NUM_SAMPLE_DATA,ms.mNextData,ms.mNextNumPointers * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}",0.971767028627838
43317,"/** 
 * True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   
 */
public final static boolean isNonSeparator(char c){
  return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == WILD || c == WAIT || c == PAUSE;
}","private static boolean isNonSeparator(String address){
  for (int i=0, count=address.length(); i < count; i++) {
    if (!isNonSeparator(address.charAt(i))) {
      return false;
    }
  }
  return true;
}",0.0222717149220489
43318,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 1))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}",0.9970414201183432
43319,"private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=false;
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}","private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=isWait(phoneNumber.charAt(currIndex));
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}",0.9628975265017669
43320,"/** 
 * format orignal dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (PhoneNumberUtils.isDialable(c)) {
      if (c == '+') {
        String ps=null;
        SystemProperties.get(TelephonyProperties.PROPERTY_IDP_STRING,ps);
        if (TextUtils.isEmpty(ps)) {
          ps=""String_Node_Str"";
        }
        ret.append(ps);
      }
 else {
        ret.append(c);
      }
    }
 else     if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return ret.toString();
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}",0.4951069227981152
43321,"void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    final int N=mHosts.size();
    for (int i=0; i < N; i++) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}","void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    for (int i=mHosts.size() - 1; i >= 0; i--) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}",0.9406504065040652
43322,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  shutdownIfNoPower();
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}",0.9863676901516116
43323,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}",0.995398773006135
43324,"/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if (locStrings.length == 3) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}","/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if ((locStrings != null) && (locStrings.length == 3)) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}",0.9878731343283582
43325,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9608294930875576
43326,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally, except those intended to be synthesized to file.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        try {
          result=sNativeSynth.stop();
        }
 catch (        NullPointerException e1) {
          result=TextToSpeech.ERROR;
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9406688241639698
43327,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  stopAll(""String_Node_Str"");
  cleanUpPlayer();
  if (sNativeSynth != null) {
    sNativeSynth.shutdown();
  }
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8146067415730337
43328,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9600307455803228
43329,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9753215154675008
43330,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}",0.9852682145716574
43331,"synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      return 0;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}","synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      continue;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}",0.980440097799511
43332,"public void setFilename(String filename){
  mFilename=filename;
}","public void setFilename(String filename){
  if (mFilename == null || !mFilename.equals(filename)) {
    mFilename=filename;
    mCachedAttributes=null;
  }
}",0.5855855855855856
43333,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}",0.995398773006135
43334,"static public Allocation createSized(RenderScript rs,Element e,int count){
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
  }
  return new Allocation(id,rs);
}","static public Allocation createSized(RenderScript rs,Element e,int count) throws IllegalArgumentException {
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
    if (id == 0) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return new Allocation(id,rs);
}",0.8226299694189603
43335,"static public Allocation createTyped(RenderScript rs,Type type){
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}","static public Allocation createTyped(RenderScript rs,Type type) throws IllegalArgumentException {
  if (type.mID == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}",0.5594059405940595
43336,"BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
}","BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
  mDestroyed=false;
}",0.8214285714285714
43337,"protected void finalize() throws Throwable {
  if (mID != 0) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}","protected void finalize() throws Throwable {
  if (!mDestroyed) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}",0.9466192170818504
43338,"public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mRS.nElementDestroy(mID);
  mID=0;
}","public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nElementDestroy(mID);
}",0.7534246575342466
43339,"static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mType.mID,en.mKind.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}","static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mKind.mID,en.mType.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}",0.7983193277310925
43340,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}",0.5462184873949579
43341,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}",0.5462184873949579
43342,"public void destroy(){
  mRS.nScriptDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nScriptDestroy(mID);
}",0.4857142857142857
43343,"private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
  }
}","private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
    mDataConnection.setDataEnabled(true);
  }
}",0.95906432748538
43344,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPerms(deletedPs);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}",0.9851439182915506
43345,"private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
    WifiNative.startPacketFiltering();
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
synchronized (mWifiStateTracker) {
      WifiNative.startPacketFiltering();
    }
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9449838187702264
43346,"public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
    WifiNative.stopPacketFiltering();
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
synchronized (mWifiStateTracker) {
      WifiNative.stopPacketFiltering();
    }
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9572139303482587
43347,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}",0.999875868917577
43348,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9610145608266792
43349,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9291907514450868
43350,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
43351,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
43352,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9655577299412916
43353,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9752650176678446
43354,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9610145608266792
43355,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9291907514450868
43356,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
43357,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
43358,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9655577299412916
43359,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9752650176678446
43360,"public void data(float[] d){
  mRS.nAdapter1DData(mID,d);
}","public void data(float[] d){
  mRS.nAdapter2DData(mID,d);
}",0.9830508474576272
43361,"public void destroy(){
  mRS.nAdapter1DDestroy(mID);
  mID=0;
}","public void destroy(){
  mRS.nAdapter2DDestroy(mID);
  mID=0;
}",0.984126984126984
43362,"public void setConstraint(Dimension dim,int value){
  mRS.nAdapter1DSetConstraint(mID,dim.mID,value);
}","public void setConstraint(Dimension dim,int value){
  mRS.nAdapter2DSetConstraint(mID,dim.mID,value);
}",0.9902912621359224
43363,"public void subData(int off,int count,float[] d){
  mRS.nAdapter1DSubData(mID,off,count,d);
}","public void subData(int xoff,int yoff,int w,int h,float[] d){
  mRS.nAdapter2DSubData(mID,xoff,yoff,w,h,d);
}",0.8514851485148515
43364,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9906059182714888
43365,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9450867052023122
43366,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
43367,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
43368,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9906066536203524
43369,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9915194346289752
43370,"private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}","private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  if (signalType != IS95_CONST_IR_SIGNAL_IS54B) {
    alertPitch=TAPIAMSSCDMA_SIGNAL_PITCH_UNKNOWN;
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}",0.8620689655172413
43371,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public void handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public boolean handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
  return false;
}",0.984958217270195
43372,"private void setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    if (cy == 0 && cx != 0) {
      pinScrollBy(cx,0,animate,0);
    }
  }
 else {
    pinScrollBy(cx,cy,animate,0);
  }
}","private boolean setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return false;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    return cy == 0 && cx != 0 && pinScrollBy(cx,0,animate,0);
  }
 else {
    return pinScrollBy(cx,cy,animate,0);
  }
}",0.8299465240641711
43373,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
try {
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeSystemId=0;
}
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
try {
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeNetworkId=0;
}
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.6074195820615168
43374,"/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if ((mHomeSystemId != 0) && (mHomeSystemId == newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
if (mIsInPrl) {
if (namMatch && (mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
 else {
if (mRegistrationState == 5) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else {
}
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}","/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if (!isSidsAllZeros() && isHomeSid(newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
boolean isPrlLoaded=true;
if (TextUtils.isEmpty(mPrlVersion)) {
isPrlLoaded=false;
}
if (!isPrlLoaded) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!isSidsAllZeros()) {
if (!namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
}
 else if (namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!namMatch && mIsInPrl) {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
 else {
if ((mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
}
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ isPrlLoaded+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}",0.92001298841866
43375,"/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
  if (batteryLevel == 0 && pluggedInStatus != BATTERY_STATUS_CHARGING && pluggedInStatus != BATTERY_STATUS_UNKNOWN) {
    ShutdownThread.shutdown(mContext,false);
  }
}","/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
}",0.8585944115156647
43376,"public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    invalidate();
  }
}","public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    configureBounds();
    invalidate();
  }
}",0.9565217391304348
43377,"Resources getTopLevelResources(String appDir){
synchronized (mPackages) {
    WeakReference<Resources> wr=mActiveResources.get(appDir);
    Resources r=wr != null ? wr.get() : null;
    if (r != null && r.getAssets().isUpToDate()) {
      return r;
    }
    AssetManager assets=new AssetManager();
    if (assets.addAssetPath(appDir) == 0) {
      return null;
    }
    Configuration config=getConfiguration();
    if (config != null && config.customTheme != null) {
      String resourcePath=config.customTheme.getThemeResourcePath();
      if (resourcePath != null) {
        if (assets.addAssetPath(resourcePath) == 0) {
          Log.e(TAG,""String_Node_Str"" + resourcePath);
        }
      }
      PackageInfo pi=getPackageInfo(config.customTheme.getThemePackageName(),0);
      String resDir=pi.getResDir();
      if (assets.addAssetPath(resDir) == 0) {
        Log.e(TAG,""String_Node_Str"" + resDir);
      }
    }
    DisplayMetrics metrics=getDisplayMetricsLocked(false);
    r=new Resources(assets,metrics,config);
    mActiveResources.put(appDir,new WeakReference<Resources>(r));
    return r;
  }
}","Resources getTopLevelResources(String appDir){
synchronized (mPackages) {
    WeakReference<Resources> wr=mActiveResources.get(appDir);
    Resources r=wr != null ? wr.get() : null;
    if (r != null && r.getAssets().isUpToDate()) {
      return r;
    }
    AssetManager assets=new AssetManager();
    if (assets.addAssetPath(appDir) == 0) {
      return null;
    }
    Configuration config=getConfiguration();
    if (config != null && config.customTheme != null) {
      String resourcePath=config.customTheme.getThemeResourcePath();
      if (resourcePath != null) {
        if (assets.addAssetPath(resourcePath) == 0) {
          Log.e(TAG,""String_Node_Str"" + resourcePath);
        }
      }
      PackageInfo pi=getPackageInfo(config.customTheme.getThemePackageName(),0);
      if (pi != null) {
        String resDir=pi.getResDir();
        if (assets.addAssetPath(resDir) == 0) {
          Log.e(TAG,""String_Node_Str"" + resDir);
        }
      }
    }
    DisplayMetrics metrics=getDisplayMetricsLocked(false);
    r=new Resources(assets,metrics,config);
    mActiveResources.put(appDir,new WeakReference<Resources>(r));
    return r;
  }
}",0.982316534040672
43378,"/** 
 * Shows this context menu, allowing the optional original view (and its ancestors) to add items.
 * @param originalView Optional, the original view that triggered thecontext menu.
 * @param token Optional, the window token that should be set on the contextmenu's window.
 * @return If the context menu was shown, the {@link MenuDialogHelper} fordismissing it. Otherwise, null.
 */
public MenuDialogHelper show(View originalView,IBinder token){
  if (originalView != null) {
    originalView.createContextMenu(this);
  }
  if (getVisibleItems().size() > 0) {
    EventLog.writeEvent(50001,1);
    MenuDialogHelper helper=new MenuDialogHelper(this);
    helper.show(token);
    return helper;
  }
  return null;
}","/** 
 * Shows this context menu, allowing the optional original view (and its ancestors) to add items.
 * @param originalView Optional, the original view that triggered thecontext menu.
 * @param token Optional, the window token that should be set on the contextmenu's window.
 * @return If the context menu was shown, the {@link MenuDialogHelper} fordismissing it. Otherwise, null.
 */
public MenuDialogHelper show(View originalView,IBinder token){
  if (originalView != null) {
    originalView.createContextMenu(this);
  }
  if (getVisibleItems().size() > 0) {
    EventLog.writeEvent(50001,1);
    MenuDialogHelper helper=new MenuDialogHelper(this);
    Dialog d=helper.create(token);
    mContext=d.getContext();
    d.show();
    return helper;
  }
  return null;
}",0.9314516129032258
43379,"LayoutInflater getInflater(){
  if (mInflater == null) {
    Context wrappedContext=new ContextThemeWrapper(mContext,THEME_RES_FOR_TYPE[mMenuType]);
    mInflater=(LayoutInflater)wrappedContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  return mInflater;
}","LayoutInflater getInflater(){
  if (mInflater == null) {
    Context wrappedContext=new ContextThemeWrapper(getContext(),THEME_RES_FOR_TYPE[mMenuType]);
    mInflater=(LayoutInflater)wrappedContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  return mInflater;
}",0.9632352941176472
43380,"/** 
 * Shows menu as a dialog. 
 * @param windowToken Optional token to assign to the window.
 */
public void show(IBinder windowToken){
  final MenuBuilder menu=mMenu;
  mAdapter=menu.getMenuAdapter(MenuBuilder.TYPE_DIALOG);
  final AlertDialog.Builder builder=new AlertDialog.Builder(menu.getContext()).setAdapter(mAdapter,this);
  final View headerView=menu.getHeaderView();
  if (headerView != null) {
    builder.setCustomTitle(headerView);
  }
 else {
    builder.setIcon(menu.getHeaderIcon()).setTitle(menu.getHeaderTitle());
  }
  builder.setOnKeyListener(this);
  builder.setRecycleOnMeasureEnabled(false);
  mDialog=builder.create();
  WindowManager.LayoutParams lp=mDialog.getWindow().getAttributes();
  lp.type=WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;
  if (windowToken != null) {
    lp.token=windowToken;
  }
  lp.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  mDialog.show();
}","/** 
 * Shows menu as a dialog. 
 * @param windowToken Optional token to assign to the window.
 */
public void show(IBinder windowToken){
  create(windowToken);
  mDialog.show();
}",0.3257918552036199
43381,"@Override public void inflate(Resources r,XmlPullParser parser,AttributeSet attrs) throws XmlPullParserException, IOException {
  final GradientState st=mGradientState;
  TypedArray a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawable);
  super.inflateWithAttributes(r,parser,a,com.android.internal.R.styleable.GradientDrawable_visible);
  int shapeType=a.getInt(com.android.internal.R.styleable.GradientDrawable_shape,RECTANGLE);
  if (shapeType == RING) {
    st.mInnerRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_innerRadius,-1);
    if (st.mInnerRadius == -1) {
      st.mInnerRadiusRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_innerRadiusRatio,3.0f);
    }
    st.mThickness=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_thickness,-1);
    if (st.mThickness == -1) {
      st.mThicknessRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_thicknessRatio,9.0f);
    }
    st.mUseLevelForShape=a.getBoolean(com.android.internal.R.styleable.GradientDrawable_useLevel,true);
  }
  a.recycle();
  setShape(shapeType);
  int type;
  final int innerDepth=parser.getDepth() + 1;
  int depth;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && ((depth=parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
    if (type != XmlPullParser.START_TAG) {
      continue;
    }
    if (depth > innerDepth) {
      continue;
    }
    String name=parser.getName();
    if (name.equals(""String_Node_Str"")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSize);
      int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_width,-1);
      int height=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_height,-1);
      a.recycle();
      setSize(width,height);
    }
 else     if (name.equals(""String_Node_Str"")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableGradient);
      int startColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_startColor,0);
      boolean hasCenterColor=a.hasValue(com.android.internal.R.styleable.GradientDrawableGradient_centerColor);
      int centerColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_centerColor,0);
      int endColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_endColor,0);
      int gradientType=a.getInt(com.android.internal.R.styleable.GradientDrawableGradient_type,LINEAR_GRADIENT);
      st.mCenterX=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerX,0.5f);
      st.mCenterY=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerY,0.5f);
      st.mUseLevel=a.getBoolean(com.android.internal.R.styleable.GradientDrawableGradient_useLevel,false);
      st.mGradient=gradientType;
      if (gradientType == LINEAR_GRADIENT) {
        int angle=(int)a.getFloat(com.android.internal.R.styleable.GradientDrawableGradient_angle,0);
        angle%=360;
        if (angle % 45 != 0) {
          throw new XmlPullParserException(a.getPositionDescription() + ""String_Node_Str"" + ""String_Node_Str"");
        }
switch (angle) {
case 0:
          st.mOrientation=Orientation.LEFT_RIGHT;
        break;
case 45:
      st.mOrientation=Orientation.BL_TR;
    break;
case 90:
  st.mOrientation=Orientation.BOTTOM_TOP;
break;
case 135:
st.mOrientation=Orientation.BR_TL;
break;
case 180:
st.mOrientation=Orientation.RIGHT_LEFT;
break;
case 225:
st.mOrientation=Orientation.TR_BL;
break;
case 270:
st.mOrientation=Orientation.TOP_BOTTOM;
break;
case 315:
st.mOrientation=Orientation.TL_BR;
break;
}
}
 else {
TypedValue tv=a.peekValue(com.android.internal.R.styleable.GradientDrawableGradient_gradientRadius);
if (tv != null) {
boolean radiusRel=tv.type == TypedValue.TYPE_FRACTION;
st.mGradientRadius=radiusRel ? tv.getFraction(1.0f,1.0f) : tv.getFloat();
}
 else if (gradientType == RADIAL_GRADIENT) {
throw new XmlPullParserException(a.getPositionDescription() + ""String_Node_Str"" + ""String_Node_Str"");
}
}
a.recycle();
if (hasCenterColor) {
st.mColors=new int[3];
st.mColors[0]=startColor;
st.mColors[1]=centerColor;
st.mColors[2]=endColor;
st.mPositions=new float[3];
st.mPositions[0]=0.0f;
st.mPositions[1]=st.mCenterX != 0.5f ? st.mCenterX : st.mCenterY;
st.mPositions[2]=1f;
}
 else {
st.mColors=new int[2];
st.mColors[0]=startColor;
st.mColors[1]=endColor;
}
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSolid);
int argb=a.getColor(com.android.internal.R.styleable.GradientDrawableSolid_color,0);
a.recycle();
setColor(argb);
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableStroke);
int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableStroke_width,0);
int color=a.getColor(com.android.internal.R.styleable.GradientDrawableStroke_color,0);
float dashWidth=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashWidth,0);
if (dashWidth != 0.0f) {
float dashGap=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashGap,0);
setStroke(width,color,dashWidth,dashGap);
}
 else {
setStroke(width,color);
}
a.recycle();
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.DrawableCorners);
int radius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_radius,0);
setCornerRadius(radius);
int topLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topLeftRadius,radius);
int topRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topRightRadius,radius);
int bottomLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomLeftRadius,radius);
int bottomRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomRightRadius,radius);
if (topLeftRadius != radius && topRightRadius != radius && bottomLeftRadius != radius && bottomRightRadius != radius) {
setCornerRadii(new float[]{topLeftRadius,topLeftRadius,topRightRadius,topRightRadius,bottomLeftRadius,bottomLeftRadius,bottomRightRadius,bottomRightRadius});
}
a.recycle();
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawablePadding);
mPadding=new Rect(a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_left,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_top,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_right,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_bottom,0));
a.recycle();
mGradientState.mPadding=mPadding;
}
 else {
Log.w(""String_Node_Str"",""String_Node_Str"" + name);
}
}
}","@Override public void inflate(Resources r,XmlPullParser parser,AttributeSet attrs) throws XmlPullParserException, IOException {
  final GradientState st=mGradientState;
  TypedArray a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawable);
  super.inflateWithAttributes(r,parser,a,com.android.internal.R.styleable.GradientDrawable_visible);
  int shapeType=a.getInt(com.android.internal.R.styleable.GradientDrawable_shape,RECTANGLE);
  if (shapeType == RING) {
    st.mInnerRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_innerRadius,-1);
    if (st.mInnerRadius == -1) {
      st.mInnerRadiusRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_innerRadiusRatio,3.0f);
    }
    st.mThickness=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_thickness,-1);
    if (st.mThickness == -1) {
      st.mThicknessRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_thicknessRatio,9.0f);
    }
    st.mUseLevelForShape=a.getBoolean(com.android.internal.R.styleable.GradientDrawable_useLevel,true);
  }
  a.recycle();
  setShape(shapeType);
  int type;
  final int innerDepth=parser.getDepth() + 1;
  int depth;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && ((depth=parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
    if (type != XmlPullParser.START_TAG) {
      continue;
    }
    if (depth > innerDepth) {
      continue;
    }
    String name=parser.getName();
    if (name.equals(""String_Node_Str"")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSize);
      int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_width,-1);
      int height=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_height,-1);
      a.recycle();
      setSize(width,height);
    }
 else     if (name.equals(""String_Node_Str"")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableGradient);
      int startColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_startColor,0);
      boolean hasCenterColor=a.hasValue(com.android.internal.R.styleable.GradientDrawableGradient_centerColor);
      int centerColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_centerColor,0);
      int endColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_endColor,0);
      int gradientType=a.getInt(com.android.internal.R.styleable.GradientDrawableGradient_type,LINEAR_GRADIENT);
      st.mCenterX=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerX,0.5f);
      st.mCenterY=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerY,0.5f);
      st.mUseLevel=a.getBoolean(com.android.internal.R.styleable.GradientDrawableGradient_useLevel,false);
      st.mGradient=gradientType;
      if (gradientType == LINEAR_GRADIENT) {
        int angle=(int)a.getFloat(com.android.internal.R.styleable.GradientDrawableGradient_angle,0);
        angle%=360;
        if (angle % 45 != 0) {
          throw new XmlPullParserException(a.getPositionDescription() + ""String_Node_Str"" + ""String_Node_Str"");
        }
switch (angle) {
case 0:
          st.mOrientation=Orientation.LEFT_RIGHT;
        break;
case 45:
      st.mOrientation=Orientation.BL_TR;
    break;
case 90:
  st.mOrientation=Orientation.BOTTOM_TOP;
break;
case 135:
st.mOrientation=Orientation.BR_TL;
break;
case 180:
st.mOrientation=Orientation.RIGHT_LEFT;
break;
case 225:
st.mOrientation=Orientation.TR_BL;
break;
case 270:
st.mOrientation=Orientation.TOP_BOTTOM;
break;
case 315:
st.mOrientation=Orientation.TL_BR;
break;
}
}
 else {
TypedValue tv=a.peekValue(com.android.internal.R.styleable.GradientDrawableGradient_gradientRadius);
if (tv != null) {
boolean radiusRel=tv.type == TypedValue.TYPE_FRACTION;
st.mGradientRadius=radiusRel ? tv.getFraction(1.0f,1.0f) : tv.getFloat();
}
 else if (gradientType == RADIAL_GRADIENT) {
throw new XmlPullParserException(a.getPositionDescription() + ""String_Node_Str"" + ""String_Node_Str"");
}
}
a.recycle();
if (hasCenterColor) {
st.mColors=new int[3];
st.mColors[0]=startColor;
st.mColors[1]=centerColor;
st.mColors[2]=endColor;
st.mPositions=new float[3];
st.mPositions[0]=0.0f;
st.mPositions[1]=st.mCenterX != 0.5f ? st.mCenterX : st.mCenterY;
st.mPositions[2]=1f;
}
 else {
st.mColors=new int[2];
st.mColors[0]=startColor;
st.mColors[1]=endColor;
}
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSolid);
int argb=a.getColor(com.android.internal.R.styleable.GradientDrawableSolid_color,0);
a.recycle();
setColor(argb);
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableStroke);
int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableStroke_width,0);
int color=a.getColor(com.android.internal.R.styleable.GradientDrawableStroke_color,0);
float dashWidth=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashWidth,0);
if (dashWidth != 0.0f) {
float dashGap=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashGap,0);
setStroke(width,color,dashWidth,dashGap);
}
 else {
setStroke(width,color);
}
a.recycle();
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.DrawableCorners);
int radius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_radius,0);
setCornerRadius(radius);
int topLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topLeftRadius,radius);
int topRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topRightRadius,radius);
int bottomLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomLeftRadius,radius);
int bottomRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomRightRadius,radius);
if (topLeftRadius != radius && topRightRadius != radius && bottomLeftRadius != radius && bottomRightRadius != radius) {
setCornerRadii(new float[]{topLeftRadius,topLeftRadius,topRightRadius,topRightRadius,bottomRightRadius,bottomRightRadius,bottomLeftRadius,bottomLeftRadius});
}
a.recycle();
}
 else if (name.equals(""String_Node_Str"")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawablePadding);
mPadding=new Rect(a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_left,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_top,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_right,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_bottom,0));
a.recycle();
mGradientState.mPadding=mPadding;
}
 else {
Log.w(""String_Node_Str"",""String_Node_Str"" + name);
}
}
}",0.9948798179490826
43382,"/** 
 * @param context Parent.
 * @param theme the theme to apply to this dialog
 * @param callBack How parent is notified.
 * @param hourOfDay The initial hour.
 * @param minute The initial minute.
 * @param is24HourView Whether this is a 24 hour view, or AM/PM.
 */
public TimePickerDialog(Context context,int theme,OnTimeSetListener callBack,int hourOfDay,int minute,boolean is24HourView){
  super(context,theme);
  mCallback=callBack;
  mInitialHourOfDay=hourOfDay;
  mInitialMinute=minute;
  mIs24HourView=is24HourView;
  mDateFormat=DateFormat.getTimeFormat(context);
  mCalendar=Calendar.getInstance();
  updateTitle(mInitialHourOfDay,mInitialMinute);
  setButton(context.getText(R.string.date_time_set),this);
  setButton2(context.getText(R.string.cancel),(OnClickListener)null);
  setIcon(R.drawable.ic_dialog_time);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  setView(view);
  mTimePicker=(TimePicker)view.findViewById(R.id.timePicker);
  mTimePicker.setCurrentHour(mInitialHourOfDay);
  mTimePicker.setCurrentMinute(mInitialMinute);
  mTimePicker.setIs24HourView(mIs24HourView);
  mTimePicker.setOnTimeChangedListener(this);
}","/** 
 * @param context Parent.
 * @param theme the theme to apply to this dialog
 * @param callBack How parent is notified.
 * @param hourOfDay The initial hour.
 * @param minute The initial minute.
 * @param is24HourView Whether this is a 24 hour view, or AM/PM.
 */
public TimePickerDialog(Context context,int theme,OnTimeSetListener callBack,int hourOfDay,int minute,boolean is24HourView){
  super(context,theme);
  mCallback=callBack;
  mInitialHourOfDay=hourOfDay;
  mInitialMinute=minute;
  mIs24HourView=is24HourView;
  mDateFormat=DateFormat.getTimeFormat(getContext());
  mCalendar=Calendar.getInstance();
  updateTitle(mInitialHourOfDay,mInitialMinute);
  setButton(context.getText(R.string.date_time_set),this);
  setButton2(context.getText(R.string.cancel),(OnClickListener)null);
  setIcon(R.drawable.ic_dialog_time);
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=inflater.inflate(R.layout.time_picker_dialog,null);
  setView(view);
  mTimePicker=(TimePicker)view.findViewById(R.id.timePicker);
  mTimePicker.setCurrentHour(mInitialHourOfDay);
  mTimePicker.setCurrentMinute(mInitialMinute);
  mTimePicker.setIs24HourView(mIs24HourView);
  mTimePicker.setOnTimeChangedListener(this);
}",0.9944664031620554
43383,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}",0.9896414342629484
43384,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}",0.4682395644283121
43385,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}",0.9233926128590972
43386,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.9173457508731082
43387,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.8687258687258688
43388,"/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  for (int i=0, count=mServices.size(); i < count; i++) {
    Service service=mServices.get(i);
    if (service.mIsDefault == isDefault) {
      if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
        mHandledFeedbackTypes|=service.mFeedbackType;
        notifyAccessibilityServiceDelayedLocked(service,event);
      }
    }
  }
}","/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  try {
    for (int i=0, count=mServices.size(); i < count; i++) {
      Service service=mServices.get(i);
      if (service.mIsDefault == isDefault) {
        if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
          mHandledFeedbackTypes|=service.mFeedbackType;
          notifyAccessibilityServiceDelayedLocked(service,event);
        }
      }
    }
  }
 catch (  IndexOutOfBoundsException oobe) {
    return;
  }
}",0.9415584415584416
43389,"@Override protected void onBindView(View view){
  super.onBindView(view);
  SeekBar seekbar=(SeekBar)view.findViewById(com.android.internal.R.id.seekbar_preference);
  if (seekbar != null) {
    seekbar.setProgress(mProgress);
    if (mThumb != null)     seekbar.setThumb(mThumb);
    if (mThumbOffset > 0)     seekbar.setThumbOffset(mThumbOffset);
    if (mMinWidth > 0)     seekbar.setMinimumWidth(mMinWidth);
    if (mMax > 0)     seekbar.setMax(mMax);
    seekbar.setOnSeekBarChangeListener(this);
  }
}","@Override protected void onBindView(View view){
  super.onBindView(view);
  SeekBar seekbar=(SeekBar)view.findViewById(com.android.internal.R.id.seekbar_preference);
  if (seekbar != null) {
    if (mMax > 0)     seekbar.setMax(mMax);
    if (mThumb != null)     seekbar.setThumb(mThumb);
    if (mThumbOffset > 0)     seekbar.setThumbOffset(mThumbOffset);
    if (mMinWidth > 0)     seekbar.setMinimumWidth(mMinWidth);
    if (mProgress > 0)     seekbar.setProgress(mProgress);
    seekbar.setOnSeekBarChangeListener(this);
  }
}",0.9006750241080038
43390,"/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_SPEAKER) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  IAudioService service=getService();
  try {
    return service.isSpeakerphoneOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.5512820512820513
43391,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6524822695035462
43392,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.5585331452750353
43393,"/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  IAudioService service=getService();
  try {
    return service.isBluetoothScoOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.5727411944869831
43394,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mHeadsetState=0;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}",0.9328671328671329
43395,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO),address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_TTY);
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_TTY),""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_HEADPHONE);
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_SPEAKER);
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_SPEAKER),""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}",0.8498947860649988
43396,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.getMode();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerMode(mRingerMode);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.8062325209748302
43397,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}",0.9896414342629484
43398,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}",0.4682395644283121
43399,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}",0.9233926128590972
43400,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.9173457508731082
43401,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.8687258687258688
43402,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}",0.9869665218502428
43403,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9964831280321748
43404,"final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,null);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}","final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,dm);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}",0.9975389663658736
43405,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}",0.9987747009156326
43406,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}",0.9987747009156326
43407,"public void handleMessage(Message msg){
  AsyncResult ar;
switch (msg.what) {
case EVENT_POLL_CALLS_RESULT:
{
      Log.d(LOG_TAG,""String_Node_Str"");
      ar=(AsyncResult)msg.obj;
      if (msg == lastRelevantPoll) {
        if (DBG_POLL)         log(""String_Node_Str"");
        needsPoll=false;
        lastRelevantPoll=null;
        handlePollCalls((AsyncResult)msg.obj);
      }
    }
  break;
case EVENT_OPERATION_COMPLETE:
operationComplete();
break;
case EVENT_SWITCH_RESULT:
break;
case EVENT_GET_LAST_CALL_FAIL_CAUSE:
int causeCode;
ar=(AsyncResult)msg.obj;
operationComplete();
if (ar.exception != null) {
causeCode=CallFailCause.NORMAL_CLEARING;
Log.i(LOG_TAG,""String_Node_Str"");
}
 else {
causeCode=((int[])ar.result)[0];
}
for (int i=0, s=droppedDuringPoll.size(); i < s; i++) {
CdmaConnection conn=droppedDuringPoll.get(i);
conn.onRemoteDisconnect(causeCode);
}
updatePhoneState();
phone.notifyPreciseCallStateChanged();
droppedDuringPoll.clear();
break;
case EVENT_REPOLL_AFTER_DELAY:
case EVENT_CALL_STATE_CHANGE:
pollCallsWhenSafe();
break;
case EVENT_RADIO_AVAILABLE:
handleRadioAvailable();
break;
case EVENT_RADIO_NOT_AVAILABLE:
handleRadioNotAvailable();
break;
case EVENT_EXIT_ECM_RESPONSE_CDMA:
if (pendingCallInECM) {
cm.dial(pendingMO.address,pendingCallClirMode,obtainCompleteMessage());
pendingCallInECM=false;
}
phone.unsetOnEcbModeExitResponse(this);
break;
case EVENT_CALL_WAITING_INFO_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
handleCallWaitingInfo((CdmaCallWaitingNotification)ar.result);
Log.d(LOG_TAG,""String_Node_Str"");
}
break;
case EVENT_THREE_WAY_DIAL_L2_RESULT_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
pendingMO.onConnectedInOrOut();
}
break;
default :
{
throw new RuntimeException(""String_Node_Str"");
}
}
}","public void handleMessage(Message msg){
  AsyncResult ar;
switch (msg.what) {
case EVENT_POLL_CALLS_RESULT:
{
      Log.d(LOG_TAG,""String_Node_Str"");
      ar=(AsyncResult)msg.obj;
      if (msg == lastRelevantPoll) {
        if (DBG_POLL)         log(""String_Node_Str"");
        needsPoll=false;
        lastRelevantPoll=null;
        handlePollCalls((AsyncResult)msg.obj);
      }
    }
  break;
case EVENT_OPERATION_COMPLETE:
operationComplete();
break;
case EVENT_SWITCH_RESULT:
break;
case EVENT_GET_LAST_CALL_FAIL_CAUSE:
int causeCode;
ar=(AsyncResult)msg.obj;
operationComplete();
if (ar.exception != null) {
causeCode=CallFailCause.NORMAL_CLEARING;
Log.i(LOG_TAG,""String_Node_Str"");
}
 else {
causeCode=((int[])ar.result)[0];
}
for (int i=0, s=droppedDuringPoll.size(); i < s; i++) {
CdmaConnection conn=droppedDuringPoll.get(i);
conn.onRemoteDisconnect(causeCode);
}
updatePhoneState();
phone.notifyPreciseCallStateChanged();
droppedDuringPoll.clear();
break;
case EVENT_REPOLL_AFTER_DELAY:
case EVENT_CALL_STATE_CHANGE:
pollCallsWhenSafe();
break;
case EVENT_RADIO_AVAILABLE:
handleRadioAvailable();
break;
case EVENT_RADIO_NOT_AVAILABLE:
handleRadioNotAvailable();
break;
case EVENT_EXIT_ECM_RESPONSE_CDMA:
if (pendingCallInECM) {
cm.dial(pendingMO.address,pendingCallClirMode,obtainCompleteMessage());
pendingCallInECM=false;
}
phone.unsetOnEcbModeExitResponse(this);
break;
case EVENT_CALL_WAITING_INFO_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
handleCallWaitingInfo((CdmaCallWaitingNotification)ar.result);
Log.d(LOG_TAG,""String_Node_Str"");
}
break;
case EVENT_THREE_WAY_DIAL_L2_RESULT_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
pendingMO.onConnectedInOrOut();
pendingMO=null;
}
break;
default :
{
throw new RuntimeException(""String_Node_Str"");
}
}
}",0.9955282280603688
43408,"private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=p.readInt();
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}","private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=notification.presentationFromCLIP(p.readInt());
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}",0.947680157946693
43409,"private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLog(response);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}","private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}",0.9984712285207608
43410,"/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length < NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}","/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length >= NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}",0.998652896273013
43411,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.TTS_ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(1000,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.TTS_SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.TTS_ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.TTS_SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.989667049368542
43412,"private void processSpeechQueue(){
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock();
    if (!speechQueueAvailable) {
      return;
    }
    if (mSpeechQueue.size() < 1) {
      mIsSpeaking=false;
      broadcastTtsQueueProcessingCompleted();
      return;
    }
    mCurrentSpeechItem=mSpeechQueue.get(0);
    mIsSpeaking=true;
    SoundResource sr=getSoundResource(mCurrentSpeechItem);
    Log.i(""String_Node_Str"",""String_Node_Str"" + mCurrentSpeechItem.mText);
    if (sr == null) {
      if (mCurrentSpeechItem.mType == SpeechItem.TEXT) {
        mCurrentSpeechItem=splitCurrentTextIfNeeded(mCurrentSpeechItem);
        speakInternalOnly(mCurrentSpeechItem);
      }
 else       if (mCurrentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
        synthToFileInternalOnly(mCurrentSpeechItem);
      }
 else {
        silence(mCurrentSpeechItem);
      }
    }
 else {
      cleanUpPlayer();
      if (sr.mSourcePackageName == PKGNAME) {
        mPlayer=MediaPlayer.create(this,sr.mResId);
      }
 else       if (sr.mSourcePackageName != null) {
        Context ctx;
        try {
          ctx=this.createPackageContext(sr.mSourcePackageName,0);
        }
 catch (        NameNotFoundException e) {
          e.printStackTrace();
          mSpeechQueue.remove(0);
          mIsSpeaking=false;
          return;
        }
        mPlayer=MediaPlayer.create(ctx,sr.mResId);
      }
 else {
        mPlayer=MediaPlayer.create(this,Uri.parse(sr.mFilename));
      }
      if (mPlayer == null) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        return;
      }
      mPlayer.setOnCompletionListener(this);
      try {
        mPlayer.setAudioStreamType(getStreamTypeFromParams(mCurrentSpeechItem.mParams));
        mPlayer.start();
      }
 catch (      IllegalStateException e) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        cleanUpPlayer();
        return;
      }
    }
    if (mSpeechQueue.size() > 0) {
      mSpeechQueue.remove(0);
    }
  }
  finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
  }
}","private void processSpeechQueue(){
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (!speechQueueAvailable) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    if (mSpeechQueue.size() < 1) {
      mIsSpeaking=false;
      broadcastTtsQueueProcessingCompleted();
      return;
    }
    mCurrentSpeechItem=mSpeechQueue.get(0);
    mIsSpeaking=true;
    SoundResource sr=getSoundResource(mCurrentSpeechItem);
    Log.i(""String_Node_Str"",""String_Node_Str"" + mCurrentSpeechItem.mText);
    if (sr == null) {
      if (mCurrentSpeechItem.mType == SpeechItem.TEXT) {
        mCurrentSpeechItem=splitCurrentTextIfNeeded(mCurrentSpeechItem);
        speakInternalOnly(mCurrentSpeechItem);
      }
 else       if (mCurrentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
        synthToFileInternalOnly(mCurrentSpeechItem);
      }
 else {
        silence(mCurrentSpeechItem);
      }
    }
 else {
      cleanUpPlayer();
      if (sr.mSourcePackageName == PKGNAME) {
        mPlayer=MediaPlayer.create(this,sr.mResId);
      }
 else       if (sr.mSourcePackageName != null) {
        Context ctx;
        try {
          ctx=this.createPackageContext(sr.mSourcePackageName,0);
        }
 catch (        NameNotFoundException e) {
          e.printStackTrace();
          mSpeechQueue.remove(0);
          mIsSpeaking=false;
          return;
        }
        mPlayer=MediaPlayer.create(ctx,sr.mResId);
      }
 else {
        mPlayer=MediaPlayer.create(this,Uri.parse(sr.mFilename));
      }
      if (mPlayer == null) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        return;
      }
      mPlayer.setOnCompletionListener(this);
      try {
        mPlayer.setAudioStreamType(getStreamTypeFromParams(mCurrentSpeechItem.mParams));
        mPlayer.start();
      }
 catch (      IllegalStateException e) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        cleanUpPlayer();
        return;
      }
    }
    if (mSpeechQueue.size() > 0) {
      mSpeechQueue.remove(0);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
  }
}",0.953388876379194
43413,"/** 
 * @see AudioManager#reloadAudioSettings() 
 */
public void reloadAudioSettings(){
  readPersistedSettings();
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=0; streamType < numStreamTypes; streamType++) {
    VolumeStreamState streamState=mStreamStates[streamType];
    if (streamType != AudioSystem.STREAM_BLUETOOTH_SCO) {
      String settingName=System.VOLUME_SETTINGS[streamType];
      String lastAudibleSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
      int index=Settings.System.getInt(mContentResolver,settingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
      if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
        index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
      }
 else {
        index*=10;
      }
      streamState.mIndex=streamState.getValidIndex(index);
      index=(index + 5) / 10;
      index=Settings.System.getInt(mContentResolver,lastAudibleSettingName,(index > 0) ? index : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
      if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
        index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
      }
 else {
        index*=10;
      }
      streamState.mLastAudibleIndex=streamState.getValidIndex(index);
    }
    if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType)) {
      int size=streamState.mDeathHandlers.size();
      for (int i=0; i < size; i++) {
        streamState.mDeathHandlers.get(i).mMuteCount=1;
        streamState.mDeathHandlers.get(i).mute(false);
      }
    }
    if (streamState.muteCount() == 0) {
      setStreamVolumeIndex(streamType,streamState.mIndex);
    }
  }
  setRingerModeInt(getRingerMode(),false);
}","/** 
 * @see AudioManager#reloadAudioSettings() 
 */
public void reloadAudioSettings(){
  readPersistedSettings();
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=0; streamType < numStreamTypes; streamType++) {
    VolumeStreamState streamState=mStreamStates[streamType];
    String settingName=System.VOLUME_SETTINGS[STREAM_VOLUME_ALIAS[streamType]];
    String lastAudibleSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
    int index=Settings.System.getInt(mContentResolver,settingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
    if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
      index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
    }
 else {
      index*=10;
    }
    streamState.mIndex=streamState.getValidIndex(index);
    index=(index + 5) / 10;
    index=Settings.System.getInt(mContentResolver,lastAudibleSettingName,(index > 0) ? index : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
    if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
      index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
    }
 else {
      index*=10;
    }
    streamState.mLastAudibleIndex=streamState.getValidIndex(index);
    if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType)) {
      int size=streamState.mDeathHandlers.size();
      for (int i=0; i < size; i++) {
        streamState.mDeathHandlers.get(i).mMuteCount=1;
        streamState.mDeathHandlers.get(i).mute(false);
      }
    }
    if (streamState.muteCount() == 0) {
      setStreamVolumeIndex(streamType,streamState.mIndex);
    }
  }
  setRingerModeInt(getRingerMode(),false);
}",0.9639190378410092
43414,"/** 
 * Recycles an event if it can be safely recycled. The condition is that no not notified service is interested in the event.
 * @param event The event.
 */
private void tryRecycleLocked(AccessibilityEvent event){
  int eventType=event.getEventType();
  List<Service> services=mServices;
  for (int i=0, count=services.size(); i < count; i++) {
    Service service=services.get(i);
    if (service.mPendingEvents.get(eventType) == event) {
      return;
    }
  }
  event.recycle();
}","/** 
 * Recycles an event if it can be safely recycled. The condition is that no not notified service is interested in the event.
 * @param event The event.
 */
private void tryRecycleLocked(AccessibilityEvent event){
  if (event == null) {
    return;
  }
  int eventType=event.getEventType();
  List<Service> services=mServices;
  for (int i=0, count=services.size(); i < count; i++) {
    Service service=services.get(i);
    if (service.mPendingEvents.get(eventType) == event) {
      return;
    }
  }
  event.recycle();
}",0.961576354679803
43415,"/** 
 * Request the device MDN / H_SID / H_NID / MIN. ""response"" is const char  [0] is MDN if CDMA subscription is available [1] is H_SID (Home SID) if CDMA subscription is available [2] is H_NID (Home NID) if CDMA subscription is available [3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
 */
public void getCDMASubscription(Message response);","/** 
 * Request the device MDN / H_SID / H_NID / MIN. ""response"" is const char  [0] is MDN if CDMA subscription is available [1] is H_SID (Home SID) in hexadecimal if CDMA subscription is available [2] is H_NID (Home NID) in hexadecimal if CDMA subscription is available [3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
 */
public void getCDMASubscription(Message response);",0.9603174603174603
43416,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0]) : 0;
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0]) : 0;
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0],16) : 0;
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0],16) : 0;
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.9992507492507492
43417,"/** 
 * @return Whether music is being played right now.
 */
boolean isMusicActive(){
  final IAudioService audio=getAudioInterface();
  if (audio == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return audio.isMusicActive();
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
    return false;
  }
}","/** 
 * @return Whether music is being played right now.
 */
boolean isMusicActive(){
  final AudioManager am=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  if (am == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  return am.isMusicActive();
}",0.5886075949367089
43418,"/** 
 * Check a parcel containing metadata is well formed. The header is checked as well as the individual records format. However, the data inside the record is not checked because we do lazy access (we check/unmarshall only data the user asks for.) Format of a metadata parcel: <pre> 1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                     metadata total size                       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |     'M'       |     'E'       |     'T'       |     'A'       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                .... metadata records ....                     | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </pre>
 * @param parcel With the serialized data. Metadata keeps areference on it to access it later on. The caller should not modify the parcel after this call (and not call recycle on it.)
 * @return false if an error occurred.
 */
public boolean parse(Parcel parcel){
  if (parcel.dataAvail() < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + parcel.dataAvail());
    return false;
  }
  final int pin=parcel.dataPosition();
  final int size=parcel.readInt();
  if (parcel.dataAvail() < size || size < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + size);
    parcel.setDataPosition(pin);
    return false;
  }
  final int kShouldBeMetaMarker=parcel.readInt();
  if (kShouldBeMetaMarker != kMetaMarker) {
    Log.e(TAG,""String_Node_Str"" + Integer.toHexString(kShouldBeMetaMarker));
    parcel.setDataPosition(pin);
    return false;
  }
  if (!scanAllRecords(parcel,size - kMetaHeaderSize)) {
    parcel.setDataPosition(pin);
    return false;
  }
  mParcel=parcel;
  return true;
}","/** 
 * Check a parcel containing metadata is well formed. The header is checked as well as the individual records format. However, the data inside the record is not checked because we do lazy access (we check/unmarshall only data the user asks for.) Format of a metadata parcel: <pre> 1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                     metadata total size                       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |     'M'       |     'E'       |     'T'       |     'A'       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                .... metadata records ....                     | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </pre>
 * @param parcel With the serialized data. Metadata keeps areference on it to access it later on. The caller should not modify the parcel after this call (and not call recycle on it.)
 * @return false if an error occurred.
 */
public boolean parse(Parcel parcel){
  if (parcel.dataAvail() < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + parcel.dataAvail());
    return false;
  }
  final int pin=parcel.dataPosition();
  final int size=parcel.readInt();
  if (parcel.dataAvail() + 4 < size || size < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + size + ""String_Node_Str""+ parcel.dataAvail()+ ""String_Node_Str""+ pin);
    parcel.setDataPosition(pin);
    return false;
  }
  final int kShouldBeMetaMarker=parcel.readInt();
  if (kShouldBeMetaMarker != kMetaMarker) {
    Log.e(TAG,""String_Node_Str"" + Integer.toHexString(kShouldBeMetaMarker));
    parcel.setDataPosition(pin);
    return false;
  }
  if (!scanAllRecords(parcel,size - kMetaHeaderSize)) {
    parcel.setDataPosition(pin);
    return false;
  }
  mParcel=parcel;
  return true;
}",0.9831349206349206
43419,"private void assertParse() throws Exception {
  mParcel.writeInt(kToken);
  mParcel.setDataPosition(0);
  assertTrue(mMetadata.parse(mParcel));
  assertEquals(kToken,mParcel.readInt());
}","private void assertParse() throws Exception {
  mParcel.setDataPosition(0);
  assertTrue(mMetadata.parse(mParcel));
}",0.7697368421052632
43420,"void acceptCall() throws CallStateException {
  if (ringingCall.getState() == CdmaCall.State.INCOMING) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    setMute(false);
    cm.acceptCall(obtainCompleteMessage());
  }
 else   if (ringingCall.getState() == CdmaCall.State.WAITING) {
    CdmaConnection cwConn=(CdmaConnection)(ringingCall.getLatestConnection());
    cwConn.updateParent(ringingCall,foregroundCall);
    cwConn.onConnectedInOrOut();
    switchWaitingOrHoldingAndActive();
  }
 else {
    throw new CallStateException(""String_Node_Str"");
  }
}","void acceptCall() throws CallStateException {
  if (ringingCall.getState() == CdmaCall.State.INCOMING) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    setMute(false);
    cm.acceptCall(obtainCompleteMessage());
  }
 else   if (ringingCall.getState() == CdmaCall.State.WAITING) {
    CdmaConnection cwConn=(CdmaConnection)(ringingCall.getLatestConnection());
    cwConn.updateParent(ringingCall,foregroundCall);
    cwConn.onConnectedInOrOut();
    updatePhoneState();
    switchWaitingOrHoldingAndActive();
  }
 else {
    throw new CallStateException(""String_Node_Str"");
  }
}",0.978984238178634
43421,"protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      connections[i]=null;
    }
 else     if (conn != null && dc != null && !conn.compareTo(dc)) {
      droppedDuringPoll.add(conn);
      connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
      if (connections[i].getCall() == ringingCall) {
        newRinging=connections[i];
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInECM) {
      pendingCallInECM=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}","protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInECM) {
      pendingCallInECM=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}",0.967391304347826
43422,"private void handleCallWaitingInfo(CdmaCallWaitingNotification cw){
  if (foregroundCall.connections.size() > 1) {
    foregroundCall.setGeneric(true);
  }
  ringingCall.setGeneric(false);
  new CdmaConnection(phone.getContext(),cw,this,ringingCall);
  notifyCallWaitingInfo(cw);
}","private void handleCallWaitingInfo(CdmaCallWaitingNotification cw){
  if (foregroundCall.connections.size() > 1) {
    foregroundCall.setGeneric(true);
  }
  ringingCall.setGeneric(false);
  new CdmaConnection(phone.getContext(),cw,this,ringingCall);
  updatePhoneState();
  notifyCallWaitingInfo(cw);
}",0.9623287671232876
43423,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,streamState.mIndex);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,streamState.mLastAudibleIndex);
}","private void persistVolume(VolumeStreamState streamState){
  if (streamState.mStreamType != AudioManager.STREAM_BLUETOOTH_SCO) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,streamState.mIndex);
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,streamState.mLastAudibleIndex);
  }
}",0.8704318936877077
43424,"public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation != Configuration.NAVIGATION_NONAV) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}","public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation == Configuration.NAVIGATION_DPAD || mConfiguration.navigation == Configuration.NAVIGATION_TRACKBALL) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED && mConfiguration.keyboard != Configuration.KEYBOARD_NOKEYS) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}",0.7958883994126285
43425,"public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation != Configuration.NAVIGATION_NONAV) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}","public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation == Configuration.NAVIGATION_DPAD || mConfiguration.navigation == Configuration.NAVIGATION_TRACKBALL) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED && mConfiguration.keyboard != Configuration.KEYBOARD_NOKEYS) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}",0.7958883994126285
43426,"private final void updateBattery(Intent intent){
  mBatteryData.iconId=intent.getIntExtra(""String_Node_Str"",0);
  mBatteryData.iconLevel=intent.getIntExtra(""String_Node_Str"",0);
  mService.updateIcon(mBatteryIcon,mBatteryData,null);
  int plugged=intent.getIntExtra(""String_Node_Str"",0);
  int level=intent.getIntExtra(""String_Node_Str"",-1);
  if (false) {
    Log.d(TAG,""String_Node_Str"" + level + ""String_Node_Str""+ plugged+ ""String_Node_Str""+ mBatteryPlugged+ ""String_Node_Str""+ mBatteryLevel+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ mBatteryFirst);
  }
  int oldPlugged=mBatteryPlugged;
  int oldThreshold=mBatteryThreshold;
  pickNextBatteryLevel(level);
  mBatteryPlugged=plugged;
  mBatteryLevel=level;
  if (mBatteryFirst) {
    mBatteryFirst=false;
  }
  if (false) {
    Log.d(TAG,""String_Node_Str"" + plugged + ""String_Node_Str""+ oldPlugged+ ""String_Node_Str""+ level+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ oldThreshold);
  }
  if (plugged == 0 && ((oldPlugged != 0 && level < mBatteryThresholds[BATTERY_THRESHOLD_WARNING]) || (mBatteryThreshold > oldThreshold && mBatteryThreshold > BATTERY_THRESHOLD_WARNING))) {
    mSentLowBatteryBroadcast=true;
    mContext.sendBroadcast(new Intent(Intent.ACTION_BATTERY_LOW));
    if (SHOW_LOW_BATTERY_WARNING) {
      if (false) {
        Log.d(TAG,""String_Node_Str"" + mPhoneState + ""String_Node_Str""+ mLowBatteryDialog+ ""String_Node_Str""+ mBatteryShowLowOnEndCall);
      }
      if (mPhoneState == TelephonyManager.CALL_STATE_IDLE) {
        showLowBatteryWarning();
      }
 else {
        mBatteryShowLowOnEndCall=true;
      }
    }
  }
 else   if (mBatteryThreshold < BATTERY_THRESHOLD_WARNING) {
    if (mSentLowBatteryBroadcast == true) {
      mSentLowBatteryBroadcast=false;
      mContext.sendBroadcast(new Intent(Intent.ACTION_BATTERY_OKAY));
    }
    if (SHOW_LOW_BATTERY_WARNING) {
      if (mLowBatteryDialog != null) {
        mLowBatteryDialog.dismiss();
        mBatteryShowLowOnEndCall=false;
      }
    }
  }
}","private final void updateBattery(Intent intent){
  mBatteryData.iconId=intent.getIntExtra(""String_Node_Str"",0);
  mBatteryData.iconLevel=intent.getIntExtra(""String_Node_Str"",0);
  mService.updateIcon(mBatteryIcon,mBatteryData,null);
  int plugged=intent.getIntExtra(""String_Node_Str"",0);
  int level=intent.getIntExtra(""String_Node_Str"",-1);
  if (false) {
    Log.d(TAG,""String_Node_Str"" + level + ""String_Node_Str""+ plugged+ ""String_Node_Str""+ mBatteryPlugged+ ""String_Node_Str""+ mBatteryLevel+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ mBatteryFirst);
  }
  int oldPlugged=mBatteryPlugged;
  int oldThreshold=mBatteryThreshold;
  pickNextBatteryLevel(level);
  mBatteryPlugged=plugged;
  mBatteryLevel=level;
  if (mBatteryFirst) {
    mBatteryFirst=false;
  }
  if (false) {
    Log.d(TAG,""String_Node_Str"" + plugged + ""String_Node_Str""+ oldPlugged+ ""String_Node_Str""+ level+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ oldThreshold);
  }
  if (plugged == 0 && ((oldPlugged != 0 && level < mBatteryThresholds[BATTERY_THRESHOLD_WARNING]) || (mBatteryThreshold > oldThreshold && mBatteryThreshold > BATTERY_THRESHOLD_WARNING))) {
    mSentLowBatteryBroadcast=true;
    Intent batIntent=new Intent(Intent.ACTION_BATTERY_LOW);
    batIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mContext.sendBroadcast(batIntent);
    if (SHOW_LOW_BATTERY_WARNING) {
      if (false) {
        Log.d(TAG,""String_Node_Str"" + mPhoneState + ""String_Node_Str""+ mLowBatteryDialog+ ""String_Node_Str""+ mBatteryShowLowOnEndCall);
      }
      if (mPhoneState == TelephonyManager.CALL_STATE_IDLE) {
        showLowBatteryWarning();
      }
 else {
        mBatteryShowLowOnEndCall=true;
      }
    }
  }
 else   if (mBatteryThreshold < BATTERY_THRESHOLD_WARNING) {
    if (mSentLowBatteryBroadcast == true) {
      mSentLowBatteryBroadcast=false;
      Intent batIntent=new Intent(Intent.ACTION_BATTERY_OKAY);
      batIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(batIntent);
    }
    if (SHOW_LOW_BATTERY_WARNING) {
      if (mLowBatteryDialog != null) {
        mLowBatteryDialog.dismiss();
        mBatteryShowLowOnEndCall=false;
      }
    }
  }
}",0.9275634995296332
43427,"private Uri endFile(FileCacheEntry entry,boolean ringtones,boolean notifications,boolean alarms,boolean music,boolean podcasts) throws RemoteException {
  Uri tableUri;
  boolean isAudio=MediaFile.isAudioFileType(mFileType);
  boolean isVideo=MediaFile.isVideoFileType(mFileType);
  boolean isImage=MediaFile.isImageFileType(mFileType);
  if (isVideo) {
    tableUri=mVideoUri;
  }
 else   if (isImage) {
    tableUri=mImagesUri;
  }
 else   if (isAudio) {
    tableUri=mAudioUri;
  }
 else {
    return null;
  }
  entry.mTableUri=tableUri;
  if (mArtist == null || mArtist.length() == 0) {
    mArtist=mAlbumArtist;
  }
  ContentValues values=toValues();
  String title=values.getAsString(MediaStore.MediaColumns.TITLE);
  if (TextUtils.isEmpty(title)) {
    title=values.getAsString(MediaStore.MediaColumns.DATA);
    int lastSlash=title.lastIndexOf('/');
    if (lastSlash >= 0) {
      lastSlash++;
      if (lastSlash < title.length()) {
        title=title.substring(lastSlash);
      }
    }
    int lastDot=title.lastIndexOf('.');
    if (lastDot > 0) {
      title=title.substring(0,lastDot);
    }
    values.put(MediaStore.MediaColumns.TITLE,title);
  }
  if (isAudio) {
    values.put(Audio.Media.IS_RINGTONE,ringtones);
    values.put(Audio.Media.IS_NOTIFICATION,notifications);
    values.put(Audio.Media.IS_ALARM,alarms);
    values.put(Audio.Media.IS_MUSIC,music);
    values.put(Audio.Media.IS_PODCAST,podcasts);
  }
 else   if (mFileType == MediaFile.FILE_TYPE_JPEG) {
    HashMap<String,String> exifData=ExifInterface.loadExifData(entry.mPath);
    if (exifData != null) {
      float[] latlng=ExifInterface.getLatLng(exifData);
      if (latlng != null) {
        values.put(Images.Media.LATITUDE,latlng[0]);
        values.put(Images.Media.LONGITUDE,latlng[1]);
      }
    }
  }
  Uri result=null;
  long rowId=entry.mRowId;
  if (rowId == 0) {
    result=mMediaProvider.insert(tableUri,values);
    if (result != null) {
      rowId=ContentUris.parseId(result);
      entry.mRowId=rowId;
    }
  }
 else {
    result=ContentUris.withAppendedId(tableUri,rowId);
    mMediaProvider.update(result,values,null,null);
  }
  if (mProcessGenres && mGenre != null) {
    String genre=mGenre;
    Uri uri=mGenreCache.get(genre);
    if (uri == null) {
      Cursor cursor=null;
      try {
        cursor=mMediaProvider.query(mGenresUri,GENRE_LOOKUP_PROJECTION,MediaStore.Audio.Genres.NAME + ""String_Node_Str"",new String[]{genre},null);
        if (cursor == null || cursor.getCount() == 0) {
          values.clear();
          values.put(MediaStore.Audio.Genres.NAME,genre);
          uri=mMediaProvider.insert(mGenresUri,values);
        }
 else {
          cursor.moveToNext();
          uri=ContentUris.withAppendedId(mGenresUri,cursor.getLong(0));
        }
        if (uri != null) {
          uri=Uri.withAppendedPath(uri,Genres.Members.CONTENT_DIRECTORY);
          mGenreCache.put(genre,uri);
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
    if (uri != null) {
      values.clear();
      values.put(MediaStore.Audio.Genres.Members.AUDIO_ID,Long.valueOf(rowId));
      mMediaProvider.insert(uri,values);
    }
  }
  if (notifications && !mDefaultNotificationSet) {
    if (TextUtils.isEmpty(mDefaultNotificationFilename) || doesPathHaveFilename(entry.mPath,mDefaultNotificationFilename)) {
      setSettingIfNotSet(Settings.System.NOTIFICATION_SOUND,tableUri,rowId);
      mDefaultNotificationSet=true;
    }
  }
 else   if (ringtones && !mDefaultRingtoneSet) {
    if (TextUtils.isEmpty(mDefaultRingtoneFilename) || doesPathHaveFilename(entry.mPath,mDefaultRingtoneFilename)) {
      setSettingIfNotSet(Settings.System.RINGTONE,tableUri,rowId);
      mDefaultRingtoneSet=true;
    }
  }
  return result;
}","private Uri endFile(FileCacheEntry entry,boolean ringtones,boolean notifications,boolean alarms,boolean music,boolean podcasts) throws RemoteException {
  Uri tableUri;
  boolean isAudio=MediaFile.isAudioFileType(mFileType);
  boolean isVideo=MediaFile.isVideoFileType(mFileType);
  boolean isImage=MediaFile.isImageFileType(mFileType);
  if (isVideo) {
    tableUri=mVideoUri;
  }
 else   if (isImage) {
    tableUri=mImagesUri;
  }
 else   if (isAudio) {
    tableUri=mAudioUri;
  }
 else {
    return null;
  }
  entry.mTableUri=tableUri;
  if (mArtist == null || mArtist.length() == 0) {
    mArtist=mAlbumArtist;
  }
  ContentValues values=toValues();
  String title=values.getAsString(MediaStore.MediaColumns.TITLE);
  if (TextUtils.isEmpty(title.trim())) {
    title=values.getAsString(MediaStore.MediaColumns.DATA);
    int lastSlash=title.lastIndexOf('/');
    if (lastSlash >= 0) {
      lastSlash++;
      if (lastSlash < title.length()) {
        title=title.substring(lastSlash);
      }
    }
    int lastDot=title.lastIndexOf('.');
    if (lastDot > 0) {
      title=title.substring(0,lastDot);
    }
    values.put(MediaStore.MediaColumns.TITLE,title);
  }
  if (isAudio) {
    values.put(Audio.Media.IS_RINGTONE,ringtones);
    values.put(Audio.Media.IS_NOTIFICATION,notifications);
    values.put(Audio.Media.IS_ALARM,alarms);
    values.put(Audio.Media.IS_MUSIC,music);
    values.put(Audio.Media.IS_PODCAST,podcasts);
  }
 else   if (mFileType == MediaFile.FILE_TYPE_JPEG) {
    HashMap<String,String> exifData=ExifInterface.loadExifData(entry.mPath);
    if (exifData != null) {
      float[] latlng=ExifInterface.getLatLng(exifData);
      if (latlng != null) {
        values.put(Images.Media.LATITUDE,latlng[0]);
        values.put(Images.Media.LONGITUDE,latlng[1]);
      }
    }
  }
  Uri result=null;
  long rowId=entry.mRowId;
  if (rowId == 0) {
    result=mMediaProvider.insert(tableUri,values);
    if (result != null) {
      rowId=ContentUris.parseId(result);
      entry.mRowId=rowId;
    }
  }
 else {
    result=ContentUris.withAppendedId(tableUri,rowId);
    mMediaProvider.update(result,values,null,null);
  }
  if (mProcessGenres && mGenre != null) {
    String genre=mGenre;
    Uri uri=mGenreCache.get(genre);
    if (uri == null) {
      Cursor cursor=null;
      try {
        cursor=mMediaProvider.query(mGenresUri,GENRE_LOOKUP_PROJECTION,MediaStore.Audio.Genres.NAME + ""String_Node_Str"",new String[]{genre},null);
        if (cursor == null || cursor.getCount() == 0) {
          values.clear();
          values.put(MediaStore.Audio.Genres.NAME,genre);
          uri=mMediaProvider.insert(mGenresUri,values);
        }
 else {
          cursor.moveToNext();
          uri=ContentUris.withAppendedId(mGenresUri,cursor.getLong(0));
        }
        if (uri != null) {
          uri=Uri.withAppendedPath(uri,Genres.Members.CONTENT_DIRECTORY);
          mGenreCache.put(genre,uri);
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
    if (uri != null) {
      values.clear();
      values.put(MediaStore.Audio.Genres.Members.AUDIO_ID,Long.valueOf(rowId));
      mMediaProvider.insert(uri,values);
    }
  }
  if (notifications && !mDefaultNotificationSet) {
    if (TextUtils.isEmpty(mDefaultNotificationFilename) || doesPathHaveFilename(entry.mPath,mDefaultNotificationFilename)) {
      setSettingIfNotSet(Settings.System.NOTIFICATION_SOUND,tableUri,rowId);
      mDefaultNotificationSet=true;
    }
  }
 else   if (ringtones && !mDefaultRingtoneSet) {
    if (TextUtils.isEmpty(mDefaultRingtoneFilename) || doesPathHaveFilename(entry.mPath,mDefaultRingtoneFilename)) {
      setSettingIfNotSet(Settings.System.RINGTONE,tableUri,rowId);
      mDefaultRingtoneSet=true;
    }
  }
  return result;
}",0.999078826161337
43428,"/** 
 * Converts the byte array provided to a unicode string.
 * @param b the byte array to convert to a string
 * @param includesNull determine if the byte string provided contains theUNICODE null character at the end or not; if it does, it will be removed
 * @return a Unicode string
 * @throws IllegalArgumentException if the byte array has an odd length
 */
public static String convertToUnicode(byte[] b,boolean includesNull){
  if (b == null) {
    return null;
  }
  int arrayLength=b.length;
  if (!((arrayLength % 2) == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  arrayLength=(arrayLength >> 1);
  if (includesNull) {
    arrayLength-=1;
  }
  char[] c=new char[arrayLength];
  for (int i=0; i < arrayLength; i++) {
    int upper=b[2 * i];
    int lower=b[(2 * i) + 1];
    if (upper < 0) {
      upper+=256;
    }
    if (lower < 0) {
      lower+=256;
    }
    c[i]=(char)((upper << 8) | lower);
  }
  return new String(c);
}","/** 
 * Converts the byte array provided to a unicode string.
 * @param b the byte array to convert to a string
 * @param includesNull determine if the byte string provided contains theUNICODE null character at the end or not; if it does, it will be removed
 * @return a Unicode string
 * @throws IllegalArgumentException if the byte array has an odd length
 */
public static String convertToUnicode(byte[] b,boolean includesNull){
  if (b == null || b.length == 0) {
    return null;
  }
  int arrayLength=b.length;
  if (!((arrayLength % 2) == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  arrayLength=(arrayLength >> 1);
  if (includesNull) {
    arrayLength-=1;
  }
  char[] c=new char[arrayLength];
  for (int i=0; i < arrayLength; i++) {
    int upper=b[2 * i];
    int lower=b[(2 * i) + 1];
    if (upper < 0) {
      upper+=256;
    }
    if (lower < 0) {
      lower+=256;
    }
    c[i]=(char)((upper << 8) | lower);
  }
  return new String(c);
}",0.9912596401028276
43429,"public void onCompletion(MediaPlayer arg0){
  String callingApp=mCurrentSpeechItem.mCallingApp;
  ArrayList<String> params=mCurrentSpeechItem.mParams;
  String utteranceId=""String_Node_Str"";
  if (params != null) {
    for (int i=0; i < params.size() - 1; i=i + 2) {
      String param=params.get(i);
      if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
        utteranceId=params.get(i + 1);
      }
    }
  }
  if (utteranceId.length() > 0) {
    dispatchUtteranceCompletedCallback(utteranceId,callingApp);
  }
  mCurrentSpeechItem=null;
  processSpeechQueue();
}","public void onCompletion(MediaPlayer arg0){
  String callingApp=mCurrentSpeechItem.mCallingApp;
  ArrayList<String> params=mCurrentSpeechItem.mParams;
  String utteranceId=""String_Node_Str"";
  if (params != null) {
    for (int i=0; i < params.size() - 1; i=i + 2) {
      String param=params.get(i);
      if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
        utteranceId=params.get(i + 1);
      }
    }
  }
  if (utteranceId.length() > 0) {
    dispatchUtteranceCompletedCallback(utteranceId,callingApp);
  }
  processSpeechQueue();
}",0.9764192139737992
43430,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.setPriority(Thread.MIN_PRIORITY);
      synth.start();
      return;
    }
    if (speechItem.mParams != null) {
      String language=""String_Node_Str"";
      String country=""String_Node_Str"";
      String variant=""String_Node_Str"";
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
    }
    nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    mCurrentSpeechItem=null;
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.setPriority(Thread.MIN_PRIORITY);
      synth.start();
      return;
    }
    if (speechItem.mParams != null) {
      String language=""String_Node_Str"";
      String country=""String_Node_Str"";
      String variant=""String_Node_Str"";
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
    }
    nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.922696962212892
43431,"private void silence(final SpeechItem speechItem){
class SilenceThread implements Runnable {
    public void run(){
      String utteranceId=""String_Node_Str"";
      if (speechItem.mParams != null) {
        for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
          String param=speechItem.mParams.get(i);
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      try {
        Thread.sleep(speechItem.mDuration);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread slnc=(new Thread(new SilenceThread()));
  slnc.setPriority(Thread.MIN_PRIORITY);
  slnc.start();
}","private void silence(final SpeechItem speechItem){
class SilenceThread implements Runnable {
    public void run(){
      String utteranceId=""String_Node_Str"";
      if (speechItem.mParams != null) {
        for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
          String param=speechItem.mParams.get(i);
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      try {
        Thread.sleep(speechItem.mDuration);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        processSpeechQueue();
      }
    }
  }
  Thread slnc=(new Thread(new SilenceThread()));
  slnc.setPriority(Thread.MIN_PRIORITY);
  slnc.start();
}",0.9823812066203952
43432,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}",0.9398907103825136
43433,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.speak(speechItem.mText,streamType);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.speak(speechItem.mText,streamType);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}",0.9459901800327332
43434,"public void onChanged(NumberPicker picker,int oldVal,int newVal){
  mYear=newVal;
  if (mOnDateChangedListener != null) {
    mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
  }
}","public void onChanged(NumberPicker picker,int oldVal,int newVal){
  mYear=newVal;
  adjustMaxDay();
  if (mOnDateChangedListener != null) {
    mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
  }
  updateDaySpinner();
}",0.9107142857142856
43435,"public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  mMonthPicker.setRange(1,12,dfs.getShortMonths());
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers();
  if (!isEnabled()) {
    setEnabled(false);
  }
}","public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  mMonthPicker.setRange(1,12,dfs.getShortMonths());
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      adjustMaxDay();
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      adjustMaxDay();
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers();
  if (!isEnabled()) {
    setEnabled(false);
  }
}",0.9841125737630504
43436,"private void validateCurrentView(CharSequence str){
  int val=getSelectedPos(str.toString());
  if ((val >= mStart) && (val <= mEnd)) {
    mPrevious=mCurrent;
    mCurrent=val;
    notifyChange();
  }
  updateView();
}","private void validateCurrentView(CharSequence str){
  int val=getSelectedPos(str.toString());
  if ((val >= mStart) && (val <= mEnd)) {
    if (mCurrent != val) {
      mPrevious=mCurrent;
      mCurrent=val;
      notifyChange();
    }
  }
  updateView();
}",0.859538784067086
43437,"private String makeUriString(){
  StringBuilder builder=new StringBuilder();
  if (scheme != null) {
    builder.append(scheme).append(':');
  }
  appendSspTo(builder);
  if (fragment != null && !fragment.isEmpty()) {
    builder.append('#').append(fragment.getEncoded());
  }
  return builder.toString();
}","private String makeUriString(){
  StringBuilder builder=new StringBuilder();
  if (scheme != null) {
    builder.append(scheme).append(':');
  }
  appendSspTo(builder);
  if (!fragment.isEmpty()) {
    builder.append('#').append(fragment.getEncoded());
  }
  return builder.toString();
}",0.9663299663299664
43438,"/** 
 * Searches the query string for parameter values with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return a list of decoded values
 */
public List<String> getQueryParameters(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getQuery();
  if (query == null) {
    return Collections.emptyList();
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  query=""String_Node_Str"" + query;
  String prefix=""String_Node_Str"" + encodedKey + ""String_Node_Str"";
  ArrayList<String> values=new ArrayList<String>();
  int start=0;
  int length=query.length();
  while (start < length) {
    start=query.indexOf(prefix,start);
    if (start == -1) {
      break;
    }
    start+=prefix.length();
    int end=query.indexOf('&',start);
    if (end == -1) {
      end=query.length();
    }
    String value=query.substring(start,end);
    values.add(decode(value));
    start=end;
  }
  return Collections.unmodifiableList(values);
}","/** 
 * Searches the query string for parameter values with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return a list of decoded values
 */
public List<String> getQueryParameters(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getEncodedQuery();
  if (query == null) {
    return Collections.emptyList();
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  query=""String_Node_Str"" + query;
  String prefix=""String_Node_Str"" + encodedKey + ""String_Node_Str"";
  ArrayList<String> values=new ArrayList<String>();
  int start=0;
  int length=query.length();
  while (start < length) {
    start=query.indexOf(prefix,start);
    if (start == -1) {
      break;
    }
    start+=prefix.length();
    int end=query.indexOf('&',start);
    if (end == -1) {
      end=query.length();
    }
    String value=query.substring(start,end);
    values.add(decode(value));
    start=end;
  }
  return Collections.unmodifiableList(values);
}",0.9971853638922396
43439,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getQuery();
  if (query == null) {
    return null;
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  String prefix=encodedKey + ""String_Node_Str"";
  if (query.length() < prefix.length()) {
    return null;
  }
  int start;
  if (query.startsWith(prefix)) {
    start=prefix.length();
  }
 else {
    prefix=""String_Node_Str"" + prefix;
    start=query.indexOf(prefix);
    if (start == -1) {
      return null;
    }
    start+=prefix.length();
  }
  int end=query.indexOf('&',start);
  if (end == -1) {
    end=query.length();
  }
  String value=query.substring(start,end);
  return decode(value);
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  String prefix=encodedKey + ""String_Node_Str"";
  if (query.length() < prefix.length()) {
    return null;
  }
  int start;
  if (query.startsWith(prefix)) {
    start=prefix.length();
  }
 else {
    prefix=""String_Node_Str"" + prefix;
    start=query.indexOf(prefix);
    if (start == -1) {
      return null;
    }
    start+=prefix.length();
  }
  int end=query.indexOf('&',start);
  if (end == -1) {
    end=query.length();
  }
  String value=query.substring(start,end);
  return decode(value);
}",0.9970174691095016
43440,"private void appendSspTo(StringBuilder builder){
  if (authority != null) {
    String encodedAuthority=authority.getEncoded();
    if (encodedAuthority != null) {
      builder.append(""String_Node_Str"").append(encodedAuthority);
    }
  }
  String encodedPath=path.getEncoded();
  if (encodedPath != null) {
    builder.append(encodedPath);
  }
  if (query != null && !query.isEmpty()) {
    builder.append('?').append(query.getEncoded());
  }
}","private void appendSspTo(StringBuilder builder){
  String encodedAuthority=authority.getEncoded();
  if (encodedAuthority != null) {
    builder.append(""String_Node_Str"").append(encodedAuthority);
  }
  String encodedPath=path.getEncoded();
  if (encodedPath != null) {
    builder.append(encodedPath);
  }
  if (!query.isEmpty()) {
    builder.append('?').append(query.getEncoded());
  }
}",0.5789473684210527
43441,"private HierarchicalUri(String scheme,Part authority,PathPart path,Part query,Part fragment){
  this.scheme=scheme;
  this.authority=authority;
  this.path=path;
  this.query=query;
  this.fragment=fragment;
}","private HierarchicalUri(String scheme,Part authority,PathPart path,Part query,Part fragment){
  this.scheme=scheme;
  this.authority=Part.nonNull(authority);
  this.path=path == null ? PathPart.NULL : path;
  this.query=Part.nonNull(query);
  this.fragment=Part.nonNull(fragment);
}",0.7576374745417516
43442,"private void release(){
  if (mMediaPlayer != null) {
    mMediaPlayer.reset();
    mMediaPlayer.release();
    mMediaPlayer=null;
    mCurrentState=STATE_IDLE;
    mTargetState=STATE_IDLE;
  }
}","private void release(boolean cleartargetstate){
  if (mMediaPlayer != null) {
    mMediaPlayer.reset();
    mMediaPlayer.release();
    mMediaPlayer=null;
    mCurrentState=STATE_IDLE;
    if (cleartargetstate) {
      mTargetState=STATE_IDLE;
    }
  }
}",0.8666666666666667
43443,"public void surfaceDestroyed(SurfaceHolder holder){
  mSurfaceHolder=null;
  if (mMediaController != null)   mMediaController.hide();
  release();
}","public void surfaceDestroyed(SurfaceHolder holder){
  mSurfaceHolder=null;
  if (mMediaController != null)   mMediaController.hide();
  release(true);
}",0.9866666666666668
43444,"private void openVideo(){
  if (mUri == null || mSurfaceHolder == null) {
    return;
  }
  Intent i=new Intent(""String_Node_Str"");
  i.putExtra(""String_Node_Str"",""String_Node_Str"");
  mContext.sendBroadcast(i);
  release();
  try {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnPreparedListener(mPreparedListener);
    mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
    mDuration=-1;
    mMediaPlayer.setOnCompletionListener(mCompletionListener);
    mMediaPlayer.setOnErrorListener(mErrorListener);
    mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
    mCurrentBufferPercentage=0;
    mMediaPlayer.setDataSource(mContext,mUri);
    mMediaPlayer.setDisplay(mSurfaceHolder);
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
    mMediaPlayer.setScreenOnWhilePlaying(true);
    mMediaPlayer.prepareAsync();
    mCurrentState=STATE_PREPARING;
    mTargetState=STATE_PREPARED;
    attachMediaController();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
catch (  IllegalArgumentException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
}","private void openVideo(){
  if (mUri == null || mSurfaceHolder == null) {
    return;
  }
  Intent i=new Intent(""String_Node_Str"");
  i.putExtra(""String_Node_Str"",""String_Node_Str"");
  mContext.sendBroadcast(i);
  release(false);
  try {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnPreparedListener(mPreparedListener);
    mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
    mDuration=-1;
    mMediaPlayer.setOnCompletionListener(mCompletionListener);
    mMediaPlayer.setOnErrorListener(mErrorListener);
    mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
    mCurrentBufferPercentage=0;
    mMediaPlayer.setDataSource(mContext,mUri);
    mMediaPlayer.setDisplay(mSurfaceHolder);
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
    mMediaPlayer.setScreenOnWhilePlaying(true);
    mMediaPlayer.prepareAsync();
    mCurrentState=STATE_PREPARING;
    attachMediaController();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
catch (  IllegalArgumentException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
}",0.985062893081761
43445,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode());
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode(),false);
}",0.9875518672199172
43446,"private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.977752424415288
43447,"/** 
 * @see AudioManager#setRingerMode(int) 
 */
public void setRingerMode(int ringerMode){
  if (ringerMode != mRingerMode) {
    setRingerModeInt(ringerMode);
    broadcastRingerMode();
  }
}","/** 
 * @see AudioManager#setRingerMode(int) 
 */
public void setRingerMode(int ringerMode){
  if (ringerMode != mRingerMode) {
    setRingerModeInt(ringerMode,true);
    broadcastRingerMode();
  }
}",0.9872773536895676
43448,"/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( Contacts.People.CONTENT_URI.addId(2), projection,    // Which columns to return. null,          // WHERE clause. People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);","/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection,    // Which columns to return. null,          // WHERE clause. null,          // WHERE clause value substitution People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param selectionArgs You may include ?s in selection, which will be replaced bythe values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);",0.934640522875817
43449,"private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}","private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    if (mBatteryLevel >= 100) {
      mBatteryInfoText.setText(R.string.lockscreen_charged);
    }
 else {
      mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
    }
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}",0.9175627240143368
43450,"private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}","private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    if (mBatteryLevel >= 100) {
      mBatteryInfoText.setText(R.string.lockscreen_charged);
    }
 else {
      mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
    }
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}",0.9175627240143368
43451,"public void onCompletion(MediaPlayer mp){
  if (mMediaController != null) {
    mMediaController.hide();
  }
  if (mOnCompletionListener != null) {
    mOnCompletionListener.onCompletion(mMediaPlayer);
  }
}","public void onCompletion(MediaPlayer mp){
  mIsPlaybackCompleted=true;
  if (mMediaController != null) {
    mMediaController.hide();
  }
  if (mOnCompletionListener != null) {
    mOnCompletionListener.onCompletion(mMediaPlayer);
  }
}",0.9345372460496614
43452,"public void surfaceChanged(SurfaceHolder holder,int format,int w,int h){
  mSurfaceWidth=w;
  mSurfaceHeight=h;
  if (mMediaPlayer != null && mIsPrepared && mVideoWidth == w && mVideoHeight == h) {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    mMediaPlayer.start();
    if (mMediaController != null) {
      mMediaController.show();
    }
  }
}","public void surfaceChanged(SurfaceHolder holder,int format,int w,int h){
  mSurfaceWidth=w;
  mSurfaceHeight=h;
  if (mMediaPlayer != null && mIsPrepared && mVideoWidth == w && mVideoHeight == h) {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (!mIsPlaybackCompleted) {
      start();
    }
    if (mMediaController != null) {
      mMediaController.show();
    }
  }
}",0.7995337995337995
43453,"public void start(){
  if (mMediaPlayer != null && mIsPrepared) {
    mMediaPlayer.start();
    mStartWhenPrepared=false;
  }
 else {
    mStartWhenPrepared=true;
  }
}","public void start(){
  mIsPlaybackCompleted=false;
  if (mMediaPlayer != null && mIsPrepared) {
    mMediaPlayer.start();
    mStartWhenPrepared=false;
  }
 else {
    mStartWhenPrepared=true;
  }
}",0.918032786885246
43454,"public void onPrepared(MediaPlayer mp){
  mIsPrepared=true;
  if (mOnPreparedListener != null) {
    mOnPreparedListener.onPrepared(mMediaPlayer);
  }
  if (mMediaController != null) {
    mMediaController.setEnabled(true);
  }
  mVideoWidth=mp.getVideoWidth();
  mVideoHeight=mp.getVideoHeight();
  if (mVideoWidth != 0 && mVideoHeight != 0) {
    getHolder().setFixedSize(mVideoWidth,mVideoHeight);
    if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
      if (mSeekWhenPrepared != 0) {
        mMediaPlayer.seekTo(mSeekWhenPrepared);
        mSeekWhenPrepared=0;
      }
      if (mStartWhenPrepared) {
        mMediaPlayer.start();
        mStartWhenPrepared=false;
        if (mMediaController != null) {
          mMediaController.show();
        }
      }
 else       if (!isPlaying() && (mSeekWhenPrepared != 0 || getCurrentPosition() > 0)) {
        if (mMediaController != null) {
          mMediaController.show(0);
        }
      }
    }
  }
 else {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (mStartWhenPrepared) {
      mMediaPlayer.start();
      mStartWhenPrepared=false;
    }
  }
}","public void onPrepared(MediaPlayer mp){
  mIsPrepared=true;
  if (mOnPreparedListener != null) {
    mOnPreparedListener.onPrepared(mMediaPlayer);
  }
  if (mMediaController != null) {
    mMediaController.setEnabled(true);
  }
  mVideoWidth=mp.getVideoWidth();
  mVideoHeight=mp.getVideoHeight();
  if (mVideoWidth != 0 && mVideoHeight != 0) {
    getHolder().setFixedSize(mVideoWidth,mVideoHeight);
    if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
      if (mSeekWhenPrepared != 0) {
        mMediaPlayer.seekTo(mSeekWhenPrepared);
        mSeekWhenPrepared=0;
      }
      if (mStartWhenPrepared) {
        start();
        mStartWhenPrepared=false;
        if (mMediaController != null) {
          mMediaController.show();
        }
      }
 else       if (!isPlaying() && (mSeekWhenPrepared != 0 || getCurrentPosition() > 0)) {
        if (mMediaController != null) {
          mMediaController.show(0);
        }
      }
    }
  }
 else {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (mStartWhenPrepared) {
      start();
      mStartWhenPrepared=false;
    }
  }
}",0.945193929173693
43455,"private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultLanguage(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}","private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}",0.9584664536741214
43456,"/** 
 * Returns a constant indicating the type of activity on a data connection (cellular).
 * @see #DATA_ACTIVITY_NONE
 * @see #DATA_ACTIVITY_IN
 * @see #DATA_ACTIVITY_OUT
 * @see #DATA_ACTIVITY_INOUT
 * @see #DATA_ACTIVITY_DORMANT
 */
public int getDataActivity(){
  try {
    return getITelephony().getDataActivity();
  }
 catch (  RemoteException ex) {
    return DATA_ACTIVITY_NONE;
  }
}","/** 
 * Returns a constant indicating the type of activity on a data connection (cellular).
 * @see #DATA_ACTIVITY_NONE
 * @see #DATA_ACTIVITY_IN
 * @see #DATA_ACTIVITY_OUT
 * @see #DATA_ACTIVITY_INOUT
 * @see #DATA_ACTIVITY_DORMANT
 */
public int getDataActivity(){
  try {
    return getITelephony().getDataActivity();
  }
 catch (  RemoteException ex) {
    return DATA_ACTIVITY_NONE;
  }
catch (  NullPointerException ex) {
    return DATA_ACTIVITY_NONE;
  }
}",0.9171528588098016
43457,"/** 
 * Returns a constant indicating the call state (cellular) on the device.
 */
public int getCallState(){
  try {
    return getITelephony().getCallState();
  }
 catch (  RemoteException ex) {
    return CALL_STATE_IDLE;
  }
}","/** 
 * Returns a constant indicating the call state (cellular) on the device.
 */
public int getCallState(){
  try {
    return getITelephony().getCallState();
  }
 catch (  RemoteException ex) {
    return CALL_STATE_IDLE;
  }
catch (  NullPointerException ex) {
    return CALL_STATE_IDLE;
  }
}",0.8674242424242424
43458,"public void onChildViewRemoved(View p,View child){
  if (child == this) {
    if (inEditingMode()) {
      clearTextEntry();
    }
  }
}","public void onChildViewRemoved(View p,View child){
  if (child == this) {
    clearTextEntry();
  }
}",0.8523206751054853
43459,"@Override public boolean performLongClick(){
  if (inEditingMode()) {
    return mWebTextView.performLongClick();
  }
 else {
    return super.performLongClick();
  }
}","@Override public boolean performLongClick(){
  if (mNativeClass != 0 && nativeCursorIsTextInput()) {
    mWebViewCore.sendMessage(EventHub.CLICK,nativeCursorFramePointer(),nativeCursorNodePointer());
    rebuildWebTextView();
  }
  if (inEditingMode()) {
    return mWebTextView.performLongClick();
  }
 else {
    return super.performLongClick();
  }
}",0.6449136276391555
43460,"@Override public boolean onTrackballEvent(MotionEvent ev){
  long time=ev.getEventTime();
  if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
    if (ev.getY() > 0)     pageDown(true);
    if (ev.getY() < 0)     pageUp(true);
    return true;
  }
  if (ev.getAction() == MotionEvent.ACTION_DOWN) {
    mPrivateHandler.removeMessages(SWITCH_TO_CLICK);
    mTrackballDown=true;
    if (mNativeClass != 0) {
      nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
    }
    if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
      nativeSelectBestAt(mLastCursorBounds);
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time+ ""String_Node_Str""+ mLastCursorTime);
    }
    if (isInTouchMode())     requestFocusFromTouch();
    return false;
  }
  if (ev.getAction() == MotionEvent.ACTION_UP) {
    mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
    mTrackballDown=false;
    mTrackballUpTime=time;
    if (mShiftIsPressed) {
      if (mExtendSelection) {
        commitCopy();
      }
 else {
        mExtendSelection=true;
      }
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
    }
    return false;
  }
  if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return false;
  }
  if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (mTrackballDown) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  switchOutDrawHistory();
  if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + time + ""String_Node_Str""+ mTrackballLastTime);
    }
    mTrackballFirstTime=time;
    mTrackballXMove=mTrackballYMove=0;
  }
  mTrackballLastTime=time;
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
  }
  mTrackballRemainsX+=ev.getX();
  mTrackballRemainsY+=ev.getY();
  doTrackball(time);
  return true;
}","@Override public boolean onTrackballEvent(MotionEvent ev){
  long time=ev.getEventTime();
  if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
    if (ev.getY() > 0)     pageDown(true);
    if (ev.getY() < 0)     pageUp(true);
    return true;
  }
  if (ev.getAction() == MotionEvent.ACTION_DOWN) {
    mPrivateHandler.removeMessages(SWITCH_TO_CLICK);
    mTrackballDown=true;
    if (mNativeClass == 0) {
      return false;
    }
    nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
    if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
      nativeSelectBestAt(mLastCursorBounds);
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time+ ""String_Node_Str""+ mLastCursorTime);
    }
    if (isInTouchMode())     requestFocusFromTouch();
    return false;
  }
  if (ev.getAction() == MotionEvent.ACTION_UP) {
    mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
    mTrackballDown=false;
    mTrackballUpTime=time;
    if (mShiftIsPressed) {
      if (mExtendSelection) {
        commitCopy();
      }
 else {
        mExtendSelection=true;
      }
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
    }
    return false;
  }
  if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return false;
  }
  if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (mTrackballDown) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  switchOutDrawHistory();
  if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + time + ""String_Node_Str""+ mTrackballLastTime);
    }
    mTrackballFirstTime=time;
    mTrackballXMove=mTrackballYMove=0;
  }
  mTrackballLastTime=time;
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
  }
  mTrackballRemainsX+=ev.getX();
  mTrackballRemainsY+=ev.getY();
  doTrackball(time);
  return true;
}",0.99317697228145
43461,"private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultLanguage(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}","private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}",0.9584664536741214
43462,"private static byte[] numberToCalledPartyBCDHelper(byte[] ret,int offset,String number){
  if (hasPlus(number)) {
    number=number.replaceAll(""String_Node_Str"",""String_Node_Str"");
    ret[offset]=(byte)TOA_International;
  }
 else {
    ret[offset]=(byte)TOA_Unknown;
  }
  int size=number.length();
  int curChar=0;
  int countFullBytes=ret.length - offset - 1- ((size - curChar) & 1);
  for (int i=1; i < 1 + countFullBytes; i++) {
    ret[offset + i]=(byte)((charToBCD(number.charAt(curChar++))) | (charToBCD(number.charAt(curChar++))) << 4);
  }
  if (countFullBytes + offset < ret.length - 1) {
    ret[ret.length - 1]=(byte)(charToBCD(number.charAt(curChar)) | (0xf << 4));
  }
  return ret;
}","/** 
 * If includeLength is true, prepend a one-byte length value to the return array.
 */
private static byte[] numberToCalledPartyBCDHelper(String number,boolean includeLength){
  int numberLenReal=number.length();
  int numberLenEffective=numberLenReal;
  boolean hasPlus=number.indexOf('+') != -1;
  if (hasPlus)   numberLenEffective--;
  if (numberLenEffective == 0)   return null;
  int resultLen=(numberLenEffective + 1) / 2;
  int extraBytes=1;
  if (includeLength)   extraBytes++;
  resultLen+=extraBytes;
  byte[] result=new byte[resultLen];
  int digitCount=0;
  for (int i=0; i < numberLenReal; i++) {
    char c=number.charAt(i);
    if (c == '+')     continue;
    int shift=((digitCount & 0x01) == 1) ? 4 : 0;
    result[extraBytes + (digitCount >> 1)]|=(byte)((charToBCD(c) & 0x0F) << shift);
    digitCount++;
  }
  if ((digitCount & 0x01) == 1)   result[extraBytes + (digitCount >> 1)]|=0xF0;
  int offset=0;
  if (includeLength)   result[offset++]=(byte)(resultLen - 1);
  result[offset]=(byte)(hasPlus ? TOA_International : TOA_Unknown);
  return result;
}",0.1137387387387387
43463,"/** 
 * Note: calls extractNetworkPortion(), so do not use for SIM EF[ADN] style records Exceptions thrown if extractNetworkPortion(s).length() == 0
 */
public static byte[] networkPortionToCalledPartyBCD(String s){
  return numberToCalledPartyBCD(extractNetworkPortion(s));
}","/** 
 * Note: calls extractNetworkPortion(), so do not use for SIM EF[ADN] style records Returns null if network portion is empty.
 */
public static byte[] networkPortionToCalledPartyBCD(String s){
  String networkPortion=extractNetworkPortion(s);
  return numberToCalledPartyBCDHelper(networkPortion,false);
}",0.6655290102389079
43464,"/** 
 * Convert a dialing number to BCD byte array
 * @param number dialing number stringif the dialing number starts with '+', set to internationl TOA
 * @return BCD byte array
 */
public static byte[] numberToCalledPartyBCD(String number){
  int size=(hasPlus(number) ? number.length() - 1 : number.length());
  byte[] ret=new byte[(size + 1) / 2 + 1];
  return numberToCalledPartyBCDHelper(ret,0,number);
}","/** 
 * Convert a dialing number to BCD byte array
 * @param number dialing number stringif the dialing number starts with '+', set to internationl TOA
 * @return BCD byte array
 */
public static byte[] numberToCalledPartyBCD(String number){
  return numberToCalledPartyBCDHelper(number,false);
}",0.7063829787234043
43465,"/** 
 * Same as   {@link #networkPortionToCalledPartyBCD}, but includes a one-byte length prefix.
 */
public static byte[] networkPortionToCalledPartyBCDWithLength(String s){
  return numberToCalledPartyBCDWithLength(extractNetworkPortion(s));
}","/** 
 * Same as   {@link #networkPortionToCalledPartyBCD}, but includes a one-byte length prefix.
 */
public static byte[] networkPortionToCalledPartyBCDWithLength(String s){
  String networkPortion=extractNetworkPortion(s);
  return numberToCalledPartyBCDHelper(networkPortion,true);
}",0.6854990583804144
43466,"@SmallTest public void testA() throws Exception {
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  byte[] b=new byte[20];
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  byte[] bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(7,bRet.length);
  for (int i=0; i < 7; i++) {
    assertEquals(b[i],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(bRet,0,bRet.length));
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2B;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x81;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xA1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  assertNull(PhoneNumberUtils.extractNetworkPortion(null));
  assertNull(PhoneNumberUtils.extractPostDialPortion(null));
  assertTrue(PhoneNumberUtils.compare(null,null));
  assertFalse(PhoneNumberUtils.compare(null,""String_Node_Str""));
  assertFalse(PhoneNumberUtils.compare(""String_Node_Str"",null));
  assertNull(PhoneNumberUtils.toCallerIDMinMatch(null));
  assertNull(PhoneNumberUtils.getStrippedReversed(null));
  assertNull(PhoneNumberUtils.stringFromStringAndTOA(null,1));
}","@SmallTest public void testA() throws Exception {
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  byte[] b=new byte[20];
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  byte[] bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(7,bRet.length);
  for (int i=0; i < 7; i++) {
    assertEquals(b[i],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength(""String_Node_Str"");
  assertEquals(8,bRet.length);
  assertEquals(bRet[0],7);
  for (int i=1; i < 8; i++) {
    assertEquals(b[i - 1],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(bRet,0,bRet.length));
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2B;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x81;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xA1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  assertNull(PhoneNumberUtils.extractNetworkPortion(null));
  assertNull(PhoneNumberUtils.extractPostDialPortion(null));
  assertTrue(PhoneNumberUtils.compare(null,null));
  assertFalse(PhoneNumberUtils.compare(null,""String_Node_Str""));
  assertFalse(PhoneNumberUtils.compare(""String_Node_Str"",null));
  assertNull(PhoneNumberUtils.toCallerIDMinMatch(null));
  assertNull(PhoneNumberUtils.getStrippedReversed(null));
  assertNull(PhoneNumberUtils.stringFromStringAndTOA(null,1));
}",0.9790868924889544
43467,"/** 
 * Inject a pointer (touch) event into the UI.
 * @param ev A motion event describing the pointer (touch) action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectPointerEvent(MotionEvent ev,boolean sync){
  int result=dispatchPointer(null,ev,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Inject a pointer (touch) event into the UI.
 * @param ev A motion event describing the pointer (touch) action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectPointerEvent(MotionEvent ev,boolean sync){
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchPointer(null,ev,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8523862375138734
43468,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchKey(KeyEvent event,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + event);
  Object focusObj=mKeyWaiter.waitForNextEventTarget(event,null,null,false,false);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + event);
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ event);
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      return INJECT_NO_PERMISSION;
    }
  }
synchronized (mWindowMap) {
    mKeyWaiter.bindTargetWindowLocked(focus);
  }
  mKeyWaiter.recordDispatchState(event,focus);
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS) {
      Log.v(TAG,""String_Node_Str"" + event.getKeyCode() + ""String_Node_Str""+ focus);
    }
    focus.mClient.dispatchKey(event);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchKey(KeyEvent event,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + event);
  Object focusObj=mKeyWaiter.waitForNextEventTarget(event,null,null,false,false,pid,uid);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + event);
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ event);
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      return INJECT_NO_PERMISSION;
    }
  }
synchronized (mWindowMap) {
    mKeyWaiter.bindTargetWindowLocked(focus);
  }
  mKeyWaiter.recordDispatchState(event,focus);
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS) {
      Log.v(TAG,""String_Node_Str"" + event.getKeyCode() + ""String_Node_Str""+ focus);
    }
    focus.mClient.dispatchKey(event);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9973856209150328
43469,"Object findTargetWindow(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent){
  mOutsideTouchTargets=null;
  if (nextKey != null) {
    final int keycode=nextKey.getKeyCode();
    final int repeatCount=nextKey.getRepeatCount();
    final boolean down=nextKey.getAction() != KeyEvent.ACTION_UP;
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(keycode);
    if (!dispatch) {
      mPolicy.interceptKeyTi(null,keycode,nextKey.getMetaState(),down,repeatCount);
      Log.w(TAG,""String_Node_Str"" + nextKey);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    if (mPolicy.interceptKeyTi(focus,keycode,nextKey.getMetaState(),down,repeatCount)) {
      return CONSUMED_EVENT_TOKEN;
    }
    return focus;
  }
 else   if (!isPointerEvent) {
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(-1);
    if (!dispatch) {
      Log.w(TAG,""String_Node_Str"" + nextMotion);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    return focus;
  }
  if (nextMotion == null) {
    return SKIP_TARGET_TOKEN;
  }
  boolean dispatch=mKeyWaiter.checkShouldDispatchKey(KeyEvent.KEYCODE_UNKNOWN);
  if (!dispatch) {
    Log.w(TAG,""String_Node_Str"" + nextMotion);
    return SKIP_TARGET_TOKEN;
  }
  int action=nextMotion.getAction();
  final float xf=nextMotion.getX();
  final float yf=nextMotion.getY();
  final long eventTime=nextMotion.getEventTime();
  final boolean screenWasOff=qev != null && (qev.flags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=null;
synchronized (mWindowMap) {
synchronized (this) {
      if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
          Log.w(TAG,""String_Node_Str"" + mMotionTarget);
          mMotionTarget=null;
        }
        final int x=(int)xf;
        final int y=(int)yf;
        final ArrayList windows=mWindows;
        final int N=windows.size();
        WindowState topErrWindow=null;
        final Rect tmpRect=mTempRect;
        for (int i=N - 1; i >= 0; i--) {
          WindowState child=(WindowState)windows.get(i);
          final int flags=child.mAttrs.flags;
          if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
            if (topErrWindow == null) {
              topErrWindow=child;
            }
          }
          if (!child.isVisibleLw()) {
            continue;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
              child.mNextOutsideTouch=mOutsideTouchTargets;
              mOutsideTouchTargets=child;
            }
            continue;
          }
          tmpRect.set(child.mFrame);
          if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
            tmpRect.left+=child.mGivenContentInsets.left;
            tmpRect.top+=child.mGivenContentInsets.top;
            tmpRect.right-=child.mGivenContentInsets.right;
            tmpRect.bottom-=child.mGivenContentInsets.bottom;
          }
 else           if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
            tmpRect.left+=child.mGivenVisibleInsets.left;
            tmpRect.top+=child.mGivenVisibleInsets.top;
            tmpRect.right-=child.mGivenVisibleInsets.right;
            tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
          }
          final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
          if (tmpRect.contains(x,y) || touchFlags == 0) {
            if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
              mMotionTarget=child;
            }
 else {
              mMotionTarget=null;
            }
            break;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
        }
        if (topErrWindow != null && mMotionTarget != topErrWindow) {
          mMotionTarget=null;
        }
      }
      target=mMotionTarget;
    }
  }
  wakeupIfNeeded(target,eventType(nextMotion));
  return target != null ? target : SKIP_TARGET_TOKEN;
}","Object findTargetWindow(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,int callingPid,int callingUid){
  mOutsideTouchTargets=null;
  if (nextKey != null) {
    final int keycode=nextKey.getKeyCode();
    final int repeatCount=nextKey.getRepeatCount();
    final boolean down=nextKey.getAction() != KeyEvent.ACTION_UP;
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(keycode);
    if (!dispatch) {
      if (callingUid == 0 || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
        mPolicy.interceptKeyTi(null,keycode,nextKey.getMetaState(),down,repeatCount);
      }
      Log.w(TAG,""String_Node_Str"" + nextKey);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    if (callingUid == 0 || (focus != null && callingUid == focus.mSession.mUid) || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
      if (mPolicy.interceptKeyTi(focus,keycode,nextKey.getMetaState(),down,repeatCount)) {
        return CONSUMED_EVENT_TOKEN;
      }
    }
    return focus;
  }
 else   if (!isPointerEvent) {
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(-1);
    if (!dispatch) {
      Log.w(TAG,""String_Node_Str"" + nextMotion);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    return focus;
  }
  if (nextMotion == null) {
    return SKIP_TARGET_TOKEN;
  }
  boolean dispatch=mKeyWaiter.checkShouldDispatchKey(KeyEvent.KEYCODE_UNKNOWN);
  if (!dispatch) {
    Log.w(TAG,""String_Node_Str"" + nextMotion);
    return SKIP_TARGET_TOKEN;
  }
  int action=nextMotion.getAction();
  final float xf=nextMotion.getX();
  final float yf=nextMotion.getY();
  final long eventTime=nextMotion.getEventTime();
  final boolean screenWasOff=qev != null && (qev.flags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=null;
synchronized (mWindowMap) {
synchronized (this) {
      if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
          Log.w(TAG,""String_Node_Str"" + mMotionTarget);
          mMotionTarget=null;
        }
        final int x=(int)xf;
        final int y=(int)yf;
        final ArrayList windows=mWindows;
        final int N=windows.size();
        WindowState topErrWindow=null;
        final Rect tmpRect=mTempRect;
        for (int i=N - 1; i >= 0; i--) {
          WindowState child=(WindowState)windows.get(i);
          final int flags=child.mAttrs.flags;
          if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
            if (topErrWindow == null) {
              topErrWindow=child;
            }
          }
          if (!child.isVisibleLw()) {
            continue;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
              child.mNextOutsideTouch=mOutsideTouchTargets;
              mOutsideTouchTargets=child;
            }
            continue;
          }
          tmpRect.set(child.mFrame);
          if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
            tmpRect.left+=child.mGivenContentInsets.left;
            tmpRect.top+=child.mGivenContentInsets.top;
            tmpRect.right-=child.mGivenContentInsets.right;
            tmpRect.bottom-=child.mGivenContentInsets.bottom;
          }
 else           if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
            tmpRect.left+=child.mGivenVisibleInsets.left;
            tmpRect.top+=child.mGivenVisibleInsets.top;
            tmpRect.right-=child.mGivenVisibleInsets.right;
            tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
          }
          final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
          if (tmpRect.contains(x,y) || touchFlags == 0) {
            if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
              mMotionTarget=child;
            }
 else {
              mMotionTarget=null;
            }
            break;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
        }
        if (topErrWindow != null && mMotionTarget != topErrWindow) {
          mMotionTarget=null;
        }
      }
      target=mMotionTarget;
    }
  }
  wakeupIfNeeded(target,eventType(nextMotion));
  return target != null ? target : SKIP_TARGET_TOKEN;
}",0.9558425328056654
43470,"/** 
 * Wait for the last event dispatch to complete, then find the next target that should receive the given event and wait for that one to be ready to receive it.
 */
Object waitForNextEventTarget(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,boolean failIfTimeout){
  long startTime=SystemClock.uptimeMillis();
  long keyDispatchingTimeout=5 * 1000;
  long waitedFor=0;
  while (true) {
    WindowState targetWin=mLastWin;
    boolean targetIsNew=targetWin == null;
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + mFinished + ""String_Node_Str""+ mLastWin);
    if (targetIsNew) {
      Object target=findTargetWindow(nextKey,qev,nextMotion,isPointerEvent);
      if (target == SKIP_TARGET_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return null;
      }
      if (target == CONSUMED_EVENT_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return target;
      }
      targetWin=(WindowState)target;
    }
    AppWindowToken targetApp=null;
synchronized (this) {
      if (!targetIsNew && mLastWin == null) {
        continue;
      }
      if (mFinished && !mDisplayFrozen) {
        if (!mEventDispatching) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
        if (targetWin != null) {
          if (targetIsNew && !targetWin.mToken.paused) {
            return targetWin;
          }
        }
 else         if (mFocusedApp == null) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
      }
      if (DEBUG_INPUT)       Log.v(TAG,""String_Node_Str"" + mLastBinder + ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ targetIsNew+ ""String_Node_Str""+ (targetWin != null ? targetWin.mToken.paused : false)+ ""String_Node_Str""+ mFocusedApp+ ""String_Node_Str""+ mCurrentFocus);
      targetApp=targetWin != null ? targetWin.mAppToken : mFocusedApp;
      long curTimeout=keyDispatchingTimeout;
      if (mTimeToSwitch != 0) {
        long now=SystemClock.uptimeMillis();
        if (mTimeToSwitch <= now) {
          doFinishedKeyLocked(true);
          continue;
        }
        long switchTimeout=mTimeToSwitch - now;
        if (curTimeout > switchTimeout) {
          curTimeout=switchTimeout;
        }
      }
      try {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + curTimeout);
        wait(curTimeout);
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + SystemClock.uptimeMillis() + ""String_Node_Str""+ startTime+ ""String_Node_Str""+ mTimeToSwitch+ ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mLastWin+ ""String_Node_Str""+ mLastBinder+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mCurrentFocus);
      }
 catch (      InterruptedException e) {
      }
    }
    if (mWasFrozen) {
      waitedFor=0;
      mWasFrozen=false;
    }
 else {
      waitedFor=SystemClock.uptimeMillis() - startTime;
    }
    if (waitedFor >= keyDispatchingTimeout && mTimeToSwitch == 0) {
      IApplicationToken at=null;
synchronized (this) {
        Log.w(TAG,""String_Node_Str"" + (targetWin != null ? targetWin.mAttrs.getTitle() : ""String_Node_Str""));
        Log.w(TAG,""String_Node_Str"" + mDispatchState);
        Log.w(TAG,""String_Node_Str"" + new DispatchState(nextKey,targetWin));
        if (targetWin != null) {
          at=targetWin.getAppToken();
        }
 else         if (targetApp != null) {
          at=targetApp.appToken;
        }
      }
      boolean abort=true;
      if (at != null) {
        try {
          long timeout=at.getKeyDispatchingTimeout();
          if (timeout > waitedFor) {
            keyDispatchingTimeout=timeout - waitedFor;
            continue;
          }
 else {
            abort=at.keyDispatchingTimedOut();
          }
        }
 catch (        RemoteException ex) {
        }
      }
synchronized (this) {
        if (abort && (mLastWin == targetWin || targetWin == null)) {
          mFinished=true;
          if (mLastWin != null) {
            if (DEBUG_INPUT)             Log.v(TAG,""String_Node_Str"" + mLastWin + ""String_Node_Str"");
            if (mLastWin.mToken.paused) {
              Log.w(TAG,""String_Node_Str"");
              mLastWin.mToken.paused=false;
            }
          }
          if (mMotionTarget == targetWin) {
            mMotionTarget=null;
          }
          mLastWin=null;
          mLastBinder=null;
          if (failIfTimeout || targetWin == null) {
            return null;
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          startTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}","/** 
 * Wait for the last event dispatch to complete, then find the next target that should receive the given event and wait for that one to be ready to receive it.
 */
Object waitForNextEventTarget(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,boolean failIfTimeout,int callingPid,int callingUid){
  long startTime=SystemClock.uptimeMillis();
  long keyDispatchingTimeout=5 * 1000;
  long waitedFor=0;
  while (true) {
    WindowState targetWin=mLastWin;
    boolean targetIsNew=targetWin == null;
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + mFinished + ""String_Node_Str""+ mLastWin);
    if (targetIsNew) {
      Object target=findTargetWindow(nextKey,qev,nextMotion,isPointerEvent,callingPid,callingUid);
      if (target == SKIP_TARGET_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return null;
      }
      if (target == CONSUMED_EVENT_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return target;
      }
      targetWin=(WindowState)target;
    }
    AppWindowToken targetApp=null;
synchronized (this) {
      if (!targetIsNew && mLastWin == null) {
        continue;
      }
      if (mFinished && !mDisplayFrozen) {
        if (!mEventDispatching) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
        if (targetWin != null) {
          if (targetIsNew && !targetWin.mToken.paused) {
            return targetWin;
          }
        }
 else         if (mFocusedApp == null) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
      }
      if (DEBUG_INPUT)       Log.v(TAG,""String_Node_Str"" + mLastBinder + ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ targetIsNew+ ""String_Node_Str""+ (targetWin != null ? targetWin.mToken.paused : false)+ ""String_Node_Str""+ mFocusedApp+ ""String_Node_Str""+ mCurrentFocus);
      targetApp=targetWin != null ? targetWin.mAppToken : mFocusedApp;
      long curTimeout=keyDispatchingTimeout;
      if (mTimeToSwitch != 0) {
        long now=SystemClock.uptimeMillis();
        if (mTimeToSwitch <= now) {
          doFinishedKeyLocked(true);
          continue;
        }
        long switchTimeout=mTimeToSwitch - now;
        if (curTimeout > switchTimeout) {
          curTimeout=switchTimeout;
        }
      }
      try {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + curTimeout);
        wait(curTimeout);
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + SystemClock.uptimeMillis() + ""String_Node_Str""+ startTime+ ""String_Node_Str""+ mTimeToSwitch+ ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mLastWin+ ""String_Node_Str""+ mLastBinder+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mCurrentFocus);
      }
 catch (      InterruptedException e) {
      }
    }
    if (mWasFrozen) {
      waitedFor=0;
      mWasFrozen=false;
    }
 else {
      waitedFor=SystemClock.uptimeMillis() - startTime;
    }
    if (waitedFor >= keyDispatchingTimeout && mTimeToSwitch == 0) {
      IApplicationToken at=null;
synchronized (this) {
        Log.w(TAG,""String_Node_Str"" + (targetWin != null ? targetWin.mAttrs.getTitle() : ""String_Node_Str""));
        Log.w(TAG,""String_Node_Str"" + mDispatchState);
        Log.w(TAG,""String_Node_Str"" + new DispatchState(nextKey,targetWin));
        if (targetWin != null) {
          at=targetWin.getAppToken();
        }
 else         if (targetApp != null) {
          at=targetApp.appToken;
        }
      }
      boolean abort=true;
      if (at != null) {
        try {
          long timeout=at.getKeyDispatchingTimeout();
          if (timeout > waitedFor) {
            keyDispatchingTimeout=timeout - waitedFor;
            continue;
          }
 else {
            abort=at.keyDispatchingTimedOut();
          }
        }
 catch (        RemoteException ex) {
        }
      }
synchronized (this) {
        if (abort && (mLastWin == targetWin || targetWin == null)) {
          mFinished=true;
          if (mLastWin != null) {
            if (DEBUG_INPUT)             Log.v(TAG,""String_Node_Str"" + mLastWin + ""String_Node_Str"");
            if (mLastWin.mToken.paused) {
              Log.w(TAG,""String_Node_Str"");
              mLastWin.mToken.paused=false;
            }
          }
          if (mMotionTarget == targetWin) {
            mMotionTarget=null;
          }
          mLastWin=null;
          mLastBinder=null;
          if (failIfTimeout || targetWin == null) {
            return null;
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          startTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}",0.9946938775510203
43471,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchPointer(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT || WindowManagerPolicy.WATCH_POINTER)   Log.v(TAG,""String_Node_Str"" + ev);
  Object targetObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,true,false);
  int action=ev.getAction();
  if (action == MotionEvent.ACTION_UP) {
    mKeyWaiter.mMotionTarget=null;
    mPowerManager.logPointerUpEvent();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
  }
  if (targetObj == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Log.w(TAG,""String_Node_Str"" + ev.getAction());
    }
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (targetObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState target=(WindowState)targetObj;
  final long eventTime=ev.getEventTime();
  if (uid != 0 && uid != target.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ target+ ""String_Node_Str""+ target.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
    boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(ev);
    boolean returnFlag=false;
    if ((action == MotionEvent.ACTION_DOWN)) {
      mFatTouch=false;
      if (cheekPress) {
        mFatTouch=true;
        returnFlag=true;
      }
    }
 else {
      if (action == MotionEvent.ACTION_UP) {
        if (mFatTouch) {
          mFatTouch=false;
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
        }
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (mFatTouch) {
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"");
          mFatTouch=true;
        }
      }
    }
    if (returnFlag) {
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_FAILED;
    }
  }
  if (action == MotionEvent.ACTION_DOWN) {
    int max_events_per_sec=35;
    try {
      max_events_per_sec=Integer.parseInt(SystemProperties.get(""String_Node_Str""));
      if (max_events_per_sec < 1) {
        max_events_per_sec=35;
      }
    }
 catch (    NumberFormatException e) {
    }
    mMinWaitTimeBetweenTouchEvents=1000 / max_events_per_sec;
  }
  if (action == MotionEvent.ACTION_MOVE) {
    long nextEventTime=mLastTouchEventTime + mMinWaitTimeBetweenTouchEvents;
    long now=SystemClock.uptimeMillis();
    if (now < nextEventTime) {
      try {
        Thread.sleep(nextEventTime - now);
      }
 catch (      InterruptedException e) {
      }
      mLastTouchEventTime=nextEventTime;
    }
 else {
      mLastTouchEventTime=now;
    }
  }
synchronized (mWindowMap) {
    if (qev != null && action == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(target,KeyWaiter.RETURN_PENDING_POINTER,qev);
      ev=null;
    }
 else {
      if (action == MotionEvent.ACTION_DOWN) {
        WindowState out=mKeyWaiter.mOutsideTouchTargets;
        if (out != null) {
          MotionEvent oev=MotionEvent.obtain(ev);
          oev.setAction(MotionEvent.ACTION_OUTSIDE);
          do {
            final Rect frame=out.mFrame;
            oev.offsetLocation(-(float)frame.left,-(float)frame.top);
            try {
              out.mClient.dispatchPointer(oev,eventTime);
            }
 catch (            android.os.RemoteException e) {
              Log.i(TAG,""String_Node_Str"" + out);
            }
            oev.offsetLocation((float)frame.left,(float)frame.top);
            out=out.mNextOutsideTouch;
          }
 while (out != null);
          mKeyWaiter.mOutsideTouchTargets=null;
        }
      }
      final Rect frame=target.mFrame;
      ev.offsetLocation(-(float)frame.left,-(float)frame.top);
      mKeyWaiter.bindTargetWindowLocked(target);
    }
  }
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS || WindowManagerPolicy.WATCH_POINTER) {
      Log.v(TAG,""String_Node_Str"" + qev + ""String_Node_Str""+ target);
    }
    target.mClient.dispatchPointer(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + target);
    mKeyWaiter.mMotionTarget=null;
    try {
      removeWindow(target.mSession,target.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchPointer(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT || WindowManagerPolicy.WATCH_POINTER)   Log.v(TAG,""String_Node_Str"" + ev);
  Object targetObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,true,false,pid,uid);
  int action=ev.getAction();
  if (action == MotionEvent.ACTION_UP) {
    mKeyWaiter.mMotionTarget=null;
    mPowerManager.logPointerUpEvent();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
  }
  if (targetObj == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Log.w(TAG,""String_Node_Str"" + ev.getAction());
    }
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (targetObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState target=(WindowState)targetObj;
  final long eventTime=ev.getEventTime();
  if (uid != 0 && uid != target.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ target+ ""String_Node_Str""+ target.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
    boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(ev);
    boolean returnFlag=false;
    if ((action == MotionEvent.ACTION_DOWN)) {
      mFatTouch=false;
      if (cheekPress) {
        mFatTouch=true;
        returnFlag=true;
      }
    }
 else {
      if (action == MotionEvent.ACTION_UP) {
        if (mFatTouch) {
          mFatTouch=false;
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
        }
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (mFatTouch) {
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"");
          mFatTouch=true;
        }
      }
    }
    if (returnFlag) {
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_FAILED;
    }
  }
  if (action == MotionEvent.ACTION_DOWN) {
    int max_events_per_sec=35;
    try {
      max_events_per_sec=Integer.parseInt(SystemProperties.get(""String_Node_Str""));
      if (max_events_per_sec < 1) {
        max_events_per_sec=35;
      }
    }
 catch (    NumberFormatException e) {
    }
    mMinWaitTimeBetweenTouchEvents=1000 / max_events_per_sec;
  }
  if (action == MotionEvent.ACTION_MOVE) {
    long nextEventTime=mLastTouchEventTime + mMinWaitTimeBetweenTouchEvents;
    long now=SystemClock.uptimeMillis();
    if (now < nextEventTime) {
      try {
        Thread.sleep(nextEventTime - now);
      }
 catch (      InterruptedException e) {
      }
      mLastTouchEventTime=nextEventTime;
    }
 else {
      mLastTouchEventTime=now;
    }
  }
synchronized (mWindowMap) {
    if (qev != null && action == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(target,KeyWaiter.RETURN_PENDING_POINTER,qev);
      ev=null;
    }
 else {
      if (action == MotionEvent.ACTION_DOWN) {
        WindowState out=mKeyWaiter.mOutsideTouchTargets;
        if (out != null) {
          MotionEvent oev=MotionEvent.obtain(ev);
          oev.setAction(MotionEvent.ACTION_OUTSIDE);
          do {
            final Rect frame=out.mFrame;
            oev.offsetLocation(-(float)frame.left,-(float)frame.top);
            try {
              out.mClient.dispatchPointer(oev,eventTime);
            }
 catch (            android.os.RemoteException e) {
              Log.i(TAG,""String_Node_Str"" + out);
            }
            oev.offsetLocation((float)frame.left,(float)frame.top);
            out=out.mNextOutsideTouch;
          }
 while (out != null);
          mKeyWaiter.mOutsideTouchTargets=null;
        }
      }
      final Rect frame=target.mFrame;
      ev.offsetLocation(-(float)frame.left,-(float)frame.top);
      mKeyWaiter.bindTargetWindowLocked(target);
    }
  }
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS || WindowManagerPolicy.WATCH_POINTER) {
      Log.v(TAG,""String_Node_Str"" + qev + ""String_Node_Str""+ target);
    }
    target.mClient.dispatchPointer(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + target);
    mKeyWaiter.mMotionTarget=null;
    try {
      removeWindow(target.mSession,target.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9992110453648916
43472,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchTrackball(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + ev.getAction() + ""String_Node_Str""+ ev.getX()+ ""String_Node_Str""+ ev.getY()+ ""String_Node_Str"");
  Object focusObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,false,false);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + ev);
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  final long eventTime=ev.getEventTime();
synchronized (mWindowMap) {
    if (qev != null && ev.getAction() == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(focus,KeyWaiter.RETURN_PENDING_TRACKBALL,qev);
      ev=null;
    }
 else {
      mKeyWaiter.bindTargetWindowLocked(focus);
    }
  }
  try {
    focus.mClient.dispatchTrackball(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchTrackball(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + ev.getAction() + ""String_Node_Str""+ ev.getX()+ ""String_Node_Str""+ ev.getY()+ ""String_Node_Str"");
  Object focusObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,false,false,pid,uid);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + ev);
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  final long eventTime=ev.getEventTime();
synchronized (mWindowMap) {
    if (qev != null && ev.getAction() == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(focus,KeyWaiter.RETURN_PENDING_TRACKBALL,qev);
      ev=null;
    }
 else {
      mKeyWaiter.bindTargetWindowLocked(focus);
    }
  }
  try {
    focus.mClient.dispatchTrackball(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9978552278820376
43473,"/** 
 * Inject a trackball (navigation device) event into the UI.
 * @param ev A motion event describing the trackball action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectTrackballEvent(MotionEvent ev,boolean sync){
  int result=dispatchTrackball(null,ev,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Inject a trackball (navigation device) event into the UI.
 * @param ev A motion event describing the trackball action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectTrackballEvent(MotionEvent ev,boolean sync){
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchTrackball(null,ev,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8707557502738226
43474,"/** 
 * Injects a keystroke event into the UI.
 * @param ev A motion event describing the keystroke action.  (Be sure to use{@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectKeyEvent(KeyEvent ev,boolean sync){
  long downTime=ev.getDownTime();
  long eventTime=ev.getEventTime();
  int action=ev.getAction();
  int code=ev.getKeyCode();
  int repeatCount=ev.getRepeatCount();
  int metaState=ev.getMetaState();
  int deviceId=ev.getDeviceId();
  int scancode=ev.getScanCode();
  if (eventTime == 0)   eventTime=SystemClock.uptimeMillis();
  if (downTime == 0)   downTime=eventTime;
  KeyEvent newEvent=new KeyEvent(downTime,eventTime,action,code,repeatCount,metaState,deviceId,scancode,KeyEvent.FLAG_FROM_SYSTEM);
  int result=dispatchKey(newEvent,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Injects a keystroke event into the UI.
 * @param ev A motion event describing the keystroke action.  (Be sure to use{@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectKeyEvent(KeyEvent ev,boolean sync){
  long downTime=ev.getDownTime();
  long eventTime=ev.getEventTime();
  int action=ev.getAction();
  int code=ev.getKeyCode();
  int repeatCount=ev.getRepeatCount();
  int metaState=ev.getMetaState();
  int deviceId=ev.getDeviceId();
  int scancode=ev.getScanCode();
  if (eventTime == 0)   eventTime=SystemClock.uptimeMillis();
  if (downTime == 0)   downTime=eventTime;
  KeyEvent newEvent=new KeyEvent(downTime,eventTime,action,code,repeatCount,metaState,deviceId,scancode,KeyEvent.FLAG_FROM_SYSTEM);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchKey(newEvent,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8498475609756098
43475,"private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile)) {
      System.out.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}","private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  ParcelFileDescriptor fd=null;
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
    try {
      fd=ParcelFileDescriptor.open(new File(profileFile),ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_READ_WRITE);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + profileFile);
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile,fd)) {
      System.err.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}",0.8583230070218918
43476,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9984246588342476
43477,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}",0.8470380194518126
43478,"final void handleProfilerControl(boolean start,String path){
  if (start) {
    File file=new File(path);
    file.getParentFile().mkdirs();
    try {
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + path + ""String_Node_Str"");
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}",0.6239813736903376
43479,"public void profilerControl(boolean start,String path){
  queueOrSendMessage(H.PROFILER_CONTROL,path,start ? 1 : 0);
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd){
  ProfilerControlData pcd=new ProfilerControlData();
  pcd.path=path;
  pcd.fd=fd;
  queueOrSendMessage(H.PROFILER_CONTROL,pcd,start ? 1 : 0);
}",0.672514619883041
43480,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(String)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}",0.9953297216514104
43481,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
profilerControl(start,path);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9950936927351184
43482,"public void profilerControl(boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}",0.7908101571946796
43483,"public boolean profileControl(String process,boolean start,String path) throws RemoteException ;","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8888888888888888
43484,"void profilerControl(boolean start,String path) throws RemoteException ;","void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8571428571428571
43485,"/** 
 * Start method tracing, specifying the trace log file name and the buffer size. The trace files will be put under ""/sdcard"" unless an absolute path is given. See <a href=""  {@docRoot}guide/developing/tools/traceview.html"">Traceview: A Graphical Log Viewer</a> for information about reading trace files. <p> When method tracing is enabled, the VM will run more slowly than usual, so the timings from the trace files should only be considered in relative terms (e.g. was run #1 faster than run #2).  The times for native methods will not change, so don't try to use this to compare the performance of interpreted and native implementations of the same method.  As an alternative, consider using ""native"" tracing in the emulator via   {@link #startNativeTracing()}. </p>
 * @param traceName    Name for the trace log file to create.If no name argument is given, this value defaults to ""/sdcard/dmtrace.trace"". If the files already exist, they will be truncated. If the trace file given does not end in "".trace"", it will be appended for you.
 * @param bufferSize    The maximum amount of trace data we gather. If not given, it defaults to 8MB.
 */
public static void startMethodTracing(String traceName,int bufferSize,int flags){
  String pathName=traceName;
  if (pathName.charAt(0) != '/')   pathName=DEFAULT_TRACE_PATH_PREFIX + pathName;
  if (!pathName.endsWith(DEFAULT_TRACE_EXTENSION))   pathName=pathName + DEFAULT_TRACE_EXTENSION;
  VMDebug.startMethodTracing(pathName,bufferSize,flags);
}","/** 
 * Like startMethodTracing(String, int, int), but taking an already-opened FileDescriptor in which the trace is written.  The file name is also supplied simply for logging.  Makes a dup of the file descriptor. Not exposed in the SDK unless we are really comfortable with supporting this and find it would be useful.
 * @hide
 */
public static void startMethodTracing(String traceName,FileDescriptor fd,int bufferSize,int flags){
  VMDebug.startMethodTracing(traceName,fd,bufferSize,flags);
}",0.1573934837092732
43486,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
synchronized (this) {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
      throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    ProcessRecord proc=null;
    try {
      int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(pid);
      }
    }
 catch (    NumberFormatException e) {
    }
    if (proc == null) {
      HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
      SparseArray<ProcessRecord> procs=all.get(process);
      if (procs != null && procs.size() > 0) {
        proc=procs.valueAt(0);
      }
    }
    if (proc == null || proc.thread == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + process);
    }
    boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
    if (isSecure) {
      if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
        throw new SecurityException(""String_Node_Str"" + proc);
      }
    }
    try {
      proc.thread.profilerControl(start,path);
      return true;
    }
 catch (    RemoteException e) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  try {
synchronized (this) {
      if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
      }
      if (start && fd == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ProcessRecord proc=null;
      try {
        int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
      }
 catch (      NumberFormatException e) {
      }
      if (proc == null) {
        HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
        SparseArray<ProcessRecord> procs=all.get(process);
        if (procs != null && procs.size() > 0) {
          proc=procs.valueAt(0);
        }
      }
      if (proc == null || proc.thread == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + process);
      }
      boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
      if (isSecure) {
        if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
          throw new SecurityException(""String_Node_Str"" + proc);
        }
      }
      proc.thread.profilerControl(start,path,fd);
      fd=null;
      return true;
    }
  }
 catch (  RemoteException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 finally {
    if (fd != null) {
      try {
        fd.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.7981888745148771
43487,"private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile)) {
      System.out.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}","private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  ParcelFileDescriptor fd=null;
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
    try {
      fd=ParcelFileDescriptor.open(new File(profileFile),ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_READ_WRITE);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + profileFile);
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile,fd)) {
      System.err.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}",0.8583230070218918
43488,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9984246588342476
43489,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}",0.8470380194518126
43490,"final void handleProfilerControl(boolean start,String path){
  if (start) {
    File file=new File(path);
    file.getParentFile().mkdirs();
    try {
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + path + ""String_Node_Str"");
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}",0.6239813736903376
43491,"public void profilerControl(boolean start,String path){
  queueOrSendMessage(H.PROFILER_CONTROL,path,start ? 1 : 0);
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd){
  ProfilerControlData pcd=new ProfilerControlData();
  pcd.path=path;
  pcd.fd=fd;
  queueOrSendMessage(H.PROFILER_CONTROL,pcd,start ? 1 : 0);
}",0.672514619883041
43492,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(String)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}",0.9953297216514104
43493,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
profilerControl(start,path);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9950936927351184
43494,"public void profilerControl(boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}",0.7908101571946796
43495,"public boolean profileControl(String process,boolean start,String path) throws RemoteException ;","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8888888888888888
43496,"void profilerControl(boolean start,String path) throws RemoteException ;","void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8571428571428571
43497,"/** 
 * Start method tracing, specifying the trace log file name and the buffer size. The trace files will be put under ""/sdcard"" unless an absolute path is given. See <a href=""  {@docRoot}guide/developing/tools/traceview.html"">Traceview: A Graphical Log Viewer</a> for information about reading trace files. <p> When method tracing is enabled, the VM will run more slowly than usual, so the timings from the trace files should only be considered in relative terms (e.g. was run #1 faster than run #2).  The times for native methods will not change, so don't try to use this to compare the performance of interpreted and native implementations of the same method.  As an alternative, consider using ""native"" tracing in the emulator via   {@link #startNativeTracing()}. </p>
 * @param traceName    Name for the trace log file to create.If no name argument is given, this value defaults to ""/sdcard/dmtrace.trace"". If the files already exist, they will be truncated. If the trace file given does not end in "".trace"", it will be appended for you.
 * @param bufferSize    The maximum amount of trace data we gather. If not given, it defaults to 8MB.
 */
public static void startMethodTracing(String traceName,int bufferSize,int flags){
  String pathName=traceName;
  if (pathName.charAt(0) != '/')   pathName=DEFAULT_TRACE_PATH_PREFIX + pathName;
  if (!pathName.endsWith(DEFAULT_TRACE_EXTENSION))   pathName=pathName + DEFAULT_TRACE_EXTENSION;
  VMDebug.startMethodTracing(pathName,bufferSize,flags);
}","/** 
 * Like startMethodTracing(String, int, int), but taking an already-opened FileDescriptor in which the trace is written.  The file name is also supplied simply for logging.  Makes a dup of the file descriptor. Not exposed in the SDK unless we are really comfortable with supporting this and find it would be useful.
 * @hide
 */
public static void startMethodTracing(String traceName,FileDescriptor fd,int bufferSize,int flags){
  VMDebug.startMethodTracing(traceName,fd,bufferSize,flags);
}",0.1573934837092732
43498,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
synchronized (this) {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
      throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    ProcessRecord proc=null;
    try {
      int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(pid);
      }
    }
 catch (    NumberFormatException e) {
    }
    if (proc == null) {
      HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
      SparseArray<ProcessRecord> procs=all.get(process);
      if (procs != null && procs.size() > 0) {
        proc=procs.valueAt(0);
      }
    }
    if (proc == null || proc.thread == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + process);
    }
    boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
    if (isSecure) {
      if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
        throw new SecurityException(""String_Node_Str"" + proc);
      }
    }
    try {
      proc.thread.profilerControl(start,path);
      return true;
    }
 catch (    RemoteException e) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  try {
synchronized (this) {
      if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
      }
      if (start && fd == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ProcessRecord proc=null;
      try {
        int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
      }
 catch (      NumberFormatException e) {
      }
      if (proc == null) {
        HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
        SparseArray<ProcessRecord> procs=all.get(process);
        if (procs != null && procs.size() > 0) {
          proc=procs.valueAt(0);
        }
      }
      if (proc == null || proc.thread == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + process);
      }
      boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
      if (isSecure) {
        if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
          throw new SecurityException(""String_Node_Str"" + proc);
        }
      }
      proc.thread.profilerControl(start,path,fd);
      fd=null;
      return true;
    }
  }
 catch (  RemoteException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 finally {
    if (fd != null) {
      try {
        fd.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.7981888745148771
43499,"public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOffLocked();
  }
}","public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOffLocked();
}",0.8775510204081632
43500,"public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    Uid u=mUidStats.get(mWifiOnUid);
    if (u != null) {
      u.noteWifiTurnedOffLocked();
    }
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    mWifiOnUid=-1;
  }
}",0.8406374501992032
43501,"public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOnLocked();
  }
}","public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOnLocked();
}",0.8769230769230769
43502,"public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOffLocked();
  }
}","public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOffLocked();
}",0.8775510204081632
43503,"public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      Uid u=mUidStats.get(mWifiOnUid);
      if (u != null) {
        u.noteWifiTurnedOffLocked();
      }
    }
    mWifiOnUid=uid;
    Uid u=mUidStats.get(uid);
    if (u != null) {
      u.noteWifiTurnedOnLocked();
    }
  }
}","public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    }
    mWifiOnUid=uid;
    getUidStatsLocked(uid).noteWifiTurnedOnLocked();
  }
}",0.5824175824175825
43504,"public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOnLocked();
  }
}","public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOnLocked();
}",0.8769230769230769
43505,"/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
  boolean wasNavigating=mNavigating;
  mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
  if (wasNavigating != mNavigating) {
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
synchronized (mListeners) {
      int size=mListeners.size();
      for (int i=0; i < size; i++) {
        Listener listener=mListeners.get(i);
        try {
          if (mNavigating) {
            listener.mListener.onGpsStarted();
          }
 else {
            listener.mListener.onGpsStopped();
          }
        }
 catch (        RemoteException e) {
          Log.w(TAG,""String_Node_Str"");
          mListeners.remove(listener);
          size--;
        }
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}","/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
synchronized (mListeners) {
    boolean wasNavigating=mNavigating;
    mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
    if (wasNavigating == mNavigating) {
      return;
    }
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
    int size=mListeners.size();
    for (int i=0; i < size; i++) {
      Listener listener=mListeners.get(i);
      try {
        if (mNavigating) {
          listener.mListener.onGpsStarted();
        }
 else {
          listener.mListener.onGpsStopped();
        }
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
        mListeners.remove(listener);
        size--;
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}",0.7651515151515151
43506,"public void addListener(int uid){
  mClientUids.put(uid,0);
  if (mNavigating) {
    try {
      mBatteryStats.noteStartGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void addListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) >= 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.put(uid,0);
    if (mNavigating) {
      try {
        mBatteryStats.noteStartGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.2857142857142857
43507,"public void removeListener(int uid){
  mClientUids.delete(uid);
  if (mNavigating) {
    try {
      mBatteryStats.noteStopGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void removeListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) < 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.delete(uid);
    if (mNavigating) {
      try {
        mBatteryStats.noteStopGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.296795952782462
43508,"public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOffLocked();
  }
}","public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOffLocked();
}",0.8775510204081632
43509,"public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    Uid u=mUidStats.get(mWifiOnUid);
    if (u != null) {
      u.noteWifiTurnedOffLocked();
    }
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    mWifiOnUid=-1;
  }
}",0.8406374501992032
43510,"public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOnLocked();
  }
}","public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOnLocked();
}",0.8769230769230769
43511,"public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOffLocked();
  }
}","public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOffLocked();
}",0.8775510204081632
43512,"public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      Uid u=mUidStats.get(mWifiOnUid);
      if (u != null) {
        u.noteWifiTurnedOffLocked();
      }
    }
    mWifiOnUid=uid;
    Uid u=mUidStats.get(uid);
    if (u != null) {
      u.noteWifiTurnedOnLocked();
    }
  }
}","public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    }
    mWifiOnUid=uid;
    getUidStatsLocked(uid).noteWifiTurnedOnLocked();
  }
}",0.5824175824175825
43513,"public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOnLocked();
  }
}","public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOnLocked();
}",0.8769230769230769
43514,"/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
  boolean wasNavigating=mNavigating;
  mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
  if (wasNavigating != mNavigating) {
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
synchronized (mListeners) {
      int size=mListeners.size();
      for (int i=0; i < size; i++) {
        Listener listener=mListeners.get(i);
        try {
          if (mNavigating) {
            listener.mListener.onGpsStarted();
          }
 else {
            listener.mListener.onGpsStopped();
          }
        }
 catch (        RemoteException e) {
          Log.w(TAG,""String_Node_Str"");
          mListeners.remove(listener);
          size--;
        }
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}","/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
synchronized (mListeners) {
    boolean wasNavigating=mNavigating;
    mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
    if (wasNavigating == mNavigating) {
      return;
    }
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
    int size=mListeners.size();
    for (int i=0; i < size; i++) {
      Listener listener=mListeners.get(i);
      try {
        if (mNavigating) {
          listener.mListener.onGpsStarted();
        }
 else {
          listener.mListener.onGpsStopped();
        }
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
        mListeners.remove(listener);
        size--;
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}",0.7651515151515151
43515,"public void addListener(int uid){
  mClientUids.put(uid,0);
  if (mNavigating) {
    try {
      mBatteryStats.noteStartGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void addListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) >= 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.put(uid,0);
    if (mNavigating) {
      try {
        mBatteryStats.noteStartGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.2857142857142857
43516,"public void removeListener(int uid){
  mClientUids.delete(uid);
  if (mNavigating) {
    try {
      mBatteryStats.noteStopGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void removeListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) < 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.delete(uid);
    if (mNavigating) {
      try {
        mBatteryStats.noteStopGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.296795952782462
43517,"@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}","@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable || mBackgroundResource != 0) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}",0.947565543071161
43518,"@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}","@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable || mBackgroundResource != 0) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}",0.947565543071161
43519,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.info.packageName);
    if (app.instrumentationInfo != null) {
      ensurePackageDexOpt(app.instrumentationInfo.packageName);
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9849274812778462
43520,"/** 
 * The default implementation returns the given amount of text from the current cursor position in the buffer.
 */
public CharSequence getTextBeforeCursor(int length,int flags){
  final Editable content=getEditable();
  if (content == null)   return null;
  int a=Selection.getSelectionStart(content);
  int b=Selection.getSelectionEnd(content);
  if (a > b) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (length > a) {
    length=a;
  }
  if ((flags & GET_TEXT_WITH_STYLES) != 0) {
    return content.subSequence(a - length,a);
  }
  return TextUtils.substring(content,a - length,a);
}","/** 
 * The default implementation returns the given amount of text from the current cursor position in the buffer.
 */
public CharSequence getTextBeforeCursor(int length,int flags){
  final Editable content=getEditable();
  if (content == null)   return null;
  int a=Selection.getSelectionStart(content);
  int b=Selection.getSelectionEnd(content);
  if (a > b) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a <= 0) {
    return ""String_Node_Str"";
  }
  if (length > a) {
    length=a;
  }
  if ((flags & GET_TEXT_WITH_STYLES) != 0) {
    return content.subSequence(a - length,a);
  }
  return TextUtils.substring(content,a - length,a);
}",0.9594155844155844
43521,"private void replaceText(CharSequence text,int newCursorPosition,boolean composing){
  final Editable content=getEditable();
  if (content == null) {
    return;
  }
  beginBatchEdit();
  int a=getComposingSpanStart(content);
  int b=getComposingSpanEnd(content);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b);
  if (b < a) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a != -1 && b != -1) {
    removeComposingSpans(content);
  }
 else {
    a=Selection.getSelectionStart(content);
    b=Selection.getSelectionEnd(content);
    if (a >= 0 && b >= 0 && a != b) {
      if (b < a) {
        int tmp=a;
        a=b;
        b=tmp;
      }
    }
  }
  if (composing) {
    Spannable sp=null;
    if (!(text instanceof Spannable)) {
      sp=new SpannableStringBuilder(text);
      text=sp;
      if (mDefaultComposingSpans == null) {
        Context context;
        if (mTargetView != null) {
          context=mTargetView.getContext();
        }
 else         if (mIMM.mServedView != null) {
          context=mIMM.mServedView.getContext();
        }
 else {
          context=null;
        }
        if (context != null) {
          TypedArray ta=context.getTheme().obtainStyledAttributes(new int[]{com.android.internal.R.attr.candidatesTextStyleSpans});
          CharSequence style=ta.getText(0);
          ta.recycle();
          if (style != null && style instanceof Spanned) {
            mDefaultComposingSpans=((Spanned)style).getSpans(0,style.length(),Object.class);
          }
        }
      }
      if (mDefaultComposingSpans != null) {
        for (int i=0; i < mDefaultComposingSpans.length; ++i) {
          sp.setSpan(mDefaultComposingSpans[i],0,sp.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
      }
    }
 else {
      sp=(Spannable)text;
    }
    setComposingSpans(sp);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ text+ ""String_Node_Str""+ composing+ ""String_Node_Str""+ text.getClass().getCanonicalName());
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(text,lp,""String_Node_Str"");
  }
  if (newCursorPosition > 0) {
    newCursorPosition+=b - 1;
  }
 else {
    newCursorPosition+=a;
  }
  if (newCursorPosition < 0)   newCursorPosition=0;
  if (newCursorPosition > content.length())   newCursorPosition=content.length();
  Selection.setSelection(content,newCursorPosition);
  content.replace(a,b,text);
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
  }
  endBatchEdit();
}","private void replaceText(CharSequence text,int newCursorPosition,boolean composing){
  final Editable content=getEditable();
  if (content == null) {
    return;
  }
  beginBatchEdit();
  int a=getComposingSpanStart(content);
  int b=getComposingSpanEnd(content);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b);
  if (b < a) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a != -1 && b != -1) {
    removeComposingSpans(content);
  }
 else {
    a=Selection.getSelectionStart(content);
    b=Selection.getSelectionEnd(content);
    if (a < 0)     a=0;
    if (b < 0)     b=0;
    if (b < a) {
      int tmp=a;
      a=b;
      b=tmp;
    }
  }
  if (composing) {
    Spannable sp=null;
    if (!(text instanceof Spannable)) {
      sp=new SpannableStringBuilder(text);
      text=sp;
      if (mDefaultComposingSpans == null) {
        Context context;
        if (mTargetView != null) {
          context=mTargetView.getContext();
        }
 else         if (mIMM.mServedView != null) {
          context=mIMM.mServedView.getContext();
        }
 else {
          context=null;
        }
        if (context != null) {
          TypedArray ta=context.getTheme().obtainStyledAttributes(new int[]{com.android.internal.R.attr.candidatesTextStyleSpans});
          CharSequence style=ta.getText(0);
          ta.recycle();
          if (style != null && style instanceof Spanned) {
            mDefaultComposingSpans=((Spanned)style).getSpans(0,style.length(),Object.class);
          }
        }
      }
      if (mDefaultComposingSpans != null) {
        for (int i=0; i < mDefaultComposingSpans.length; ++i) {
          sp.setSpan(mDefaultComposingSpans[i],0,sp.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
      }
    }
 else {
      sp=(Spannable)text;
    }
    setComposingSpans(sp);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ text+ ""String_Node_Str""+ composing+ ""String_Node_Str""+ text.getClass().getCanonicalName());
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(text,lp,""String_Node_Str"");
  }
  if (newCursorPosition > 0) {
    newCursorPosition+=b - 1;
  }
 else {
    newCursorPosition+=a;
  }
  if (newCursorPosition < 0)   newCursorPosition=0;
  if (newCursorPosition > content.length())   newCursorPosition=content.length();
  Selection.setSelection(content,newCursorPosition);
  content.replace(a,b,text);
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
  }
  endBatchEdit();
}",0.9720406681190996
43522,"protected void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode != InputMethodManager.RESULT_SHOWN) {
    Selection.setSelection((Spannable)mText,mNewStart,mNewEnd);
  }
}","protected void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode != InputMethodManager.RESULT_SHOWN) {
    final int len=mText.length();
    if (mNewStart > len) {
      mNewStart=len;
    }
    if (mNewEnd > len) {
      mNewEnd=len;
    }
    Selection.setSelection((Spannable)mText,mNewStart,mNewEnd);
  }
}",0.7335907335907336
43523,"private Rect sendOurVisibleRect(){
  Rect rect=new Rect();
  calcOurContentVisibleRect(rect);
  if (mFindIsUp) {
    rect.bottom-=viewToContent(FIND_HEIGHT);
  }
  if (!rect.equals(mLastVisibleRectSent)) {
    Point pos=new Point(rect.left,rect.top);
    mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,nativeMoveGeneration(),0,pos);
    mLastVisibleRectSent=rect;
  }
  Rect globalRect=new Rect();
  if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
    mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS,globalRect);
    mLastGlobalRect=globalRect;
  }
  return rect;
}","private Rect sendOurVisibleRect(){
  Rect rect=new Rect();
  calcOurContentVisibleRect(rect);
  if (!rect.equals(mLastVisibleRectSent)) {
    Point pos=new Point(rect.left,rect.top);
    mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,nativeMoveGeneration(),0,pos);
    mLastVisibleRectSent=rect;
  }
  Rect globalRect=new Rect();
  if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + globalRect.left + ""String_Node_Str""+ globalRect.top+ ""String_Node_Str""+ globalRect.right+ ""String_Node_Str""+ globalRect.bottom);
    }
    mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS,globalRect);
    mLastGlobalRect=globalRect;
  }
  return rect;
}",0.7973273942093542
43524,"private void rebuildWebTextView(){
  if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus()) || (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM)) {
    return;
  }
  boolean alreadyThere=inEditingMode();
  if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
    if (alreadyThere) {
      mWebTextView.remove();
    }
    return;
  }
  if (mWebTextView == null) {
    mWebTextView=new WebTextView(mContext,WebView.this);
    mTextGeneration=0;
  }
  mWebTextView.setTextSize(contentToView(nativeFocusCandidateTextSize()));
  Rect visibleRect=sendOurVisibleRect();
  Rect bounds=nativeFocusCandidateNodeBounds();
  if (!Rect.intersects(bounds,visibleRect)) {
    return;
  }
  String text=nativeFocusCandidateText();
  int nodePointer=nativeFocusCandidatePointer();
  if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
    Spannable spannable=(Spannable)mWebTextView.getText();
    int start=Selection.getSelectionStart(spannable);
    int end=Selection.getSelectionEnd(spannable);
    if (text != null && !text.equals(spannable.toString()) && nativeTextGeneration() == mTextGeneration) {
      mWebTextView.setTextAndKeepSelection(text);
    }
 else {
      Selection.setSelection(spannable,start,end);
    }
  }
 else {
    Rect vBox=contentToView(bounds);
    mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
    mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
    mWebTextView.setNodePointer(nodePointer);
    int maxLength=-1;
    boolean isTextField=nativeFocusCandidateIsTextField();
    if (isTextField) {
      maxLength=nativeFocusCandidateMaxLength();
      String name=nativeFocusCandidateName();
      if (mWebViewCore.getSettings().getSaveFormData() && name != null) {
        Message update=mPrivateHandler.obtainMessage(REQUEST_FORM_DATA,nodePointer);
        RequestFormData updater=new RequestFormData(name,getUrl(),update);
        Thread t=new Thread(updater);
        t.start();
      }
    }
    mWebTextView.setMaxLength(maxLength);
    AutoCompleteAdapter adapter=null;
    mWebTextView.setAdapterCustom(adapter);
    mWebTextView.setSingleLine(isTextField);
    mWebTextView.setInPassword(nativeFocusCandidateIsPassword());
    if (null == text) {
      mWebTextView.setText(""String_Node_Str"",0,0);
    }
 else {
      if (false) {
        mWebTextView.setText(text,0,text.length());
      }
 else       if (isTextField) {
        int length=text.length();
        mWebTextView.setText(text,length,length);
      }
 else {
        mWebTextView.setText(text,0,0);
      }
    }
    mWebTextView.requestFocus();
  }
}","private void rebuildWebTextView(){
  if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus()) || (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM)) {
    return;
  }
  boolean alreadyThere=inEditingMode();
  if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
    if (alreadyThere) {
      mWebTextView.remove();
    }
    return;
  }
  if (mWebTextView == null) {
    mWebTextView=new WebTextView(mContext,WebView.this);
    mTextGeneration=0;
  }
  mWebTextView.setTextSize(contentToView(nativeFocusCandidateTextSize()));
  Rect visibleRect=new Rect();
  calcOurContentVisibleRect(visibleRect);
  Rect bounds=nativeFocusCandidateNodeBounds();
  if (!Rect.intersects(bounds,visibleRect)) {
    return;
  }
  String text=nativeFocusCandidateText();
  int nodePointer=nativeFocusCandidatePointer();
  if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
    Spannable spannable=(Spannable)mWebTextView.getText();
    int start=Selection.getSelectionStart(spannable);
    int end=Selection.getSelectionEnd(spannable);
    if (text != null && !text.equals(spannable.toString()) && nativeTextGeneration() == mTextGeneration) {
      mWebTextView.setTextAndKeepSelection(text);
    }
 else {
      Selection.setSelection(spannable,start,end);
    }
  }
 else {
    Rect vBox=contentToView(bounds);
    mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
    mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
    mWebTextView.setNodePointer(nodePointer);
    int maxLength=-1;
    boolean isTextField=nativeFocusCandidateIsTextField();
    if (isTextField) {
      maxLength=nativeFocusCandidateMaxLength();
      String name=nativeFocusCandidateName();
      if (mWebViewCore.getSettings().getSaveFormData() && name != null) {
        Message update=mPrivateHandler.obtainMessage(REQUEST_FORM_DATA,nodePointer);
        RequestFormData updater=new RequestFormData(name,getUrl(),update);
        Thread t=new Thread(updater);
        t.start();
      }
    }
    mWebTextView.setMaxLength(maxLength);
    AutoCompleteAdapter adapter=null;
    mWebTextView.setAdapterCustom(adapter);
    mWebTextView.setSingleLine(isTextField);
    mWebTextView.setInPassword(nativeFocusCandidateIsPassword());
    if (null == text) {
      mWebTextView.setText(""String_Node_Str"",0,0);
    }
 else {
      if (false) {
        mWebTextView.setText(text,0,text.length());
      }
 else       if (isTextField) {
        int length=text.length();
        mWebTextView.setText(text,length,length);
      }
 else {
        mWebTextView.setText(text,0,0);
      }
    }
    mWebTextView.requestFocus();
  }
}",0.992534527808884
43525,"private void calcOurVisibleRect(Rect r){
  Point p=new Point();
  getGlobalVisibleRect(r,p);
  r.offset(-p.x,-p.y);
}","private void calcOurVisibleRect(Rect r){
  Point p=new Point();
  getGlobalVisibleRect(r,p);
  r.offset(-p.x,-p.y);
  if (mFindIsUp) {
    r.bottom-=FIND_HEIGHT;
  }
}",0.823943661971831
43526,"private void updateSharedUserPerms(PackageSetting deletedPs){
  if ((deletedPs == null) || (deletedPs.pkg == null)) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  if (deletedPs.sharedUser == null) {
    return;
  }
  SharedUserSetting sus=deletedPs.sharedUser;
  for (  String eachPerm : deletedPs.pkg.requestedPermissions) {
    boolean used=false;
    if (!sus.grantedPermissions.contains(eachPerm)) {
      continue;
    }
    for (    PackageSetting pkg : sus.packages) {
      if (pkg.grantedPermissions.contains(eachPerm)) {
        used=true;
        break;
      }
    }
    if (!used) {
      sus.grantedPermissions.remove(eachPerm);
      sus.loadedPermissions.remove(eachPerm);
    }
  }
  int newGids[]=null;
  for (  PackageSetting pkg : sus.packages) {
    newGids=appendInts(newGids,pkg.gids);
  }
  sus.gids=newGids;
}","private void updateSharedUserPerms(PackageSetting deletedPs){
  if ((deletedPs == null) || (deletedPs.pkg == null)) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  if (deletedPs.sharedUser == null) {
    return;
  }
  SharedUserSetting sus=deletedPs.sharedUser;
  for (  String eachPerm : deletedPs.pkg.requestedPermissions) {
    boolean used=false;
    if (!sus.grantedPermissions.contains(eachPerm)) {
      continue;
    }
    for (    PackageSetting pkg : sus.packages) {
      if (pkg.pkg.requestedPermissions.contains(eachPerm)) {
        used=true;
        break;
      }
    }
    if (!used) {
      sus.grantedPermissions.remove(eachPerm);
      sus.loadedPermissions.remove(eachPerm);
    }
  }
  int newGids[]=null;
  for (  PackageSetting pkg : sus.packages) {
    newGids=appendInts(newGids,pkg.gids);
  }
  sus.gids=newGids;
}",0.9917061611374408
43527,"/** 
 * Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard   {@link Context#startActivity} call: theactivity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process.  In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. <p>The function returns as soon as the activity goes idle following the call to its  {@link Activity#onCreate}.  Generally this means it has gone through the full initialization including   {@link Activity#onResume} anddrawn and displayed its initial window.
 * @param intent Description of the activity to start.
 * @see Context#startActivity
 */
public Activity startActivitySync(Intent intent){
  validateNotAppThread();
synchronized (mSync) {
    intent=new Intent(intent);
    ActivityInfo ai=intent.resolveActivityInfo(getTargetContext().getPackageManager(),0);
    if (ai == null) {
      throw new RuntimeException(""String_Node_Str"" + intent);
    }
    if (!ai.applicationInfo.processName.equals(getTargetContext().getPackageName())) {
      throw new RuntimeException(""String_Node_Str"" + ai.applicationInfo.packageName + ""String_Node_Str""+ intent);
    }
    intent.setComponent(new ComponentName(ai.applicationInfo.packageName,ai.name));
    final ActivityWaiter aw=new ActivityWaiter(intent);
    if (mWaitingActivities == null) {
      mWaitingActivities=new ArrayList();
    }
    mWaitingActivities.add(aw);
    getTargetContext().startActivity(intent);
    do {
      try {
        mSync.wait();
      }
 catch (      InterruptedException e) {
      }
    }
 while (mWaitingActivities.contains(aw));
    return aw.activity;
  }
}","/** 
 * Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard   {@link Context#startActivity} call: theactivity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process.  In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. <p>The function returns as soon as the activity goes idle following the call to its  {@link Activity#onCreate}.  Generally this means it has gone through the full initialization including   {@link Activity#onResume} anddrawn and displayed its initial window.
 * @param intent Description of the activity to start.
 * @see Context#startActivity
 */
public Activity startActivitySync(Intent intent){
  validateNotAppThread();
synchronized (mSync) {
    intent=new Intent(intent);
    ActivityInfo ai=intent.resolveActivityInfo(getTargetContext().getPackageManager(),0);
    if (ai == null) {
      throw new RuntimeException(""String_Node_Str"" + intent);
    }
    String myProc=mThread.getProcessName();
    if (!ai.processName.equals(myProc)) {
      throw new RuntimeException(""String_Node_Str"" + myProc + ""String_Node_Str""+ ai.processName+ ""String_Node_Str""+ intent);
    }
    intent.setComponent(new ComponentName(ai.applicationInfo.packageName,ai.name));
    final ActivityWaiter aw=new ActivityWaiter(intent);
    if (mWaitingActivities == null) {
      mWaitingActivities=new ArrayList();
    }
    mWaitingActivities.add(aw);
    getTargetContext().startActivity(intent);
    do {
      try {
        mSync.wait();
      }
 catch (      InterruptedException e) {
      }
    }
 while (mWaitingActivities.contains(aw));
    return aw.activity;
  }
}",0.95658835546476
43528,"/** 
 * Sends a series of key events through instrumentation and waits for idle. For instance: sendKeys(KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
 * @param keys The series of key codes to send through instrumentation.
 */
public void sendKeys(int... keys){
  final int count=keys.length;
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i++) {
    instrumentation.sendKeyDownUpSync(keys[i]);
  }
  instrumentation.waitForIdleSync();
}","/** 
 * Sends a series of key events through instrumentation and waits for idle. For instance: sendKeys(KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
 * @param keys The series of key codes to send through instrumentation.
 */
public void sendKeys(int... keys){
  final int count=keys.length;
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i++) {
    try {
      instrumentation.sendKeyDownUpSync(keys[i]);
    }
 catch (    SecurityException e) {
    }
  }
  instrumentation.waitForIdleSync();
}",0.9412935323383084
43529,"/** 
 * Sends a series of key events through instrumentation and waits for idle. Each key code must be preceded by the number of times the key code must be sent. For instance: sendRepeatedKeys(1, KEYCODE_DPAD_CENTER, 2, KEYCODE_DPAD_LEFT).
 * @param keys The series of key repeats and codes to send through instrumentation.
 */
public void sendRepeatedKeys(int... keys){
  final int count=keys.length;
  if ((count & 0x1) == 0x1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i+=2) {
    final int keyCount=keys[i];
    final int keyCode=keys[i + 1];
    for (int j=0; j < keyCount; j++) {
      instrumentation.sendKeyDownUpSync(keyCode);
    }
  }
  instrumentation.waitForIdleSync();
}","/** 
 * Sends a series of key events through instrumentation and waits for idle. Each key code must be preceded by the number of times the key code must be sent. For instance: sendRepeatedKeys(1, KEYCODE_DPAD_CENTER, 2, KEYCODE_DPAD_LEFT).
 * @param keys The series of key repeats and codes to send through instrumentation.
 */
public void sendRepeatedKeys(int... keys){
  final int count=keys.length;
  if ((count & 0x1) == 0x1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i+=2) {
    final int keyCount=keys[i];
    final int keyCode=keys[i + 1];
    for (int j=0; j < keyCount; j++) {
      try {
        instrumentation.sendKeyDownUpSync(keyCode);
      }
 catch (      SecurityException e) {
      }
    }
  }
  instrumentation.waitForIdleSync();
}",0.9605650382577988
43530,"TimeStats(Parcel in){
  final int[] localTimes=times;
  for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
    localTimes[i]=in.readInt();
  }
}","TimeStats(Parcel in){
  count=in.readInt();
  final int[] localTimes=times;
  for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
    localTimes[i]=in.readInt();
  }
}",0.9271523178807948
43531,"public void noteResumeComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
  if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
    return;
  }
  if ((mResumedPkg != null) && (mResumedPkg.equalsIgnoreCase(pkgName))) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + pkgName);
synchronized (mStatsLock) {
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      pus=new PkgUsageStatsExtended();
      mStats.put(pkgName,pus);
    }
    pus.updateResume();
  }
  mResumedPkg=pkgName;
}","public void noteResumeComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
synchronized (mStatsLock) {
    if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
      return;
    }
    final boolean samePackage=pkgName.equals(mLastResumedPkg);
    if (mIsResumed) {
      if (samePackage) {
        Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
      if (mLastResumedPkg != null) {
        Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mLastResumedPkg);
        PkgUsageStatsExtended pus=mStats.get(mLastResumedPkg);
        if (pus != null) {
          pus.updatePause();
        }
      }
    }
    final boolean sameComp=samePackage && componentName.getClassName().equals(mLastResumedComp);
    mIsResumed=true;
    mLastResumedPkg=pkgName;
    mLastResumedComp=componentName.getClassName();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      pus=new PkgUsageStatsExtended();
      mStats.put(pkgName,pus);
    }
    pus.updateResume(!samePackage);
    if (!sameComp) {
      pus.addLaunchCount(mLastResumedComp);
    }
  }
}",0.4756697648988518
43532,"private void collectDumpInfoFromParcelFLOCK(Parcel in,PrintWriter pw,String date,boolean isCompactOutput){
  StringBuilder sb=new StringBuilder(512);
  if (isCompactOutput) {
    sb.append(""String_Node_Str"");
    sb.append(CHECKIN_VERSION);
    sb.append(',');
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(date);
  int vers=in.readInt();
  if (vers != VERSION) {
    sb.append(""String_Node_Str"");
    pw.println(sb.toString());
    return;
  }
  pw.println(sb.toString());
  int N=in.readInt();
  while (N > 0) {
    N--;
    String pkgName=in.readString();
    if (pkgName == null) {
      break;
    }
    sb.setLength(0);
    PkgUsageStatsExtended pus=new PkgUsageStatsExtended(in);
    if (isCompactOutput) {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
            sb.append(""String_Node_Str"");
            sb.append(times.times[i]);
          }
          sb.append('\n');
        }
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append(""String_Node_Str"");
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          int lastBin=0;
          boolean first=true;
          for (int i=0; i < NUM_LAUNCH_TIME_BINS - 1; i++) {
            if (times.times[i] != 0) {
              sb.append(first ? ""String_Node_Str"" : ""String_Node_Str"");
              sb.append(lastBin);
              sb.append('-');
              sb.append(LAUNCH_TIME_BINS[i]);
              sb.append('=');
              sb.append(times.times[i]);
              first=false;
            }
            lastBin=LAUNCH_TIME_BINS[i];
          }
          if (times.times[NUM_LAUNCH_TIME_BINS - 1] != 0) {
            sb.append(first ? ""String_Node_Str"" : ""String_Node_Str"");
            sb.append(""String_Node_Str"");
            sb.append(lastBin);
            sb.append('=');
            sb.append(times.times[NUM_LAUNCH_TIME_BINS - 1]);
          }
          sb.append('\n');
        }
      }
    }
    pw.write(sb.toString());
  }
}","private void collectDumpInfoFromParcelFLOCK(Parcel in,PrintWriter pw,String date,boolean isCompactOutput){
  StringBuilder sb=new StringBuilder(512);
  if (isCompactOutput) {
    sb.append(""String_Node_Str"");
    sb.append(CHECKIN_VERSION);
    sb.append(',');
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(date);
  int vers=in.readInt();
  if (vers != VERSION) {
    sb.append(""String_Node_Str"");
    pw.println(sb.toString());
    return;
  }
  pw.println(sb.toString());
  int N=in.readInt();
  while (N > 0) {
    N--;
    String pkgName=in.readString();
    if (pkgName == null) {
      break;
    }
    sb.setLength(0);
    PkgUsageStatsExtended pus=new PkgUsageStatsExtended(in);
    if (isCompactOutput) {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(',');
      sb.append(pus.mLaunchCount);
      sb.append(',');
      sb.append(pus.mUsageTime);
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          sb.append(',');
          sb.append(times.count);
          for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
            sb.append(""String_Node_Str"");
            sb.append(times.times[i]);
          }
          sb.append('\n');
        }
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append(""String_Node_Str"");
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          sb.append(""String_Node_Str"");
          sb.append(times.count);
          sb.append(""String_Node_Str"");
          int lastBin=0;
          for (int i=0; i < NUM_LAUNCH_TIME_BINS - 1; i++) {
            if (times.times[i] != 0) {
              sb.append(""String_Node_Str"");
              sb.append(lastBin);
              sb.append('-');
              sb.append(LAUNCH_TIME_BINS[i]);
              sb.append(""String_Node_Str"");
              sb.append(times.times[i]);
            }
            lastBin=LAUNCH_TIME_BINS[i];
          }
          if (times.times[NUM_LAUNCH_TIME_BINS - 1] != 0) {
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            sb.append(lastBin);
            sb.append(""String_Node_Str"");
            sb.append(times.times[NUM_LAUNCH_TIME_BINS - 1]);
          }
          sb.append('\n');
        }
      }
    }
    pw.write(sb.toString());
  }
}",0.9363399826539462
43533,"public void notePauseComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
  if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
    return;
  }
  if ((mResumedPkg == null) || (!pkgName.equalsIgnoreCase(mResumedPkg))) {
    Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + pkgName);
  writeStatsToFile(false);
synchronized (mStatsLock) {
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      Log.w(TAG,""String_Node_Str"" + pkgName);
      return;
    }
    pus.updatePause();
  }
}","public void notePauseComponent(ComponentName componentName){
  enforceCallingPermission();
synchronized (mStatsLock) {
    String pkgName;
    if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
      return;
    }
    if (!mIsResumed) {
      Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      return;
    }
    mIsResumed=false;
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      Log.w(TAG,""String_Node_Str"" + pkgName);
      return;
    }
    pus.updatePause();
  }
  writeStatsToFile(false);
}",0.7807153965785381
43534,"void updateResume(){
  mLaunchCount++;
  mResumedTime=SystemClock.elapsedRealtime();
}","void updateResume(boolean launched){
  if (launched) {
    mLaunchCount++;
  }
  mResumedTime=SystemClock.elapsedRealtime();
}",0.8113207547169812
43535,"/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}","/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (routes == 0 && mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (routes == 0 && mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (routes == 0 && mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (routes == 0 && mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}",0.9947423764458464
43536,"@Override public void onBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState){
  LinkedList<File> dirsToScan=new LinkedList<File>();
  ArrayList<String> allFiles=new ArrayList<String>();
  dirsToScan.add(getFilesDir());
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + getFilesDir().getAbsolutePath() + ""String_Node_Str"");
  while (dirsToScan.size() > 0) {
    File dir=dirsToScan.removeFirst();
    File[] contents=dir.listFiles();
    if (contents != null) {
      for (      File f : contents) {
        if (f.isDirectory()) {
          dirsToScan.add(f);
        }
 else         if (f.isFile()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + f.getAbsolutePath());
          allFiles.add(f.getAbsolutePath());
        }
      }
    }
  }
  FileBackupHelper.performBackup(this,oldState,data,newState,(String[])allFiles.toArray());
}","@Override public void onBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState){
  LinkedList<File> dirsToScan=new LinkedList<File>();
  ArrayList<String> allFiles=new ArrayList<String>();
  dirsToScan.add(getFilesDir());
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + getFilesDir().getAbsolutePath() + ""String_Node_Str"");
  while (dirsToScan.size() > 0) {
    File dir=dirsToScan.removeFirst();
    File[] contents=dir.listFiles();
    if (contents != null) {
      for (      File f : contents) {
        if (f.isDirectory()) {
          dirsToScan.add(f);
        }
 else         if (f.isFile()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + f.getAbsolutePath());
          allFiles.add(f.getAbsolutePath());
        }
      }
    }
  }
  FileBackupHelper helper=new FileBackupHelper(this);
  helper.performBackup(oldState,data,newState,(String[])allFiles.toArray());
}",0.9728230726566832
43537,"/** 
 * Based on oldState, determine which of the files from the application's data directory need to be backed up, write them to the data stream, and fill in newState with the state as it exists now.
 */
public static void performBackup(Context context,ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState,String[] files){
  File base=context.getFilesDir();
  final int N=files.length;
  String[] fullPaths=new String[N];
  for (int i=0; i < N; i++) {
    fullPaths[i]=(new File(base,files[i])).getAbsolutePath();
  }
  performBackup_checked(oldState,data,newState,fullPaths,files);
}","/** 
 * Based on oldState, determine which of the files from the application's data directory need to be backed up, write them to the data stream, and fill in newState with the state as it exists now.
 */
public void performBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState,String[] files){
  File base=mContext.getFilesDir();
  final int N=files.length;
  String[] fullPaths=new String[N];
  for (int i=0; i < N; i++) {
    fullPaths[i]=(new File(base,files[i])).getAbsolutePath();
  }
  String[] keys=makeKeys(mKeyPrefix,files);
  performBackup_checked(oldState,data,newState,fullPaths,keys);
}",0.9383506805444356
43538,"public static void performBackup(Context context,ParcelFileDescriptor oldSnapshot,ParcelFileDescriptor newSnapshot,BackupDataOutput data,String[] prefGroups){
  final int N=prefGroups.length;
  String[] files=new String[N];
  for (int i=0; i < N; i++) {
    files[i]=context.getSharedPrefsFile(prefGroups[i]).toString();
  }
  FileBackupHelper.performBackup_checked(oldSnapshot,data,newSnapshot,files,prefGroups);
}","public void performBackup(ParcelFileDescriptor oldSnapshot,ParcelFileDescriptor newSnapshot,BackupDataOutput data,String[] prefGroups){
  Context context=mContext;
  final int N=prefGroups.length;
  String[] files=new String[N];
  for (int i=0; i < N; i++) {
    files[i]=context.getSharedPrefsFile(prefGroups[i]).getAbsolutePath();
  }
  String[] keys=FileBackupHelper.makeKeys(mKeyPrefix,prefGroups);
  FileBackupHelper.performBackup_checked(oldSnapshot,data,newSnapshot,files,prefGroups);
}",0.6387665198237885
43539,"public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data) throws RemoteException {
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File imageFileName=new File(packageDir,DATA_FILE_NAME);
  return -1;
}","public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data) throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  int err=0;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize);
      if (dataSize > bufSize) {
        bufSize=dataSize;
        buf=new byte[bufSize];
      }
      changeSet.readEntityData(buf,dataSize);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + dataSize);
      File entityFile=new File(packageDir,key);
      FileOutputStream entity=new FileOutputStream(entityFile);
      try {
        entity.write(buf,0,dataSize);
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
        err=-1;
      }
 finally {
        entity.close();
      }
    }
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"");
    e.printStackTrace();
    err=-1;
  }
  return err;
}",0.1495081967213114
43540,"public int endSession() throws RemoteException {
  return 0;
}","public int endSession() throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  return 0;
}",0.7337278106508875
43541,"public int startSession() throws RemoteException {
  return 0;
}","public int startSession() throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  mDataDir.mkdirs();
  return 0;
}",0.6597938144329897
43542,"public int getRestoreData(int token,PackageInfo packageInfo,ParcelFileDescriptor output) throws android.os.RemoteException {
  if (token != 0)   return -1;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File imageFile=new File(packageDir,DATA_FILE_NAME);
  return copyFileToFD(imageFile,output);
}","public int getRestoreData(int token,PackageInfo packageInfo,ParcelFileDescriptor output) throws android.os.RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ packageInfo.packageName);
  if (token != 0)   return -1;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File[] blobs=packageDir.listFiles();
  int err=0;
  if (blobs != null && blobs.length > 0) {
    for (    File f : blobs) {
      err=copyFileToFD(f,output);
      if (err != 0)       break;
    }
  }
  return err;
}",0.5330188679245284
43543,"public PackageInfo[] getAppSet(int token) throws android.os.RemoteException {
  File[] packageDirs=mDataDir.listFiles(mDirFileFilter);
  ArrayList<PackageInfo> packages=new ArrayList<PackageInfo>();
  for (  File dir : packageDirs) {
    try {
      PackageInfo pkg=mPackageManager.getPackageInfo(dir.getName(),PackageManager.GET_SIGNATURES);
      if (pkg != null) {
        packages.add(pkg);
      }
    }
 catch (    NameNotFoundException e) {
    }
  }
  Log.v(TAG,""String_Node_Str"" + packages.size() + ""String_Node_Str"");
  for (  PackageInfo p : packages) {
    Log.v(TAG,""String_Node_Str"" + p.packageName);
  }
  PackageInfo[] result=new PackageInfo[packages.size()];
  return packages.toArray(result);
}","public PackageInfo[] getAppSet(int token) throws android.os.RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + token);
  File[] packageDirs=mDataDir.listFiles(mDirFileFilter);
  ArrayList<PackageInfo> packages=new ArrayList<PackageInfo>();
  for (  File dir : packageDirs) {
    try {
      PackageInfo pkg=mPackageManager.getPackageInfo(dir.getName(),PackageManager.GET_SIGNATURES);
      if (pkg != null) {
        packages.add(pkg);
      }
    }
 catch (    NameNotFoundException e) {
    }
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + packages.size() + ""String_Node_Str"");
    for (    PackageInfo p : packages) {
      Log.v(TAG,""String_Node_Str"" + p.packageName);
    }
  }
  PackageInfo[] result=new PackageInfo[packages.size()];
  return packages.toArray(result);
}",0.9389110225763612
43544,"public LocalTransport(Context context){
  mContext=context;
  mPackageManager=context.getPackageManager();
}","public LocalTransport(Context context){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  mContext=context;
  mPackageManager=context.getPackageManager();
}",0.8275862068965517
43545,"public final void finishSubActivity(IBinder token,String resultWho,int requestCode){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return;
    }
    HistoryRecord self=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    int i;
    for (i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.resultTo == self && r.requestCode == requestCode) {
        if ((r.resultWho == null && resultWho == null) || (r.resultWho != null && r.resultWho.equals(resultWho))) {
          finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
        }
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","public final void finishSubActivity(IBinder token,String resultWho,int requestCode){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord self=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    int i;
    for (i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.resultTo == self && r.requestCode == requestCode) {
        if ((r.resultWho == null && resultWho == null) || (r.resultWho != null && r.resultWho.equals(resultWho))) {
          finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
        }
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}",0.99601593625498
43546,"public void setPersistent(IBinder token,boolean isPersistent){
  if (checkCallingPermission(android.Manifest.permission.PERSISTENT_ACTIVITY) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.PERSISTENT_ACTIVITY;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
synchronized (this) {
    int index=indexOfTokenLocked(token,true);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    ProcessRecord app=r.app;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + isPersistent + ""String_Node_Str""+ r);
    if (isPersistent) {
      if (r.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      r.persistent=true;
      app.persistentActivities++;
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + app.persistentActivities);
      if (app.persistentActivities > 1) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      if (app.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      final long origId=Binder.clearCallingIdentity();
      updateOomAdjLocked();
      Binder.restoreCallingIdentity(origId);
    }
 else {
      if (!r.persistent) {
        return;
      }
      r.persistent=false;
      final long origId=Binder.clearCallingIdentity();
      decPersistentCountLocked(app);
      Binder.restoreCallingIdentity(origId);
    }
  }
}","public void setPersistent(IBinder token,boolean isPersistent){
  if (checkCallingPermission(android.Manifest.permission.PERSISTENT_ACTIVITY) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.PERSISTENT_ACTIVITY;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    ProcessRecord app=r.app;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + isPersistent + ""String_Node_Str""+ r);
    if (isPersistent) {
      if (r.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      r.persistent=true;
      app.persistentActivities++;
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + app.persistentActivities);
      if (app.persistentActivities > 1) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      if (app.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      final long origId=Binder.clearCallingIdentity();
      updateOomAdjLocked();
      Binder.restoreCallingIdentity(origId);
    }
 else {
      if (!r.persistent) {
        return;
      }
      r.persistent=false;
      final long origId=Binder.clearCallingIdentity();
      decPersistentCountLocked(app);
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.9984192222573506
43547,"public final void activityDestroyed(IBinder token){
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + token);
synchronized (this) {
    mHandler.removeMessages(DESTROY_TIMEOUT_MSG,token);
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (r.state == ActivityState.DESTROYING) {
        final long origId=Binder.clearCallingIdentity();
        removeActivityFromHistoryLocked(r);
        Binder.restoreCallingIdentity(origId);
      }
    }
  }
}","public final void activityDestroyed(IBinder token){
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + token);
synchronized (this) {
    mHandler.removeMessages(DESTROY_TIMEOUT_MSG,token);
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (r.state == ActivityState.DESTROYING) {
        final long origId=Binder.clearCallingIdentity();
        removeActivityFromHistoryLocked(r);
        Binder.restoreCallingIdentity(origId);
      }
    }
  }
}",0.9943396226415094
43548,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret,false);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9981796116504854
43549,"private final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,boolean onlyIfNeeded,boolean componentSpecified){
  Log.i(TAG,""String_Node_Str"" + intent);
  HistoryRecord sourceRecord=null;
  HistoryRecord resultRecord=null;
  if (resultTo != null) {
    int index=indexOfTokenLocked(resultTo,false);
    if (DEBUG_RESULTS)     Log.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ index+ ""String_Node_Str"");
    if (index >= 0) {
      sourceRecord=(HistoryRecord)mHistory.get(index);
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      return START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  int err=START_SUCCESS;
  if (intent.getComponent() == null) {
    err=START_INTENT_NOT_RESOLVED;
  }
  if (err == START_SUCCESS && aInfo == null) {
    err=START_CLASS_NOT_FOUND;
  }
  ProcessRecord callerApp=null;
  if (err == START_SUCCESS && caller != null) {
    callerApp=getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=START_PERMISSION_DENIED;
    }
  }
  if (err != START_SUCCESS) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    return err;
  }
  final int perm=checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.exported ? -1 : aInfo.applicationInfo.uid);
  if (perm != PackageManager.PERMISSION_GRANTED) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    String msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
  if (mWatcher != null) {
    boolean abort=false;
    try {
      Intent watchIntent=intent.cloneFilter();
      abort=!mWatcher.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mWatcher=null;
    }
    if (abort) {
      if (resultRecord != null) {
        sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
      }
      return START_SUCCESS;
    }
  }
  HistoryRecord r=new HistoryRecord(this,callerApp,callingUid,intent,resolvedType,aInfo,mConfiguration,resultRecord,resultWho,requestCode,componentSpecified);
  if (mResumedActivity == null || mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch();
      pal.r=r;
      pal.sourceRecord=sourceRecord;
      pal.grantedUriPermissions=grantedUriPermissions;
      pal.grantedMode=grantedMode;
      pal.onlyIfNeeded=onlyIfNeeded;
      mPendingActivityLaunches.add(pal);
      return START_SWITCHES_CANCELED;
    }
  }
  if (mDidAppSwitch) {
    mAppSwitchesAllowedTime=0;
  }
 else {
    mDidAppSwitch=true;
  }
  doPendingActivityLaunchesLocked(false);
  return startActivityUncheckedLocked(r,sourceRecord,grantedUriPermissions,grantedMode,onlyIfNeeded,true);
}","private final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,boolean onlyIfNeeded,boolean componentSpecified){
  Log.i(TAG,""String_Node_Str"" + intent);
  HistoryRecord sourceRecord=null;
  HistoryRecord resultRecord=null;
  if (resultTo != null) {
    int index=indexOfTokenLocked(resultTo);
    if (DEBUG_RESULTS)     Log.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ index+ ""String_Node_Str"");
    if (index >= 0) {
      sourceRecord=(HistoryRecord)mHistory.get(index);
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      return START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  int err=START_SUCCESS;
  if (intent.getComponent() == null) {
    err=START_INTENT_NOT_RESOLVED;
  }
  if (err == START_SUCCESS && aInfo == null) {
    err=START_CLASS_NOT_FOUND;
  }
  ProcessRecord callerApp=null;
  if (err == START_SUCCESS && caller != null) {
    callerApp=getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=START_PERMISSION_DENIED;
    }
  }
  if (err != START_SUCCESS) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    return err;
  }
  final int perm=checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.exported ? -1 : aInfo.applicationInfo.uid);
  if (perm != PackageManager.PERMISSION_GRANTED) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    String msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
  if (mWatcher != null) {
    boolean abort=false;
    try {
      Intent watchIntent=intent.cloneFilter();
      abort=!mWatcher.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mWatcher=null;
    }
    if (abort) {
      if (resultRecord != null) {
        sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
      }
      return START_SUCCESS;
    }
  }
  HistoryRecord r=new HistoryRecord(this,callerApp,callingUid,intent,resolvedType,aInfo,mConfiguration,resultRecord,resultWho,requestCode,componentSpecified);
  if (mResumedActivity == null || mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch();
      pal.r=r;
      pal.sourceRecord=sourceRecord;
      pal.grantedUriPermissions=grantedUriPermissions;
      pal.grantedMode=grantedMode;
      pal.onlyIfNeeded=onlyIfNeeded;
      mPendingActivityLaunches.add(pal);
      return START_SWITCHES_CANCELED;
    }
  }
  if (mDidAppSwitch) {
    mAppSwitchesAllowedTime=0;
  }
 else {
    mDidAppSwitch=true;
  }
  doPendingActivityLaunchesLocked(false);
  return startActivityUncheckedLocked(r,sourceRecord,grantedUriPermissions,grantedMode,onlyIfNeeded,true);
}",0.9992462311557788
43550,"private final int indexOfTokenLocked(IBinder token,boolean required){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  if (index < 0 && required) {
    RuntimeInit.crash(TAG,new InvalidTokenException(token));
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}",0.7988587731811697
43551,"public int getRequestedOrientation(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    return mWindowManager.getAppOrientation(r);
  }
}","public int getRequestedOrientation(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    return mWindowManager.getAppOrientation(r);
  }
}",0.990353697749196
43552,"public final void activityStopped(IBinder token,Bitmap thumbnail,CharSequence description){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  HistoryRecord r=null;
  final long origId=Binder.clearCallingIdentity();
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      r.thumbnail=thumbnail;
      r.description=description;
      r.stopped=true;
      r.state=ActivityState.STOPPED;
      if (!r.finishing) {
        if (r.configDestroy) {
          destroyActivityLocked(r,true);
          resumeTopActivityLocked(null);
        }
      }
    }
  }
  if (r != null) {
    sendPendingThumbnail(r,null,null,null,false);
  }
  trimApplications();
  Binder.restoreCallingIdentity(origId);
}","public final void activityStopped(IBinder token,Bitmap thumbnail,CharSequence description){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  HistoryRecord r=null;
  final long origId=Binder.clearCallingIdentity();
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      r.thumbnail=thumbnail;
      r.description=description;
      r.stopped=true;
      r.state=ActivityState.STOPPED;
      if (!r.finishing) {
        if (r.configDestroy) {
          destroyActivityLocked(r,true);
          resumeTopActivityLocked(null);
        }
      }
    }
  }
  if (r != null) {
    sendPendingThumbnail(r,null,null,null,false);
  }
  trimApplications();
  Binder.restoreCallingIdentity(origId);
}",0.9961587708066582
43553,"public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r)) {
        resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r)) {
        resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}",0.9956896551724138
43554,"public ComponentName getActivityClassForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.intent.getComponent();
    }
    return null;
  }
}","public ComponentName getActivityClassForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.intent.getComponent();
    }
    return null;
  }
}",0.9890510948905108
43555,"final void activityIdleInternal(IBinder token,boolean fromTimeout){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  ArrayList<HistoryRecord> stops=null;
  ArrayList<HistoryRecord> finishes=null;
  ArrayList<HistoryRecord> thumbnails=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
synchronized (this) {
    if (token != null) {
      mHandler.removeMessages(IDLE_TIMEOUT_MSG,token);
    }
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
        mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
        mLaunchingActivity.release();
      }
      r.idle=true;
      scheduleAppGcsLocked();
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (DEBUG_VISBILITY)       Log.v(TAG,""String_Node_Str"" + r);
      ensureActivitiesVisibleLocked(null,0);
      if (!mBooted && !fromTimeout) {
        mBooted=true;
        enableScreen=true;
      }
    }
    stops=processStoppingActivitiesLocked(true);
    NS=stops != null ? stops.size() : 0;
    if ((NF=mFinishingActivities.size()) > 0) {
      finishes=new ArrayList<HistoryRecord>(mFinishingActivities);
      mFinishingActivities.clear();
    }
    if ((NT=mCancelledThumbnails.size()) > 0) {
      thumbnails=new ArrayList<HistoryRecord>(mCancelledThumbnails);
      mCancelledThumbnails.clear();
    }
    booting=mBooting;
    mBooting=false;
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    HistoryRecord r=(HistoryRecord)stops.get(i);
synchronized (this) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    HistoryRecord r=(HistoryRecord)finishes.get(i);
synchronized (this) {
      destroyActivityLocked(r,true);
    }
  }
  for (i=0; i < NT; i++) {
    HistoryRecord r=(HistoryRecord)thumbnails.get(i);
    sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        this.startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
synchronized (this) {
        broadcastIntentLocked(null,null,new Intent(Intent.ACTION_BOOT_COMPLETED,null),null,null,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,false,false,MY_PID,Process.SYSTEM_UID);
      }
    }
  }
  trimApplications();
  if (enableScreen) {
    EventLog.writeEvent(LOG_BOOT_PROGRESS_ENABLE_SCREEN,SystemClock.uptimeMillis());
    enableScreenAfterBoot();
  }
}","final void activityIdleInternal(IBinder token,boolean fromTimeout){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  ArrayList<HistoryRecord> stops=null;
  ArrayList<HistoryRecord> finishes=null;
  ArrayList<HistoryRecord> thumbnails=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
synchronized (this) {
    if (token != null) {
      mHandler.removeMessages(IDLE_TIMEOUT_MSG,token);
    }
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
        mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
        mLaunchingActivity.release();
      }
      r.idle=true;
      scheduleAppGcsLocked();
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (DEBUG_VISBILITY)       Log.v(TAG,""String_Node_Str"" + r);
      ensureActivitiesVisibleLocked(null,0);
      if (!mBooted && !fromTimeout) {
        mBooted=true;
        enableScreen=true;
      }
    }
    stops=processStoppingActivitiesLocked(true);
    NS=stops != null ? stops.size() : 0;
    if ((NF=mFinishingActivities.size()) > 0) {
      finishes=new ArrayList<HistoryRecord>(mFinishingActivities);
      mFinishingActivities.clear();
    }
    if ((NT=mCancelledThumbnails.size()) > 0) {
      thumbnails=new ArrayList<HistoryRecord>(mCancelledThumbnails);
      mCancelledThumbnails.clear();
    }
    booting=mBooting;
    mBooting=false;
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    HistoryRecord r=(HistoryRecord)stops.get(i);
synchronized (this) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    HistoryRecord r=(HistoryRecord)finishes.get(i);
synchronized (this) {
      destroyActivityLocked(r,true);
    }
  }
  for (i=0; i < NT; i++) {
    HistoryRecord r=(HistoryRecord)thumbnails.get(i);
    sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        this.startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
synchronized (this) {
        broadcastIntentLocked(null,null,new Intent(Intent.ACTION_BOOT_COMPLETED,null),null,null,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,false,false,MY_PID,Process.SYSTEM_UID);
      }
    }
  }
  trimApplications();
  if (enableScreen) {
    EventLog.writeEvent(LOG_BOOT_PROGRESS_ENABLE_SCREEN,SystemClock.uptimeMillis());
    enableScreenAfterBoot();
  }
}",0.9990482233502538
43556,"public int bindService(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags){
  if (service != null && service.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    HistoryRecord activity=null;
    if (token != null) {
      int aindex=indexOfTokenLocked(token,false);
      if (aindex < 0) {
        Log.w(TAG,""String_Node_Str"" + token);
        return 0;
      }
      activity=(HistoryRecord)mHistory.get(aindex);
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid());
    if (res == null) {
      return 0;
    }
    if (res.record == null) {
      return -1;
    }
    ServiceRecord s=res.record;
    final long origId=Binder.clearCallingIdentity();
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + s.shortName);
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags);
    IBinder binder=connection.asBinder();
    s.connections.put(binder,c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    mServiceConnections.put(binder,c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!bringUpServiceLocked(s,service.getFlags(),false)) {
        return 0;
      }
    }
    if (s.app != null) {
      updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","public int bindService(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags){
  if (service != null && service.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    HistoryRecord activity=null;
    if (token != null) {
      int aindex=indexOfTokenLocked(token);
      if (aindex < 0) {
        Log.w(TAG,""String_Node_Str"" + token);
        return 0;
      }
      activity=(HistoryRecord)mHistory.get(aindex);
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid());
    if (res == null) {
      return 0;
    }
    if (res.record == null) {
      return -1;
    }
    ServiceRecord s=res.record;
    final long origId=Binder.clearCallingIdentity();
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + s.shortName);
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags);
    IBinder binder=connection.asBinder();
    s.connections.put(binder,c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    mServiceConnections.put(binder,c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!bringUpServiceLocked(s,service.getFlags(),false)) {
        return 0;
      }
    }
    if (s.app != null) {
      updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}",0.998984771573604
43557,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9986388384754992
43558,"/** 
 * @return Returns true if the activity is being finished, false if forsome reason it is being left as-is.
 */
private final boolean requestFinishActivityLocked(IBinder token,int resultCode,Intent resultData,String reason){
  if (DEBUG_RESULTS)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
  int index=indexOfTokenLocked(token,false);
  if (index < 0) {
    return false;
  }
  HistoryRecord r=(HistoryRecord)mHistory.get(index);
  boolean lastActivity=true;
  for (int i=mHistory.size() - 1; i >= 0; i--) {
    HistoryRecord p=(HistoryRecord)mHistory.get(i);
    if (!p.finishing && p != r) {
      lastActivity=false;
      break;
    }
  }
  if (lastActivity) {
    if (r.intent.hasCategory(Intent.CATEGORY_HOME)) {
      return false;
    }
  }
  finishActivityLocked(r,index,resultCode,resultData,reason);
  return true;
}","/** 
 * @return Returns true if the activity is being finished, false if forsome reason it is being left as-is.
 */
private final boolean requestFinishActivityLocked(IBinder token,int resultCode,Intent resultData,String reason){
  if (DEBUG_RESULTS)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
  int index=indexOfTokenLocked(token);
  if (index < 0) {
    return false;
  }
  HistoryRecord r=(HistoryRecord)mHistory.get(index);
  boolean lastActivity=true;
  for (int i=mHistory.size() - 1; i >= 0; i--) {
    HistoryRecord p=(HistoryRecord)mHistory.get(i);
    if (!p.finishing && p != r) {
      lastActivity=false;
      break;
    }
  }
  if (lastActivity) {
    if (r.intent.hasCategory(Intent.CATEGORY_HOME)) {
      return false;
    }
  }
  finishActivityLocked(r,index,resultCode,resultData,reason);
  return true;
}",0.9966178128523112
43559,"private HistoryRecord getCallingRecordLocked(IBinder token){
  int index=indexOfTokenLocked(token,true);
  if (index >= 0) {
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r != null) {
      return r.resultTo;
    }
  }
  return null;
}","private HistoryRecord getCallingRecordLocked(IBinder token){
  int index=indexOfTokenLocked(token);
  if (index >= 0) {
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r != null) {
      return r.resultTo;
    }
  }
  return null;
}",0.9900199600798404
43560,"public String getPackageForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.packageName;
    }
    return null;
  }
}","public String getPackageForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.packageName;
    }
    return null;
  }
}",0.9880478087649402
43561,"public IIntentSender getIntentSender(int type,String packageName,IBinder token,String resultWho,int requestCode,Intent intent,String resolvedType,int flags){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int callingUid=Binder.getCallingUid();
    try {
      if (callingUid != 0 && callingUid != Process.SYSTEM_UID && Process.supportsProcesses()) {
        int uid=ActivityThread.getPackageManager().getPackageUid(packageName);
        if (uid != Binder.getCallingUid()) {
          String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ ""String_Node_Str""+ packageName;
          Log.w(TAG,msg);
          throw new SecurityException(msg);
        }
      }
    }
 catch (    RemoteException e) {
      throw new SecurityException(e);
    }
    HistoryRecord activity=null;
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      int index=indexOfTokenLocked(token,false);
      if (index < 0) {
        return null;
      }
      activity=(HistoryRecord)mHistory.get(index);
      if (activity.finishing) {
        return null;
      }
    }
    final boolean noCreate=(flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent=(flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent=(flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags&=~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key=new PendingIntentRecord.Key(type,packageName,activity,resultWho,requestCode,intent,resolvedType,flags);
    WeakReference<PendingIntentRecord> ref;
    ref=mIntentSenderRecords.get(key);
    PendingIntentRecord rec=ref != null ? ref.get() : null;
    if (rec != null) {
      if (!cancelCurrent) {
        if (updateCurrent) {
          rec.key.requestIntent.replaceExtras(intent);
        }
        return rec;
      }
      rec.canceled=true;
      mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
      return rec;
    }
    rec=new PendingIntentRecord(this,key,callingUid);
    mIntentSenderRecords.put(key,rec.ref);
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      if (activity.pendingResults == null) {
        activity.pendingResults=new HashSet<WeakReference<PendingIntentRecord>>();
      }
      activity.pendingResults.add(rec.ref);
    }
    return rec;
  }
}","public IIntentSender getIntentSender(int type,String packageName,IBinder token,String resultWho,int requestCode,Intent intent,String resolvedType,int flags){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int callingUid=Binder.getCallingUid();
    try {
      if (callingUid != 0 && callingUid != Process.SYSTEM_UID && Process.supportsProcesses()) {
        int uid=ActivityThread.getPackageManager().getPackageUid(packageName);
        if (uid != Binder.getCallingUid()) {
          String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ ""String_Node_Str""+ packageName;
          Log.w(TAG,msg);
          throw new SecurityException(msg);
        }
      }
    }
 catch (    RemoteException e) {
      throw new SecurityException(e);
    }
    HistoryRecord activity=null;
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      int index=indexOfTokenLocked(token);
      if (index < 0) {
        return null;
      }
      activity=(HistoryRecord)mHistory.get(index);
      if (activity.finishing) {
        return null;
      }
    }
    final boolean noCreate=(flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent=(flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent=(flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags&=~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key=new PendingIntentRecord.Key(type,packageName,activity,resultWho,requestCode,intent,resolvedType,flags);
    WeakReference<PendingIntentRecord> ref;
    ref=mIntentSenderRecords.get(key);
    PendingIntentRecord rec=ref != null ? ref.get() : null;
    if (rec != null) {
      if (!cancelCurrent) {
        if (updateCurrent) {
          rec.key.requestIntent.replaceExtras(intent);
        }
        return rec;
      }
      rec.canceled=true;
      mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
      return rec;
    }
    rec=new PendingIntentRecord(this,key,callingUid);
    mIntentSenderRecords.put(key,rec.ref);
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      if (activity.pendingResults == null) {
        activity.pendingResults=new HashSet<WeakReference<PendingIntentRecord>>();
      }
      activity.pendingResults.add(rec.ref);
    }
    return rec;
  }
}",0.9988019169329072
43562,"final void sendPendingThumbnail(HistoryRecord r,IBinder token,Bitmap thumbnail,CharSequence description,boolean always){
  TaskRecord task=null;
  ArrayList receivers=null;
synchronized (this) {
    if (r == null) {
      int index=indexOfTokenLocked(token,false);
      if (index < 0) {
        return;
      }
      r=(HistoryRecord)mHistory.get(index);
    }
    if (thumbnail == null) {
      thumbnail=r.thumbnail;
      description=r.description;
    }
    if (thumbnail == null && !always) {
      return;
    }
    task=r.task;
    int N=mPendingThumbnails.size();
    int i=0;
    while (i < N) {
      PendingThumbnailsRecord pr=(PendingThumbnailsRecord)mPendingThumbnails.get(i);
      if (pr.pendingRecords.remove(r)) {
        if (receivers == null) {
          receivers=new ArrayList();
        }
        receivers.add(pr);
        if (pr.pendingRecords.size() == 0) {
          pr.finished=true;
          mPendingThumbnails.remove(i);
          N--;
          continue;
        }
      }
      i++;
    }
  }
  if (receivers != null) {
    final int N=receivers.size();
    for (int i=0; i < N; i++) {
      try {
        PendingThumbnailsRecord pr=(PendingThumbnailsRecord)receivers.get(i);
        pr.receiver.newThumbnail(task != null ? task.taskId : -1,thumbnail,description);
        if (pr.finished) {
          pr.receiver.finished();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}","final void sendPendingThumbnail(HistoryRecord r,IBinder token,Bitmap thumbnail,CharSequence description,boolean always){
  TaskRecord task=null;
  ArrayList receivers=null;
synchronized (this) {
    if (r == null) {
      int index=indexOfTokenLocked(token);
      if (index < 0) {
        return;
      }
      r=(HistoryRecord)mHistory.get(index);
    }
    if (thumbnail == null) {
      thumbnail=r.thumbnail;
      description=r.description;
    }
    if (thumbnail == null && !always) {
      return;
    }
    task=r.task;
    int N=mPendingThumbnails.size();
    int i=0;
    while (i < N) {
      PendingThumbnailsRecord pr=(PendingThumbnailsRecord)mPendingThumbnails.get(i);
      if (pr.pendingRecords.remove(r)) {
        if (receivers == null) {
          receivers=new ArrayList();
        }
        receivers.add(pr);
        if (pr.pendingRecords.size() == 0) {
          pr.finished=true;
          mPendingThumbnails.remove(i);
          N--;
          continue;
        }
      }
      i++;
    }
  }
  if (receivers != null) {
    final int N=receivers.size();
    for (int i=0; i < N; i++) {
      try {
        PendingThumbnailsRecord pr=(PendingThumbnailsRecord)receivers.get(i);
        pr.receiver.newThumbnail(task != null ? task.taskId : -1,thumbnail,description);
        if (pr.finished) {
          pr.receiver.finished();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}",0.9979480164158688
43563,"final void activityPaused(IBinder token,Bundle icicle,boolean timeout){
  if (DEBUG_PAUSE)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ icicle+ ""String_Node_Str""+ timeout);
  HistoryRecord r=null;
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      if (!timeout) {
        r.icicle=icicle;
        r.haveState=true;
      }
      mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
      if (mPausingActivity == r) {
        r.state=ActivityState.PAUSED;
        completePauseLocked();
      }
 else {
        EventLog.writeEvent(LOG_AM_FAILED_TO_PAUSE_ACTIVITY,System.identityHashCode(r),r.shortComponentName,mPausingActivity != null ? mPausingActivity.shortComponentName : ""String_Node_Str"");
      }
    }
  }
}","final void activityPaused(IBinder token,Bundle icicle,boolean timeout){
  if (DEBUG_PAUSE)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ icicle+ ""String_Node_Str""+ timeout);
  HistoryRecord r=null;
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      if (!timeout) {
        r.icicle=icicle;
        r.haveState=true;
      }
      mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
      if (mPausingActivity == r) {
        r.state=ActivityState.PAUSED;
        completePauseLocked();
      }
 else {
        EventLog.writeEvent(LOG_AM_FAILED_TO_PAUSE_ACTIVITY,System.identityHashCode(r),r.shortComponentName,mPausingActivity != null ? mPausingActivity.shortComponentName : ""String_Node_Str"");
      }
    }
  }
}",0.9962871287128712
43564,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  for (  DataConnection connBase : dataConnectionList) {
    CdmaDataConnection conn=(CdmaDataConnection)connBase;
    if (conn != null) {
      if (tearDown) {
        Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
        conn.disconnect(msg);
      }
 else {
        conn.clearSettings();
      }
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
  }
 else   if (state != State.IDLE) {
    setState(State.DISCONNECTING);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  for (  DataConnection connBase : dataConnectionList) {
    CdmaDataConnection conn=(CdmaDataConnection)connBase;
    if (conn != null) {
      if (tearDown) {
        Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
        conn.disconnect(msg);
      }
 else {
        conn.clearSettings();
      }
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
  }
}",0.9548713622943904
43565,"/** 
 * @override com.android.internal.telephony.DataConnectionTracker
 */
protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!mCdmaPhone.mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}","/** 
 * @override com.android.internal.telephony.DataConnectionTracker
 */
protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!mCdmaPhone.mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}",0.935672514619883
43566,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying PdpConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  for (  DataConnection conn : pdpList) {
    PdpConnection pdp=(PdpConnection)conn;
    if (tearDown) {
      Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
      pdp.disconnect(msg);
    }
 else {
      pdp.clearSettings();
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
    mActiveApn=null;
  }
 else   if (state != State.IDLE) {
    setState(State.DISCONNECTING);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying PdpConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  for (  DataConnection conn : pdpList) {
    PdpConnection pdp=(PdpConnection)conn;
    if (tearDown) {
      Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
      pdp.disconnect(msg);
    }
 else {
      pdp.clearSettings();
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
    mActiveApn=null;
  }
}",0.9527176314626602
43567,"/** 
 * Handles changes to the APN database.
 */
private void onApnChanged(){
  boolean isConnected;
  isConnected=(state != State.IDLE && state != State.FAILED);
  ((GSMPhone)phone).updateCurrentCarrierInProvider();
  createAllApnList();
  if (state != State.DISCONNECTING) {
    cleanUpConnection(isConnected,Phone.REASON_APN_CHANGED);
    if (!isConnected) {
      trySetupData(Phone.REASON_APN_CHANGED);
    }
  }
}","/** 
 * Handles changes to the APN database.
 */
private void onApnChanged(){
  boolean isConnected;
  isConnected=(state != State.IDLE && state != State.FAILED);
  ((GSMPhone)phone).updateCurrentCarrierInProvider();
  createAllApnList();
  if (state != State.DISCONNECTING) {
    cleanUpConnection(isConnected,Phone.REASON_APN_CHANGED);
    if (!isConnected) {
      nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
      trySetupData(Phone.REASON_APN_CHANGED);
    }
  }
}",0.9318435754189944
43568,"protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!((GSMPhone)phone).mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}","protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!((GSMPhone)phone).mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}",0.9235048678720446
43569,"public boolean isStreamAffectedByRingerMode(int streamType){
  int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  return (ringerModeAffectedStreams & (1 << streamType)) != 0;
}","public boolean isStreamAffectedByRingerMode(int streamType){
  return (mRingerModeAffectedStreams & (1 << streamType)) != 0;
}",0.6666666666666666
43570,"/** 
 * Sync the STREAM_RING and STREAM_NOTIFICATION volumes if mandated by the value in Settings.
 * @param streamType Type of the stream
 * @param index Volume index for the stream
 * @param force If true, set the volume even if the current and desiredvolume as same
 */
private void syncRingerAndNotificationStreamVolume(int streamType,int index,boolean force){
  boolean notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1) == 1;
  if (notificationsUseRingVolume) {
    if (streamType == AudioManager.STREAM_NOTIFICATION) {
      streamType=AudioManager.STREAM_RING;
    }
    if (streamType == AudioManager.STREAM_RING) {
      setStreamVolumeInt(AudioManager.STREAM_NOTIFICATION,index,force);
    }
  }
}","/** 
 * Sync the STREAM_RING and STREAM_NOTIFICATION volumes if mandated by the value in Settings.
 * @param streamType Type of the stream
 * @param index Volume index for the stream
 * @param force If true, set the volume even if the current and desiredvolume as same
 */
private void syncRingerAndNotificationStreamVolume(int streamType,int index,boolean force){
  boolean notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1) == 1;
  if (notificationsUseRingVolume) {
    if (streamType == AudioManager.STREAM_NOTIFICATION) {
      streamType=AudioManager.STREAM_RING;
    }
    if (streamType == AudioManager.STREAM_RING) {
      setStreamVolumeInt(AudioManager.STREAM_NOTIFICATION,index,force,true);
    }
  }
}",0.996776273372018
43571,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  setRingerModeInt(getRingerMode());
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode());
}",0.5139664804469274
43572,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 */
private void setStreamVolumeInt(int streamType,int index,boolean force){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}",0.9294781382228492
43573,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}",0.9952978056426331
43574,"public boolean adjustIndex(int deltaIndex){
  return setIndex(mIndex + deltaIndex);
}","public boolean adjustIndex(int deltaIndex){
  return setIndex(mIndex + deltaIndex,true);
}",0.9714285714285714
43575,"private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,0,false);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}","private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}",0.9015673981191222
43576,"public boolean setIndex(int index){
  int oldIndex=mIndex;
  mIndex=getValidIndex(index);
  if (oldIndex != mIndex) {
    if (mIndex > 0) {
      mLastAudibleIndex=mIndex;
    }
    return true;
  }
 else {
    return false;
  }
}","public boolean setIndex(int index,boolean lastAudible){
  int oldIndex=mIndex;
  mIndex=getValidIndex(index);
  if (oldIndex != mIndex) {
    if (lastAudible) {
      mLastAudibleIndex=mIndex;
    }
    return true;
  }
 else {
    return false;
  }
}",0.9147609147609148
43577,"/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true);
}
}
}","/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}",0.9995593548955672
43578,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode != mMode) {
      if (AudioSystem.setMode(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[streamType].mIndex;
    syncRingerAndNotificationStreamVolume(streamType,index,true);
    setStreamVolumeInt(streamType,index,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode != mMode) {
      if (AudioSystem.setMode(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[streamType].mIndex;
    syncRingerAndNotificationStreamVolume(streamType,index,true);
    setStreamVolumeInt(streamType,index,true,true);
  }
}",0.9954995499549956
43579,"private void readPersistedSettings(){
  final ContentResolver cr=mContentResolver;
  mRingerMode=System.getInt(cr,System.MODE_RINGER,AudioManager.RINGER_MODE_NORMAL);
  mVibrateSetting=System.getInt(cr,System.VIBRATE_ON,0);
  mMuteAffectedStreams=System.getInt(cr,System.MUTE_STREAMS_AFFECTED,((1 << AudioSystem.STREAM_MUSIC) | (1 << AudioSystem.STREAM_RING) | (1 << AudioSystem.STREAM_SYSTEM)));
  broadcastRingerMode();
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
}","private void readPersistedSettings(){
  final ContentResolver cr=mContentResolver;
  mRingerMode=System.getInt(cr,System.MODE_RINGER,AudioManager.RINGER_MODE_NORMAL);
  mVibrateSetting=System.getInt(cr,System.VIBRATE_ON,0);
  mRingerModeAffectedStreams=Settings.System.getInt(cr,Settings.System.MODE_RINGER_STREAMS_AFFECTED,((1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)));
  mMuteAffectedStreams=System.getInt(cr,System.MUTE_STREAMS_AFFECTED,((1 << AudioSystem.STREAM_MUSIC) | (1 << AudioSystem.STREAM_RING) | (1 << AudioSystem.STREAM_SYSTEM)));
  broadcastRingerMode();
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
}",0.817629179331307
43580,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  syncRingerAndNotificationStreamVolume(streamType,index,false);
  setStreamVolumeInt(streamType,index,false);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  syncRingerAndNotificationStreamVolume(streamType,index,false);
  setStreamVolumeInt(streamType,index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}",0.9930651872399444
43581,"private void updateProviderListenersLocked(String provider,boolean enabled){
  int listeners=0;
  LocationProviderProxy p=mProvidersByName.get(provider);
  if (p == null) {
    return;
  }
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records != null) {
    final int N=records.size();
    for (int i=0; i < N; i++) {
      UpdateRecord record=records.get(i);
      if (!record.mReceiver.callProviderEnabledLocked(provider,enabled)) {
        if (deadReceivers == null) {
          deadReceivers=new ArrayList<Receiver>();
          deadReceivers.add(record.mReceiver);
        }
      }
      listeners++;
    }
  }
  if (deadReceivers != null) {
    for (int i=deadReceivers.size() - 1; i >= 0; i--) {
      removeUpdatesLocked(deadReceivers.get(i));
    }
  }
  if (enabled) {
    p.enable();
    if (listeners > 0) {
      p.setMinTime(getMinTimeLocked(provider));
      p.enableLocationTracking(true);
    }
  }
 else {
    p.enableLocationTracking(false);
    p.disable();
  }
}","private void updateProviderListenersLocked(String provider,boolean enabled){
  int listeners=0;
  LocationProviderProxy p=mProvidersByName.get(provider);
  if (p == null) {
    return;
  }
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records != null) {
    final int N=records.size();
    for (int i=0; i < N; i++) {
      UpdateRecord record=records.get(i);
      if (!record.mReceiver.callProviderEnabledLocked(provider,enabled)) {
        if (deadReceivers == null) {
          deadReceivers=new ArrayList<Receiver>();
        }
        deadReceivers.add(record.mReceiver);
      }
      listeners++;
    }
  }
  if (deadReceivers != null) {
    for (int i=deadReceivers.size() - 1; i >= 0; i--) {
      removeUpdatesLocked(deadReceivers.get(i));
    }
  }
  if (enabled) {
    p.enable();
    if (listeners > 0) {
      p.setMinTime(getMinTimeLocked(provider));
      p.enableLocationTracking(true);
    }
  }
 else {
    p.enableLocationTracking(false);
    p.disable();
  }
}",0.9914529914529916
43582,"/** 
 * Formats a date or a time range according to the local conventions. <p> Example output strings (date formats in these examples are shown using the US date format convention but that may change depending on the local settings): <ul> <li>10:15am</li> <li>3:00pm - 4:00pm</li> <li>3pm - 4pm</li> <li>3PM - 4PM</li> <li>08:00 - 17:00</li> <li>Oct 9</li> <li>Tue, Oct 9</li> <li>October 9, 2007</li> <li>Oct 9 - 10</li> <li>Oct 9 - 10, 2007</li> <li>Oct 28 - Nov 3, 2007</li> <li>Dec 31, 2007 - Jan 1, 2008</li> <li>Oct 9, 8:00am - Oct 10, 5:00pm</li> <li>12/31/2007 - 01/01/2008</li> </ul> <p> The flags argument is a bitmask of options from the following list: <ul> <li>FORMAT_SHOW_TIME</li> <li>FORMAT_SHOW_WEEKDAY</li> <li>FORMAT_SHOW_YEAR</li> <li>FORMAT_NO_YEAR</li> <li>FORMAT_SHOW_DATE</li> <li>FORMAT_NO_MONTH_DAY</li> <li>FORMAT_12HOUR</li> <li>FORMAT_24HOUR</li> <li>FORMAT_CAP_AMPM</li> <li>FORMAT_NO_NOON</li> <li>FORMAT_CAP_NOON</li> <li>FORMAT_NO_MIDNIGHT</li> <li>FORMAT_CAP_MIDNIGHT</li> <li>FORMAT_UTC</li> <li>FORMAT_ABBREV_TIME</li> <li>FORMAT_ABBREV_WEEKDAY</li> <li>FORMAT_ABBREV_MONTH</li> <li>FORMAT_ABBREV_ALL</li> <li>FORMAT_NUMERIC_DATE</li> </ul> <p> If FORMAT_SHOW_TIME is set, the time is shown as part of the date range. If the start and end time are the same, then just the start time is shown. <p> If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown. <p> If FORMAT_SHOW_YEAR is set, then the year is always shown. If FORMAT_NO_YEAR is set, then the year is not shown. If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year is shown only if it is different from the current year, or if the start and end dates fall on different years.  If both are set, FORMAT_SHOW_YEAR takes precedence. <p> Normally the date is shown unless the start and end day are the same. If FORMAT_SHOW_DATE is set, then the date is always shown, even for same day ranges. <p> If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the month name will be shown, not the day of the month.  For example, ""January, 2008"" instead of ""January 6 - 12, 2008"". <p> If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM"" and ""PM"" are capitalized. <p> If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is shown instead of ""noon"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is shown instead of ""noon"". <p> If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is shown instead of ""midnight"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Midnight"" is shown instead of ""midnight"". <p> If FORMAT_12HOUR is set and the time is shown, then the time is shown in the 12-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_24HOUR is set and the time is shown, then the time is shown in the 24-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_UTC is set, then the UTC timezone is used for the start and end milliseconds. <p> If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the start and end times (if shown) are abbreviated by not showing the minutes if they are zero.  For example, instead of ""3:00pm"" the time would be abbreviated to ""3pm"". <p> If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown) are abbreviated to 3-letter strings. <p> If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format instead of using the name of the month.  For example, ""12/31/2008"" instead of ""December 31, 2008"".
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @return a string containing the formatted date/time range.
 */
public static String formatDateRange(Context context,long startMillis,long endMillis,int flags){
  Resources res=Resources.getSystem();
  boolean showTime=(flags & FORMAT_SHOW_TIME) != 0;
  boolean showWeekDay=(flags & FORMAT_SHOW_WEEKDAY) != 0;
  boolean showYear=(flags & FORMAT_SHOW_YEAR) != 0;
  boolean noYear=(flags & FORMAT_NO_YEAR) != 0;
  boolean useUTC=(flags & FORMAT_UTC) != 0;
  boolean abbrevWeekDay=(flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
  boolean abbrevMonth=(flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
  boolean noMonthDay=(flags & FORMAT_NO_MONTH_DAY) != 0;
  boolean numericDate=(flags & FORMAT_NUMERIC_DATE) != 0;
  boolean isInstant=(startMillis == endMillis);
  Time startDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
  startDate.set(startMillis);
  Time endDate;
  int dayDistance;
  if (isInstant) {
    endDate=startDate;
    dayDistance=0;
  }
 else {
    endDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    endDate.set(endMillis);
    int startJulianDay=Time.getJulianDay(startMillis,startDate.gmtoff);
    int endJulianDay=Time.getJulianDay(endMillis,endDate.gmtoff);
    dayDistance=endJulianDay - startJulianDay;
  }
  if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
    endDate.monthDay-=1;
    endDate.normalize(true);
  }
  int startDay=startDate.monthDay;
  int startMonthNum=startDate.month;
  int startYear=startDate.year;
  int endDay=endDate.monthDay;
  int endMonthNum=endDate.month;
  int endYear=endDate.year;
  String startWeekDayString=""String_Node_Str"";
  String endWeekDayString=""String_Node_Str"";
  if (showWeekDay) {
    String weekDayFormat=""String_Node_Str"";
    if (abbrevWeekDay) {
      weekDayFormat=ABBREV_WEEKDAY_FORMAT;
    }
 else {
      weekDayFormat=WEEKDAY_FORMAT;
    }
    startWeekDayString=startDate.format(weekDayFormat);
    endWeekDayString=isInstant ? startWeekDayString : endDate.format(weekDayFormat);
  }
  String startTimeString=""String_Node_Str"";
  String endTimeString=""String_Node_Str"";
  if (showTime) {
    String startTimeFormat=""String_Node_Str"";
    String endTimeFormat=""String_Node_Str"";
    boolean force24Hour=(flags & FORMAT_24HOUR) != 0;
    boolean force12Hour=(flags & FORMAT_12HOUR) != 0;
    boolean use24Hour;
    if (force24Hour) {
      use24Hour=true;
    }
 else     if (force12Hour) {
      use24Hour=false;
    }
 else {
      use24Hour=DateFormat.is24HourFormat(context);
    }
    if (use24Hour) {
      startTimeFormat=HOUR_MINUTE_24;
      endTimeFormat=HOUR_MINUTE_24;
    }
 else {
      boolean abbrevTime=(flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
      boolean capAMPM=(flags & FORMAT_CAP_AMPM) != 0;
      boolean noNoon=(flags & FORMAT_NO_NOON) != 0;
      boolean capNoon=(flags & FORMAT_CAP_NOON) != 0;
      boolean noMidnight=(flags & FORMAT_NO_MIDNIGHT) != 0;
      boolean capMidnight=(flags & FORMAT_CAP_MIDNIGHT) != 0;
      boolean startOnTheHour=startDate.minute == 0 && startDate.second == 0;
      boolean endOnTheHour=endDate.minute == 0 && endDate.second == 0;
      if (abbrevTime && startOnTheHour) {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
        }
      }
 else {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
        }
      }
      if (!isInstant) {
        if (abbrevTime && endOnTheHour) {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
          }
        }
 else {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
          }
        }
        if (endDate.hour == 12 && endOnTheHour && !noNoon) {
          if (capNoon) {
            endTimeFormat=res.getString(com.android.internal.R.string.Noon);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.noon);
          }
        }
 else         if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
          if (capMidnight) {
            endTimeFormat=res.getString(com.android.internal.R.string.Midnight);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.midnight);
          }
        }
      }
      if (startDate.hour == 12 && startOnTheHour && !noNoon) {
        if (capNoon) {
          startTimeFormat=res.getString(com.android.internal.R.string.Noon);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.noon);
        }
      }
    }
    startTimeString=startDate.format(startTimeFormat);
    endTimeString=isInstant ? startTimeString : endDate.format(endTimeFormat);
  }
  if (showYear) {
  }
 else   if (noYear) {
    showYear=false;
  }
 else   if (startYear != endYear) {
    showYear=true;
  }
 else {
    Time currentTime=new Time();
    currentTime.setToNow();
    showYear=startYear != currentTime.year;
  }
  String defaultDateFormat, fullFormat, dateRange;
  if (numericDate) {
    defaultDateFormat=res.getString(com.android.internal.R.string.numeric_date);
  }
 else   if (showYear) {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day_year);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day_year);
      }
    }
  }
 else {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day);
      }
    }
  }
  if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
    }
  }
 else {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.date1_time1_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.date1_date2);
    }
  }
  if (noMonthDay && startMonthNum == endMonthNum) {
    String startDateString=startDate.format(defaultDateFormat);
    return startDateString;
  }
  if (startYear != endYear || noMonthDay) {
    String startDateString=startDate.format(defaultDateFormat);
    String endDateString=endDate.format(defaultDateFormat);
    dateRange=String.format(fullFormat,startWeekDayString,startDateString,startTimeString,endWeekDayString,endDateString,endTimeString);
    return dateRange;
  }
  String monthFormat;
  if (numericDate) {
    monthFormat=NUMERIC_MONTH_FORMAT;
  }
 else   if (abbrevMonth) {
    monthFormat=ABBREV_MONTH_FORMAT;
  }
 else {
    monthFormat=MONTH_FORMAT;
  }
  String startMonthString=startDate.format(monthFormat);
  String startMonthDayString=startDate.format(MONTH_DAY_FORMAT);
  String startYearString=startDate.format(YEAR_FORMAT);
  String endMonthString=isInstant ? null : endDate.format(monthFormat);
  String endMonthDayString=isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
  String endYearString=isInstant ? null : endDate.format(YEAR_FORMAT);
  if (startMonthNum != endMonthNum) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameYearTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  if (startDay != endDay) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameMonthTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  boolean showDate=(flags & FORMAT_SHOW_DATE) != 0;
  if (!showTime && !showDate && !showWeekDay)   showDate=true;
  String timeString=""String_Node_Str"";
  if (showTime) {
    if (isInstant) {
      timeString=startTimeString;
    }
 else {
      String timeFormat=res.getString(com.android.internal.R.string.time1_time2);
      timeString=String.format(timeFormat,startTimeString,endTimeString);
    }
  }
  fullFormat=""String_Node_Str"";
  String dateString=""String_Node_Str"";
  if (showDate) {
    dateString=startDate.format(defaultDateFormat);
    if (showWeekDay) {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_wday_date);
      }
 else {
        fullFormat=res.getString(com.android.internal.R.string.wday_date);
      }
    }
 else {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_date);
      }
 else {
        return dateString;
      }
    }
  }
 else   if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.time_wday);
    }
 else {
      return startWeekDayString;
    }
  }
 else   if (showTime) {
    return timeString;
  }
  dateRange=String.format(fullFormat,timeString,startWeekDayString,dateString);
  return dateRange;
}","/** 
 * Formats a date or a time range according to the local conventions. <p> Example output strings (date formats in these examples are shown using the US date format convention but that may change depending on the local settings): <ul> <li>10:15am</li> <li>3:00pm - 4:00pm</li> <li>3pm - 4pm</li> <li>3PM - 4PM</li> <li>08:00 - 17:00</li> <li>Oct 9</li> <li>Tue, Oct 9</li> <li>October 9, 2007</li> <li>Oct 9 - 10</li> <li>Oct 9 - 10, 2007</li> <li>Oct 28 - Nov 3, 2007</li> <li>Dec 31, 2007 - Jan 1, 2008</li> <li>Oct 9, 8:00am - Oct 10, 5:00pm</li> <li>12/31/2007 - 01/01/2008</li> </ul> <p> The flags argument is a bitmask of options from the following list: <ul> <li>FORMAT_SHOW_TIME</li> <li>FORMAT_SHOW_WEEKDAY</li> <li>FORMAT_SHOW_YEAR</li> <li>FORMAT_NO_YEAR</li> <li>FORMAT_SHOW_DATE</li> <li>FORMAT_NO_MONTH_DAY</li> <li>FORMAT_12HOUR</li> <li>FORMAT_24HOUR</li> <li>FORMAT_CAP_AMPM</li> <li>FORMAT_NO_NOON</li> <li>FORMAT_CAP_NOON</li> <li>FORMAT_NO_MIDNIGHT</li> <li>FORMAT_CAP_MIDNIGHT</li> <li>FORMAT_UTC</li> <li>FORMAT_ABBREV_TIME</li> <li>FORMAT_ABBREV_WEEKDAY</li> <li>FORMAT_ABBREV_MONTH</li> <li>FORMAT_ABBREV_ALL</li> <li>FORMAT_NUMERIC_DATE</li> </ul> <p> If FORMAT_SHOW_TIME is set, the time is shown as part of the date range. If the start and end time are the same, then just the start time is shown. <p> If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown. <p> If FORMAT_SHOW_YEAR is set, then the year is always shown. If FORMAT_NO_YEAR is set, then the year is not shown. If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year is shown only if it is different from the current year, or if the start and end dates fall on different years.  If both are set, FORMAT_SHOW_YEAR takes precedence. <p> Normally the date is shown unless the start and end day are the same. If FORMAT_SHOW_DATE is set, then the date is always shown, even for same day ranges. <p> If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the month name will be shown, not the day of the month.  For example, ""January, 2008"" instead of ""January 6 - 12, 2008"". <p> If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM"" and ""PM"" are capitalized.  You should not use this flag because in some locales these terms cannot be capitalized, and in many others it doesn't make sense to do so even though it is possible. <p> If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is shown instead of ""noon"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is shown instead of ""noon"".  You should probably not use this flag because in many locales it will not make sense to capitalize the term. <p> If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is shown instead of ""midnight"". <p> If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight"" is shown instead of ""midnight"".  You should probably not use this flag because in many locales it will not make sense to capitalize the term. <p> If FORMAT_12HOUR is set and the time is shown, then the time is shown in the 12-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_24HOUR is set and the time is shown, then the time is shown in the 24-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_UTC is set, then the UTC timezone is used for the start and end milliseconds. <p> If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the start and end times (if shown) are abbreviated by not showing the minutes if they are zero.  For example, instead of ""3:00pm"" the time would be abbreviated to ""3pm"". <p> If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown) are abbreviated to 3-letter strings. <p> If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format instead of using the name of the month.  For example, ""12/31/2008"" instead of ""December 31, 2008"".
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @return a string containing the formatted date/time range.
 */
public static String formatDateRange(Context context,long startMillis,long endMillis,int flags){
  Resources res=Resources.getSystem();
  boolean showTime=(flags & FORMAT_SHOW_TIME) != 0;
  boolean showWeekDay=(flags & FORMAT_SHOW_WEEKDAY) != 0;
  boolean showYear=(flags & FORMAT_SHOW_YEAR) != 0;
  boolean noYear=(flags & FORMAT_NO_YEAR) != 0;
  boolean useUTC=(flags & FORMAT_UTC) != 0;
  boolean abbrevWeekDay=(flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
  boolean abbrevMonth=(flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
  boolean noMonthDay=(flags & FORMAT_NO_MONTH_DAY) != 0;
  boolean numericDate=(flags & FORMAT_NUMERIC_DATE) != 0;
  boolean isInstant=(startMillis == endMillis);
  Time startDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
  startDate.set(startMillis);
  Time endDate;
  int dayDistance;
  if (isInstant) {
    endDate=startDate;
    dayDistance=0;
  }
 else {
    endDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    endDate.set(endMillis);
    int startJulianDay=Time.getJulianDay(startMillis,startDate.gmtoff);
    int endJulianDay=Time.getJulianDay(endMillis,endDate.gmtoff);
    dayDistance=endJulianDay - startJulianDay;
  }
  if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
    endDate.monthDay-=1;
    endDate.normalize(true);
  }
  int startDay=startDate.monthDay;
  int startMonthNum=startDate.month;
  int startYear=startDate.year;
  int endDay=endDate.monthDay;
  int endMonthNum=endDate.month;
  int endYear=endDate.year;
  String startWeekDayString=""String_Node_Str"";
  String endWeekDayString=""String_Node_Str"";
  if (showWeekDay) {
    String weekDayFormat=""String_Node_Str"";
    if (abbrevWeekDay) {
      weekDayFormat=ABBREV_WEEKDAY_FORMAT;
    }
 else {
      weekDayFormat=WEEKDAY_FORMAT;
    }
    startWeekDayString=startDate.format(weekDayFormat);
    endWeekDayString=isInstant ? startWeekDayString : endDate.format(weekDayFormat);
  }
  String startTimeString=""String_Node_Str"";
  String endTimeString=""String_Node_Str"";
  if (showTime) {
    String startTimeFormat=""String_Node_Str"";
    String endTimeFormat=""String_Node_Str"";
    boolean force24Hour=(flags & FORMAT_24HOUR) != 0;
    boolean force12Hour=(flags & FORMAT_12HOUR) != 0;
    boolean use24Hour;
    if (force24Hour) {
      use24Hour=true;
    }
 else     if (force12Hour) {
      use24Hour=false;
    }
 else {
      use24Hour=DateFormat.is24HourFormat(context);
    }
    if (use24Hour) {
      startTimeFormat=endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_24);
    }
 else {
      boolean abbrevTime=(flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
      boolean capAMPM=(flags & FORMAT_CAP_AMPM) != 0;
      boolean noNoon=(flags & FORMAT_NO_NOON) != 0;
      boolean capNoon=(flags & FORMAT_CAP_NOON) != 0;
      boolean noMidnight=(flags & FORMAT_NO_MIDNIGHT) != 0;
      boolean capMidnight=(flags & FORMAT_CAP_MIDNIGHT) != 0;
      boolean startOnTheHour=startDate.minute == 0 && startDate.second == 0;
      boolean endOnTheHour=endDate.minute == 0 && endDate.second == 0;
      if (abbrevTime && startOnTheHour) {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
        }
      }
 else {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
        }
      }
      if (!isInstant) {
        if (abbrevTime && endOnTheHour) {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
          }
        }
 else {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
          }
        }
        if (endDate.hour == 12 && endOnTheHour && !noNoon) {
          if (capNoon) {
            endTimeFormat=res.getString(com.android.internal.R.string.Noon);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.noon);
          }
        }
 else         if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
          if (capMidnight) {
            endTimeFormat=res.getString(com.android.internal.R.string.Midnight);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.midnight);
          }
        }
      }
      if (startDate.hour == 12 && startOnTheHour && !noNoon) {
        if (capNoon) {
          startTimeFormat=res.getString(com.android.internal.R.string.Noon);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.noon);
        }
      }
    }
    startTimeString=startDate.format(startTimeFormat);
    endTimeString=isInstant ? startTimeString : endDate.format(endTimeFormat);
  }
  if (showYear) {
  }
 else   if (noYear) {
    showYear=false;
  }
 else   if (startYear != endYear) {
    showYear=true;
  }
 else {
    Time currentTime=new Time();
    currentTime.setToNow();
    showYear=startYear != currentTime.year;
  }
  String defaultDateFormat, fullFormat, dateRange;
  if (numericDate) {
    defaultDateFormat=res.getString(com.android.internal.R.string.numeric_date);
  }
 else   if (showYear) {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day_year);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day_year);
      }
    }
  }
 else {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day);
      }
    }
  }
  if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
    }
  }
 else {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.date1_time1_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.date1_date2);
    }
  }
  if (noMonthDay && startMonthNum == endMonthNum) {
    String startDateString=startDate.format(defaultDateFormat);
    return startDateString;
  }
  if (startYear != endYear || noMonthDay) {
    String startDateString=startDate.format(defaultDateFormat);
    String endDateString=endDate.format(defaultDateFormat);
    dateRange=String.format(fullFormat,startWeekDayString,startDateString,startTimeString,endWeekDayString,endDateString,endTimeString);
    return dateRange;
  }
  String monthFormat;
  if (numericDate) {
    monthFormat=NUMERIC_MONTH_FORMAT;
  }
 else   if (abbrevMonth) {
    monthFormat=ABBREV_MONTH_FORMAT;
  }
 else {
    monthFormat=MONTH_FORMAT;
  }
  String startMonthString=startDate.format(monthFormat);
  String startMonthDayString=startDate.format(MONTH_DAY_FORMAT);
  String startYearString=startDate.format(YEAR_FORMAT);
  String endMonthString=isInstant ? null : endDate.format(monthFormat);
  String endMonthDayString=isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
  String endYearString=isInstant ? null : endDate.format(YEAR_FORMAT);
  if (startMonthNum != endMonthNum) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameYearTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  if (startDay != endDay) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameMonthTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  boolean showDate=(flags & FORMAT_SHOW_DATE) != 0;
  if (!showTime && !showDate && !showWeekDay)   showDate=true;
  String timeString=""String_Node_Str"";
  if (showTime) {
    if (isInstant) {
      timeString=startTimeString;
    }
 else {
      String timeFormat=res.getString(com.android.internal.R.string.time1_time2);
      timeString=String.format(timeFormat,startTimeString,endTimeString);
    }
  }
  fullFormat=""String_Node_Str"";
  String dateString=""String_Node_Str"";
  if (showDate) {
    dateString=startDate.format(defaultDateFormat);
    if (showWeekDay) {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_wday_date);
      }
 else {
        fullFormat=res.getString(com.android.internal.R.string.wday_date);
      }
    }
 else {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_date);
      }
 else {
        return dateString;
      }
    }
  }
 else   if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.time_wday);
    }
 else {
      return startWeekDayString;
    }
  }
 else   if (showTime) {
    return timeString;
  }
  dateRange=String.format(fullFormat,timeString,startWeekDayString,dateString);
  return dateRange;
}",0.9827678691162666
43583,"public void save(OutputStream stream,boolean closeStream) throws IOException {
  if (!mChanged) {
    return;
  }
  DataOutputStream out=null;
  try {
    long start;
    if (PROFILE_LOADING_SAVING) {
      start=SystemClock.elapsedRealtime();
    }
    final HashMap<String,ArrayList<Gesture>> maps=mNamedGestures;
    out=new DataOutputStream((stream instanceof BufferedOutputStream) ? out : new BufferedOutputStream(out,GestureConstants.IO_BUFFER_SIZE));
    out.writeShort(FILE_FORMAT_VERSION);
    out.writeInt(maps.size());
    for (    Map.Entry<String,ArrayList<Gesture>> entry : maps.entrySet()) {
      final String key=entry.getKey();
      final ArrayList<Gesture> examples=entry.getValue();
      final int count=examples.size();
      out.writeUTF(key);
      out.writeInt(count);
      for (int i=0; i < count; i++) {
        examples.get(i).serialize(out);
      }
    }
    out.flush();
    if (PROFILE_LOADING_SAVING) {
      long end=SystemClock.elapsedRealtime();
      Log.d(LOG_TAG,""String_Node_Str"" + (end - start) + ""String_Node_Str"");
    }
    mChanged=false;
  }
  finally {
    if (closeStream)     GestureUtilities.closeStream(out);
  }
}","public void save(OutputStream stream,boolean closeStream) throws IOException {
  if (!mChanged) {
    return;
  }
  DataOutputStream out=null;
  try {
    long start;
    if (PROFILE_LOADING_SAVING) {
      start=SystemClock.elapsedRealtime();
    }
    final HashMap<String,ArrayList<Gesture>> maps=mNamedGestures;
    out=new DataOutputStream((stream instanceof BufferedOutputStream) ? stream : new BufferedOutputStream(stream,GestureConstants.IO_BUFFER_SIZE));
    out.writeShort(FILE_FORMAT_VERSION);
    out.writeInt(maps.size());
    for (    Map.Entry<String,ArrayList<Gesture>> entry : maps.entrySet()) {
      final String key=entry.getKey();
      final ArrayList<Gesture> examples=entry.getValue();
      final int count=examples.size();
      out.writeUTF(key);
      out.writeInt(count);
      for (int i=0; i < count; i++) {
        examples.get(i).serialize(out);
      }
    }
    out.flush();
    if (PROFILE_LOADING_SAVING) {
      long end=SystemClock.elapsedRealtime();
      Log.d(LOG_TAG,""String_Node_Str"" + (end - start) + ""String_Node_Str"");
    }
    mChanged=false;
  }
  finally {
    if (closeStream)     GestureUtilities.closeStream(out);
  }
}",0.9923076923076924
43584,"@Override protected void runTest() throws Throwable {
  ReliabilityTestActivity activity=getActivity();
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  File testListFile=new File(TEST_LIST_FILE);
  if (!testListFile.exists())   throw new FileNotFoundException(""String_Node_Str"");
  BufferedReader listReader=new BufferedReader(new FileReader(testListFile));
  String lastUrl=readTestStatus();
  if (lastUrl != null && !TEST_DONE.equals(lastUrl))   fastForward(listReader,lastUrl);
  String url=null;
  Handler handler=null;
  boolean timeoutFlag=false;
  long start, elapsed;
  while ((url=listReader.readLine()) != null) {
    start=System.currentTimeMillis();
    Log.v(LOGTAG,""String_Node_Str"" + url);
    updateTestStatus(url);
    activity.reset();
    handler=activity.getHandler();
    handler.sendMessage(handler.obtainMessage(ReliabilityTestActivity.MSG_NAVIGATE,runner.mTimeoutInMillis,0,url));
    timeoutFlag=activity.waitUntilDone();
    elapsed=System.currentTimeMillis() - start;
    if (elapsed < 1000) {
      Log.w(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
 else {
      Log.v(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
    if (timeoutFlag) {
      writeTimeoutFile(url);
    }
    System.runFinalization();
    System.gc();
    System.gc();
  }
  activity.finish();
  listReader.close();
}","@Override protected void runTest() throws Throwable {
  ReliabilityTestActivity activity=getActivity();
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  File testListFile=new File(TEST_LIST_FILE);
  if (!testListFile.exists())   throw new FileNotFoundException(""String_Node_Str"");
  BufferedReader listReader=new BufferedReader(new FileReader(testListFile));
  String lastUrl=readTestStatus();
  if (lastUrl != null && !TEST_DONE.equals(lastUrl))   fastForward(listReader,lastUrl);
  String url=null;
  Handler handler=null;
  boolean timeoutFlag=false;
  long start, elapsed;
  while ((url=listReader.readLine()) != null) {
    start=System.currentTimeMillis();
    Log.v(LOGTAG,""String_Node_Str"" + url);
    updateTestStatus(url);
    activity.reset();
    handler=activity.getHandler();
    handler.sendMessage(handler.obtainMessage(ReliabilityTestActivity.MSG_NAVIGATE,runner.mTimeoutInMillis,0,url));
    timeoutFlag=activity.waitUntilDone();
    elapsed=System.currentTimeMillis() - start;
    if (elapsed < 1000) {
      Log.w(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
 else {
      Log.v(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
    if (timeoutFlag) {
      writeTimeoutFile(url);
    }
    System.runFinalization();
    System.gc();
    System.gc();
  }
  updateTestStatus(TEST_DONE);
  activity.finish();
  listReader.close();
}",0.9888849049838652
43585,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9076704545454546
43586,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
43587,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
43588,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8565082185695246
43589,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
43590,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
43591,"private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}","private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}",0.8548812664907651
43592,"@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
43593,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
43594,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
43595,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
43596,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
43597,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
43598,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
43599,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
43600,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
43601,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
43602,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
43603,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
43604,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
43605,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
43606,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
43607,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
43608,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
43609,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
43610,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
43611,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
43612,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
43613,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
43614,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
43615,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
43616,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
43617,"private void getPermissionsForPackage(String packageName,Set<PermissionInfo> permSet){
  PackageInfo pkgInfo;
  try {
    pkgInfo=mPm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + packageName);
    return;
  }
  if (pkgInfo == null) {
    return;
  }
  String strList[]=pkgInfo.requestedPermissions;
  if (strList == null) {
    return;
  }
  extractPerms(strList,permSet);
}","private void getPermissionsForPackage(String packageName,Set<PermissionInfo> permSet){
  PackageInfo pkgInfo;
  try {
    pkgInfo=mPm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + packageName);
    return;
  }
  if ((pkgInfo != null) && (pkgInfo.requestedPermissions != null)) {
    extractPerms(pkgInfo.requestedPermissions,permSet);
  }
}",0.8107502799552072
43618,"public AppSecurityPermissions(Context context,PackageParser.Package pkg){
  mContext=context;
  mPm=mContext.getPackageManager();
  mPermsList=new ArrayList<PermissionInfo>();
  Set<PermissionInfo> permSet=new HashSet<PermissionInfo>();
  if (pkg == null) {
    return;
  }
  if (pkg.mSharedUserId != null) {
    int sharedUid;
    try {
      sharedUid=mPm.getUidForSharedUser(pkg.mSharedUserId);
    }
 catch (    NameNotFoundException e) {
      Log.w(TAG,""String_Node_Str"" + pkg.packageName);
      return;
    }
    getAllUsedPermissions(sharedUid,permSet);
  }
 else {
    ArrayList<String> strList=pkg.requestedPermissions;
    int size;
    if ((strList == null) || ((size=strList.size()) == 0)) {
      return;
    }
    extractPerms(strList.toArray(new String[size]),permSet);
  }
  for (  PermissionInfo tmpInfo : permSet) {
    mPermsList.add(tmpInfo);
  }
}","public AppSecurityPermissions(Context context,PackageParser.Package pkg){
  mContext=context;
  mPm=mContext.getPackageManager();
  mPermsList=new ArrayList<PermissionInfo>();
  Set<PermissionInfo> permSet=new HashSet<PermissionInfo>();
  if (pkg == null) {
    return;
  }
  if (pkg.requestedPermissions != null) {
    ArrayList<String> strList=pkg.requestedPermissions;
    int size=strList.size();
    if (size > 0) {
      extractPerms(strList.toArray(new String[size]),permSet);
    }
  }
  if (pkg.mSharedUserId != null) {
    int sharedUid;
    try {
      sharedUid=mPm.getUidForSharedUser(pkg.mSharedUserId);
      getAllUsedPermissions(sharedUid,permSet);
    }
 catch (    NameNotFoundException e) {
      Log.w(TAG,""String_Node_Str"" + pkg.packageName);
    }
  }
  for (  PermissionInfo tmpInfo : permSet) {
    mPermsList.add(tmpInfo);
  }
}",0.5870069605568445
43619,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.991995583770356
43620,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  parcel.writeBundle(this);
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  if (mParcelledData != null) {
    int length=mParcelledData.dataSize();
    parcel.writeInt(length);
    parcel.writeInt(0x4C444E42);
    parcel.appendFrom(mParcelledData,0,length);
  }
 else {
    parcel.writeInt(-1);
    parcel.writeInt(0x4C444E42);
    int oldPos=parcel.dataPosition();
    parcel.writeMapInternal(mMap);
    int newPos=parcel.dataPosition();
    parcel.setDataPosition(oldPos - 8);
    int length=newPos - oldPos;
    parcel.writeInt(length);
    parcel.setDataPosition(newPos);
  }
}",0.4655870445344129
43621,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  mParcelledData.setDataPosition(0);
  Bundle b=mParcelledData.readBundleUnpacked(mClassLoader);
  mMap=b.mMap;
  mHasFds=mParcelledData.hasFileDescriptors();
  mFdsKnown=true;
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new HashMap<String,Object>();
  }
  mParcelledData.readMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}",0.6112412177985949
43622,"/** 
 * Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
public void readFromParcel(Parcel parcel){
  mParcelledData=parcel;
  mHasFds=mParcelledData.hasFileDescriptors();
  mFdsKnown=true;
}","/** 
 * Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
public void readFromParcel(Parcel parcel){
  int length=parcel.readInt();
  if (length < 0) {
    throw new RuntimeException(""String_Node_Str"" + length);
  }
  readFromParcelInner(parcel,length);
}",0.6847360912981455
43623,"private void readMapInternal(Map outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.put(key,value);
    N--;
  }
}","void readMapInternal(Map outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.put(key,value);
    N--;
  }
}",0.9791666666666666
43624,"/** 
 * Flatten a Bundle into the parcel at the current dataPosition(), growing dataCapacity() if needed.
 */
public final void writeBundle(Bundle val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  if (val.mParcelledData != null) {
    int length=val.mParcelledData.dataSize();
    appendFrom(val.mParcelledData,0,length);
  }
 else {
    writeInt(-1);
    int oldPos=dataPosition();
    writeInt(0x4C444E42);
    writeMapInternal(val.mMap);
    int newPos=dataPosition();
    setDataPosition(oldPos - 4);
    int length=newPos - oldPos;
    writeInt(length);
    setDataPosition(newPos);
  }
}","/** 
 * Flatten a Bundle into the parcel at the current dataPosition(), growing dataCapacity() if needed.
 */
public final void writeBundle(Bundle val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  val.writeToParcel(this,0);
}",0.5402843601895735
43625,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int offset=dataPosition();
  int length=readInt();
  if (length < 0) {
    return null;
  }
  int magic=readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  setDataPosition(offset + length + 4);
  Parcel p=new Parcel(0);
  p.setDataPosition(0);
  p.appendFrom(this,offset,length + 4);
  p.setDataPosition(0);
  final Bundle bundle=new Bundle(p);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}",0.520586182833217
43626,"/** 
 * Flatten a Map into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
private void writeMapInternal(Map<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  Set<Map.Entry<String,Object>> entries=val.entrySet();
  writeInt(entries.size());
  for (  Map.Entry<String,Object> e : entries) {
    writeValue(e.getKey());
    writeValue(e.getValue());
  }
}","/** 
 * Flatten a Map into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeMapInternal(Map<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  Set<Map.Entry<String,Object>> entries=val.entrySet();
  writeInt(entries.size());
  for (  Map.Entry<String,Object> e : entries) {
    writeValue(e.getKey());
    writeValue(e.getValue());
  }
}",0.9910514541387024
43627,"void replaceTextfieldText(int oldStart,int oldEnd,String replace,int newStart,int newEnd){
  HashMap arg=new HashMap();
  arg.put(""String_Node_Str"",new WebViewCore.FocusData(mFocusData));
  arg.put(""String_Node_Str"",replace);
  arg.put(""String_Node_Str"",new Integer(newStart));
  arg.put(""String_Node_Str"",new Integer(newEnd));
  mTextGeneration++;
  mWebViewCore.sendMessage(EventHub.REPLACE_TEXT,oldStart,oldEnd,arg);
}","void replaceTextfieldText(int oldStart,int oldEnd,String replace,int newStart,int newEnd){
  HashMap arg=new HashMap();
  arg.put(""String_Node_Str"",new WebViewCore.FocusData(mFocusData));
  arg.put(""String_Node_Str"",replace);
  arg.put(""String_Node_Str"",Integer.valueOf(newStart));
  arg.put(""String_Node_Str"",Integer.valueOf(newEnd));
  mTextGeneration++;
  mWebViewCore.sendMessage(EventHub.REPLACE_TEXT,oldStart,oldEnd,arg);
}",0.971764705882353
43628,"/** 
 * Build an SQL query string from the given clauses.
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null willreturn all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQLWHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQLGROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause(excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the SQL query string
 */
public static String buildQueryString(boolean distinct,String tables,String[] columns,String where,String groupBy,String having,String orderBy,String limit){
  if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuilder query=new StringBuilder(120);
  query.append(""String_Node_Str"");
  if (distinct) {
    query.append(""String_Node_Str"");
  }
  if (columns != null && columns.length != 0) {
    appendColumns(query,columns);
  }
 else {
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  query.append(tables);
  appendClause(query,""String_Node_Str"",where);
  appendClause(query,""String_Node_Str"",groupBy);
  appendClause(query,""String_Node_Str"",having);
  appendClause(query,""String_Node_Str"",orderBy);
  appendClauseEscapeClause(query,""String_Node_Str"",limit);
  return query.toString();
}","/** 
 * Build an SQL query string from the given clauses.
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null willreturn all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQLWHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQLGROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause(excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the SQL query string
 */
public static String buildQueryString(boolean distinct,String tables,String[] columns,String where,String groupBy,String having,String orderBy,String limit){
  if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!TextUtils.isEmpty(limit) && !sLimitPattern.matcher(limit).matches()) {
    throw new IllegalArgumentException(""String_Node_Str"" + limit);
  }
  StringBuilder query=new StringBuilder(120);
  query.append(""String_Node_Str"");
  if (distinct) {
    query.append(""String_Node_Str"");
  }
  if (columns != null && columns.length != 0) {
    appendColumns(query,columns);
  }
 else {
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  query.append(tables);
  appendClause(query,""String_Node_Str"",where);
  appendClause(query,""String_Node_Str"",groupBy);
  appendClause(query,""String_Node_Str"",having);
  appendClause(query,""String_Node_Str"",orderBy);
  appendClause(query,""String_Node_Str"",limit);
  return query.toString();
}",0.9652342906499676
43629,"/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( Contacts.People.CONTENT_URI.addId(2), projection,    // Which columns to return. null,          // WHERE clause. People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);","/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection,    // Which columns to return. null,          // WHERE clause. null,          // WHERE clause value substitution People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param selectionArgs You may include ?s in selection, which will be replaced bythe values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);",0.934640522875817
43630,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}",0.8603351955307262
43631,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.821673525377229
43632,"public void onKeyguardExitResult(boolean success){
  if (success) {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.7146401985111662
43633,"protected void onHandleIntent(Intent intent){
  if (REMOTE_INTENT_ACTION.equals(intent.getAction())) {
    boolean fromTrustedServer=intent.getBooleanExtra(""String_Node_Str"",false);
    if (fromTrustedServer) {
      String accountName=intent.getStringExtra(""String_Node_Str"");
      String token=intent.getStringExtra(""String_Node_Str"");
      if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(token)) {
        if (Config.LOGD) {
          Log.d(TAG,""String_Node_Str"");
        }
        return;
      }
      if (Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ token);
      }
      handleTickle(this,accountName,token);
    }
 else {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    }
  }
 else   if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    long refreshTime=getSharedPreferences(sSubscribedFeedsPrefs,Context.MODE_WORLD_READABLE).getLong(sRefreshTime,0);
    scheduleRefresh(this,refreshTime);
  }
 else   if (SUBSCRIBED_FEEDS_REFRESH_ACTION.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    handleRefreshAlarm(this);
  }
}","protected void onHandleIntent(Intent intent){
  if (REMOTE_INTENT_ACTION.equals(intent.getAction())) {
    boolean fromTrustedServer=intent.getBooleanExtra(""String_Node_Str"",false);
    if (fromTrustedServer) {
      String accountName=intent.getStringExtra(""String_Node_Str"");
      String token=intent.getStringExtra(Intent.EXTRA_REMOTE_INTENT_TOKEN);
      if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(token)) {
        if (Config.LOGD) {
          Log.d(TAG,""String_Node_Str"");
        }
        return;
      }
      if (Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ token);
      }
      handleTickle(this,accountName,token);
    }
 else {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    }
  }
 else   if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    long refreshTime=getSharedPreferences(sSubscribedFeedsPrefs,Context.MODE_WORLD_READABLE).getLong(sRefreshTime,0);
    scheduleRefresh(this,refreshTime);
  }
 else   if (SUBSCRIBED_FEEDS_REFRESH_ACTION.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    handleRefreshAlarm(this);
  }
}",0.9805786761791518
43634,"private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_CLASS_NOT_FOUND:
      System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
  break;
case IActivityManager.START_DELIVERED_TO_TOP:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}","private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_SWITCHES_CANCELED:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    break;
case IActivityManager.START_DELIVERED_TO_TOP:
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_CLASS_NOT_FOUND:
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_PERMISSION_DENIED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}",0.5306930693069307
43635,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9940025252525252
43636,"private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_CLASS_NOT_FOUND:
      System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
  break;
case IActivityManager.START_DELIVERED_TO_TOP:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}","private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_SWITCHES_CANCELED:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    break;
case IActivityManager.START_DELIVERED_TO_TOP:
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_CLASS_NOT_FOUND:
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_PERMISSION_DENIED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}",0.5306930693069307
43637,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9940025252525252
43638,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}",0.8603351955307262
43639,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.821673525377229
43640,"public void onKeyguardExitResult(boolean success){
  if (success) {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.7146401985111662
43641,"/** 
 * <p> Call mDb.endTransaction(). If successful is true, try to call mDb.setTransactionSuccessful() before calling mDb.endTransaction(). This method MUST be used with   {@link #beginBatch()}. </p>
 * @hide This method must be used with {@link #beginTransaction}
 */
public final void endBatch(boolean successful){
  try {
    if (successful) {
      mDb.setTransactionSuccessful();
    }
  }
  finally {
    mApplyingBatch.set(false);
    getDatabase().endTransaction();
    for (    Uri url : mPendingBatchNotifications.get()) {
      getContext().getContentResolver().notifyChange(url,null,changeRequiresLocalSync(url));
    }
    mDb.endTransaction();
  }
}","/** 
 * <p> Finish batch transaction. If ""successful"" is true, try to call mDb.setTransactionSuccessful() before calling mDb.endTransaction(). This method MUST be used with   {@link #beginBatch()}. </p>
 * @hide This method must be used with {@link #beginTransaction}
 */
public final void endBatch(boolean successful){
  try {
    if (successful) {
      mDb.setTransactionSuccessful();
    }
  }
  finally {
    mApplyingBatch.set(false);
    getDatabase().endTransaction();
    for (    Uri url : mPendingBatchNotifications.get()) {
      getContext().getContentResolver().notifyChange(url,null,changeRequiresLocalSync(url));
    }
  }
}",0.9256704980842912
43642,"/** 
 * <p> Call mOpenHelper.getWritableDatabase() and mDb.beginTransaction().  {@link #endTransaction} MUST be called after calling this method.Those methods should be used like this: </p> <pre class=""prettyprint""> boolean successful = false; if (!beginTransaction()) { return; } try { // Do something related to mDb successful = true; return ret; } finally { endTransaction(successful); } </pre>
 * @hide This method should be used only when {@link #applyBatch} is not enough and must beused with  {@link #endTransaction}. e.g. If returned value has to be used during one transaction, this method might be useful.
 */
public final void beginBatch(){
  if (mApplyingBatch.get() == null) {
    mApplyingBatch.set(false);
    mPendingBatchNotifications.set(new HashSet<Uri>());
  }
  if (applyingBatch()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteDatabase db=getDatabase();
  db.beginTransaction();
  boolean successful=false;
  try {
    mApplyingBatch.set(true);
    successful=true;
  }
  finally {
    if (!successful) {
      db.endTransaction();
    }
  }
}","/** 
 * <p> Start batch transaction.   {@link #endTransaction} MUST be called after calling this method. Those methods should be used like this: </p> <pre class=""prettyprint""> boolean successful = false; beginBatch() try { // Do something related to mDb successful = true; return ret; } finally { endBatch(successful); } </pre>
 * @hide This method should be used only when {@link #applyBatch} is not enough and must beused with  {@link #endBatch}. e.g. If returned value has to be used during one transaction, this method might be useful.
 */
public final void beginBatch(){
  if (mApplyingBatch.get() == null) {
    mApplyingBatch.set(false);
    mPendingBatchNotifications.set(new HashSet<Uri>());
  }
  if (applyingBatch()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteDatabase db=getDatabase();
  db.beginTransaction();
  boolean successful=false;
  try {
    mApplyingBatch.set(true);
    successful=true;
  }
  finally {
    if (!successful) {
      db.endTransaction();
    }
  }
}",0.9182509505703422
43643,"static void addFileType(String extension,int fileType,String mimeType){
  sFileTypeMap.put(extension,new MediaFileType(fileType,mimeType));
  sMimeTypeMap.put(mimeType,new Integer(fileType));
}","static void addFileType(String extension,int fileType,String mimeType){
  sFileTypeMap.put(extension,new MediaFileType(fileType,mimeType));
  sMimeTypeMap.put(mimeType,Integer.valueOf(fileType));
}",0.9692307692307692
43644,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9920395278616524
43645,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9920395278616524
43646,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  if (mRequestedWidth <= 0) {
    myWidth*=mAppScale;
    myHeight*=mAppScale;
  }
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=(int)(getWidth() * mAppScale);
      mLayout.height=(int)(getHeight() * mAppScale);
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      mContentInsets.scale(mAppScaleInverted);
      mVisibleInsets.scale(mAppScaleInverted);
      mWinFrame.scale(mAppScaleInverted);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  if (mRequestedWidth <= 0) {
    myWidth*=mAppScale;
    myHeight*=mAppScale;
  }
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=(int)(mLeft * mAppScale);
      mLayout.y=(int)(mTop * mAppScale);
      mLayout.width=(int)(getWidth() * mAppScale);
      mLayout.height=(int)(getHeight() * mAppScale);
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      mContentInsets.scale(mAppScaleInverted);
      mVisibleInsets.scale(mAppScaleInverted);
      mWinFrame.scale(mAppScaleInverted);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.9894153225806452
43647,"void setLayoutParams(WindowManager.LayoutParams attrs,boolean newView){
synchronized (this) {
    int oldSoftInputMode=mWindowAttributes.softInputMode;
    mWindowAttributes.copyFrom(attrs);
    mWindowAttributes.scale(mAppScale);
    if (newView) {
      mSoftInputMode=attrs.softInputMode;
      requestLayout();
    }
    if ((attrs.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      mWindowAttributes.softInputMode=(mWindowAttributes.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | (oldSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
    }
    mWindowAttributesChanged=true;
    scheduleTraversals();
  }
}","void setLayoutParams(WindowManager.LayoutParams attrs,boolean newView){
synchronized (this) {
    int oldSoftInputMode=mWindowAttributes.softInputMode;
    mWindowAttributes.copyFrom(attrs);
    if (newView) {
      mSoftInputMode=attrs.softInputMode;
      requestLayout();
    }
    if ((attrs.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      mWindowAttributes.softInputMode=(mWindowAttributes.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | (oldSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
    }
    mWindowAttributesChanged=true;
    scheduleTraversals();
  }
}",0.9721059972105998
43648,"private int relayoutWindow(WindowManager.LayoutParams params,int viewVisibility,boolean insetsPending) throws RemoteException {
  int relayoutResult=sWindowSession.relayout(mWindow,params,(int)(mView.mMeasuredWidth * mAppScale),(int)(mView.mMeasuredHeight * mAppScale),viewVisibility,insetsPending,mWinFrame,mPendingContentInsets,mPendingVisibleInsets,mSurface);
  mPendingContentInsets.scale(mAppScaleInverted);
  mPendingVisibleInsets.scale(mAppScaleInverted);
  mWinFrame.scale(mAppScaleInverted);
  return relayoutResult;
}","private int relayoutWindow(WindowManager.LayoutParams params,int viewVisibility,boolean insetsPending) throws RemoteException {
  boolean restore=false;
  if (params != null && mAppScale != 1.0f) {
    restore=true;
    params.scale(mAppScale,mWindowLayoutParamsBackup);
  }
  int relayoutResult=sWindowSession.relayout(mWindow,params,(int)(mView.mMeasuredWidth * mAppScale),(int)(mView.mMeasuredHeight * mAppScale),viewVisibility,insetsPending,mWinFrame,mPendingContentInsets,mPendingVisibleInsets,mSurface);
  if (restore) {
    params.restore(mWindowLayoutParamsBackup);
  }
  mPendingContentInsets.scale(mAppScaleInverted);
  mPendingVisibleInsets.scale(mAppScaleInverted);
  mWinFrame.scale(mAppScaleInverted);
  return relayoutResult;
}",0.830575256107171
43649,"/** 
 * We have one child
 */
public void setView(View view,WindowManager.LayoutParams attrs,View panelParentView){
synchronized (this) {
    if (mView == null) {
      mView=view;
      mAppScale=mView.getContext().getApplicationScale();
      mAppScaleInverted=1.0f / mAppScale;
      mWindowAttributes.copyFrom(attrs);
      mSoftInputMode=attrs.softInputMode;
      mWindowAttributesChanged=true;
      mAttachInfo.mRootView=view;
      if (panelParentView != null) {
        mAttachInfo.mPanelParentWindowToken=panelParentView.getApplicationWindowToken();
      }
      mAdded=true;
      int res;
      requestLayout();
      try {
        res=sWindowSession.add(mWindow,attrs,getHostVisibility(),mAttachInfo.mContentInsets);
      }
 catch (      RemoteException e) {
        mAdded=false;
        mView=null;
        mAttachInfo.mRootView=null;
        unscheduleTraversals();
        throw new RuntimeException(""String_Node_Str"",e);
      }
      mAttachInfo.mContentInsets.scale(mAppScaleInverted);
      mPendingContentInsets.set(mAttachInfo.mContentInsets);
      mPendingVisibleInsets.set(0,0,0,0);
      if (Config.LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"" + mWindow);
      if (res < WindowManagerImpl.ADD_OKAY) {
        mView=null;
        mAttachInfo.mRootView=null;
        mAdded=false;
        unscheduleTraversals();
switch (res) {
case WindowManagerImpl.ADD_BAD_APP_TOKEN:
case WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN:
          throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_NOT_APP_TOKEN:
        throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_APP_EXITING:
      throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_DUPLICATE_ADD:
    throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_STARTING_NOT_NEEDED:
  return;
case WindowManagerImpl.ADD_MULTIPLE_SINGLETON:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_PERMISSION_DENIED:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
}
throw new RuntimeException(""String_Node_Str"" + res);
}
view.assignParent(this);
mAddedTouchMode=(res & WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE) != 0;
mAppVisible=(res & WindowManagerImpl.ADD_FLAG_APP_VISIBLE) != 0;
}
}
}","/** 
 * We have one child
 */
public void setView(View view,WindowManager.LayoutParams attrs,View panelParentView){
synchronized (this) {
    if (mView == null) {
      mView=view;
      mAppScale=mView.getContext().getApplicationScale();
      if (mAppScale != 1.0f) {
        mWindowLayoutParamsBackup=new int[4];
      }
      mAppScaleInverted=1.0f / mAppScale;
      mWindowAttributes.copyFrom(attrs);
      mSoftInputMode=attrs.softInputMode;
      mWindowAttributesChanged=true;
      mAttachInfo.mRootView=view;
      if (panelParentView != null) {
        mAttachInfo.mPanelParentWindowToken=panelParentView.getApplicationWindowToken();
      }
      mAdded=true;
      int res;
      requestLayout();
      try {
        res=sWindowSession.add(mWindow,attrs,getHostVisibility(),mAttachInfo.mContentInsets);
      }
 catch (      RemoteException e) {
        mAdded=false;
        mView=null;
        mAttachInfo.mRootView=null;
        unscheduleTraversals();
        throw new RuntimeException(""String_Node_Str"",e);
      }
      mAttachInfo.mContentInsets.scale(mAppScaleInverted);
      mPendingContentInsets.set(mAttachInfo.mContentInsets);
      mPendingVisibleInsets.set(0,0,0,0);
      if (Config.LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"" + mWindow);
      if (res < WindowManagerImpl.ADD_OKAY) {
        mView=null;
        mAttachInfo.mRootView=null;
        mAdded=false;
        unscheduleTraversals();
switch (res) {
case WindowManagerImpl.ADD_BAD_APP_TOKEN:
case WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN:
          throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_NOT_APP_TOKEN:
        throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_APP_EXITING:
      throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_DUPLICATE_ADD:
    throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_STARTING_NOT_NEEDED:
  return;
case WindowManagerImpl.ADD_MULTIPLE_SINGLETON:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_PERMISSION_DENIED:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
}
throw new RuntimeException(""String_Node_Str"" + res);
}
view.assignParent(this);
mAddedTouchMode=(res & WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE) != 0;
mAppVisible=(res & WindowManagerImpl.ADD_FLAG_APP_VISIBLE) != 0;
}
}
}",0.983732057416268
43650,"void scale(float scale){
  if (scale != 1.0f) {
    x*=scale;
    y*=scale;
    if (width > 0) {
      width*=scale;
    }
    if (height > 0) {
      height*=scale;
    }
  }
}","/** 
 * Scale the layout params' coordinates and size. Returns the original info as a backup so that the caller can restore the layout params;
 */
void scale(float scale,int[] backup){
  if (scale != 1.0f) {
    backup[0]=x;
    backup[1]=y;
    x*=scale;
    y*=scale;
    if (width > 0) {
      backup[2]=width;
      width*=scale;
    }
    if (height > 0) {
      backup[3]=height;
      height*=scale;
    }
  }
}",0.5949579831932773
43651,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.991995583770356
43652,"public void setSyncProviderAutomatically(String account,String providerName,boolean sync){
synchronized (mAuthorities) {
    if (account != null) {
      AuthorityInfo authority=getAuthorityLocked(account,providerName,""String_Node_Str"");
      if (authority != null) {
        authority.enabled=sync;
      }
    }
 else {
      int i=mAuthorities.size();
      while (i > 0) {
        i--;
        AuthorityInfo authority=mAuthorities.get(i);
        if (authority.account.equals(account) && authority.authority.equals(providerName)) {
          authority.enabled=sync;
        }
      }
    }
    writeAccountInfoLocked();
  }
  reportChange(CHANGE_SETTINGS);
}","public void setSyncProviderAutomatically(String account,String providerName,boolean sync){
synchronized (mAuthorities) {
    if (account != null) {
      AuthorityInfo authority=getAuthorityLocked(account,providerName,""String_Node_Str"");
      if (authority != null) {
        authority.enabled=sync;
      }
    }
 else {
      int i=mAuthorities.size();
      while (i > 0) {
        i--;
        AuthorityInfo authority=mAuthorities.get(i);
        if (authority.authority.equals(providerName)) {
          authority.enabled=sync;
        }
      }
    }
    writeAccountInfoLocked();
  }
  reportChange(CHANGE_SETTINGS);
}",0.9712955779674166
43653,"private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,PackageManager.GET_SHARED_LIBRARY_FILES | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}","private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}",0.9736034376918354
43654,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9929955638571096
43655,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,0);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,PackageManager.GET_SHARED_LIBRARY_FILES);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9676002196595276
43656,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9903279075253596
43657,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}",0.9681274900398408
43658,"final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}","final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}",0.9750759878419452
43659,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",PackageManager.GET_SHARED_LIBRARY_FILES);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9825602968460112
43660,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.7618680046314165
43661,"public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),0);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(PackageManager.GET_SHARED_LIBRARY_FILES);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}","public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}",0.9876084262701365
43662,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9907636855147556
43663,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),PackageManager.GET_SHARED_LIBRARY_FILES);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),STOCK_PM_FLAGS);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9966792118662828
43664,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),0);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}",0.9954037076758082
43665,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,PackageManager.GET_SHARED_LIBRARY_FILES);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.992707826932426
43666,"void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9680456490727531
43667,"private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,PackageManager.GET_SHARED_LIBRARY_FILES | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}","private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}",0.9736034376918354
43668,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9929955638571096
43669,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,0);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,PackageManager.GET_SHARED_LIBRARY_FILES);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9676002196595276
43670,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9903279075253596
43671,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}",0.9681274900398408
43672,"final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}","final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}",0.9750759878419452
43673,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",PackageManager.GET_SHARED_LIBRARY_FILES);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9825602968460112
43674,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.7618680046314165
43675,"public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),0);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(PackageManager.GET_SHARED_LIBRARY_FILES);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}","public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}",0.9876084262701365
43676,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9907636855147556
43677,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),PackageManager.GET_SHARED_LIBRARY_FILES);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),STOCK_PM_FLAGS);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9966792118662828
43678,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),0);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}",0.9954037076758082
43679,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,PackageManager.GET_SHARED_LIBRARY_FILES);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.992707826932426
43680,"void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9680456490727531
43681,"@Suppress public void testStartUpTime() throws Exception {
  createDB();
  audioPlaybackStartupTime(MediaNames.MP3FILES);
  audioPlaybackStartupTime(MediaNames.AACFILES);
}","@Suppress public void testStartUpTime() throws Exception {
  createDB();
  audioPlaybackStartupTime(MediaNames.MP3FILES);
  audioPlaybackStartupTime(MediaNames.AACFILES);
  if (mDB.isOpen()) {
    mDB.close();
  }
}",0.8888888888888888
43682,"public void createDB(){
  mDB=SQLiteDatabase.openOrCreateDatabase(""String_Node_Str"",null);
  mDB.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void createDB(){
  mDB=SQLiteDatabase.openOrCreateDatabase(""String_Node_Str"",null);
  mDB.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  mDB.execSQL(""String_Node_Str"");
}",0.9291666666666668
43683,"@SuppressWarnings({""String_Node_Str""}) protected void performFiltering(CharSequence text,int keyCode){
  mFilter.filter(text,this);
}","/** 
 * <p>Starts filtering the content of the drop down list. The filtering pattern is the content of the edit box. Subclasses should override this method to filter with a different pattern, for instance a substring of <code>text</code>.</p>
 * @param text the filtering pattern
 * @param keyCode the last character inserted in the edit box; beware thatthis will be null when text is being added through a soft input method.
 */
@SuppressWarnings({""String_Node_Str""}) protected void performFiltering(CharSequence text,int keyCode){
  mFilter.filter(text,this);
}",0.382183908045977
43684,"@Override public void handleMessage(Message msg){
  try {
    if (msg.what == MESSAGE_LOCATION_CHANGED) {
synchronized (mLock) {
        Location location=(Location)msg.obj;
        if (mCollector != null && LocationManager.GPS_PROVIDER.equals(location.getProvider())) {
          try {
            mCollector.updateLocation(location);
          }
 catch (          RemoteException e) {
            Log.w(TAG,""String_Node_Str"");
          }
        }
        String provider=location.getProvider();
        if (!isAllowedBySettingsLocked(provider)) {
          return;
        }
        if (mWakeLockAcquireTime != 0) {
          handleLocationChangedLocked(location);
        }
        if ((mWakeLockAcquireTime != 0) && (SystemClock.elapsedRealtime() - mWakeLockAcquireTime > MAX_TIME_FOR_WAKE_LOCK)) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageAtFrontOfQueue(m);
        }
 else         if (mWakeLockAcquireTime != 0 && mWakeLockGpsReceived && mWakeLockNetworkReceived) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          mWakeLockAcquireTime=0;
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageDelayed(m,TIME_AFTER_WAKE_LOCK);
        }
      }
    }
 else     if (msg.what == MESSAGE_RELEASE_WAKE_LOCK) {
      log(""String_Node_Str"");
synchronized (mLock) {
        updateWakelockStatusLocked();
        releaseWakeLockLocked();
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Override public void handleMessage(Message msg){
  try {
    if (msg.what == MESSAGE_LOCATION_CHANGED) {
synchronized (mLock) {
        Location location=(Location)msg.obj;
        if (mCollector != null && LocationManager.GPS_PROVIDER.equals(location.getProvider())) {
          try {
            mCollector.updateLocation(location);
          }
 catch (          RemoteException e) {
            Log.w(TAG,""String_Node_Str"");
          }
        }
        String provider=location.getProvider();
        if (!isAllowedBySettingsLocked(provider)) {
          return;
        }
        handleLocationChangedLocked(location);
        if ((mWakeLockAcquireTime != 0) && (SystemClock.elapsedRealtime() - mWakeLockAcquireTime > MAX_TIME_FOR_WAKE_LOCK)) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageAtFrontOfQueue(m);
        }
 else         if (mWakeLockAcquireTime != 0 && mWakeLockGpsReceived && mWakeLockNetworkReceived) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          mWakeLockAcquireTime=0;
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageDelayed(m,TIME_AFTER_WAKE_LOCK);
        }
      }
    }
 else     if (msg.what == MESSAGE_RELEASE_WAKE_LOCK) {
      log(""String_Node_Str"");
synchronized (mLock) {
        updateWakelockStatusLocked();
        releaseWakeLockLocked();
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9835658914728682
43685,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
43686,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
43687,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
43688,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
43689,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
43690,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
43691,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
43692,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
43693,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
43694,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
43695,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
43696,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
43697,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
43698,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
43699,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
43700,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
43701,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
43702,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
43703,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
43704,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
43705,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
43706,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
43707,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
43708,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
43709,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
43710,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
43711,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
43712,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
43713,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
43714,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
43715,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
43716,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
43717,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
43718,"@Override protected void finalize() throws Throwable {
  clear();
}","@Override protected void finalize() throws Throwable {
  release();
}",0.9558823529411764
43719,"public void dump(boolean timeout,String webkitData){
  if (mResultFile == null || mResultFile.length() == 0) {
    finished();
    return;
  }
  try {
    File parentDir=new File(mResultFile).getParentFile();
    if (!parentDir.exists()) {
      parentDir.mkdirs();
    }
    FileOutputStream os=new FileOutputStream(mResultFile);
    if (timeout) {
      Log.w(""String_Node_Str"",mResultFile);
      os.write(TIMEOUT_STR.getBytes());
      os.write('\n');
    }
    if (mDumpTitleChanges)     os.write(mTitleChanges.toString().getBytes());
    if (mDialogStrings != null)     os.write(mDialogStrings.toString().getBytes());
    mDialogStrings=null;
    os.write(webkitData.getBytes());
    os.flush();
    os.close();
  }
 catch (  IOException ex) {
    Log.e(LOGTAG,""String_Node_Str"" + mResultFile + ""String_Node_Str""+ ex.getMessage());
  }
  finished();
}","public void dump(boolean timeout,String webkitData){
  if (mResultFile == null || mResultFile.length() == 0) {
    finished();
    return;
  }
  try {
    File parentDir=new File(mResultFile).getParentFile();
    if (!parentDir.exists()) {
      parentDir.mkdirs();
    }
    FileOutputStream os=new FileOutputStream(mResultFile);
    if (timeout) {
      Log.w(""String_Node_Str"",mResultFile);
      os.write(TIMEOUT_STR.getBytes());
      os.write('\n');
    }
    if (mDumpTitleChanges)     os.write(mTitleChanges.toString().getBytes());
    if (mDialogStrings != null)     os.write(mDialogStrings.toString().getBytes());
    mDialogStrings=null;
    if (webkitData != null)     os.write(webkitData.getBytes());
    os.flush();
    os.close();
  }
 catch (  IOException ex) {
    Log.e(LOGTAG,""String_Node_Str"" + mResultFile + ""String_Node_Str""+ ex.getMessage());
  }
  finished();
}",0.983926521239954
43720,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
43721,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
43722,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
43723,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
43724,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
43725,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
43726,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
43727,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
43728,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
43729,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
43730,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
43731,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
43732,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
43733,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
43734,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
43735,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
43736,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
43737,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
43738,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
43739,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
43740,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
43741,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
43742,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
43743,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
43744,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
43745,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
43746,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
43747,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
43748,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
43749,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
43750,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
43751,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
43752,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
43753,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
43754,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
43755,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
43756,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
43757,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
43758,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
43759,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
43760,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
43761,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
43762,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
43763,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
43764,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
43765,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
43766,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
43767,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
43768,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
43769,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
43770,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
43771,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
43772,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
43773,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
43774,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
43775,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
43776,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
43777,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
43778,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
43779,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
43780,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
43781,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
43782,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
43783,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
43784,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
43785,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
43786,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
43787,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
43788,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
43789,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
43790,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
43791,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
43792,"@Override public boolean requestChildRectangleOnScreen(View child,Rect rect,boolean immediate){
  rect.offset(child.getLeft() - child.getScrollX(),child.getTop() - child.getScrollY());
  int height=getHeight() - getHorizontalScrollbarHeight();
  int screenTop=mScrollY;
  int screenBottom=screenTop + height;
  int scrollYDelta=0;
  if (rect.bottom > screenBottom && rect.top > screenTop) {
    if (rect.height() > height) {
      scrollYDelta+=(rect.top - screenTop);
    }
 else {
      scrollYDelta+=(rect.bottom - screenBottom);
    }
  }
 else   if (rect.top < screenTop) {
    scrollYDelta-=(screenTop - rect.top);
  }
  int width=getWidth() - getVerticalScrollbarWidth();
  int screenLeft=mScrollX;
  int screenRight=screenLeft + width;
  int scrollXDelta=0;
  if (rect.right > screenRight && rect.left > screenLeft) {
    if (rect.width() > width) {
      scrollXDelta+=(rect.left - screenLeft);
    }
 else {
      scrollXDelta+=(rect.right - screenRight);
    }
  }
 else   if (rect.left < screenLeft) {
    scrollXDelta-=(screenLeft - rect.left);
  }
  if ((scrollYDelta | scrollXDelta) != 0) {
    return pinScrollBy(scrollXDelta,scrollYDelta,!immediate,0);
  }
  return false;
}","@Override public boolean requestChildRectangleOnScreen(View child,Rect rect,boolean immediate){
  rect.offset(child.getLeft() - child.getScrollX(),child.getTop() - child.getScrollY());
  int height=getHeight() - getHorizontalScrollbarHeight();
  int screenTop=mScrollY;
  int screenBottom=screenTop + height;
  int scrollYDelta=0;
  if (rect.bottom > screenBottom) {
    int oneThirdOfScreenHeight=height / 3;
    if (rect.height() > 2 * oneThirdOfScreenHeight) {
      scrollYDelta=rect.top - screenTop;
    }
 else {
      scrollYDelta=rect.top - (screenTop + oneThirdOfScreenHeight);
    }
  }
 else   if (rect.top < screenTop) {
    scrollYDelta=rect.top - screenTop;
  }
  int width=getWidth() - getVerticalScrollbarWidth();
  int screenLeft=mScrollX;
  int screenRight=screenLeft + width;
  int scrollXDelta=0;
  if (rect.right > screenRight && rect.left > screenLeft) {
    if (rect.width() > width) {
      scrollXDelta+=(rect.left - screenLeft);
    }
 else {
      scrollXDelta+=(rect.right - screenRight);
    }
  }
 else   if (rect.left < screenLeft) {
    scrollXDelta-=(screenLeft - rect.left);
  }
  if ((scrollYDelta | scrollXDelta) != 0) {
    return pinScrollBy(scrollXDelta,scrollYDelta,!immediate,0);
  }
  return false;
}",0.3904644471845458
43793,"public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=mSensorRotation;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    float delta=zyangle - PIVOT;
    if (((orientation >= 0) && (orientation <= LP_UPPER)) || (orientation >= PL_LOWER)) {
      float threshold;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
      }
      rotation=(orientation >= PL_LOWER && orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
    }
  }
  if (rotation != mSensorRotation) {
    mSensorRotation=rotation;
    onOrientationChanged(mSensorRotation);
  }
}","public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=-1;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
      float threshold;
      float delta=zyangle - PIVOT;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
        rotation=(orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
        rotation=(orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
      }
    }
 else     if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
      rotation=Surface.ROTATION_90;
    }
 else     if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
      rotation=Surface.ROTATION_0;
    }
    if ((rotation != -1) && (rotation != mSensorRotation)) {
      mSensorRotation=rotation;
      onOrientationChanged(mSensorRotation);
    }
  }
}",0.5112448527082674
43794,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,0);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9712007089056268
43795,"public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation,animFlags);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.9858520900321543
43796,"Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,1);
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}","Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags & (~Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE));
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}",0.972972972972973
43797,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
43798,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
43799,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
43800,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
43801,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
43802,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
43803,"void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  update();
}","void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(""String_Node_Str""),false,this);
  update();
}",0.9011689691817216
43804,"void updateRotation(){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.9573283858998144
43805,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation();
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}",0.9951690821256038
43806,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.9941176470588236
43807,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation();
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9992181391712276
43808,"public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp()) {
    return mSensorRotation >= 0 ? mSensorRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}","public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp(orientation)) {
    int curRotation=mOrientationListener.getCurrentRotation();
    return curRotation >= 0 ? curRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}",0.9041353383458648
43809,"void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mSensorRotation=-1;
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mSensorRotation=-1;
    mOrientationSensorEnabled=false;
  }
}","void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mOrientationSensorEnabled=false;
  }
}",0.933774834437086
43810,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation();
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}",0.9483509645301804
43811,"boolean useSensorForOrientationLp(){
  if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}","boolean useSensorForOrientationLp(int appOrientation){
  if (appOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (appOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || appOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}",0.9302325581395348
43812,"@Override public void onOrientationChanged(int rotation){
  if (rotation != mSensorRotation) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mSensorRotation);
    mSensorRotation=rotation;
    try {
      mWindowManager.setRotation(rotation,false);
    }
 catch (    RemoteException e) {
    }
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.7458866544789763
43813,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
43814,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
43815,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
43816,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
43817,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
43818,"void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,mFancyRotationAnimation | animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.95578231292517
43819,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.824
43820,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.934065934065934
43821,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9667170953101362
43822,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}",0.9894490035169988
43823,"@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.945945945945946
43824,"/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  setEnabled(!disableDependent);
}","/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  if (mDependencyMet == disableDependent) {
    mDependencyMet=!disableDependent;
    notifyDependencyChange(shouldDisableDependents());
    notifyChanged();
  }
}",0.7933425797503467
43825,"/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled;
}","/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled && mDependencyMet;
}",0.953846153846154
43826,"/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  setEnabled(!disableDependent);
}","/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  if (mDependencyMet == disableDependent) {
    mDependencyMet=!disableDependent;
    notifyDependencyChange(shouldDisableDependents());
    notifyChanged();
  }
}",0.7933425797503467
43827,"/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled;
}","/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled && mDependencyMet;
}",0.953846153846154
43828,"void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,mFancyRotationAnimation | animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.95578231292517
43829,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.824
43830,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.934065934065934
43831,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9667170953101362
43832,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}",0.9894490035169988
43833,"@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.945945945945946
43834,"public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=mSensorRotation;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    float delta=zyangle - PIVOT;
    if (((orientation >= 0) && (orientation <= LP_UPPER)) || (orientation >= PL_LOWER)) {
      float threshold;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
      }
      rotation=(orientation >= PL_LOWER && orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
    }
  }
  if (rotation != mSensorRotation) {
    mSensorRotation=rotation;
    onOrientationChanged(mSensorRotation);
  }
}","public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=-1;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
      float threshold;
      float delta=zyangle - PIVOT;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
        rotation=(orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
        rotation=(orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
      }
    }
 else     if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
      rotation=Surface.ROTATION_90;
    }
 else     if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
      rotation=Surface.ROTATION_0;
    }
    if ((rotation != -1) && (rotation != mSensorRotation)) {
      mSensorRotation=rotation;
      onOrientationChanged(mSensorRotation);
    }
  }
}",0.5112448527082674
43835,"void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  update();
}","void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(""String_Node_Str""),false,this);
  update();
}",0.9011689691817216
43836,"void updateRotation(){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.9573283858998144
43837,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation();
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}",0.9951690821256038
43838,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.9941176470588236
43839,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation();
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9992181391712276
43840,"public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp()) {
    return mSensorRotation >= 0 ? mSensorRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}","public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp(orientation)) {
    int curRotation=mOrientationListener.getCurrentRotation();
    return curRotation >= 0 ? curRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}",0.9041353383458648
43841,"void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mSensorRotation=-1;
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mSensorRotation=-1;
    mOrientationSensorEnabled=false;
  }
}","void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mOrientationSensorEnabled=false;
  }
}",0.933774834437086
43842,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation();
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}",0.9483509645301804
43843,"boolean useSensorForOrientationLp(){
  if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}","boolean useSensorForOrientationLp(int appOrientation){
  if (appOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (appOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || appOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}",0.9302325581395348
43844,"@Override public void onOrientationChanged(int rotation){
  if (rotation != mSensorRotation) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mSensorRotation);
    mSensorRotation=rotation;
    try {
      mWindowManager.setRotation(rotation,false);
    }
 catch (    RemoteException e) {
    }
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.7458866544789763
43845,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
43846,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
43847,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
43848,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
43849,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,0);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9712007089056268
43850,"public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation,animFlags);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.9858520900321543
43851,"Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,1);
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}","Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags & (~Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE));
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}",0.972972972972973
43852,"/** 
 * Construct a SELECT statement suitable for use in a group of SELECT statements that will be joined through UNION operators in buildUnionQuery.
 * @param projectionIn A list of which columns to return. Passingnull will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,formatted as an SQL WHERE clause (excluding the WHERE itself).  Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, whichwill be replaced by the values from selectionArgs, in order that they appear in the selection.  The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formattedas an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include inthe cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself).  Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQLORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
public String buildQuery(String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){
  String[] projection=computeProjection(projectionIn);
  if (mWhereClause.length() > 0) {
    mWhereClause.append(')');
  }
  if (selection != null && selection.length() > 0) {
    if (mWhereClause.length() > 0) {
      mWhereClause.append(""String_Node_Str"");
    }
    mWhereClause.append('(');
    mWhereClause.append(selection);
    mWhereClause.append(')');
  }
  return buildQueryString(mDistinct,mTables,projection,mWhereClause.toString(),groupBy,having,sortOrder,limit);
}","/** 
 * Construct a SELECT statement suitable for use in a group of SELECT statements that will be joined through UNION operators in buildUnionQuery.
 * @param projectionIn A list of which columns to return. Passingnull will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,formatted as an SQL WHERE clause (excluding the WHERE itself).  Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, whichwill be replaced by the values from selectionArgs, in order that they appear in the selection.  The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formattedas an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include inthe cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself).  Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQLORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
public String buildQuery(String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){
  String[] projection=computeProjection(projectionIn);
  StringBuilder where=new StringBuilder();
  if (mWhereClause.length() > 0) {
    where.append(mWhereClause.toString());
    where.append(')');
  }
  if (selection != null && selection.length() > 0) {
    if (mWhereClause.length() > 0) {
      where.append(""String_Node_Str"");
    }
    where.append('(');
    where.append(selection);
    where.append(')');
  }
  return buildQueryString(mDistinct,mTables,projection,where.toString(),groupBy,having,sortOrder,limit);
}",0.964516129032258
43853,"public void dispatchKey(KeyEvent event){
  if (mSession != null && mSurface != null) {
    try {
      mSession.finishKey(mWindow);
    }
 catch (    RemoteException ex) {
    }
  }
}","public void dispatchKey(KeyEvent event){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (surfaceView.mSession != null && surfaceView.mSurface != null) {
      try {
        surfaceView.mSession.finishKey(surfaceView.mWindow);
      }
 catch (      RemoteException ex) {
      }
    }
  }
}",0.6469428007889546
43854,"public void dispatchGetNewSurface(){
  Message msg=mHandler.obtainMessage(GET_NEW_SURFACE_MSG);
  mHandler.sendMessage(msg);
}","public void dispatchGetNewSurface(){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    Message msg=surfaceView.mHandler.obtainMessage(GET_NEW_SURFACE_MSG);
    surfaceView.mHandler.sendMessage(msg);
  }
}",0.6406685236768802
43855,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw){
  if (localLOGV)   Log.v(""String_Node_Str"",SurfaceView.this + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
    if (mCurWidth != w || mCurHeight != h) {
      mCurWidth=w;
      mCurHeight=h;
    }
    if (reportDraw) {
      try {
        mSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}",0.8479020979020979
43856,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow();
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.9994579945799458
43857,"/** 
 * {@inheritDoc} 
 */
public void systemReady(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    Log.i(TAG,""String_Node_Str"" + menuState);
    if (menuState > 0) {
      ActivityManagerNative.getDefault().enterSafeMode();
    }
 else {
      mKeyguardMediator.onSystemReady();
      android.os.SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * {@inheritDoc} 
 */
public void systemReady(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    Log.i(TAG,""String_Node_Str"" + menuState);
    if (menuState > 0) {
      ActivityManagerNative.getDefault().enterSafeMode();
    }
    mKeyguardMediator.onSystemReady();
    android.os.SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}",0.9791666666666666
43858,"public static final CharSequence getDisplayLabel(Context context,int type,CharSequence label){
  CharSequence display=""String_Node_Str"";
  if (type != TYPE_CUSTOM) {
    CharSequence[] labels=context.getResources().getTextArray(com.android.internal.R.array.organizationTypes);
    try {
      display=labels[type - 1];
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      display=labels[People.Phones.TYPE_HOME - 1];
    }
  }
 else {
    if (!TextUtils.isEmpty(label)) {
      display=label;
    }
  }
  return display;
}","public static final CharSequence getDisplayLabel(Context context,int type,CharSequence label){
  CharSequence display=""String_Node_Str"";
  if (type != TYPE_CUSTOM) {
    CharSequence[] labels=context.getResources().getTextArray(com.android.internal.R.array.organizationTypes);
    try {
      display=labels[type - 1];
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      display=labels[Organizations.TYPE_WORK - 1];
    }
  }
 else {
    if (!TextUtils.isEmpty(label)) {
      display=label;
    }
  }
  return display;
}",0.9716446124763704
43859,"private void addSensorInstance(ISensor sensor,Path path){
  try {
    ISensor sensorInstance=sensor.create(path);
    if (sensor != null) {
      ISensor oldSensor=sensorInstances.forcePut(path,sensorInstance);
      if (oldSensor != null) {
        removeSensorInstance(oldSensor);
      }
      HashMap<String,Object> properties=new HashMap<>();
      properties.put(SENSOR_DATA,sensorInstance);
      properties.put(SENSOR_SOURCE,path);
      properties.put(SENSOR_AVAILABLE,true);
      postSensorEvent(properties);
      log.debug(""String_Node_Str"" + sensorInstance + ""String_Node_Str""+ path);
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + path,e);
  }
}","private void addSensorInstance(ISensor sensor,Path path){
  try {
    ISensor sensorInstance=sensor.create(path);
    if (sensorInstance != null) {
      ISensor oldSensor=sensorInstances.forcePut(path,sensorInstance);
      if (oldSensor != null) {
        removeSensorInstance(oldSensor);
      }
      HashMap<String,Object> properties=new HashMap<>();
      properties.put(SENSOR_DATA,sensorInstance);
      properties.put(SENSOR_SOURCE,path);
      properties.put(SENSOR_AVAILABLE,true);
      postSensorEvent(properties);
      log.debug(""String_Node_Str"" + sensorInstance + ""String_Node_Str""+ path);
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + path,e);
  }
}",0.994186046511628
43860,"private boolean checkPath(Path path) throws IOException {
  if (path == null)   return false;
  if (Files.isDirectory(path)) {
    try (DirectoryStream<Path> in=Files.newDirectoryStream(path)){
      for (      Path file : in) {
        if (file.getFileName().toString().endsWith(""String_Node_Str"")) {
          return true;
        }
      }
    }
   }
  return path.getFileName().toString().endsWith(""String_Node_Str"");
}","private boolean checkPath(Path path) throws IOException {
  if (path == null)   return false;
  if (Files.isDirectory(path)) {
    try (DirectoryStream<Path> in=Files.newDirectoryStream(path)){
      for (      Path file : in) {
        if (file.getFileName().toString().endsWith(""String_Node_Str"")) {
          return true;
        }
      }
    }
   }
  return path.getFileName() == null ? false : path.getFileName().toString().endsWith(""String_Node_Str"");
}",0.958097395243488
43861,"@Override public ISensor create(Object source) throws IOException {
  AccelerationSensor sensor=null;
  Path path=pathFromSource(source);
  if (!checkPath(path))   return null;
  sensor=new AccelerationSensor();
  sensor.sourceDirectory=(Path)source;
  sensor.instance=true;
  return sensor;
}","@Override public ISensor create(Object source) throws IOException {
  AccelerationSensor sensor=null;
  Path path=pathFromSource(source);
  if (!checkPath(path))   return sensor;
  sensor=new AccelerationSensor();
  sensor.sourceDirectory=(Path)source;
  sensor.instance=true;
  return sensor;
}",0.9829931972789115
43862,"/** 
 * <p> Generates a filename with the given parameters like this </p> <p> <li>RAW: [from]_to_[to].[sensor.id].[sensor.filePrefix]</li> <li>TRAIN: [from]_to_[to].arff</li> <li>RESULT: [from]_to_[to].arff</li> </p> <p> For date formatting   {@link DateFormat.MEDIUM} is used.</p>
 * @param s Sensor
 * @param type - RAW, TRAIN or RESULT
 * @param from - Data recording start
 * @param to - Data recording end
 * @return
 */
private String generateFilename(Sensor s,String type,Date from,Date to){
  StringBuilder sb=new StringBuilder(32);
  sb.append(dateF.format(from)).append(""String_Node_Str"").append(dateF.format(to)).append(""String_Node_Str"");
switch (type) {
case RAW:
    return sb.append(s.getId()).append(""String_Node_Str"").append(s.getFilePrefix()).toString();
case TRAIN:
  return sb.append(""String_Node_Str"").toString();
case RESULT:
return sb.append(""String_Node_Str"").toString();
default :
return sb.append(""String_Node_Str"").toString();
}
}","/** 
 * <p> Generates a filename with the given parameters like this </p> <p> <li>RAW: [from]_to_[to].[sensor.id].[sensor.filePrefix]</li> <li>TRAIN: [from]_to_[to].arff</li> <li>RESULT: [from]_to_[to].arff</li> </p> <p> For date formatting   {@link DateFormat.MEDIUM} is used.</p>
 * @param s - Sensor
 * @param type - RAW, TRAIN or RESULT
 * @param from - Data recording start
 * @param to - Data recording end
 * @return
 */
private String generateFilename(Sensor s,String type,Date from,Date to){
  StringBuilder sb=new StringBuilder(32);
  sb.append(dateF.format(from)).append(""String_Node_Str"").append(dateF.format(to)).append(""String_Node_Str"");
switch (type) {
case RAW:
    return sb.append(s.getId()).append(""String_Node_Str"").append(s.getFilePrefix()).toString();
case TRAIN:
  return sb.append(""String_Node_Str"").toString();
case RESULT:
return sb.append(""String_Node_Str"").toString();
default :
return sb.append(""String_Node_Str"").toString();
}
}",0.9989561586638832
43863,"/** 
 * @param patient
 * @param sensor
 * @param type
 * @param inputURL
 */
@Override public DataStoreOutput store(Patient patient,ISensor sensor,String type,URI inputURL) throws IOException {
  IConverter converter=sensorManagerService.createConverter(sensor);
  if (converter == null)   return null;
  Sensor entity=sensorManagerService.loadSensorEntity(sensor);
  Interval interval=converter.getInterval();
  try (DataStoreOutput output=store(patient,entity,type,interval.getStart().toDate(),interval.getEnd().toDate());OutputStream os=output.outputStream;InputStream in=new FileInputStream(new File(inputURL))){
    byte[] buffer=new byte[4096];
    int bytesRead=0;
    while ((bytesRead=in.read(buffer)) != -1) {
      os.write(buffer,0,bytesRead);
    }
    return output;
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
    throw e;
  }
}","/** 
 * @param patient
 * @param sensor
 * @param type
 * @param inputURI
 */
@Override public DataStoreOutput store(Patient patient,ISensor sensor,String type,URI inputURI) throws IOException {
  InputStream inputStream=sensorManagerService.createInput(sensor,inputURI);
  IConverter converter=sensor.newConverter(inputStream);
  if (converter == null)   return null;
  Sensor entity=sensorManagerService.loadSensorEntity(sensor);
  Interval interval=converter.getInterval();
  try (DataStoreOutput output=store(patient,entity,type,interval.getStart().toDate(),interval.getEnd().toDate());OutputStream os=output.outputStream){
    Files.copy(Paths.get(inputURI),os);
    return output;
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
    throw e;
  }
}",0.7919463087248322
43864,"@Override protected Instances determineOutputFormat(Instances inputFormat) throws Exception {
  determineInputDimensions(inputFormat);
  Instances result=new Instances(inputFormat,0);
  if (dimReduction && outDimensions > 0) {
    if (inDimensions > outDimensions) {
      int toDelete=inDimensions - outDimensions;
      for (int i=inputFormat.numAttributes() - 1; toDelete > 0 && i >= 0; i--) {
        if (i != inputFormat.classIndex() && inputFormat.attribute(i).type() == Attribute.NUMERIC) {
          if (attributeNamePrefix == null || inputFormat.attribute(i).name().startsWith(attributeNamePrefix)) {
            result.deleteAttributeAt(i);
            toDelete--;
          }
        }
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + outDimensions + ""String_Node_Str""+ inDimensions+ ""String_Node_Str"");
    }
  }
  int fvc=1;
  for (int i=0; i < result.numAttributes(); i++) {
    if (attributeNamePrefix != null && result.attribute(i).name().startsWith(attributeNamePrefix)) {
      result.renameAttribute(i,attributeNamePrefix + fvc);
      fvc++;
    }
  }
  output=result;
  return output;
}","@Override protected Instances determineOutputFormat(Instances inputFormat) throws Exception {
  if (!resetOutputFormat && output != null)   return output;
  determineInputDimensions(inputFormat);
  Instances result=new Instances(inputFormat,0);
  if (dimReduction && outDimensions > 0) {
    if (inDimensions > outDimensions) {
      int toDelete=inDimensions - outDimensions;
      for (int i=inputFormat.numAttributes() - 1; toDelete > 0 && i >= 0; i--) {
        if (i != inputFormat.classIndex() && inputFormat.attribute(i).type() == Attribute.NUMERIC) {
          if (attributeNamePrefix == null || inputFormat.attribute(i).name().startsWith(attributeNamePrefix)) {
            result.deleteAttributeAt(i);
            toDelete--;
          }
        }
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + outDimensions + ""String_Node_Str""+ inDimensions+ ""String_Node_Str"");
    }
  }
  int fvc=1;
  for (int i=0; i < result.numAttributes(); i++) {
    if (attributeNamePrefix != null && result.attribute(i).name().startsWith(attributeNamePrefix)) {
      result.renameAttribute(i,attributeNamePrefix + fvc);
      fvc++;
    }
  }
  output=result;
  return output;
}",0.9739650021340164
43865,"private Instance buildOutputInstance(Vector<Instance> segment,Instances output){
  Instance result=new DenseInstance(numOuputAttributes);
  result.setDataset(output);
  Instance first=segment.firstElement();
  Instance last=segment.lastElement();
  for (int i=0; i < first.numAttributes(); i++) {
    if (first.attribute(i).type() == Attribute.DATE) {
      result.setValue(0,first.value(i));
    }
  }
  for (int i=0; i < last.numAttributes(); i++) {
    if (last.attribute(i).type() == Attribute.DATE) {
      result.setValue(1,last.value(i));
    }
  }
  Instances segmentData=new Instances(first.dataset(),0);
  for (  Instance s : segment) {
    segmentData.add(s);
  }
  segmentData.setClassIndex(result.attribute(REL_ATT_INDEX).relation().classIndex());
  result.setValue(2,result.attribute(REL_ATT_INDEX).addRelation(segmentData));
  if (sourceAttIndex > 0) {
    result.setValue(output.attribute(ResultsUtil.ATTRIBUTE_SOURCE()),first.stringValue(sourceAttIndex));
  }
  if (first.classIndex() >= 0) {
    result.setValue(result.classIndex(),first.stringValue(first.classIndex()));
  }
  return result;
}","private Instance buildOutputInstance(Vector<Instance> segment,Instances output){
  Instance result=new DenseInstance(numOuputAttributes);
  result.setDataset(output);
  Instance first=segment.firstElement();
  Instance last=segment.lastElement();
  for (int i=0; i < first.numAttributes(); i++) {
    if (first.attribute(i).type() == Attribute.DATE) {
      result.setValue(0,first.value(i));
    }
  }
  for (int i=0; i < last.numAttributes(); i++) {
    if (last.attribute(i).type() == Attribute.DATE) {
      result.setValue(1,last.value(i));
    }
  }
  Instances segmentData=new Instances(first.dataset(),0);
  for (  Instance s : segment) {
    segmentData.add(s);
  }
  segmentData.setClassIndex(result.attribute(REL_ATT_INDEX).relation().classIndex());
  result.setValue(REL_ATT_INDEX,result.attribute(REL_ATT_INDEX).addRelation(segmentData));
  if (sourceAttIndex > 0) {
    result.setValue(output.attribute(ResultsUtil.ATTRIBUTE_SOURCE()),first.stringValue(sourceAttIndex));
  }
  if (first.classIndex() >= 0) {
    result.setValue(result.classIndex(),first.stringValue(first.classIndex()));
  }
  return result;
}",0.9937388193202148
43866,"@Override public void build(Instances input){
  guessAndSetClassLabel(input);
  Instances segments=determineOutputFormat(input);
  Instances nonSegments=determineOutputFormat(input);
  Map<String,Instances> splittedInput=ResultsUtil.splitInstanceBySourceJava(input,false);
  for (  Instances inst : splittedInput.values()) {
    Instances s=new Instances(segments,0);
    Instances n=new Instances(nonSegments,0);
    this.calcSegmentation(inst,s,n);
    this.calcSurroundingSegmentationRates(inst,s,n);
    try {
      ResultsUtil.appendInstances(segments,s);
      ResultsUtil.appendInstances(nonSegments,n);
    }
 catch (    WekaException we) {
      we.printStackTrace();
    }
  }
  sendEvent(new Results(segments),SegmentationFactory.SEGMENTS());
  sendEvent(new Results(nonSegments),SegmentationFactory.NONSEGMENTS());
}","@Override public void build(Instances input){
  guessAndSetClassLabel(input);
  Instances segments=determineOutputFormat(input);
  Instances nonSegments=determineOutputFormat(input);
  Map<String,Instances> splittedInput=ResultsUtil.splitInstanceBySourceJava(input,false);
  for (  Instances inst : splittedInput.values()) {
    Instances s=new Instances(segments,0);
    Instances n=new Instances(nonSegments,0);
    this.calcSegmentation(inst,s,n);
    this.calcSurroundingSegmentationRates(inst,s,n);
    try {
      segments=ResultsUtil.appendInstances(segments,s);
      nonSegments=ResultsUtil.appendInstances(nonSegments,n);
    }
 catch (    WekaException we) {
      we.printStackTrace();
    }
  }
  sendEvent(new Results(segments),SegmentationFactory.SEGMENTS());
  sendEvent(new Results(nonSegments),SegmentationFactory.NONSEGMENTS());
}",0.9874776386404294
43867,"private Instances calcSegmentation(Instances inst,Instances segments,Instances nonSegments){
  boolean isSegment=false;
  patterns=new double[dimensions][];
  shifts=new int[dimensions];
  shiftsCorrelation=new double[dimensions];
  double[][] values=new double[dimensions][inst.numInstances()];
  Vector<Instance> segment=new Vector<Instance>();
  for (int i=0; i < inst.numInstances(); i++) {
    int d=0;
    for (int j=0; j < inst.numAttributes(); j++) {
      if (inst.classIndex() != j && inst.attribute(j).type() == Attribute.NUMERIC) {
        values[d][i]=inst.get(i).value(j);
        d++;
      }
    }
  }
  getPatterns(0,values);
  calcShifts(0,values);
  int bestShift=bestShift();
  if (shifts[bestShift] > 0) {
    for (int i=0; i <= values[0].length - shiftSampleLength; i=i + shifts[bestShift]) {
      if (!isSegment) {
        getPatterns(i,values);
        calcShifts(i,values);
        bestShift=bestShift();
      }
      int correlations=calcCorrelations(i,values);
      if (correlations >= minAttributesWithSegments) {
        for (int j=i; j < i + shifts[bestShift]; j++) {
          segment.add(inst.get(j));
        }
        if (!isSegment) {
          getPatterns(i,values);
          calcShifts(i,values);
        }
        isSegment=true;
      }
 else {
        if (segment.size() > minSegmentLength) {
          segments.add(this.buildOutputInstance(segment,segments));
        }
 else {
          nonSegments.add(this.buildOutputInstance(segment,nonSegments));
        }
        segment.clear();
        i=i - shifts[bestShift];
        isSegment=false;
      }
    }
    if (segment.size() > minSegmentLength) {
      segments.add(this.buildOutputInstance(segment,segments));
    }
 else {
      nonSegments.add(this.buildOutputInstance(segment,nonSegments));
    }
    segment.clear();
  }
  return segments;
}","private Instances calcSegmentation(Instances inst,Instances segments,Instances nonSegments){
  boolean isSegment=false;
  patterns=new double[dimensions][];
  shifts=new int[dimensions];
  shiftsCorrelation=new double[dimensions];
  double[][] values=new double[dimensions][inst.numInstances()];
  Vector<Instance> segment=new Vector<Instance>();
  Vector<Instance> nonSegment=new Vector<Instance>();
  int timeAttIndex=-1;
  for (int i=0; i < inst.numAttributes(); i++) {
    if (inst.attribute(i).isDate()) {
      timeAttIndex=i;
      break;
    }
  }
  for (int i=0; i < inst.numInstances(); i++) {
    int d=0;
    for (int j=0; j < inst.numAttributes(); j++) {
      if (inst.classIndex() != j && inst.attribute(j).type() == Attribute.NUMERIC) {
        values[d][i]=inst.get(i).value(j);
        d++;
      }
    }
  }
  getPatterns(0,values);
  calcShifts(0,values);
  int bestShift=bestShift();
  if (shifts[bestShift] > 0) {
    for (int i=0; i <= values[0].length - shiftSampleLength; i=i + shifts[bestShift]) {
      if (!isSegment) {
        getPatterns(i,values);
        calcShifts(i,values);
        bestShift=bestShift();
      }
      int correlations=calcCorrelations(i,values);
      if (correlations >= minAttributesWithSegments) {
        for (int j=i; j < i + shifts[bestShift]; j++) {
          segment.add(inst.get(j));
        }
        if (!isSegment) {
          getPatterns(i,values);
          calcShifts(i,values);
        }
        isSegment=true;
      }
 else {
        if (segment.size() > minSegmentLength) {
          segments.add(this.buildOutputInstance(segment,segments));
        }
 else {
          if (nonSegment.isEmpty()) {
            nonSegment.addAll(segment);
          }
 else {
            Timestamp t1=new Timestamp((long)nonSegment.lastElement().value(timeAttIndex));
            Timestamp t2=new Timestamp((long)segment.firstElement().value(timeAttIndex));
            if (t2.getTime() - t1.getTime() == TIME_BETWEEN_SAMPLES) {
              nonSegment.addAll(segment);
            }
 else {
              nonSegments.add(this.buildOutputInstance(nonSegment,nonSegments));
              nonSegment.clear();
              nonSegment.addAll(segment);
            }
          }
        }
        segment.clear();
        i=i - shifts[bestShift];
        isSegment=false;
      }
    }
    if (segment.size() > minSegmentLength) {
      segments.add(this.buildOutputInstance(segment,segments));
    }
 else {
      nonSegments.add(this.buildOutputInstance(segment,nonSegments));
    }
    segment.clear();
  }
  return segments;
}",0.8340483179047189
43868,"@Override public Instances getDataSet() throws IOException {
  if (!dataset.isEmpty())   return dataset;
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar timestamp=new GregorianCalendar();
  Calendar intervalstart=new GregorianCalendar();
  Calendar intervalcurrent=new GregorianCalendar();
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  int avg_x=0;
  int avg_y=0;
  int avg_z=0;
  boolean newInterval=true;
  long interval=getIntervalLength();
  if (units > 0)   interval*=units;
  while (read != -1) {
    in.read(data,0,BLOCKSIZE);
    boolean recordEnd=setTime(date,data);
    long time=date.getTimeInMillis();
    if (recordEnd)     break;
    for (int j=0; j < CONTENT_BLOCK; j+=3) {
      timestamp.setTimeInMillis(time);
      int x=data[j];
      int y=data[j + 1];
      int z=data[j + 2];
      if (newInterval) {
        avg_x=x;
        avg_y=y;
        avg_z=z;
        newInterval=false;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
      time+=SAMPLE_DISTANCE;
      boolean insideBounds=intervalcurrent.getTimeInMillis() - intervalstart.getTimeInMillis() < interval;
      if (aggregate.equals(""String_Node_Str"") || !insideBounds) {
        DenseInstance instance=new DenseInstance(4);
        instance.setValue(timeAttribute,timestamp.getTimeInMillis());
        instance.setValue(xAttribute,avg_x);
        instance.setValue(yAttribute,avg_y);
        instance.setValue(zAttribute,avg_z);
        dataset.add(instance);
        avg_x=x;
        avg_y=y;
        avg_z=z;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
 else       if (insideBounds) {
        avg_x=(avg_x + x) / 2;
        avg_y=(avg_y + y) / 2;
        avg_z=(avg_z + z) / 2;
        intervalcurrent.setTimeInMillis(time);
      }
    }
    read=in.read(data);
  }
  in.close();
  if (output != null) {
    File out=new File(output);
    ArffSaver arffSaver=new ArffSaver();
    arffSaver.setFile(out);
    arffSaver.setInstances(dataset);
    arffSaver.writeBatch();
  }
  return dataset;
}","@Override public Instances getDataSet() throws IOException {
  if (!dataset.isEmpty())   return dataset;
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar intervalstart=new GregorianCalendar();
  Calendar intervalcurrent=new GregorianCalendar();
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  int avg_x=0;
  int avg_y=0;
  int avg_z=0;
  boolean newInterval=true;
  long interval=getIntervalLength();
  if (units > 0)   interval*=units;
  while (read != -1) {
    in.read(data,0,BLOCKSIZE);
    boolean recordEnd=setTime(date,data);
    long time=date.getTimeInMillis();
    if (recordEnd)     break;
    for (int j=0; j < CONTENT_BLOCK; j+=3) {
      int x=data[j];
      int y=data[j + 1];
      int z=data[j + 2];
      if (newInterval) {
        avg_x=x;
        avg_y=y;
        avg_z=z;
        newInterval=false;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
      boolean insideBounds=intervalcurrent.getTimeInMillis() - intervalstart.getTimeInMillis() < interval;
      if (aggregate.equals(""String_Node_Str"") || !insideBounds) {
        DenseInstance instance=new DenseInstance(4);
        instance.setValue(timeAttribute,time);
        instance.setValue(xAttribute,avg_x);
        instance.setValue(yAttribute,avg_y);
        instance.setValue(zAttribute,avg_z);
        dataset.add(instance);
        avg_x=x;
        avg_y=y;
        avg_z=z;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
 else       if (insideBounds) {
        avg_x=(avg_x + x) / 2;
        avg_y=(avg_y + y) / 2;
        avg_z=(avg_z + z) / 2;
        intervalcurrent.setTimeInMillis(time);
      }
      time+=SAMPLE_DISTANCE;
    }
    date.setTimeInMillis(time);
    read=in.read(data);
  }
  in.close();
  return dataset;
}",0.5327614963068859
43869,"@Override public Instances getDataSet() throws IOException {
  if (!dataset.isEmpty())   return dataset;
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar timestamp=new GregorianCalendar();
  Calendar intervalstart=new GregorianCalendar();
  Calendar intervalcurrent=new GregorianCalendar();
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  int avg_x=0;
  int avg_y=0;
  int avg_z=0;
  boolean newInterval=true;
  long interval=getIntervalLength();
  if (units > 0)   interval*=units;
  while (read != -1) {
    in.read(data,0,BLOCKSIZE);
    boolean recordEnd=setTime(date,data);
    long time=date.getTimeInMillis();
    if (recordEnd)     break;
    for (int j=0; j < CONTENT_BLOCK; j+=3) {
      timestamp.setTimeInMillis(time);
      int x=data[j];
      int y=data[j + 1];
      int z=data[j + 2];
      if (newInterval) {
        avg_x=x;
        avg_y=y;
        avg_z=z;
        newInterval=false;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
      time+=SAMPLE_DISTANCE;
      boolean insideBounds=intervalcurrent.getTimeInMillis() - intervalstart.getTimeInMillis() < interval;
      if (aggregate.equals(""String_Node_Str"") || !insideBounds) {
        DenseInstance instance=new DenseInstance(4);
        instance.setValue(timeAttribute,timestamp.getTimeInMillis());
        instance.setValue(xAttribute,avg_x);
        instance.setValue(yAttribute,avg_y);
        instance.setValue(zAttribute,avg_z);
        dataset.add(instance);
        avg_x=x;
        avg_y=y;
        avg_z=z;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
 else       if (insideBounds) {
        avg_x=(avg_x + x) / 2;
        avg_y=(avg_y + y) / 2;
        avg_z=(avg_z + z) / 2;
        intervalcurrent.setTimeInMillis(time);
      }
    }
    read=in.read(data);
  }
  in.close();
  if (output != null) {
    File out=new File(output);
    ArffSaver arffSaver=new ArffSaver();
    arffSaver.setFile(out);
    arffSaver.setInstances(dataset);
    arffSaver.writeBatch();
  }
  return dataset;
}","@Override public Instances getDataSet() throws IOException {
  if (!dataset.isEmpty())   return dataset;
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar intervalstart=new GregorianCalendar();
  Calendar intervalcurrent=new GregorianCalendar();
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  int avg_x=0;
  int avg_y=0;
  int avg_z=0;
  boolean newInterval=true;
  long interval=getIntervalLength();
  if (units > 0)   interval*=units;
  while (read != -1) {
    in.read(data,0,BLOCKSIZE);
    boolean recordEnd=setTime(date,data);
    long time=date.getTimeInMillis();
    if (recordEnd)     break;
    for (int j=0; j < CONTENT_BLOCK; j+=3) {
      int x=data[j];
      int y=data[j + 1];
      int z=data[j + 2];
      if (newInterval) {
        avg_x=x;
        avg_y=y;
        avg_z=z;
        newInterval=false;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
      boolean insideBounds=intervalcurrent.getTimeInMillis() - intervalstart.getTimeInMillis() < interval;
      if (aggregate.equals(""String_Node_Str"") || !insideBounds) {
        DenseInstance instance=new DenseInstance(4);
        instance.setValue(timeAttribute,time);
        instance.setValue(xAttribute,avg_x);
        instance.setValue(yAttribute,avg_y);
        instance.setValue(zAttribute,avg_z);
        dataset.add(instance);
        avg_x=x;
        avg_y=y;
        avg_z=z;
        intervalstart.setTimeInMillis(time);
        intervalcurrent.setTimeInMillis(time);
      }
 else       if (insideBounds) {
        avg_x=(avg_x + x) / 2;
        avg_y=(avg_y + y) / 2;
        avg_z=(avg_z + z) / 2;
        intervalcurrent.setTimeInMillis(time);
      }
      time+=SAMPLE_DISTANCE;
    }
    date.setTimeInMillis(time);
    read=in.read(data);
  }
  in.close();
  if (output != null) {
    File out=new File(output);
    ArffSaver arffSaver=new ArffSaver();
    arffSaver.setFile(out);
    arffSaver.setInstances(dataset);
    arffSaver.writeBatch();
  }
  return dataset;
}",0.6236902050113895
43870,"/** 
 * Create the frame.
 */
public AppFrame(){
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setBounds(100,100,950,600);
  contentPane=new JPanel();
  contentPane.setBorder(new EmptyBorder(5,5,5,5));
  setContentPane(contentPane);
  GridBagLayout gbl_contentPane=new GridBagLayout();
  gbl_contentPane.columnWidths=new int[]{0,0,0,0};
  gbl_contentPane.rowHeights=new int[]{0,0,0,0,0,0};
  gbl_contentPane.columnWeights=new double[]{0.0,1.0,0.0,Double.MIN_VALUE};
  gbl_contentPane.rowWeights=new double[]{0.0,0.0,0.0,1.0,0.0,Double.MIN_VALUE};
  contentPane.setLayout(gbl_contentPane);
  JLabel lInput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lInput=new GridBagConstraints();
  gbc_lInput.insets=new Insets(0,0,5,5);
  gbc_lInput.anchor=GridBagConstraints.EAST;
  gbc_lInput.gridx=0;
  gbc_lInput.gridy=0;
  contentPane.add(lInput,gbc_lInput);
  tInput=new JTextField();
  GridBagConstraints gbc_tInput=new GridBagConstraints();
  gbc_tInput.insets=new Insets(0,0,5,5);
  gbc_tInput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tInput.gridx=1;
  gbc_tInput.gridy=0;
  contentPane.add(tInput,gbc_tInput);
  tInput.setColumns(10);
  JButton bOpen=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bOpen=new GridBagConstraints();
  gbc_bOpen.fill=GridBagConstraints.HORIZONTAL;
  gbc_bOpen.insets=new Insets(0,0,5,0);
  gbc_bOpen.gridx=2;
  gbc_bOpen.gridy=0;
  contentPane.add(bOpen,gbc_bOpen);
  bOpen.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      dialog.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          boolean ret=f.getName().toLowerCase().endsWith(""String_Node_Str"");
          ret=ret || f.isDirectory();
          return ret;
        }
      }
);
      int ret=dialog.showOpenDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File file=dialog.getSelectedFile();
        try {
          converter.setFile(file);
          tInput.setText(file.getAbsolutePath());
        }
 catch (        IOException e1) {
          e1.printStackTrace();
        }
      }
    }
  }
);
  JLabel lOutput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lOutput=new GridBagConstraints();
  gbc_lOutput.anchor=GridBagConstraints.EAST;
  gbc_lOutput.insets=new Insets(0,0,5,5);
  gbc_lOutput.gridx=0;
  gbc_lOutput.gridy=1;
  contentPane.add(lOutput,gbc_lOutput);
  tOutput=new JTextField();
  GridBagConstraints gbc_tOutput=new GridBagConstraints();
  gbc_tOutput.insets=new Insets(0,0,5,5);
  gbc_tOutput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tOutput.gridx=1;
  gbc_tOutput.gridy=1;
  contentPane.add(tOutput,gbc_tOutput);
  tOutput.setColumns(10);
  JButton bSave=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bSave=new GridBagConstraints();
  gbc_bSave.insets=new Insets(0,0,5,0);
  gbc_bSave.fill=GridBagConstraints.HORIZONTAL;
  gbc_bSave.gridx=2;
  gbc_bSave.gridy=1;
  contentPane.add(bSave,gbc_bSave);
  bSave.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      int ret=dialog.showSaveDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        outputFile=dialog.getSelectedFile();
        tOutput.setText(outputFile.getAbsolutePath());
      }
    }
  }
);
  JPanel timePanel=new JPanel();
  GridBagConstraints gbc_timePanel=new GridBagConstraints();
  gbc_timePanel.fill=GridBagConstraints.HORIZONTAL;
  gbc_timePanel.insets=new Insets(0,0,5,5);
  gbc_timePanel.anchor=GridBagConstraints.NORTH;
  gbc_timePanel.gridwidth=2;
  gbc_timePanel.gridx=0;
  gbc_timePanel.gridy=2;
  contentPane.add(timePanel,gbc_timePanel);
  timePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
  JLabel lFrom=new JLabel(""String_Node_Str"");
  timePanel.add(lFrom);
  final JSpinner sFrom=new JSpinner();
  sFrom.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sFrom);
  JLabel lTo=new JLabel(""String_Node_Str"");
  timePanel.add(lTo);
  final JSpinner sTo=new JSpinner();
  sTo.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sTo);
  JButton bWrite=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_btnNewButton=new GridBagConstraints();
  gbc_btnNewButton.fill=GridBagConstraints.HORIZONTAL;
  gbc_btnNewButton.insets=new Insets(0,0,5,0);
  gbc_btnNewButton.gridx=2;
  gbc_btnNewButton.gridy=2;
  contentPane.add(bWrite,gbc_btnNewButton);
  bWrite.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Date from=(Date)sFrom.getValue();
      Date to=(Date)sTo.getValue();
      Persister persister=new Persister(from,to,converter);
      try {
        persister.persistAsCSV(outputFile);
      }
 catch (      IOException e1) {
        JOptionPane.showMessageDialog(contentPane,e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        e1.printStackTrace();
      }
      JOptionPane.showMessageDialog(contentPane,""String_Node_Str"" + outputFile.getAbsolutePath());
    }
  }
);
  final JPanel chartPanel=new JPanel(new BorderLayout());
  GridBagConstraints gbc_chartPanel=new GridBagConstraints();
  gbc_chartPanel.insets=new Insets(0,0,5,0);
  gbc_chartPanel.gridwidth=3;
  gbc_chartPanel.fill=GridBagConstraints.BOTH;
  gbc_chartPanel.gridx=0;
  gbc_chartPanel.gridy=3;
  contentPane.add(chartPanel,gbc_chartPanel);
  JPanel buttonPanel=new JPanel();
  GridBagConstraints gbc_buttonPanel=new GridBagConstraints();
  gbc_buttonPanel.insets=new Insets(0,0,0,5);
  gbc_buttonPanel.anchor=GridBagConstraints.SOUTHWEST;
  gbc_buttonPanel.gridwidth=2;
  gbc_buttonPanel.gridx=0;
  gbc_buttonPanel.gridy=4;
  contentPane.add(buttonPanel,gbc_buttonPanel);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
  JLabel lDate=new JLabel(""String_Node_Str"");
  buttonPanel.add(lDate);
  final JFormattedTextField tDate=new JFormattedTextField();
  tDate.setEditable(false);
  tDate.setColumns(20);
  buttonPanel.add(tDate);
  JButton bSaveAsFrom=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsFrom);
  bSaveAsFrom.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sFrom.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bSaveAsTo=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsTo);
  bSaveAsTo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sTo.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bPreview=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bPreview=new GridBagConstraints();
  gbc_bPreview.gridx=2;
  gbc_bPreview.gridy=4;
  contentPane.add(bPreview,gbc_bPreview);
  bPreview.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        chart.reset();
        chartPanel.removeAll();
        Instances dataSet=converter.getDataSet();
        chart.buildContent(dataSet);
        chartPanel.add(chart.getChartPanel(),BorderLayout.CENTER);
        chartPanel.validate();
        chart.getChart().addProgressListener(new ChartListener(tDate));
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
    }
  }
);
}","/** 
 * Create the frame.
 */
public AppFrame(){
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setBounds(100,100,950,600);
  contentPane=new JPanel();
  contentPane.setBorder(new EmptyBorder(5,5,5,5));
  setContentPane(contentPane);
  GridBagLayout gbl_contentPane=new GridBagLayout();
  gbl_contentPane.columnWidths=new int[]{0,0,0,0};
  gbl_contentPane.rowHeights=new int[]{0,0,0,0,0,0,0};
  gbl_contentPane.columnWeights=new double[]{0.0,1.0,0.0,Double.MIN_VALUE};
  gbl_contentPane.rowWeights=new double[]{0.0,0.0,0.0,1.0,0.0,0.0,Double.MIN_VALUE};
  contentPane.setLayout(gbl_contentPane);
  JLabel lInput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lInput=new GridBagConstraints();
  gbc_lInput.insets=new Insets(0,0,5,5);
  gbc_lInput.anchor=GridBagConstraints.EAST;
  gbc_lInput.gridx=0;
  gbc_lInput.gridy=0;
  contentPane.add(lInput,gbc_lInput);
  tInput=new JTextField();
  GridBagConstraints gbc_tInput=new GridBagConstraints();
  gbc_tInput.insets=new Insets(0,0,5,5);
  gbc_tInput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tInput.gridx=1;
  gbc_tInput.gridy=0;
  contentPane.add(tInput,gbc_tInput);
  tInput.setColumns(10);
  JButton bOpen=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bOpen=new GridBagConstraints();
  gbc_bOpen.fill=GridBagConstraints.HORIZONTAL;
  gbc_bOpen.insets=new Insets(0,0,5,0);
  gbc_bOpen.gridx=2;
  gbc_bOpen.gridy=0;
  contentPane.add(bOpen,gbc_bOpen);
  bOpen.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      dialog.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          boolean ret=f.getName().toLowerCase().endsWith(""String_Node_Str"");
          ret=ret || f.isDirectory();
          return ret;
        }
      }
);
      int ret=dialog.showOpenDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File file=dialog.getSelectedFile();
        try {
          converter.setFile(file);
          tInput.setText(file.getAbsolutePath());
        }
 catch (        IOException e1) {
          e1.printStackTrace();
        }
      }
    }
  }
);
  JLabel lOutput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lOutput=new GridBagConstraints();
  gbc_lOutput.anchor=GridBagConstraints.EAST;
  gbc_lOutput.insets=new Insets(0,0,5,5);
  gbc_lOutput.gridx=0;
  gbc_lOutput.gridy=1;
  contentPane.add(lOutput,gbc_lOutput);
  tOutput=new JTextField();
  GridBagConstraints gbc_tOutput=new GridBagConstraints();
  gbc_tOutput.insets=new Insets(0,0,5,5);
  gbc_tOutput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tOutput.gridx=1;
  gbc_tOutput.gridy=1;
  contentPane.add(tOutput,gbc_tOutput);
  tOutput.setColumns(10);
  JButton bSave=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bSave=new GridBagConstraints();
  gbc_bSave.insets=new Insets(0,0,5,0);
  gbc_bSave.fill=GridBagConstraints.HORIZONTAL;
  gbc_bSave.gridx=2;
  gbc_bSave.gridy=1;
  contentPane.add(bSave,gbc_bSave);
  bSave.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      int ret=dialog.showSaveDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        outputFile=dialog.getSelectedFile();
        tOutput.setText(outputFile.getAbsolutePath());
      }
    }
  }
);
  JPanel timePanel=new JPanel();
  GridBagConstraints gbc_timePanel=new GridBagConstraints();
  gbc_timePanel.fill=GridBagConstraints.HORIZONTAL;
  gbc_timePanel.insets=new Insets(0,0,5,5);
  gbc_timePanel.anchor=GridBagConstraints.NORTH;
  gbc_timePanel.gridwidth=2;
  gbc_timePanel.gridx=0;
  gbc_timePanel.gridy=2;
  contentPane.add(timePanel,gbc_timePanel);
  timePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
  JLabel lFrom=new JLabel(""String_Node_Str"");
  timePanel.add(lFrom);
  final JSpinner sFrom=new JSpinner();
  sFrom.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sFrom);
  JLabel lTo=new JLabel(""String_Node_Str"");
  timePanel.add(lTo);
  final JSpinner sTo=new JSpinner();
  sTo.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sTo);
  JButton bWrite=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_btnNewButton=new GridBagConstraints();
  gbc_btnNewButton.fill=GridBagConstraints.HORIZONTAL;
  gbc_btnNewButton.insets=new Insets(0,0,5,0);
  gbc_btnNewButton.gridx=2;
  gbc_btnNewButton.gridy=2;
  contentPane.add(bWrite,gbc_btnNewButton);
  bWrite.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Date from=(Date)sFrom.getValue();
      Date to=(Date)sTo.getValue();
      Persister persister=new Persister(from,to,converter);
      try {
        persister.persistAsCSV(outputFile);
      }
 catch (      IOException e1) {
        JOptionPane.showMessageDialog(contentPane,e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        e1.printStackTrace();
      }
      JOptionPane.showMessageDialog(contentPane,""String_Node_Str"" + outputFile.getAbsolutePath());
    }
  }
);
  final JPanel chartPanel=new JPanel(new BorderLayout());
  GridBagConstraints gbc_chartPanel=new GridBagConstraints();
  gbc_chartPanel.insets=new Insets(0,0,5,0);
  gbc_chartPanel.gridwidth=3;
  gbc_chartPanel.fill=GridBagConstraints.BOTH;
  gbc_chartPanel.gridx=0;
  gbc_chartPanel.gridy=3;
  contentPane.add(chartPanel,gbc_chartPanel);
  JPanel buttonPanel=new JPanel();
  GridBagConstraints gbc_buttonPanel=new GridBagConstraints();
  gbc_buttonPanel.insets=new Insets(0,0,5,5);
  gbc_buttonPanel.anchor=GridBagConstraints.SOUTHWEST;
  gbc_buttonPanel.gridwidth=2;
  gbc_buttonPanel.gridx=0;
  gbc_buttonPanel.gridy=4;
  contentPane.add(buttonPanel,gbc_buttonPanel);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
  JLabel lDate=new JLabel(""String_Node_Str"");
  buttonPanel.add(lDate);
  final JFormattedTextField tDate=new JFormattedTextField();
  tDate.setEditable(false);
  tDate.setColumns(20);
  buttonPanel.add(tDate);
  JButton bSaveAsFrom=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsFrom);
  bSaveAsFrom.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sFrom.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bSaveAsTo=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsTo);
  bSaveAsTo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sTo.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bPreview=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bPreview=new GridBagConstraints();
  gbc_bPreview.insets=new Insets(0,0,5,0);
  gbc_bPreview.gridx=2;
  gbc_bPreview.gridy=4;
  contentPane.add(bPreview,gbc_bPreview);
  bPreview.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        chart.reset();
        chartPanel.removeAll();
        Instances dataSet=converter.getDataSet();
        chart.buildContent(dataSet);
        chartPanel.add(chart.getChartPanel(),BorderLayout.CENTER);
        chartPanel.validate();
        chart.getChart().addProgressListener(new ChartListener(tDate));
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  progressBar=new JProgressBar();
  progressBar.setMaximum(100);
  progressBar.setMinimum(0);
  progressBar.setStringPainted(true);
  GridBagConstraints gbc_progressBar=new GridBagConstraints();
  gbc_progressBar.fill=GridBagConstraints.HORIZONTAL;
  gbc_progressBar.gridwidth=3;
  gbc_progressBar.insets=new Insets(0,0,0,5);
  gbc_progressBar.gridx=0;
  gbc_progressBar.gridy=5;
  contentPane.add(progressBar,gbc_progressBar);
  chart.addPropertyChangeListener(this);
}",0.9675202998126172
43871,"private Instances convert(String path) throws IOException {
  File oldSource=converter.retrieveFile();
  String dirPath=directory(path);
  String tmpPath=dirPath + sep + ""String_Node_Str"";
  File tmp=new File(tmpPath);
  converter.copy(new FileOutputStream(tmp),from,to);
  converter.setFile(tmp);
  Instances returns=converter.getDataSet();
  converter.setFile(oldSource);
  tmp.delete();
  return returns;
}","private Instances convert(String path) throws IOException {
  File oldSource=converter.retrieveFile();
  String dirPath=directory(path);
  String tmpPath=dirPath + sep + ""String_Node_Str"";
  File tmp=new File(tmpPath);
  converter.copy(new FileOutputStream(tmp),from,to);
  converter.reset();
  converter.setFile(tmp);
  Instances returns=converter.getDataSet();
  converter.setFile(oldSource);
  tmp.delete();
  return returns;
}",0.9749702026221692
43872,"public SDRConverter(){
  m_structure=ResultsUtil.timeSeriesResult(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  dataset=new Instances(m_structure);
  timeAttribute=dataset.attribute(ResultsUtil.ATTRIBUTE_TIMESTAMP());
  List<Attribute> valueAttributes=ResultsUtil.findValueAttributes(dataset);
  for (  Attribute attribute : valueAttributes) {
    String name=attribute.getMetadata().getProperty(ResultsUtil.META_ATTRIBUTE_NAME());
    if (name.equals(""String_Node_Str""))     xAttribute=attribute;
 else     if (name.equals(""String_Node_Str""))     yAttribute=attribute;
 else     if (name.equals(""String_Node_Str""))     zAttribute=attribute;
  }
}","public SDRConverter(){
  initStructure();
}",0.1039671682626539
43873,"public void copy(OutputStream out,Date from,Date to) throws IOException {
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  if (out == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar last=new GregorianCalendar();
  boolean init=false;
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  while (read != -1) {
    boolean recordEnd=setTime(date,data);
    if (!init) {
      init=true;
      last.setTimeInMillis(date.getTimeInMillis());
    }
    if (!date.getTime().before(from) && date.after(last))     out.write(data);
 else     if (recordEnd || date.before(last) || date.getTime().after(to))     break;
    last.setTimeInMillis(date.getTimeInMillis());
    read=in.read(data);
  }
  in.close();
}","public void copy(OutputStream out,Date from,Date to) throws IOException {
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  if (out == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar prev=new GregorianCalendar();
  boolean init=false;
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  while (read != -1) {
    boolean recordEnd=setTime(date,data);
    if (!init) {
      init=true;
      prev.setTimeInMillis(date.getTimeInMillis());
    }
    if (date.getTime().after(from) && date.after(prev))     out.write(data);
    if (recordEnd || date.before(prev) || date.getTime().after(to))     break;
    prev.setTimeInMillis(date.getTimeInMillis());
    read=in.read(data);
  }
  in.close();
}",0.9418859649122808
43874,"public void buildContent(Instances instances){
  TimeSeriesCollection dataset=(TimeSeriesCollection)this.dataset;
  if (series == null) {
    initSeries(instances);
  }
 else {
    for (    TimeSeries s : series.values()) {
      dataset.removeSeries(s);
    }
  }
  Enumeration<Instance> enumeration=instances.enumerateInstances();
  int numInst=instances.numInstances();
  int last=0;
  int i=0;
  System.out.println(""String_Node_Str"" + numInst + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  while (enumeration.hasMoreElements()) {
    Instance inst=enumeration.nextElement();
    double dateTime=inst.value(instances.attribute(ResultsUtil.ATTRIBUTE_TIMESTAMP()));
    Date date=new Date((long)dateTime);
    for (    String name : series.keySet()) {
      TimeSeries s=series.get(name);
      Attribute attribute=instances.attribute(name);
      double value=inst.value(attribute);
      s.add(new Millisecond(date),value);
    }
    last=printProgress(i,numInst,last);
    i++;
  }
  System.out.println(""String_Node_Str"");
  for (  TimeSeries s : series.values()) {
    dataset.addSeries(s);
  }
  if (chart != null)   chart.fireChartChanged();
}","public void buildContent(final Instances instances){
  final TimeSeriesCollection dataset=(TimeSeriesCollection)this.dataset;
  if (series == null) {
    initSeries(instances);
  }
 else {
    for (    TimeSeries s : series.values()) {
      dataset.removeSeries(s);
    }
  }
  new Thread(new Runnable(){
    @Override public void run(){
      Enumeration<Instance> enumeration=instances.enumerateInstances();
      int numInst=instances.numInstances();
      System.out.println(""String_Node_Str"" + numInst + ""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      support.firePropertyChange(""String_Node_Str"",-1,0);
      int last=0;
      int i=0;
      while (enumeration.hasMoreElements()) {
        Instance inst=enumeration.nextElement();
        double dateTime=inst.value(instances.attribute(ResultsUtil.ATTRIBUTE_TIMESTAMP()));
        Date date=new Date((long)dateTime);
        for (        String name : series.keySet()) {
          TimeSeries s=series.get(name);
          Attribute attribute=instances.attribute(name);
          double value=inst.value(attribute);
          s.add(new Millisecond(date),value);
        }
        last=printProgress(i,numInst,last);
        support.firePropertyChange(""String_Node_Str"",-1,last);
        i++;
      }
      System.out.println(""String_Node_Str"");
      support.firePropertyChange(""String_Node_Str"",-1,100);
      for (      TimeSeries s : series.values()) {
        dataset.addSeries(s);
      }
      if (chart != null)       chart.fireChartChanged();
    }
  }
).start();
}",0.7985294117647059
43875,"protected JFreeChart createChart(Dataset dataset){
  chart=ChartFactory.createTimeSeriesChart(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",(XYDataset)dataset,false,false,false);
  XYPlot xyplot=chart.getXYPlot();
  xyplot.setDomainCrosshairVisible(true);
  return chart;
}","protected JFreeChart createChart(Dataset dataset){
  chart=ChartFactory.createTimeSeriesChart(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",(XYDataset)dataset,true,false,false);
  XYPlot xyplot=chart.getXYPlot();
  xyplot.setDomainCrosshairVisible(true);
  return chart;
}",0.9875222816399288
43876,"@Override public void copy(OutputStream out,Date from,Date to) throws IOException {
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  if (out == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar last=new GregorianCalendar();
  boolean init=false;
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  while (read != -1) {
    boolean recordEnd=setTime(date,data);
    if (!init) {
      init=true;
      last.setTimeInMillis(date.getTimeInMillis());
    }
    if (!date.getTime().before(from) && date.after(last))     out.write(data);
 else     if (recordEnd || date.before(last) || date.getTime().after(to))     break;
    last.setTimeInMillis(date.getTimeInMillis());
    read=in.read(data);
  }
  in.close();
}","@Override public void copy(OutputStream out,Date from,Date to) throws IOException {
  if (m_sourceFile == null)   throw new IOException(""String_Node_Str"");
  if (out == null)   throw new IOException(""String_Node_Str"");
  byte[] data=new byte[BLOCKSIZE];
  Calendar date=new GregorianCalendar();
  Calendar last=new GregorianCalendar();
  boolean init=false;
  FileInputStream in=new FileInputStream(m_sourceFile);
  int read=in.read(data);
  System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  while (read != -1) {
    boolean recordEnd=setTime(date,data);
    if (!init) {
      init=true;
      last.setTimeInMillis(date.getTimeInMillis());
    }
    if (!date.getTime().before(from) && date.after(last))     out.write(data);
    if (recordEnd || date.before(last) || date.getTime().after(to))     break;
    last.setTimeInMillis(date.getTimeInMillis());
    read=in.read(data);
  }
  in.close();
}",0.9967497291440952
43877,"@Override public void actionPerformed(ActionEvent event){
  JFileChooser dialog=new JFileChooser();
  String sep=System.getProperty(""String_Node_Str"");
  String out=tInput.getText();
  int index=out.lastIndexOf(sep);
  out=out.substring(index,out.length() - 3) + configuration.getOutput();
  dialog.setSelectedFile(new File(out.substring(0,index) + out));
  int ret=dialog.showSaveDialog(contentPane);
  if (ret != JFileChooser.APPROVE_OPTION)   return;
  outputFile=dialog.getSelectedFile();
  configureConverter();
  Date from=(Date)sFrom.getValue();
  Date to=(Date)sTo.getValue();
  Persister persister=new Persister(from,to,converter,configuration.isRelativeOutput());
  try {
    if (configuration.getOutput().equals(""String_Node_Str""))     persister.persistAsARFF(outputFile);
 else     persister.persistAsCSV(outputFile,getAppFrame());
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(contentPane,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    e.printStackTrace();
  }
}","@Override public void actionPerformed(ActionEvent event){
  JFileChooser dialog=new JFileChooser();
  String out=tInput.getText();
  int index=out.lastIndexOf(File.separator);
  String file=out.substring(index,out.length() - 3) + configuration.getOutput();
  dialog.setSelectedFile(new File(out.substring(0,index) + file));
  int ret=dialog.showSaveDialog(contentPane);
  if (ret != JFileChooser.APPROVE_OPTION)   return;
  outputFile=dialog.getSelectedFile();
  configureConverter();
  Date from=(Date)sFrom.getValue();
  Date to=(Date)sTo.getValue();
  Persister persister=new Persister(from,to,converter,configuration.isRelativeOutput());
  try {
    if (configuration.getOutput().equals(""String_Node_Str""))     persister.persistAsARFF(outputFile);
 else     persister.persistAsCSV(outputFile,getAppFrame());
  }
 catch (  IOException e) {
    JOptionPane.showMessageDialog(contentPane,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    e.printStackTrace();
  }
}",0.9497991967871486
43878,"/** 
 * Create the frame.
 */
public AppFrame(){
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setBounds(100,100,950,600);
  contentPane=new JPanel();
  contentPane.setBorder(new EmptyBorder(5,5,5,5));
  setContentPane(contentPane);
  GridBagLayout gbl_contentPane=new GridBagLayout();
  gbl_contentPane.columnWidths=new int[]{0,0,0,0};
  gbl_contentPane.rowHeights=new int[]{0,0,0,0,0,0,0};
  gbl_contentPane.columnWeights=new double[]{0.0,1.0,0.0,Double.MIN_VALUE};
  gbl_contentPane.rowWeights=new double[]{0.0,0.0,0.0,1.0,0.0,0.0,Double.MIN_VALUE};
  contentPane.setLayout(gbl_contentPane);
  JLabel lInput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lInput=new GridBagConstraints();
  gbc_lInput.insets=new Insets(0,0,5,5);
  gbc_lInput.anchor=GridBagConstraints.EAST;
  gbc_lInput.gridx=0;
  gbc_lInput.gridy=0;
  contentPane.add(lInput,gbc_lInput);
  tInput=new JTextField();
  GridBagConstraints gbc_tInput=new GridBagConstraints();
  gbc_tInput.insets=new Insets(0,0,5,5);
  gbc_tInput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tInput.gridx=1;
  gbc_tInput.gridy=0;
  contentPane.add(tInput,gbc_tInput);
  tInput.setColumns(10);
  JButton bOpen=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bOpen=new GridBagConstraints();
  gbc_bOpen.fill=GridBagConstraints.HORIZONTAL;
  gbc_bOpen.insets=new Insets(0,0,5,0);
  gbc_bOpen.gridx=2;
  gbc_bOpen.gridy=0;
  contentPane.add(bOpen,gbc_bOpen);
  bOpen.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      dialog.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          boolean ret=f.getName().toLowerCase().endsWith(""String_Node_Str"");
          ret=ret || f.isDirectory();
          return ret;
        }
      }
);
      int ret=dialog.showOpenDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File file=dialog.getSelectedFile();
        try {
          converter.setFile(file);
          tInput.setText(file.getAbsolutePath());
        }
 catch (        IOException e1) {
          e1.printStackTrace();
        }
      }
    }
  }
);
  JButton bConfigure=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bConfigure=new GridBagConstraints();
  gbc_bConfigure.anchor=GridBagConstraints.NORTHEAST;
  gbc_bConfigure.insets=new Insets(0,0,5,0);
  gbc_bConfigure.gridx=2;
  gbc_bConfigure.gridy=1;
  contentPane.add(bConfigure,gbc_bConfigure);
  bConfigure.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ConfigDialog dialog=new ConfigDialog(configuration);
      dialog.setVisible(true);
      if (!dialog.isCanceled())       configuration=dialog.getConfiguration();
      System.out.println(""String_Node_Str"" + configuration);
    }
  }
);
  JPanel timePanel=new JPanel();
  GridBagConstraints gbc_timePanel=new GridBagConstraints();
  gbc_timePanel.fill=GridBagConstraints.HORIZONTAL;
  gbc_timePanel.insets=new Insets(0,0,5,5);
  gbc_timePanel.anchor=GridBagConstraints.NORTH;
  gbc_timePanel.gridwidth=2;
  gbc_timePanel.gridx=0;
  gbc_timePanel.gridy=2;
  contentPane.add(timePanel,gbc_timePanel);
  timePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
  JLabel lFrom=new JLabel(""String_Node_Str"");
  timePanel.add(lFrom);
  final JSpinner sFrom=new JSpinner();
  sFrom.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sFrom);
  JLabel lTo=new JLabel(""String_Node_Str"");
  timePanel.add(lTo);
  final JSpinner sTo=new JSpinner();
  sTo.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sTo);
  JButton bPreview=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bPreview=new GridBagConstraints();
  gbc_bPreview.fill=GridBagConstraints.HORIZONTAL;
  gbc_bPreview.insets=new Insets(0,0,5,0);
  gbc_bPreview.gridx=2;
  gbc_bPreview.gridy=2;
  contentPane.add(bPreview,gbc_bPreview);
  bPreview.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        chart.reset();
        converter.reset();
        chartPanel.removeAll();
        configureConverter();
        Instances dataSet=converter.getDataSet();
        chart.buildContent(dataSet);
        chartPanel.add(chart.getChartPanel(),BorderLayout.CENTER);
        chartPanel.validate();
        chart.getChart().addProgressListener(new ChartListener(tDate));
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  chartPanel=new JPanel(new BorderLayout());
  GridBagConstraints gbc_chartPanel=new GridBagConstraints();
  gbc_chartPanel.insets=new Insets(0,0,5,0);
  gbc_chartPanel.gridwidth=3;
  gbc_chartPanel.fill=GridBagConstraints.BOTH;
  gbc_chartPanel.gridx=0;
  gbc_chartPanel.gridy=3;
  contentPane.add(chartPanel,gbc_chartPanel);
  JPanel buttonPanel=new JPanel();
  GridBagConstraints gbc_buttonPanel=new GridBagConstraints();
  gbc_buttonPanel.insets=new Insets(0,0,5,5);
  gbc_buttonPanel.anchor=GridBagConstraints.SOUTHWEST;
  gbc_buttonPanel.gridwidth=2;
  gbc_buttonPanel.gridx=0;
  gbc_buttonPanel.gridy=4;
  contentPane.add(buttonPanel,gbc_buttonPanel);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
  JLabel lDate=new JLabel(""String_Node_Str"");
  buttonPanel.add(lDate);
  tDate=new JFormattedTextField();
  tDate.setEditable(false);
  tDate.setColumns(20);
  buttonPanel.add(tDate);
  JButton bSaveAsFrom=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsFrom);
  bSaveAsFrom.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sFrom.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bSaveAsTo=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsTo);
  bSaveAsTo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sTo.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bWrite=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_btnNewButton=new GridBagConstraints();
  gbc_btnNewButton.fill=GridBagConstraints.HORIZONTAL;
  gbc_btnNewButton.insets=new Insets(0,0,5,0);
  gbc_btnNewButton.gridx=2;
  gbc_btnNewButton.gridy=4;
  contentPane.add(bWrite,gbc_btnNewButton);
  bWrite.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      JFileChooser dialog=new JFileChooser();
      String sep=System.getProperty(""String_Node_Str"");
      String out=tInput.getText();
      int index=out.lastIndexOf(sep);
      out=out.substring(index,out.length() - 3) + configuration.getOutput();
      dialog.setSelectedFile(new File(out.substring(0,index) + out));
      int ret=dialog.showSaveDialog(contentPane);
      if (ret != JFileChooser.APPROVE_OPTION)       return;
      outputFile=dialog.getSelectedFile();
      configureConverter();
      Date from=(Date)sFrom.getValue();
      Date to=(Date)sTo.getValue();
      Persister persister=new Persister(from,to,converter,configuration.isRelativeOutput());
      try {
        if (configuration.getOutput().equals(""String_Node_Str""))         persister.persistAsARFF(outputFile);
 else         persister.persistAsCSV(outputFile,getAppFrame());
      }
 catch (      IOException e) {
        JOptionPane.showMessageDialog(contentPane,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        e.printStackTrace();
      }
    }
  }
);
  progressBar=new JProgressBar();
  progressBar.setMaximum(100);
  progressBar.setMinimum(0);
  progressBar.setStringPainted(true);
  GridBagConstraints gbc_progressBar=new GridBagConstraints();
  gbc_progressBar.fill=GridBagConstraints.HORIZONTAL;
  gbc_progressBar.gridwidth=3;
  gbc_progressBar.gridx=0;
  gbc_progressBar.gridy=5;
  contentPane.add(progressBar,gbc_progressBar);
  chart.addPropertyChangeListener(this);
}","/** 
 * Create the frame.
 */
public AppFrame(){
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setBounds(100,100,950,600);
  contentPane=new JPanel();
  contentPane.setBorder(new EmptyBorder(5,5,5,5));
  setContentPane(contentPane);
  GridBagLayout gbl_contentPane=new GridBagLayout();
  gbl_contentPane.columnWidths=new int[]{0,0,0,0};
  gbl_contentPane.rowHeights=new int[]{0,0,0,0,0,0,0};
  gbl_contentPane.columnWeights=new double[]{0.0,1.0,0.0,Double.MIN_VALUE};
  gbl_contentPane.rowWeights=new double[]{0.0,0.0,0.0,1.0,0.0,0.0,Double.MIN_VALUE};
  contentPane.setLayout(gbl_contentPane);
  JLabel lInput=new JLabel(""String_Node_Str"");
  GridBagConstraints gbc_lInput=new GridBagConstraints();
  gbc_lInput.insets=new Insets(0,0,5,5);
  gbc_lInput.anchor=GridBagConstraints.EAST;
  gbc_lInput.gridx=0;
  gbc_lInput.gridy=0;
  contentPane.add(lInput,gbc_lInput);
  tInput=new JTextField();
  GridBagConstraints gbc_tInput=new GridBagConstraints();
  gbc_tInput.insets=new Insets(0,0,5,5);
  gbc_tInput.fill=GridBagConstraints.HORIZONTAL;
  gbc_tInput.gridx=1;
  gbc_tInput.gridy=0;
  contentPane.add(tInput,gbc_tInput);
  tInput.setColumns(10);
  JButton bOpen=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bOpen=new GridBagConstraints();
  gbc_bOpen.fill=GridBagConstraints.HORIZONTAL;
  gbc_bOpen.insets=new Insets(0,0,5,0);
  gbc_bOpen.gridx=2;
  gbc_bOpen.gridy=0;
  contentPane.add(bOpen,gbc_bOpen);
  bOpen.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser dialog=new JFileChooser();
      dialog.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          boolean ret=f.getName().toLowerCase().endsWith(""String_Node_Str"");
          ret=ret || f.isDirectory();
          return ret;
        }
      }
);
      int ret=dialog.showOpenDialog(contentPane);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File file=dialog.getSelectedFile();
        try {
          converter.setFile(file);
          tInput.setText(file.getAbsolutePath());
        }
 catch (        IOException e1) {
          e1.printStackTrace();
        }
      }
    }
  }
);
  JButton bConfigure=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bConfigure=new GridBagConstraints();
  gbc_bConfigure.anchor=GridBagConstraints.NORTHEAST;
  gbc_bConfigure.insets=new Insets(0,0,5,0);
  gbc_bConfigure.gridx=2;
  gbc_bConfigure.gridy=1;
  contentPane.add(bConfigure,gbc_bConfigure);
  bConfigure.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ConfigDialog dialog=new ConfigDialog(configuration);
      dialog.setVisible(true);
      if (!dialog.isCanceled())       configuration=dialog.getConfiguration();
      System.out.println(""String_Node_Str"" + configuration);
    }
  }
);
  JPanel timePanel=new JPanel();
  GridBagConstraints gbc_timePanel=new GridBagConstraints();
  gbc_timePanel.fill=GridBagConstraints.HORIZONTAL;
  gbc_timePanel.insets=new Insets(0,0,5,5);
  gbc_timePanel.anchor=GridBagConstraints.NORTH;
  gbc_timePanel.gridwidth=2;
  gbc_timePanel.gridx=0;
  gbc_timePanel.gridy=2;
  contentPane.add(timePanel,gbc_timePanel);
  timePanel.setLayout(new FlowLayout(FlowLayout.LEFT,5,5));
  JLabel lFrom=new JLabel(""String_Node_Str"");
  timePanel.add(lFrom);
  final JSpinner sFrom=new JSpinner();
  sFrom.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sFrom);
  JLabel lTo=new JLabel(""String_Node_Str"");
  timePanel.add(lTo);
  final JSpinner sTo=new JSpinner();
  sTo.setModel(new SpinnerDateModel(new Date(),null,null,Calendar.DAY_OF_YEAR));
  timePanel.add(sTo);
  JButton bPreview=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_bPreview=new GridBagConstraints();
  gbc_bPreview.fill=GridBagConstraints.HORIZONTAL;
  gbc_bPreview.insets=new Insets(0,0,5,0);
  gbc_bPreview.gridx=2;
  gbc_bPreview.gridy=2;
  contentPane.add(bPreview,gbc_bPreview);
  bPreview.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        chart.reset();
        converter.reset();
        chartPanel.removeAll();
        configureConverter();
        Instances dataSet=converter.getDataSet();
        chart.buildContent(dataSet);
        chartPanel.add(chart.getChartPanel(),BorderLayout.CENTER);
        chartPanel.validate();
        chart.getChart().addProgressListener(new ChartListener(tDate));
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  chartPanel=new JPanel(new BorderLayout());
  GridBagConstraints gbc_chartPanel=new GridBagConstraints();
  gbc_chartPanel.insets=new Insets(0,0,5,0);
  gbc_chartPanel.gridwidth=3;
  gbc_chartPanel.fill=GridBagConstraints.BOTH;
  gbc_chartPanel.gridx=0;
  gbc_chartPanel.gridy=3;
  contentPane.add(chartPanel,gbc_chartPanel);
  JPanel buttonPanel=new JPanel();
  GridBagConstraints gbc_buttonPanel=new GridBagConstraints();
  gbc_buttonPanel.insets=new Insets(0,0,5,5);
  gbc_buttonPanel.anchor=GridBagConstraints.SOUTHWEST;
  gbc_buttonPanel.gridwidth=2;
  gbc_buttonPanel.gridx=0;
  gbc_buttonPanel.gridy=4;
  contentPane.add(buttonPanel,gbc_buttonPanel);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
  JLabel lDate=new JLabel(""String_Node_Str"");
  buttonPanel.add(lDate);
  tDate=new JFormattedTextField();
  tDate.setEditable(false);
  tDate.setColumns(20);
  buttonPanel.add(tDate);
  JButton bSaveAsFrom=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsFrom);
  bSaveAsFrom.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sFrom.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bSaveAsTo=new JButton(""String_Node_Str"");
  buttonPanel.add(bSaveAsTo);
  bSaveAsTo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=tDate.getText();
      try {
        Date date=df.parse(text);
        sTo.setValue(date);
      }
 catch (      ParseException e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton bWrite=new JButton(""String_Node_Str"");
  GridBagConstraints gbc_btnNewButton=new GridBagConstraints();
  gbc_btnNewButton.fill=GridBagConstraints.HORIZONTAL;
  gbc_btnNewButton.insets=new Insets(0,0,5,0);
  gbc_btnNewButton.gridx=2;
  gbc_btnNewButton.gridy=4;
  contentPane.add(bWrite,gbc_btnNewButton);
  bWrite.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      JFileChooser dialog=new JFileChooser();
      String out=tInput.getText();
      int index=out.lastIndexOf(File.separator);
      String file=out.substring(index,out.length() - 3) + configuration.getOutput();
      dialog.setSelectedFile(new File(out.substring(0,index) + file));
      int ret=dialog.showSaveDialog(contentPane);
      if (ret != JFileChooser.APPROVE_OPTION)       return;
      outputFile=dialog.getSelectedFile();
      configureConverter();
      Date from=(Date)sFrom.getValue();
      Date to=(Date)sTo.getValue();
      Persister persister=new Persister(from,to,converter,configuration.isRelativeOutput());
      try {
        if (configuration.getOutput().equals(""String_Node_Str""))         persister.persistAsARFF(outputFile);
 else         persister.persistAsCSV(outputFile,getAppFrame());
      }
 catch (      IOException e) {
        JOptionPane.showMessageDialog(contentPane,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        e.printStackTrace();
      }
    }
  }
);
  progressBar=new JProgressBar();
  progressBar.setMaximum(100);
  progressBar.setMinimum(0);
  progressBar.setStringPainted(true);
  GridBagConstraints gbc_progressBar=new GridBagConstraints();
  gbc_progressBar.fill=GridBagConstraints.HORIZONTAL;
  gbc_progressBar.gridwidth=3;
  gbc_progressBar.gridx=0;
  gbc_progressBar.gridy=5;
  contentPane.add(progressBar,gbc_progressBar);
  chart.addPropertyChangeListener(this);
}",0.9932440583906382
43879,"/** 
 * @param listener 
 * @param path - output file
 * @throws IOException
 */
public void persistAsCSV(File file,PropertyChangeListener listener) throws IOException {
  Instances dataset=convert(file.getAbsolutePath());
  CSVSaver saver=new CSVSaver();
  saver.addPropertyChangeListener(listener);
  saver.setFile(file);
  saver.setInstances(dataset);
  saver.setSeparator(""String_Node_Str"");
  saver.writeBatch();
}","/** 
 * @param listener
 * @param path - output file
 * @throws IOException
 */
public void persistAsCSV(File file,PropertyChangeListener listener) throws IOException {
  Instances dataset=convert(file.getAbsolutePath());
  CSVSaver saver=new CSVSaver();
  saver.addPropertyChangeListener(listener);
  saver.setFile(file);
  saver.setInstances(dataset);
  saver.setSeparator(""String_Node_Str"");
  saver.writeBatch();
}",0.998805256869773
43880,"/** 
 * <p>Converter must have a valid sourceFile</p>
 * @param from - from which date to persist
 * @param to - to which date to persist
 * @param converter
 */
public Persister(Date from,Date to,SDRConverter converter,boolean relative){
  this.from=from;
  this.to=to;
  this.relative=relative;
  this.converter=converter;
}","/** 
 * <p> Converter must have a valid sourceFile </p>
 * @param from - from which date to persist
 * @param to - to which date to persist
 * @param converter
 */
public Persister(Date from,Date to,SDRConverter converter,boolean relative){
  this.from=from;
  this.to=to;
  this.relative=relative;
  this.converter=converter;
}",0.9969418960244648
43881,"private Instances convert(String path) throws IOException {
  File oldSource=converter.retrieveFile();
  String dirPath=directory(path);
  String tmpPath=dirPath + sep + ""String_Node_Str"";
  File tmp=new File(tmpPath);
  converter.copy(new FileOutputStream(tmp),from,to);
  converter.reset();
  converter.setFile(tmp);
  converter.setAggregate(SDRConverter.AGGREGATE_NONE);
  converter.setRelativeTimestamp(relative);
  Instances returns=converter.getDataSet();
  converter.setFile(oldSource);
  tmp.delete();
  return returns;
}","private Instances convert(String path) throws IOException {
  File oldSource=converter.retrieveFile();
  String dirPath=directory(path);
  String tmpPath=dirPath + sep + ""String_Node_Str"";
  File tmp=new File(tmpPath);
  converter.copy(new FileOutputStream(tmp),from,to);
  converter.reset();
  converter.setFile(tmp);
  converter.setAggregate(SDRConverter.AGGREGATE_NONE);
  converter.setRelativeTimestamp(relative);
  Instances returns=converter.getDataSet();
  converter.setFile(oldSource);
  if (!tmp.delete())   System.err.println(""String_Node_Str"");
  return returns;
}",0.9384057971014492
43882,"/** 
 * Read CDMI blob and save the contents to a file.
 * @param remoteFileName The remote file path
 * @param localFileName Absolute path of the local file
 * @return Returns an integer containing the HTTP response code
 */
public int readToFile(String remoteFileName,String localFileName) throws IOException, URISyntaxException, CDMIOperationException, ParseException {
  HttpResponse response=read(remoteFileName);
  int responseCode=response.getStatusLine().getStatusCode();
  if (responseCode != REQUEST_OK)   throw new CDMIOperationException(""String_Node_Str"" + remoteFileName,responseCode);
  String mimeType=(String)Utils.getElement(response,""String_Node_Str"");
  FileOutputStream outputFile=new FileOutputStream(localFileName);
  if (mimeType.equals(""String_Node_Str"")) {
    outputFile.write(Utils.getObjectContent(response).getBytes());
  }
 else {
    outputFile.write(Utils.getTextContent(response).getBytes());
  }
  outputFile.close();
  return responseCode;
}","/** 
 * Read CDMI blob and save the contents to a file.
 * @param remoteFileName The remote file path
 * @param localFileName Absolute path of the local file
 * @return Returns an integer containing the HTTP response code
 */
public int readToFile(String remoteFileName,String localFileName) throws IOException, URISyntaxException, CDMIOperationException, ParseException {
  HttpResponse response=read(remoteFileName);
  int responseCode=response.getStatusLine().getStatusCode();
  if (responseCode != REQUEST_OK)   throw new CDMIOperationException(""String_Node_Str"" + remoteFileName,responseCode);
  FileOutputStream outputFile=new FileOutputStream(localFileName);
  outputFile.write(Utils.getContent(response).getBytes());
  outputFile.close();
  return responseCode;
}",0.7658843732112193
43883,"public static String getContent(String file) throws IOException {
  FileReader fileReader=new FileReader(file);
  BufferedReader in=new BufferedReader(fileReader);
  StringBuilder content=new StringBuilder(""String_Node_Str"");
  String str;
  while ((str=in.readLine()) != null) {
    content.append(str);
  }
  return content.toString();
}","/** 
 * Extract value of a CDMI object. The binary files are decoded according to JSON BASE64 rules.
 */
public static String getContent(HttpResponse response) throws IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  parser=new JSONParser();
  stream=response.getEntity().getContent();
  is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map jsonMap=(Map)parser.parse(is,containerFactory);
  String mimetype=jsonMap.get(""String_Node_Str"").toString();
  String content=jsonMap.get(""String_Node_Str"").toString();
  if (!mimetype.equals(""String_Node_Str"")) {
    byte[] decodedObj=Base64.decodeBase64(content);
    content=new String(decodedObj);
  }
  stream.close();
  is.close();
  return content;
}",0.129360465116279
43884,"public static String getTextContent(HttpResponse response) throws IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map jsonMap=(Map)parser.parse(is,containerFactory);
  String content=jsonMap.get(""String_Node_Str"").toString();
  stream.close();
  is.close();
  return content;
}","/** 
 * @deprecated Use getContent instead.
 */
public static String getTextContent(HttpResponse response) throws IOException, ParseException {
  return getContent(response);
}",0.2874845105328377
43885,"/** 
 * To extract a binary CDMI object contents. The binary files are decoded as JSON BASE64 rules.
 * @param response
 * @return
 * @throws IOException
 * @throws ParseException
 */
public static String getObjectContent(HttpResponse response) throws IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  parser=new JSONParser();
  stream=response.getEntity().getContent();
  is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map jsonMap=(Map)parser.parse(is,containerFactory);
  String content=jsonMap.get(""String_Node_Str"").toString();
  byte[] decodedObj=Base64.decodeBase64(content);
  stream.close();
  is.close();
  return new String(decodedObj);
}","/** 
 * @deprecated Use getContent instead.
 */
public static String getObjectContent(HttpResponse response) throws IOException, ParseException {
  return getContent(response);
}",0.2690659811482433
43886,"public BlobOperations(URL endpoint,DefaultHttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}","public BlobOperations(URL endpoint,HttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}",0.9707112970711296
43887,"public DefaultHttpClient getHttpclient(){
  return httpclient;
}","public HttpClient getHttpclient(){
  return httpclient;
}",0.9421487603305784
43888,"public CDMIConnection(Credentials creds,URL endpoint) throws CertificateException, NoSuchAlgorithmException, KeyManagementException, IOException, KeyStoreException, UnrecoverableKeyException {
  DefaultHttpClient httpclient=new DefaultHttpClient();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
  TrustManager[] trustManagers=new TrustManager[]{new FakeX509TrustManager()};
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,trustManagers,new SecureRandom());
  SSLSocketFactory sf=new SSLSocketFactory(context);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",80,PlainSocketFactory.getSocketFactory()));
  schemeRegistry.register(new Scheme(""String_Node_Str"",443,sf.getSocketFactory()));
  ThreadSafeClientConnManager conMg=new ThreadSafeClientConnManager(schemeRegistry);
  conMg.setMaxTotal(200);
  conMg.setDefaultMaxPerRoute(20);
  HttpHost host=new HttpHost(endpoint.getHost(),80);
  conMg.setMaxForRoute(new HttpRoute(host),50);
  httpclient=new DefaultHttpClient(conMg);
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(endpoint.getHost(),endpoint.getPort()),creds);
  this.endpoint=endpoint;
  this.blobProxy=new BlobOperations(endpoint,httpclient);
  this.containerProxy=new ContainerOperations(endpoint,httpclient);
  this.nonCdmiContainerProxy=new NonCDMIContainerOperations(endpoint,httpclient);
  this.nonCdmiBlobProxy=new NonCDMIBlobOperations(endpoint,httpclient);
}","public CDMIConnection(Credentials credentials,URL endpoint) throws CertificateException, NoSuchAlgorithmException, KeyManagementException, IOException, KeyStoreException, UnrecoverableKeyException {
  KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());
  trustStore.load(null,null);
  SSLSocketFactory factory=new CustomSSLSocketFactory(trustStore);
  factory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
  HttpParams params=new BasicHttpParams();
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setContentCharset(params,HTTP.UTF_8);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  schemeRegistry.register(new Scheme(""String_Node_Str"",factory,443));
  ThreadSafeClientConnManager conMg=new ThreadSafeClientConnManager(schemeRegistry);
  conMg.setMaxTotal(200);
  conMg.setDefaultMaxPerRoute(20);
  HttpHost host=new HttpHost(endpoint.getHost(),80);
  conMg.setMaxForRoute(new HttpRoute(host),50);
  httpclient=new DefaultHttpClient(conMg);
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(endpoint.getHost(),endpoint.getPort()),credentials);
  this.endpoint=endpoint;
  this.blobProxy=new BlobOperations(endpoint,httpclient);
  this.containerProxy=new ContainerOperations(endpoint,httpclient);
  this.nonCdmiContainerProxy=new NonCDMIContainerOperations(endpoint,httpclient);
  this.nonCdmiBlobProxy=new NonCDMIBlobOperations(endpoint,httpclient);
}",0.618437900128041
43889,"public ContainerOperations(URL endpoint,DefaultHttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}","public ContainerOperations(URL endpoint,HttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}",0.9718875502008032
43890,"public NonCDMIBlobOperations(URL endpoint,DefaultHttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}","public NonCDMIBlobOperations(URL endpoint,HttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}",0.9723320158102768
43891,"public NonCDMIContainerOperations(URL endpoint,DefaultHttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}","public NonCDMIContainerOperations(URL endpoint,HttpClient httpclient){
  this.httpclient=httpclient;
  this.endpoint=endpoint;
}",0.973384030418251
43892,"protected void createConnection() throws KeyManagementException, UnrecoverableKeyException, CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException {
  cdmiServer=new URL(""String_Node_Str"");
  parameters=new HashMap<String,Object>();
  creds=new UsernamePasswordCredentials(""String_Node_Str"",""String_Node_Str"");
  cdmiConnection=new CDMIConnection(creds,cdmiServer);
}","protected void createConnection() throws KeyManagementException, UnrecoverableKeyException, CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException {
  cdmiServer=new URL(""String_Node_Str"");
  parameters=new HashMap<String,Object>();
  credentials=new UsernamePasswordCredentials(""String_Node_Str"",""String_Node_Str"");
  cdmiConnection=new CDMIConnection(credentials,cdmiServer);
}",0.9848866498740554
43893,"/** 
 * @param args
 */
public static void main(String[] args){
  String remoteFNM=""String_Node_Str"";
  String localfile=""String_Node_Str"";
  CDMIMQOperations mq=new CDMIMQOperations();
  try {
    mq.createQueueObj(remoteFNM);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  String remoteFNM=""String_Node_Str"";
  String localfile=""String_Node_Str"";
  CDMIBlobOperations cd=new CDMIBlobOperations();
  try {
    cd.create(localfile,remoteFNM);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9310344827586208
43894,"public String[] getChildren(String remoteContainer) throws Exception {
  HttpResponse response=null;
  HttpGet httpget=new HttpGet(endpoint + remoteContainer);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_CONTAINER);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_OBJECT);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  response=httpclient.execute(httpget);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 406:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
}
InputStream respStream=response.getEntity().getContent();
Gson gson=new Gson();
ContainerReadRequest responseBody=gson.fromJson(Utils.convertStreamToString(respStream),ContainerReadRequest.class);
return responseBody.children;
}","public String[] getChildren(String remoteContainer) throws Exception {
  HttpResponse response=null;
  HttpGet httpget=new HttpGet(endpoint + remoteContainer);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_CONTAINER);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_OBJECT);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  response=httpclient.execute(httpget);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
case 406:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteContainer,responseCode);
}
InputStream respStream=response.getEntity().getContent();
Gson gson=new Gson();
ContainerReadRequest responseBody=gson.fromJson(Utils.convertStreamToString(respStream),ContainerReadRequest.class);
HttpEntity ent=response.getEntity();
EntityUtils.consume(ent);
return responseBody.children;
}",0.975575221238938
43895,"public File readFile(String remoteFNM,String localFNM) throws Exception {
  File file=null;
  BufferedWriter bw=null;
  DefaultHttpClient httpclient=new DefaultHttpClient();
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(endpoint.getHost(),endpoint.getPort()),creds);
  HttpGet httpget=new HttpGet(endpoint + remoteFNM);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_OBJECT);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  HttpResponse response=httpclient.execute(httpget);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 406:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
InputStream respStream=response.getEntity().getContent();
Gson gson=new Gson();
BlobReadResponse responseBody=gson.fromJson(Utils.convertStreamToString(respStream),BlobReadResponse.class);
if (responseBody.mimetype.equals(""String_Node_Str"")) {
URL url=new URL(endpoint + remoteFNM);
file=new File(localFNM);
bw=new BufferedWriter(new FileWriter(file));
bw.write(responseBody.value);
bw.close();
}
 else throw new IOException(responseBody.mimetype + ""String_Node_Str"");
return file;
}","public File readFile(String remoteFNM,String localFNM) throws Exception {
  File file=null;
  BufferedWriter bw=null;
  DefaultHttpClient httpclient=new DefaultHttpClient();
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(endpoint.getHost(),endpoint.getPort()),creds);
  HttpGet httpget=new HttpGet(endpoint + remoteFNM);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_OBJECT);
  httpget.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  HttpResponse response=httpclient.execute(httpget);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 406:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
InputStream respStream=response.getEntity().getContent();
Gson gson=new Gson();
BlobReadResponse responseBody=gson.fromJson(Utils.convertStreamToString(respStream),BlobReadResponse.class);
HttpEntity ent=response.getEntity();
EntityUtils.consume(ent);
if (responseBody.mimetype.equals(""String_Node_Str"")) {
URL url=new URL(endpoint + remoteFNM);
file=new File(localFNM);
bw=new BufferedWriter(new FileWriter(file));
bw.write(responseBody.value);
bw.close();
}
 else throw new IOException(responseBody.mimetype + ""String_Node_Str"");
return file;
}",0.98269706124691
43896,"public int update(String localFNM,String remoteFNM,Map parameters) throws Exception {
  HttpResponse response=null;
  HttpPut httpput=new HttpPut(endpoint + remoteFNM);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  BlobUpdateRequest update=new BlobUpdateRequest();
  update.mimetype=parameters.get(""String_Node_Str"") != null ? (String)parameters.get(""String_Node_Str"") : ""String_Node_Str"";
  if (parameters.get(""String_Node_Str"") != null)   update.metadata=(MetadataField)parameters.get(""String_Node_Str"");
  if (parameters.get(""String_Node_Str"") != null)   update.domainURI=(String)parameters.get(""String_Node_Str"");
  update.value=Utils.getContents(new File(localFNM));
  Gson gson=new Gson();
  StringEntity entity=new StringEntity(gson.toJson(update));
  httpput.setEntity(entity);
  response=httpclient.execute(httpput);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 409:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
return responseCode;
}","public int update(String localFNM,String remoteFNM,Map parameters) throws Exception {
  HttpResponse response=null;
  HttpPut httpput=new HttpPut(endpoint + remoteFNM);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpput.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  BlobUpdateRequest update=new BlobUpdateRequest();
  update.mimetype=parameters.get(""String_Node_Str"") != null ? (String)parameters.get(""String_Node_Str"") : ""String_Node_Str"";
  update.metadata=(MetadataField)parameters.get(""String_Node_Str"");
  update.domainURI=(String)parameters.get(""String_Node_Str"");
  update.value=Utils.getContents(new File(localFNM));
  Gson gson=new Gson();
  StringEntity entity=new StringEntity(gson.toJson(update));
  httpput.setEntity(entity);
  response=httpclient.execute(httpput);
  int responseCode=response.getStatusLine().getStatusCode();
  HttpEntity ent=response.getEntity();
  EntityUtils.consume(ent);
switch (responseCode) {
case 200:
    break;
case 302:
  throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 400:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 409:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
return responseCode;
}",0.9137474241978216
43897,"public void delete(String remoteFNM) throws Exception {
  HttpDelete httpdelete=new HttpDelete(endpoint + remoteFNM);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  HttpResponse response=httpclient.execute(httpdelete);
  int responseCode=response.getStatusLine().getStatusCode();
switch (responseCode) {
case 200:
    break;
case 400:
  throw new CDMIOperationException(""String_Node_Str"" + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 409:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
}","public void delete(String remoteFNM) throws Exception {
  HttpDelete httpdelete=new HttpDelete(endpoint + remoteFNM);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_DATA);
  httpdelete.setHeader(""String_Node_Str"",CDMIContentType.CDMI_SPEC_VERSION);
  HttpResponse response=httpclient.execute(httpdelete);
  int responseCode=response.getStatusLine().getStatusCode();
  HttpEntity entity=response.getEntity();
  EntityUtils.consume(entity);
switch (responseCode) {
case 200:
    break;
case 400:
  throw new CDMIOperationException(""String_Node_Str"" + remoteFNM,responseCode);
case 401:
throw new CDMIOperationException(""String_Node_Str"" + remoteFNM,responseCode);
case 403:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 404:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
case 409:
throw new CDMIOperationException(""String_Node_Str"" + endpoint + remoteFNM,responseCode);
}
}",0.9638434868746903
43898,"/** 
 * This method can be used to extract an element array from the response.
 * @param response
 * @param elementName
 * @return
 * @throws IllegalStateException
 * @throws IOException
 */
public static Object[] getElementArrary(HttpResponse response,String elementName) throws IllegalStateException, IOException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  try {
    Map json=(Map)parser.parse(is,containerFactory);
    LinkedList theList=(LinkedList)json.get(elementName);
    return theList.toArray();
  }
 catch (  ParseException pe) {
    System.err.println(pe.getMessage());
  }
 finally {
    stream.close();
    is.close();
  }
  return null;
}","/** 
 * This method can be used to extract an element array from the response.
 * @param response
 * @param elementName
 * @return
 * @throws IllegalStateException
 * @throws IOException
 * @throws ParseException 
 */
public static Object[] getElementArrary(HttpResponse response,String elementName) throws IllegalStateException, IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map json=(Map)parser.parse(is,containerFactory);
  LinkedList theList=(LinkedList)json.get(elementName);
  return theList.toArray();
}",0.8426176311519741
43899,"/** 
 * This method extracts a specific element from the response
 * @param response
 * @param elementName
 * @return
 * @throws IllegalStateException
 * @throws IOException
 */
public static Object getElement(HttpResponse response,String elementName) throws IllegalStateException, IOException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  try {
    Map json=(Map)parser.parse(is,containerFactory);
    return json.get(elementName);
  }
 catch (  ParseException pe) {
    System.err.println(pe.getMessage());
  }
 finally {
    stream.close();
    is.close();
  }
  return null;
}","/** 
 * This method extracts a specific element from the response
 * @param response
 * @param elementName
 * @return
 * @throws IllegalStateException
 * @throws IOException
 * @throws ParseException
 */
public static Object getElement(HttpResponse response,String elementName) throws IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map json=(Map)parser.parse(is,containerFactory);
  return json.get(elementName);
}",0.8264758497316637
43900,"/** 
 * This method returns the content of a text object
 * @param response
 * @return
 * @throws IllegalStateException
 * @throws IOException
 */
public static String getTextContent(HttpResponse response) throws IllegalStateException, IOException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  try {
    Map json=(Map)parser.parse(is,containerFactory);
    return json.get(""String_Node_Str"").toString();
  }
 catch (  ParseException pe) {
    System.err.println(pe.getMessage());
  }
 finally {
    stream.close();
    is.close();
  }
  return null;
}","/** 
 * This method returns the content of a text object
 * @param response
 * @return
 * @throws IllegalStateException
 * @throws IOException
 * @throws ParseException
 */
public static String getTextContent(HttpResponse response) throws IOException, ParseException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  Map json=(Map)parser.parse(is,containerFactory);
  return json.get(""String_Node_Str"").toString();
}",0.8079061148857319
43901,"/** 
 * This method returns the content of a binary file decoded using Base64
 * @param response
 * @return
 * @throws IllegalStateException
 * @throws IOException
 */
public static Object getObjectContent(HttpResponse response) throws IllegalStateException, IOException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  try {
    Map json=(Map)parser.parse(is,containerFactory);
    String content=json.get(""String_Node_Str"").toString();
    Base64 decoder=new Base64();
    System.out.println(new String(decoder.decodeBase64(content)));
    return decoder.decodeBase64(content);
  }
 catch (  ParseException pe) {
    System.err.println(pe.getMessage());
  }
 finally {
    stream.close();
    is.close();
  }
  return null;
}","/** 
 * This method returns the content of a binary file decoded using Base64
 * @param response
 * @return
 * @throws IllegalStateException
 * @throws IOException
 */
public static Object getObjectContent(HttpResponse response) throws IOException {
  JSONParser parser=new JSONParser();
  InputStream stream=response.getEntity().getContent();
  InputStreamReader is=new InputStreamReader(stream);
  Map json=null;
  parser=new JSONParser();
  stream=response.getEntity().getContent();
  is=new InputStreamReader(stream);
  ContainerFactory containerFactory=new ContainerFactory(){
    public List creatArrayContainer(){
      return new LinkedList();
    }
    public Map createObjectContainer(){
      return new LinkedHashMap();
    }
  }
;
  String content=json.get(""String_Node_Str"").toString();
  Base64 decoder=new Base64();
  return decoder.decodeBase64(content);
}",0.7688311688311689
43902,"/** 
 * Test method for reading a blob object.  {@link eu.venusc.cdmi.BlobOperations#read(java.lang.String,java.lang.String)}.
 */
@Test public void testRead(){
  HttpResponse response=null;
  int responseCode=0;
  try {
    response=cops.create(containerName + ""String_Node_Str"",parameters);
    responseCode=response.getStatusLine().getStatusCode();
    if (responseCode != 201)     fail(""String_Node_Str"" + containerName + ""String_Node_Str"");
    response=bops.create(containerName + ""String_Node_Str"" + objectName,Utils.getBytesFromFile(tmpFile),parameters);
    responseCode=response.getStatusLine().getStatusCode();
    if (responseCode != 201)     fail(""String_Node_Str"" + containerName + ""String_Node_Str""+ objectName);
    response=bops.read(containerName + ""String_Node_Str"" + objectName);
    responseCode=response.getStatusLine().getStatusCode();
    String mimeType=(String)Utils.getElement(response,""String_Node_Str"");
    if (mimeType != ""String_Node_Str"") {
      assertEquals(""String_Node_Str"",new String(Utils.getBytesFromFile(tmpFile)),Utils.getObjectContent(response));
    }
 else {
      assertEquals(""String_Node_Str"",new String(Utils.getBytesFromFile(tmpFile)),Utils.getObjectContent(response));
    }
  }
 catch (  ClientProtocolException e) {
    System.err.println(e.getMessage());
  }
catch (  IOException e) {
    System.err.println(e.getMessage());
  }
catch (  CDMIOperationException e) {
    System.err.println(e.getMessage());
  }
}","/** 
 * Test method for reading a blob object.  {@link eu.venusc.cdmi.BlobOperations#read(java.lang.String,java.lang.String)}.
 * @throws ParseException 
 * @throws IOException 
 */
@Test public void testRead() throws ParseException, IOException {
  HttpResponse response=null;
  int responseCode=-1;
  try {
    response=cops.create(containerName + ""String_Node_Str"",parameters);
    responseCode=response.getStatusLine().getStatusCode();
    if (responseCode != 201)     fail(""String_Node_Str"" + containerName + ""String_Node_Str"");
    response=bops.create(containerName + ""String_Node_Str"" + objectName,Utils.getBytesFromFile(tmpFile),parameters);
    responseCode=response.getStatusLine().getStatusCode();
    if (responseCode != 201)     fail(""String_Node_Str"" + containerName + ""String_Node_Str""+ objectName);
    response=bops.read(containerName + ""String_Node_Str"" + objectName);
    responseCode=response.getStatusLine().getStatusCode();
    String mimeType=(String)Utils.getElement(response,""String_Node_Str"");
    response=bops.read(containerName + ""String_Node_Str"" + objectName);
    responseCode=response.getStatusLine().getStatusCode();
    if (!mimeType.equals(""String_Node_Str"")) {
      assertEquals(""String_Node_Str"",new String(Utils.getBytesFromFile(tmpFile)),Utils.getObjectContent(response));
    }
 else {
      assertEquals(""String_Node_Str"",new String(Utils.getBytesFromFile(tmpFile)),Utils.getTextContent(response));
    }
  }
 catch (  ClientProtocolException e) {
    System.err.println(e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  CDMIOperationException e) {
    System.err.println(e.getMessage() + ""String_Node_Str"" + responseCode);
  }
}",0.1777497636306334
43903,"@Configuration public static Option[] configuration(){
}","@Configuration public static Option[] configuration(){
  return options(felix(),mavenConfiguration(),wrappedBundle(mavenBundle(""String_Node_Str"",""String_Node_Str"").version(""String_Node_Str"")));
}",0.446215139442231
43904,"@SuppressWarnings(""String_Node_Str"") @Override public void execute(){
  System.out.println(""String_Node_Str"" + input.getContainingType().toString());
  output=(PList<O>)CollectionFactory.listFromType(input.getContainingType().toString());
  if (end > start) {
    output.set(end - 1 - start,input.get(0));
  }
  cTask=ForTask.createFor(CPUDevice.rt,new aeminium.runtime.helpers.loops.Range(start,end),new ForBody<Integer>(){
    @Override public void iterate(    Integer line,    aeminium.runtime.Runtime rt,    Task current){
      O acc;
      if (reduceFun instanceof LambdaReducerWithSeed) {
        LambdaReducerWithSeed<O> red=(LambdaReducerWithSeed<O>)reduceFun;
        acc=red.getSeed();
        for (int i=line * outputSize; i < (line + 1) * outputSize; i++) {
          acc=reduceFun.combine(acc,input.get(i));
        }
      }
 else {
        acc=input.get(line * outputSize);
        for (int i=line * outputSize + 1; i < (line + 1) * outputSize; i++) {
          acc=reduceFun.combine(acc,input.get(i));
        }
      }
      output.set(line - start,acc);
    }
  }
,Runtime.NO_HINTS);
  CPUDevice.submit(cTask);
}","@SuppressWarnings(""String_Node_Str"") @Override public void execute(){
  output=(PList<O>)CollectionFactory.listFromType(input.getContainingType().getSimpleName());
  if (end > start) {
    output.set(end - 1 - start,input.get(0));
  }
  cTask=ForTask.createFor(CPUDevice.rt,new aeminium.runtime.helpers.loops.Range(start,end),new ForBody<Integer>(){
    @Override public void iterate(    Integer line,    aeminium.runtime.Runtime rt,    Task current){
      O acc;
      if (reduceFun instanceof LambdaReducerWithSeed) {
        LambdaReducerWithSeed<O> red=(LambdaReducerWithSeed<O>)reduceFun;
        acc=red.getSeed();
        for (int i=line * outputSize; i < (line + 1) * outputSize; i++) {
          acc=reduceFun.combine(acc,input.get(i));
        }
      }
 else {
        acc=input.get(line * outputSize);
        for (int i=line * outputSize + 1; i < (line + 1) * outputSize; i++) {
          acc=reduceFun.combine(acc,input.get(i));
        }
      }
      output.set(line - start,acc);
    }
  }
,Runtime.NO_HINTS);
  CPUDevice.submit(cTask);
}",0.9538180155464108
43905,"@SuppressWarnings(""String_Node_Str"") @Override public void execute(CLContext ctx,CLQueue q){
  CLEvent[] eventsArr=new CLEvent[1];
  int[] rs;
  boolean reuseControlBuffers=false;
  int workUnits=prepareReadBuffers(strategy.getStart(),strategy.getEnd(),strategy.getTop(),strategy.getBottom(),NUM_WORKERS);
  copyRangeBuffers(ctx);
  pbuffer=BufferHelper.createOutputBufferFor(ctx,strategy.getStart().getClass().getSimpleName(),NUM_WORKERS);
  rbuffer=(CLBuffer<Integer>)BufferHelper.createOutputBufferFor(ctx,""String_Node_Str"",NUM_WORKERS);
  abuffer=BufferHelper.createOutputBufferFor(ctx,strategy.getSeed().getClass().getSimpleName(),NUM_WORKERS);
  int global_counter=0;
  do {
synchronized (kernel) {
      if (is2D) {
      }
 else {
        int reuse_steps=reuseControlBuffers ? 1 : 0;
        kernel.setArgs(sbuffer,ebuffer,abuffer,rbuffer,starts.size(),global_counter++,reuse_steps,pbuffer);
      }
      setExtraDataArgs(7,kernel);
      eventsArr[0]=kernel.enqueueNDRange(q,new int[]{NUM_WORKERS},eventsArr);
    }
    reuseControlBuffers=true;
    rs=rbuffer.read(q,eventsArr[0]).getInts();
    for (int i=0; i < workUnits; i++) {
      if (rs[i] == 2) {
        reuseControlBuffers=false;
        break;
      }
    }
    if (reuseControlBuffers) {
      if (System.getenv(""String_Node_Str"") != null) {
        R stepXprobe=(R)BufferHelper.extractElementFromBuffer(pbuffer,q,eventsArr[0],strategy.getStart().getClass().getSimpleName());
        System.out.println(""String_Node_Str"" + stepXprobe + ""String_Node_Str""+ rs[0]);
      }
      continue;
    }
    filterAndSplitFirst(workUnits,rs);
    copyRangeBuffers(ctx);
    workUnits=starts.size();
  }
 while (!isDone);
  rbuffer.release();
  PList<T> accs=(PList<T>)BufferHelper.extractFromBuffer(abuffer,q,eventsArr[0],strategy.getSeed().getClass().getSimpleName(),workUnits);
  output=strategy.getSeed();
  for (  T acc : accs) {
    output=strategy.combine(output,acc);
  }
  abuffer.release();
}","@SuppressWarnings(""String_Node_Str"") @Override public void execute(CLContext ctx,CLQueue q){
  CLEvent[] eventsArr=new CLEvent[1];
  int[] rs;
  boolean reuseControlBuffers=false;
  int workUnits=prepareReadBuffers(strategy.getStart(),strategy.getEnd(),strategy.getTop(),strategy.getBottom(),NUM_WORKERS);
  copyRangeBuffers(ctx);
  pbuffer=BufferHelper.createOutputBufferFor(ctx,strategy.getStart().getClass().getSimpleName(),NUM_WORKERS);
  rbuffer=(CLBuffer<Integer>)BufferHelper.createOutputBufferFor(ctx,""String_Node_Str"",NUM_WORKERS);
  abuffer=BufferHelper.createOutputBufferFor(ctx,strategy.getSeed().getClass().getSimpleName(),NUM_WORKERS);
  int global_counter=0;
  do {
synchronized (kernel) {
      if (is2D) {
      }
 else {
        int reuse_steps=reuseControlBuffers ? 1 : 0;
        kernel.setArgs(sbuffer,ebuffer,abuffer,rbuffer,starts.size(),global_counter++,reuse_steps,pbuffer);
      }
      setExtraDataArgs(7,kernel);
      eventsArr[0]=kernel.enqueueNDRange(q,new int[]{NUM_WORKERS},eventsArr);
    }
    reuseControlBuffers=true;
    rs=rbuffer.read(q,eventsArr[0]).getInts();
    for (int i=0; i < workUnits; i++) {
      if (rs[i] == 2) {
        reuseControlBuffers=false;
        break;
      }
    }
    if (reuseControlBuffers) {
      if (System.getenv(""String_Node_Str"") != null) {
        R stepXprobe=(R)BufferHelper.extractElementFromBuffer(pbuffer,q,eventsArr[0],strategy.getStart().getClass().getSimpleName());
        System.out.println(""String_Node_Str"" + stepXprobe + ""String_Node_Str""+ rs[0]);
      }
      continue;
    }
    filterAndSplitFirst(workUnits,rs);
    copyRangeBuffers(ctx);
    workUnits=starts.size();
  }
 while (!isDone);
  rbuffer.release();
  PList<T> accs=(PList<T>)BufferHelper.extractFromBuffer(abuffer,q,eventsArr[0],strategy.getSeed().getClass().getSimpleName(),NUM_WORKERS);
  output=strategy.getSeed();
  for (  T acc : accs) {
    output=strategy.combine(output,acc);
  }
  abuffer.release();
}",0.9954198473282444
43906,"private static String sameOperationAs(String op){
  if (op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"") || op.equals(""String_Node_Str""))   return ""String_Node_Str"";
  return op;
}","private static String sameOperationAs(String op){
  if (op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"")|| op.equals(""String_Node_Str""))   return ""String_Node_Str"";
  if (op.equals(""String_Node_Str""))   return ""String_Node_Str"";
  return op;
}",0.7640918580375783
43907,"private static long getInterpolatedValue(String prefix,int size,String sufix){
  int sb=1 * (int)Math.pow(10,(""String_Node_Str"" + size).length());
  int st=1 * (int)Math.pow(10,(""String_Node_Str"" + size).length() + 1);
  int cutPoint=Integer.parseInt((""String_Node_Str"" + size).substring(0,1));
  long bottom=0;
  long top=0;
  try {
    bottom=getOrFail(prefix + sb + sufix);
  }
 catch (  Exception e) {
    return 0;
  }
  try {
    top=getOrFail(prefix + st + sufix);
    if (top == 0)     throw new Exception();
  }
 catch (  Exception e) {
    return bottom;
  }
  return (bottom * cutPoint + top * (10 - cutPoint)) / 10;
}","public static long getInterpolatedValue(String prefix,int size,String sufix){
  int sb=(int)Math.pow(10,Math.floor(Math.log10(size)));
  int st=(int)Math.pow(10,Math.ceil(Math.log10(size)));
  float cutPoint=size / ((float)st);
  long bottom=0;
  long top=0;
  try {
    bottom=getOrFail(prefix + sb + sufix);
  }
 catch (  Exception e) {
    return 0;
  }
  try {
    top=getOrFail(prefix + st + sufix);
    if (top == 0)     throw new Exception();
  }
 catch (  Exception e) {
    return bottom;
  }
  return (long)(bottom * cutPoint + top * (1 - cutPoint));
}",0.1645675902602854
43908,"private static long getCPUEstimation(int size,String code,String complexity,boolean isRange){
  long pTimeCPU=0;
  String[] parts=complexity.split(""String_Node_Str"");
  for (  String part : parts) {
    String[] kv=part.split(""String_Node_Str"");
    try {
      int times=Integer.parseInt(kv[0]);
      String v=kv[1];
      pTimeCPU+=times * (getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + part + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
  return pTimeCPU;
}","public static long getCPUEstimation(int size,String code,String complexity,boolean isRange){
  long pTimeCPU=0;
  String[] parts=complexity.split(""String_Node_Str"");
  for (  String part : parts) {
    String[] kv=part.split(""String_Node_Str"");
    try {
      int times=Integer.parseInt(kv[0]);
      String v=kv[1];
      pTimeCPU+=times * (getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + part + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
  return pTimeCPU;
}",0.9904761904761904
43909,"private static long getGPUEstimation(int size,String code,String complexity,boolean isRange){
  long pTimeGPU=0;
  if (!isRange) {
    pTimeGPU+=getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"");
  }
  pTimeGPU+=getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"");
  String[] parts=complexity.split(""String_Node_Str"");
  for (  String part : parts) {
    String[] kv=part.split(""String_Node_Str"");
    try {
      int times=Integer.parseInt(kv[0]);
      String v=kv[1];
      pTimeGPU+=(getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
      pTimeGPU+=times * (getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
    }
 catch (    Exception e) {
      if (System.getenv(""String_Node_Str"") != null) {
        System.out.println(""String_Node_Str"" + part);
      }
    }
  }
  return pTimeGPU;
}","public static long getGPUEstimation(int size,String code,String complexity,boolean isRange){
  long pTimeGPU=0;
  if (!isRange) {
    pTimeGPU+=getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"");
  }
  pTimeGPU+=getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"");
  String[] parts=complexity.split(""String_Node_Str"");
  for (  String part : parts) {
    String[] kv=part.split(""String_Node_Str"");
    try {
      int times=Integer.parseInt(kv[0]);
      String v=kv[1];
      pTimeGPU+=(getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
      pTimeGPU+=times * (getInterpolatedValue(""String_Node_Str"",size,""String_Node_Str"" + v));
    }
 catch (    Exception e) {
      if (System.getenv(""String_Node_Str"") != null) {
        System.out.println(""String_Node_Str"" + part);
      }
    }
  }
  return pTimeGPU;
}",0.9935559461042766
43910,"private static String sameOperationAs(String op){
  if (op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"") || op.equals(""String_Node_Str""))   return ""String_Node_Str"";
  return op;
}","private static String sameOperationAs(String op){
  if (op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"") || op.equals(""String_Node_Str"")|| op.equals(""String_Node_Str""))   return ""String_Node_Str"";
  return op;
}",0.9253012048192772
43911,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  char[] ar=((CharList)list).getArray();
  CharBuffer ibuffer=CharBuffer.wrap(ar);
  ibuffer.put(ar,0,list.size());
  return context.createCharBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  char[] ar=((CharList)list).getArray();
  CharBuffer ibuffer=CharBuffer.wrap(ar,0,list.size());
  return context.createCharBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.6998087954110899
43912,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  double[] ar=((DoubleList)list).getArray();
  DoubleBuffer ibuffer=DoubleBuffer.wrap(ar);
  return context.createDoubleBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  double[] ar=((DoubleList)list).getArray();
  DoubleBuffer ibuffer=DoubleBuffer.wrap(ar,0,list.size());
  return context.createDoubleBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.9725490196078432
43913,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  float[] ar=((FloatList)list).getArray();
  FloatBuffer ibuffer=FloatBuffer.wrap(ar);
  ibuffer.put(ar,0,list.size());
  return context.createFloatBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  float[] ar=((FloatList)list).getArray();
  FloatBuffer ibuffer=FloatBuffer.wrap(ar,0,list.size());
  return context.createFloatBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.701688555347092
43914,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  int[] ar=((IntList)list).getArray();
  IntBuffer ibuffer=IntBuffer.wrap(ar);
  return context.createIntBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  int[] ar=((IntList)list).getArray();
  IntBuffer ibuffer=IntBuffer.wrap(ar,0,list.size());
  return context.createIntBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.9708333333333332
43915,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  long[] ar=((LongList)list).getArray();
  LongBuffer ibuffer=LongBuffer.wrap(ar);
  ibuffer.put(ar,0,list.size());
  return context.createLongBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  long[] ar=((LongList)list).getArray();
  LongBuffer ibuffer=LongBuffer.wrap(ar,0,list.size());
  return context.createLongBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.6998087954110899
43916,abstract public String getOtherSources();,"public String getOtherSources(){
  return otherSources;
}",0.6530612244897959
43917,"public <O>boolean canMergeWithMap(Mapper<T,O> mapFun);","public <O>boolean canMergeWithMap(LambdaMapper<T,O> mapFun);",0.9473684210526316
43918,"@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  char[] ar=((CharList)list).getArray();
  System.out.println(""String_Node_Str"" + ar.length);
  for (int i=0; i < list.size(); i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ ar[i]);
  }
  CharBuffer ibuffer=CharBuffer.wrap(ar,0,list.size());
  return context.createCharBuffer(CLMem.Usage.Input,ibuffer,true);
}","@Override public <T>CLBuffer<?> createInputBufferFor(CLContext context,PList<T> list){
  char[] ar=((CharList)list).getArray();
  byte[] car=encodeCharToBytes(ar);
  ByteBuffer ibuffer=ByteBuffer.wrap(car,0,list.size());
  return context.createByteBuffer(CLMem.Usage.Input,ibuffer,true);
}",0.3792134831460674
43919,"@Override public PList<?> extractFromBuffer(CLBuffer<?> outbuffer,CLQueue q,CLEvent ev,int size){
  char[] content=new char[size];
  outbuffer.asCLCharBuffer().read(q,ev).get(content);
  System.out.println(""String_Node_Str"" + content.length);
  for (int i=0; i < size; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ content[i]);
  }
  return new CharList(content,size);
}","@Override public PList<?> extractFromBuffer(CLBuffer<?> outbuffer,CLQueue q,CLEvent ev,int size){
  byte[] pcontent=new byte[size];
  outbuffer.asCLByteBuffer().read(q,ev).get(pcontent);
  char[] content=decodeBytesToChar(pcontent);
  return new CharList(content,size);
}",0.5089820359281437
43920,"public void testMapCharToChar(){
  PList<Character> example=new CharList();
  for (int i=0; i < TEST_SIZE; i++) {
    example.add('h');
  }
  PList<Character> output=example.map(new LambdaMapper<Character,Character>(){
    @Override public Character map(    Character ch){
      return 'f';
    }
    public String getSource(){
      return ""String_Node_Str"";
    }
  }
);
  for (int i=0; i < TEST_SIZE; i++) {
    System.out.println(""String_Node_Str"" + (int)output.get(i));
  }
}","public void testMapCharToChar(){
  PList<Character> example=new CharList();
  for (int i=0; i < TEST_SIZE; i++) {
    example.add('h');
  }
  PList<Character> output=example.map(new LambdaMapper<Character,Character>(){
    @Override public Character map(    Character ch){
      return 'f';
    }
    public String getSource(){
      return ""String_Node_Str"";
    }
  }
);
  for (int i=0; i < TEST_SIZE; i++) {
    assertTrue(output.get(i).compareTo('f') == 0);
  }
}",0.9039070749736008
43921,"public DashStyleTemp getGridLineDashStyle(){
  return mGridLineDashStyle;
}","public DashStyle getGridLineDashStyle(){
  return mGridLineDashStyle;
}",0.9726027397260274
43922,"public Axis setGridLineDashStyle(DashStyleTemp pGridLineDashStyle){
  mGridLineDashStyle=pGridLineDashStyle;
  return this;
}","public Axis setGridLineDashStyle(DashStyle pGridLineDashStyle){
  mGridLineDashStyle=pGridLineDashStyle;
  return this;
}",0.983739837398374
43923,"public Axis setMinorGridLineDashStyle(DashStyleTemp pMinorGridLineDashStyle){
  mMinorGridLineDashStyle=pMinorGridLineDashStyle;
  return this;
}","public Axis setMinorGridLineDashStyle(DashStyle pMinorGridLineDashStyle){
  mMinorGridLineDashStyle=pMinorGridLineDashStyle;
  return this;
}",0.986013986013986
43924,"public DashStyleTemp getMinorGridLineDashStyle(){
  return mMinorGridLineDashStyle;
}","public DashStyle getMinorGridLineDashStyle(){
  return mMinorGridLineDashStyle;
}",0.9759036144578314
43925,"public PlotLine setDashStyle(DashStyleTemp pDashStyle){
  mDashStyle=pDashStyle;
  return this;
}","public PlotLine setDashStyle(DashStyle pDashStyle){
  mDashStyle=pDashStyle;
  return this;
}",0.9789473684210528
43926,"public DashStyleTemp getDashStyle(){
  return mDashStyle;
}","public DashStyle getDashStyle(){
  return mDashStyle;
}",0.9649122807017544
43927,"public DashStyle getGridLineDashStyle(){
  return mGridLineDashStyle;
}","public DashStyleTemp getGridLineDashStyle(){
  return mGridLineDashStyle;
}",0.9726027397260274
43928,"public Axis setGridLineDashStyle(DashStyle pGridLineDashStyle){
  mGridLineDashStyle=pGridLineDashStyle;
  return this;
}","public Axis setGridLineDashStyle(DashStyleTemp pGridLineDashStyle){
  mGridLineDashStyle=pGridLineDashStyle;
  return this;
}",0.983739837398374
43929,"public Axis setMinorGridLineDashStyle(DashStyle pMinorGridLineDashStyle){
  mMinorGridLineDashStyle=pMinorGridLineDashStyle;
  return this;
}","public Axis setMinorGridLineDashStyle(DashStyleTemp pMinorGridLineDashStyle){
  mMinorGridLineDashStyle=pMinorGridLineDashStyle;
  return this;
}",0.986013986013986
43930,"public DashStyle getMinorGridLineDashStyle(){
  return mMinorGridLineDashStyle;
}","public DashStyleTemp getMinorGridLineDashStyle(){
  return mMinorGridLineDashStyle;
}",0.9759036144578314
43931,"public PlotLine setDashStyle(DashStyle pDashStyle){
  mDashStyle=pDashStyle;
  return this;
}","public PlotLine setDashStyle(DashStyleTemp pDashStyle){
  mDashStyle=pDashStyle;
  return this;
}",0.9789473684210528
43932,"public DashStyle getDashStyle(){
  return mDashStyle;
}","public DashStyleTemp getDashStyle(){
  return mDashStyle;
}",0.9649122807017544
43933,"public JsonElement serialize(Object[] src,Type typeOfSrc,JsonSerializationContext context){
  System.out.println(""String_Node_Str"" + mParser.parse(mGson.toJson(src)).toString());
  return mParser.parse(mGson.toJson(src,typeOfSrc));
}","public JsonElement serialize(ISeries src,Type typeOfSrc,JsonSerializationContext context){
  return mParser.parse(mGson.toJson(src));
}",0.7010869565217391
43934,"public String toJson(){
  String json=""String_Node_Str"";
  json=gson.toJson(this);
  System.out.println(json);
  return json;
}","public String toJson(){
  String json=""String_Node_Str"";
  json=mGson.toJson(this);
  System.out.println(json);
  return json;
}",0.9882352941176472
43935,"SeriesSerializer(){
  GsonBuilder builder=new GsonBuilder().registerTypeAdapter(Object[].class,new ObjectArraySerializer(1)).setPrettyPrinting();
  mGson=builder.create();
}","SeriesSerializer(){
  GsonBuilder builder=new GsonBuilder().setPrettyPrinting();
  mGson=builder.create();
}",0.7686832740213523
43936,ISeries<DataType> setName(String pName);,"/** 
 * Sets the name of the series as shown in the legend, tooltip etc.
 * @param pName the name of the series as shown in the legend, tooltip etc
 * @return this object for convenient chaining, not a copy
 */
ISeries<DataType> setName(String pName);",0.274914089347079
43937,ISeries<DataType> setStack(String pStack);,"/** 
 * Sets the stack identifier for a stacked chart. Series with the same stack identifier will be stacked together.
 * @param pStack the stack identifier for a stacked chart
 * @return this object for convenient chaining, not a copy
 */
ISeries<DataType> setStack(String pStack);",0.2592592592592592
43938,ISeries<DataType> setXAxis(Integer pXAxis);,"/** 
 * Sets the id of the connected xAxis. When using dual or multiple xAxes, this number defines which xAxis the particular series is connected to. It refers to the index of the axis in the xAxis array, which begins with 0.
 * @param pXAxis the id of the connected xAxis
 * @return this object for convenient chaining, not a copy
 */
ISeries<DataType> setXAxis(Integer pXAxis);",0.2037914691943128
43939,Integer getYAxis();,"/** 
 * Gets the id of the connected yAxis. When using dual or multiple yAxes, this number defines which yAxis the particular series is connected to. It refers to the index of the axis in the yAxis array, which begins with 0.
 * @return the id of the connected yAxis
 */
Integer getYAxis();",0.1229773462783171
43940,String getName();,"/** 
 * Gets the name of the series as shown in the legend, tooltip etc.
 * @return the name of the series as shown in the legend, tooltip etc
 */
String getName();",0.1878453038674033
43941,Type getType();,"/** 
 * Gets the type of this series. If this is set, the default type of your chart will be ignored for this series.
 * @return the type of this series.
 * @see com.comsysto.insight.model.options.Type
 */
Type getType();",0.1271186440677966
43942,ISeries<DataType> setData(DataType pData);,"/** 
 * Sets an array of data points for this series. The concrete implementation of this interface defines which kind of data is allowed, read its JavaDocs for detailed information. To see which data are generally supported by Highcharts, look at href=""http://www.highcharts.com/ref/#series.
 * @param pData an array of data points for this series
 * @return this object for convenient chaining, not a copy
 */
ISeries<DataType> setData(DataType pData);",0.1693548387096774
43943,String getStack();,"/** 
 * Gets the stack identifier for a stacked chart. Series with the same stack identifier will be stacked together.
 * @return stack identifier for a stacked chart
 */
String getStack();",0.1739130434782608
43944,Integer getXAxis();,"/** 
 * Gets the id of the connected xAxis. When using dual or multiple xAxes, this number defines which xAxis the particular series is connected to. It refers to the index of the axis in the xAxis array, which begins with 0.
 * @return the id of the connected X-axis
 */
Integer getXAxis();",0.1225806451612903
43945,ISeries<DataType> setType(Type pType);,"/** 
 * Sets the type of this series. If you set this, the default type of your chart will be ignored for this series.
 * @param pType the type of this series
 * @return this object for convenient chaining, not a copy
 * @see com.comsysto.insight.model.options.Type
 */
ISeries<DataType> setType(Type pType);",0.2196531791907514
43946,ISeries<DataType> setYAxis(Integer pYAxis);,"/** 
 * Sets the id of the connected YAxis. When using dual or multiple YAxes, this number defines which xAxis the particular series is connected to. It refers to the index of the axis in the YAxis array, which begins with 0.
 * @param pYAxis the id of the connected yAxis
 * @return this object for convenient chaining, not a copy
 */
ISeries<DataType> setYAxis(Integer pYAxis);",0.2037914691943128
43947,DataType getData();,"/** 
 * Gets an array of data points for this series. The concrete implementation of this interface defines which kind of data is allowed, read its JavaDocs for detailed information. To see which data are generally supported by Highcharts, look at href=""http://www.highcharts.com/ref/#series.
 * @return an array of data points for the series
 */
DataType getData();",0.0987012987012987
43948,"int indexupvalue(LuaString name,expdesc v){
  int i;
  for (i=0; i < f.nups; i++) {
    if (upvalues[i].k == v.k && upvalues[i].info == v.u.s.info) {
      _assert(f.upvalues[i] == name);
      return i;
    }
  }
  checklimit(f.nups + 1,LUAI_MAXUPVALUES,""String_Node_Str"");
  if (f.upvalues == null || f.nups + 1 > f.upvalues.length)   f.upvalues=realloc(f.upvalues,f.nups * 2 + 1);
  f.upvalues[f.nups]=name;
  _assert(v.k == LexState.VLOCAL || v.k == LexState.VUPVAL);
  upvalues[f.nups]=new upvaldesc();
  upvalues[f.nups].k=(byte)(v.k);
  upvalues[f.nups].info=(byte)(v.u.s.info);
  return f.nups++;
}","int indexupvalue(LuaString name,expdesc v){
  int i;
  for (i=0; i < f.nups; i++) {
    if (upvalues[i].k == v.k && upvalues[i].info == v.u.s.info) {
      _assert(f.upvalues[i] == name);
      return i;
    }
  }
  checklimit(f.nups + 1,LUAI_MAXUPVALUES,""String_Node_Str"");
  if (f.upvalues == null || f.nups + 1 > f.upvalues.length)   f.upvalues=realloc(f.upvalues,f.nups * 2 + 1);
  f.upvalues[f.nups]=name;
  _assert(v.k == LexState.VLOCAL || v.k == LexState.VUPVAL);
  upvalues[f.nups]=new upvaldesc();
  upvalues[f.nups].k=(short)(v.k);
  upvalues[f.nups].info=(short)(v.u.s.info);
  return f.nups++;
}",0.985172981878089
43949,"private Varargs lines(final File f) throws Exception {
  IoLib iter=(IoLib)getClass().newInstance();
  iter.setfenv(f);
  return iter.bindv(""String_Node_Str"",LINES_ITER);
}","private Varargs lines(final File f){
  try {
    IoLib iter=(IoLib)getClass().newInstance();
    iter.setfenv(f);
    return iter.bindv(""String_Node_Str"",LINES_ITER);
  }
 catch (  Exception e) {
    return error(""String_Node_Str"" + e);
  }
}",0.4879227053140096
43950,"protected Varargs oncallv(int opcode,Varargs args){
  File f;
  int n;
  LuaValue v;
  try {
switch (opcode) {
case IO_FLUSH:
      checkopen(output());
    outfile.flush();
  return LuaValue.TRUE;
case IO_TMPFILE:
return tmpFile();
case IO_CLOSE:
f=args.arg1().isnil() ? output() : checkfile(args.arg1());
checkopen(f);
return ioclose(f);
case IO_INPUT:
infile=args.arg1().isnil() ? input() : args.arg1().isstring() ? ioopenfile(args.checkString(1),""String_Node_Str"") : checkfile(args.arg1());
return infile;
case IO_OUTPUT:
outfile=args.arg1().isnil() ? output() : args.arg1().isstring() ? ioopenfile(args.checkString(1),""String_Node_Str"") : checkfile(args.arg1());
return outfile;
case IO_TYPE:
if ((f=optfile(args.arg1())) != null) return f.isclosed() ? CLOSED_FILE : FILE;
return NIL;
case IO_POPEN:
return openProgram(args.checkString(1),args.optString(2,""String_Node_Str""));
case IO_OPEN:
return rawopenfile(args.checkString(1),args.optString(2,""String_Node_Str""));
case IO_LINES:
infile=args.arg1().isnil() ? input() : ioopenfile(args.checkString(1),""String_Node_Str"");
checkopen(infile);
return lines(infile);
case IO_READ:
checkopen(infile);
return ioread(infile,args);
case IO_WRITE:
checkopen(output());
return iowrite(outfile,args);
case FILE_CLOSE:
return ioclose(checkfile(args.arg1()));
case FILE_FLUSH:
checkfile(args.arg1()).flush();
return LuaValue.TRUE;
case FILE_SETVBUF:
f=checkfile(args.arg1());
f.setvbuf(args.checkString(2),args.optint(3,1024));
return LuaValue.TRUE;
case FILE_LINES:
return lines(checkfile(args.arg1()));
case FILE_READ:
f=checkfile(args.arg1());
return ioread(f,args.subargs(2));
case FILE_SEEK:
f=checkfile(args.arg1());
n=f.seek(args.optString(2,""String_Node_Str""),args.optint(3,0));
return valueOf(n);
case FILE_WRITE:
f=checkfile(args.arg1());
return iowrite(f,args.subargs(2));
case IO_INDEX:
v=args.arg(2);
return v.equals(STDOUT) ? output() : v.equals(STDIN) ? input() : v.equals(STDERR) ? errput() : NIL;
case LINES_ITER:
f=checkfile(env);
return freadline(f);
}
}
 catch (Exception ioe) {
return errorresult(ioe);
}
return NONE;
}","protected Varargs oncallv(int opcode,Varargs args){
  File f;
  int n;
  LuaValue v;
  try {
switch (opcode) {
case IO_FLUSH:
      checkopen(output());
    outfile.flush();
  return LuaValue.TRUE;
case IO_TMPFILE:
return tmpFile();
case IO_CLOSE:
f=args.arg1().isnil() ? output() : checkfile(args.arg1());
checkopen(f);
return ioclose(f);
case IO_INPUT:
infile=args.arg1().isnil() ? input() : args.arg1().isstring() ? ioopenfile(args.checkString(1),""String_Node_Str"") : checkfile(args.arg1());
return infile;
case IO_OUTPUT:
outfile=args.arg1().isnil() ? output() : args.arg1().isstring() ? ioopenfile(args.checkString(1),""String_Node_Str"") : checkfile(args.arg1());
return outfile;
case IO_TYPE:
if ((f=optfile(args.arg1())) != null) return f.isclosed() ? CLOSED_FILE : FILE;
return NIL;
case IO_POPEN:
return openProgram(args.checkString(1),args.optString(2,""String_Node_Str""));
case IO_OPEN:
return rawopenfile(args.checkString(1),args.optString(2,""String_Node_Str""));
case IO_LINES:
infile=args.arg1().isnil() ? input() : ioopenfile(args.checkString(1),""String_Node_Str"");
checkopen(infile);
return lines(infile);
case IO_READ:
checkopen(infile);
return ioread(infile,args);
case IO_WRITE:
checkopen(output());
return iowrite(outfile,args);
case FILE_CLOSE:
return ioclose(checkfile(args.arg1()));
case FILE_FLUSH:
checkfile(args.arg1()).flush();
return LuaValue.TRUE;
case FILE_SETVBUF:
f=checkfile(args.arg1());
f.setvbuf(args.checkString(2),args.optint(3,1024));
return LuaValue.TRUE;
case FILE_LINES:
return lines(checkfile(args.arg1()));
case FILE_READ:
f=checkfile(args.arg1());
return ioread(f,args.subargs(2));
case FILE_SEEK:
f=checkfile(args.arg1());
n=f.seek(args.optString(2,""String_Node_Str""),args.optint(3,0));
return valueOf(n);
case FILE_WRITE:
f=checkfile(args.arg1());
return iowrite(f,args.subargs(2));
case IO_INDEX:
v=args.arg(2);
return v.equals(STDOUT) ? output() : v.equals(STDIN) ? input() : v.equals(STDERR) ? errput() : NIL;
case LINES_ITER:
f=checkfile(env);
return freadline(f);
}
}
 catch (IOException ioe) {
return errorresult(ioe);
}
return NONE;
}",0.9995201535508638
43951,"public static final LuaFunction getCallstackFunction(int level){
  return level >= 0 || level < running_thread.calls ? running_thread.callstack[running_thread.calls - level - 1] : null;
}","public static final LuaFunction getCallstackFunction(int level){
  return level > 0 || level < running_thread.calls ? running_thread.callstack[running_thread.calls - level - 1] : null;
}",0.9973190348525468
43952,"private void getinfo(LuaState vm){
  LuaState threadVm=vm;
  CallInfo ci=null;
  LFunction func=null;
  LClosure closure=null;
  String what=""String_Node_Str"";
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  if (vm.gettop() >= 3) {
    what=vm.tostring(3);
  }
  if (vm.isnumber(2)) {
    ci=this.getcallinfo(vm,threadVm,vm.tointeger(2));
    closure=ci.closure;
  }
 else {
    func=vm.checkfunction(2);
    if (func instanceof LClosure)     closure=(LClosure)func;
  }
  vm.resettop();
  LTable info=new LTable();
  vm.pushlvalue(info);
  for (int i=0, n=what.length(); i < n; i++) {
switch (what.charAt(i)) {
case 'S':
{
        info.put(""String_Node_Str"",(closure != null ? closure.p.source : new LString(""String_Node_Str"")));
        info.put(""String_Node_Str"",(closure != null ? closure.p.source.substring(1,closure.p.source.m_length - 1) : new LString(""String_Node_Str"")));
        info.put(""String_Node_Str"",(closure != null ? closure.p.linedefined : 0));
        info.put(""String_Node_Str"",(closure != null ? closure.p.lastlinedefined : 0));
        info.put(""String_Node_Str"",new LString(what));
        break;
      }
case 'l':
{
      info.put(""String_Node_Str"",(ci != null ? ci.pc : 0));
      break;
    }
case 'u':
{
    info.put(""String_Node_Str"",(closure != null ? closure.p.nups : 0));
    info.put(""String_Node_Str"",new LString(what));
    break;
  }
case 'n':
{
  info.put(""String_Node_Str"",new LString(""String_Node_Str""));
  info.put(""String_Node_Str"",new LString(""String_Node_Str""));
  break;
}
case 'f':
{
if (func != null) info.put(""String_Node_Str"",func);
break;
}
case 'L':
{
LTable lines=new LTable();
info.put(""String_Node_Str"",lines);
if (closure != null) for (int j=0, k=1; j < closure.p.lineinfo.length; j++, k++) lines.put(k,LInteger.valueOf(closure.p.lineinfo[j]));
break;
}
}
}
}","private void getinfo(LuaState vm){
  LuaState threadVm=vm;
  CallInfo ci=null;
  LFunction func=null;
  LClosure closure=null;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  String what=vm.optstring(3,""String_Node_Str"");
  if (vm.isnumber(2)) {
    ci=this.getcallinfo(vm,threadVm,vm.tointeger(2));
    closure=ci.closure;
  }
 else {
    func=vm.checkfunction(2);
    if (func instanceof LClosure)     closure=(LClosure)func;
  }
  vm.resettop();
  LTable info=new LTable();
  vm.pushlvalue(info);
  for (int i=0, n=what.length(); i < n; i++) {
switch (what.charAt(i)) {
case 'S':
{
        String s=(closure != null ? closure.p.source.toJavaString() : ""String_Node_Str"");
        info.put(""String_Node_Str"",new LString(s.replace('@','=')));
        info.put(""String_Node_Str"",new LString(s.substring(1)));
        info.put(""String_Node_Str"",(closure != null ? closure.p.linedefined : 0));
        info.put(""String_Node_Str"",(closure != null ? closure.p.lastlinedefined : 0));
        info.put(""String_Node_Str"",new LString(""String_Node_Str""));
        break;
      }
case 'l':
{
      info.put(""String_Node_Str"",currentline(threadVm,ci,func));
      break;
    }
case 'u':
{
    info.put(""String_Node_Str"",(closure != null ? closure.p.nups : 0));
    break;
  }
case 'n':
{
  info.put(""String_Node_Str"",new LString(""String_Node_Str""));
  info.put(""String_Node_Str"",new LString(""String_Node_Str""));
  break;
}
case 'f':
{
info.put(""String_Node_Str"",closure);
break;
}
case 'L':
{
LTable lines=new LTable();
info.put(""String_Node_Str"",lines);
for (int j=threadVm.cc, k=1; j >= 0; --j) if (threadVm.calls[j].closure == func) {
int line=threadVm.debugGetLineNumber(ci);
if (line >= 0) lines.put(k++,LInteger.valueOf(line));
}
break;
}
}
}
}",0.4567015995587424
43953,"private void sethook(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  LFunction func=vm.checkfunction(2);
  LString str=vm.checklstring(3);
  int count=vm.optint(4,0);
  int mask=0;
  for (int i=0; i < str.m_length; i++) switch (str.m_bytes[str.m_offset + i]) {
case 'c':
    mask|=LuaState.LUA_MASKCALL;
  break;
case 'l':
mask|=LuaState.LUA_MASKLINE;
break;
case 'r':
mask|=LuaState.LUA_MASKRET;
break;
}
threadVm.sethook(func,mask,count);
vm.resettop();
}","private void sethook(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  LFunction func=vm.isnoneornil(2) ? null : vm.checkfunction(2);
  String str=vm.optstring(3,""String_Node_Str"");
  int count=vm.optint(4,0);
  int mask=0;
  for (int i=0; i < str.length(); i++) switch (str.charAt(i)) {
case 'c':
    mask|=LuaState.LUA_MASKCALL;
  break;
case 'l':
mask|=LuaState.LUA_MASKLINE;
break;
case 'r':
mask|=LuaState.LUA_MASKRET;
break;
}
threadVm.sethook(func,mask,count);
vm.resettop();
}",0.9146005509641874
43954,"private void traceback(LuaState vm){
  LuaState threadVm=vm;
  int level=1;
  String message=""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  if (vm.gettop() >= 3)   level=vm.optint(3,1);
  if (vm.gettop() >= 2)   message=vm.tostring(2) + ""String_Node_Str"";
  message+=threadVm.getStackTrace(level);
  vm.resettop();
  vm.pushstring(sb.toString());
}","private void traceback(LuaState vm){
  LuaState threadVm=vm;
  int level=1;
  String message=""String_Node_Str"";
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  if (vm.gettop() >= 3)   level=vm.optint(3,1);
  if (vm.gettop() >= 2)   message=vm.tostring(2) + ""String_Node_Str"";
  String trace=threadVm.getStackTrace(level - 1);
  if (trace.endsWith(""String_Node_Str""))   trace=trace.substring(0,trace.length() - 1);
  vm.resettop();
  vm.pushstring(message + trace);
}",0.7399577167019028
43955,"private void debugReturnHooks(int pc){
  if (hookfunc != null && ((hookmask & LUA_MASKRET) != 0)) {
    debugCallHook(LUA_HOOKRET,debugGetLineNumber(calls[cc]));
    hookline=-1;
  }
}","private void debugReturnHooks(){
  if (hookfunc != null && ((hookmask & LUA_MASKRET) != 0)) {
    debugCallHook(LUA_HOOKRET,debugGetLineNumber(calls[cc]));
  }
}",0.9333333333333332
43956,"private int debugGetLineNumber(CallInfo ci){
  int[] lineNumbers=ci.closure.p.lineinfo;
  int pc=getCurrentPc(ci);
  int line=(lineNumbers != null && lineNumbers.length > pc ? lineNumbers[pc] : -1);
  return line;
}","public int debugGetLineNumber(CallInfo ci){
  int[] li=ci.closure.p.lineinfo;
  int pc=ci.pc - 1;
  if (li != null && pc >= 0 && pc < li.length)   return li[pc];
  return -1;
}",0.710997442455243
43957,"private void debugCallHook(int mask,int newline){
  int prevmask=hookmask;
  try {
    hookmask=0;
    this.pushfunction(hookfunc);
switch (mask) {
default :
      this.pushstring(""String_Node_Str"");
    break;
case LUA_HOOKCOUNT:
  this.pushstring(""String_Node_Str"");
break;
case LUA_HOOKCALL:
this.pushstring(""String_Node_Str"");
break;
case LUA_HOOKRET:
this.pushstring(""String_Node_Str"");
break;
case LUA_HOOKTAILRET:
this.pushstring(""String_Node_Str"");
break;
}
this.pushinteger(newline);
this.pcall(2,0,0);
}
  finally {
hookmask=prevmask;
}
}","private void debugCallHook(int mask,int line){
  int prevmask=hookmask;
  int oldtop=top;
  LValue lineval=LNil.NIL;
  try {
    if (cc >= 0)     top=base + this.calls[cc].closure.p.maxstacksize;
    hookmask=0;
    this.pushfunction(hookfunc);
switch (mask) {
case LUA_HOOKCOUNT:
      this.pushstring(""String_Node_Str"");
    break;
case LUA_HOOKCALL:
  this.pushstring(""String_Node_Str"");
break;
case LUA_HOOKRET:
this.pushstring(""String_Node_Str"");
break;
case LUA_HOOKTAILRET:
this.pushstring(""String_Node_Str"");
break;
default :
lineval=LInteger.valueOf(line);
this.pushstring(""String_Node_Str"");
break;
}
this.pushlvalue(lineval);
this.pcall(2,0,0);
}
  finally {
hookmask=prevmask;
top=oldtop;
}
}",0.5830670926517572
43958,"private void debugBytecodeHooks(int pc){
  if (hookfunc != null && (hookmask & LUA_MASKLINE) != 0) {
    int line=debugGetLineNumber(calls[cc]);
    if (line != hookline) {
      hookline=line;
      debugCallHook(LUA_HOOKLINE,line);
    }
    if (hookcount != 0) {
      if (--hookincr <= 0) {
        hookincr=hookcount;
        debugCallHook(LUA_HOOKCOUNT,-1);
      }
    }
  }
}","private void debugBytecodeHooks(int pc){
  if (hookfunc != null && (hookmask & LUA_MASKLINE) != 0) {
    int line=debugGetLineNumber(calls[cc]);
    if ((line != hookline || cc != hookcc) && line >= 0) {
      hookline=line;
      hookcc=cc;
      debugCallHook(LUA_HOOKLINE,line);
    }
    if (hookcount != 0) {
      if (--hookincr <= 0) {
        hookincr=hookcount;
        debugCallHook(LUA_HOOKCOUNT,-1);
      }
    }
  }
}",0.941031941031941
43959,"/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    if (hooksenabled) {
      debugBytecodeHooks(ci.pc);
    }
    i=code[ci.pc++];
    o=(i >> POS_OP) & MAX_OP;
    a=(i >> POS_A) & MAXARG_A;
switch (o) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
val=this.luaV_gettable(rkb,rkc);
this.stack[base + a]=val;
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
ByteArrayOutputStream baos=new ByteArrayOutputStream();
for (int j=b, l=0; j <= c; j++, l++) {
this.stack[base + j].luaConcatTo(baos);
}
this.stack[base + a]=new LString(baos.toByteArray());
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + b);
c=LuaState.GETARG_C(i);
if (hooksenabled) {
debugCallHooks(ci.pc - 1);
}
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) luaV_adjusttop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
if (hooksenabled) {
debugTailReturnHooks(ci.pc - 1);
}
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
luaV_settop_fillabove(base + b);
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (ci.nresults >= 0) luaV_adjusttop(base + ci.nresults);
return;
}
case LuaState.OP_RETURN:
{
if (hooksenabled) {
debugReturnHooks(ci.pc - 1);
}
closeUpVals(base);
b=LuaState.GETARG_B(i) - 1;
if (b >= 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
debugAssert(ci.resultbase + b <= top);
luaV_settop_fillabove(ci.resultbase + b);
if (ci.nresults >= 0) luaV_adjusttop(ci.resultbase + ci.nresults);
calls[cc--]=null;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a].luaToNumber();
limit=this.stack[base + a + 1].luaToNumber();
step=this.stack[base + a + 2].luaToNumber();
if (init.isNil()) error(""String_Node_Str"");
if (limit.isNil()) error(""String_Node_Str"");
if (step.isNil()) error(""String_Node_Str"");
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
this.stack[base + a + 1]=limit;
this.stack[base + a + 2]=step;
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
luaV_settop_fillabove(cb + 3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
luaV_adjusttop(cb + c);
if (!this.stack[cb].isNil()) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
tbl.arrayPresize(offset + b);
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(base + a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=proto.newClosure(cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
luaV_settop_fillabove(base + a + b);
continue;
}
}
}
}","/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    if (hooksenabled) {
      debugBytecodeHooks(ci.pc);
    }
    i=code[ci.pc++];
    o=(i >> POS_OP) & MAX_OP;
    a=(i >> POS_A) & MAXARG_A;
switch (o) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
val=this.luaV_gettable(rkb,rkc);
this.stack[base + a]=val;
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
ByteArrayOutputStream baos=new ByteArrayOutputStream();
for (int j=b, l=0; j <= c; j++, l++) {
this.stack[base + j].luaConcatTo(baos);
}
this.stack[base + a]=new LString(baos.toByteArray());
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + b);
c=LuaState.GETARG_C(i);
if (hooksenabled) {
debugCallHooks();
}
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) luaV_adjusttop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
if (hooksenabled) {
debugTailReturnHooks();
}
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
luaV_settop_fillabove(base + b);
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (ci.nresults >= 0) luaV_adjusttop(base + ci.nresults);
return;
}
case LuaState.OP_RETURN:
{
if (hooksenabled) {
debugReturnHooks();
}
closeUpVals(base);
b=LuaState.GETARG_B(i) - 1;
if (b >= 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
debugAssert(ci.resultbase + b <= top);
luaV_settop_fillabove(ci.resultbase + b);
if (ci.nresults >= 0) luaV_adjusttop(ci.resultbase + ci.nresults);
calls[cc--]=null;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a].luaToNumber();
limit=this.stack[base + a + 1].luaToNumber();
step=this.stack[base + a + 2].luaToNumber();
if (init.isNil()) error(""String_Node_Str"");
if (limit.isNil()) error(""String_Node_Str"");
if (step.isNil()) error(""String_Node_Str"");
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
this.stack[base + a + 1]=limit;
this.stack[base + a + 2]=step;
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
luaV_settop_fillabove(cb + 3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
luaV_adjusttop(cb + c);
if (!this.stack[cb].isNil()) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
tbl.arrayPresize(offset + b);
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(base + a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=proto.newClosure(cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
luaV_settop_fillabove(base + a + b);
continue;
}
}
}
}",0.9982125124131084
43960,"private void debugCallHooks(int pc){
  if (hookfunc != null && ((hookmask & LUA_MASKCALL) != 0)) {
    debugCallHook(LUA_HOOKCALL,debugGetLineNumber(calls[cc]));
    hookline=-1;
  }
}","private void debugCallHooks(){
  if (hookfunc != null && ((hookmask & LUA_MASKCALL) != 0)) {
    debugCallHook(LUA_HOOKCALL,debugGetLineNumber(calls[cc]));
  }
}",0.9333333333333332
43961,"private void debugTailReturnHooks(int pc){
  if (hookfunc != null && ((hookmask & LUA_MASKRET) != 0)) {
    debugCallHook(LUA_HOOKTAILRET,debugGetLineNumber(calls[cc]));
    hookline=-1;
  }
}","private void debugTailReturnHooks(){
  if (hookfunc != null && ((hookmask & LUA_MASKRET) != 0)) {
    debugCallHook(LUA_HOOKTAILRET,debugGetLineNumber(calls[cc]));
  }
}",0.9362880886426592
43962,"private void getlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue value=LNil.NIL;
  LValue name=LNil.NIL;
  LocVars[] vars=ci.closure.p.locvars;
  if (local > 0 && local <= ci.top - ci.base) {
    value=threadVm.stack[ci.base + local - 1];
    if (vars != null && local > 0 && local <= vars.length)     name=vars[local - 1].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
  vm.pushlvalue(value);
}","private void getlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  LString name=getlocal(threadVm,threadVm.cc - (level - 1),local);
  if (name != null) {
    LValue value=vm.poplvalue();
    vm.resettop();
    vm.pushlvalue(name);
    vm.pushlvalue(value);
  }
 else {
    vm.resettop();
    vm.pushnil();
  }
}",0.4483091787439613
43963,"private void setlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 5) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  LValue value=vm.topointer(4);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue name=LNil.NIL;
  LocVars[] vars=ci.closure.p.locvars;
  if (local > 0 && local <= ci.top - ci.base) {
    threadVm.stack[ci.base + local - 1]=value;
    if (vars != null && local > 0 && local <= vars.length)     name=vars[local - 1].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
}","private void setlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 5) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  vm.settop(4);
  LString name=setlocal(threadVm,threadVm.cc - (level - 1),local);
  vm.resettop();
  if (name != null) {
    vm.pushlvalue(name);
  }
 else {
    vm.pushnil();
  }
}",0.4612159329140461
43964,"/** 
 * This utility method implements both string.find and string.match.
 */
static int str_find_aux(LuaState vm,boolean find){
  LString s=vm.checklstring(1);
  LString pat=vm.checklstring(2);
  int init=vm.optint(3,1);
  if (init > 0) {
    init=Math.min(init - 1,s.length());
  }
 else   if (init < 0) {
    init=Math.max(0,s.length() + init);
  }
  boolean fastMatch=find && (vm.toboolean(5) || pat.indexOfAny(SPECIALS) == -1);
  if (fastMatch) {
    int result=s.indexOf(pat,init);
    if (result != -1) {
      vm.pushinteger(result + 1);
      vm.pushinteger(result + pat.length());
      return 2;
    }
  }
 else {
    MatchState ms=new MatchState(vm,s,pat);
    boolean anchor=false;
    int poff=0;
    if (pat.luaByte(0) == '^') {
      anchor=true;
      poff=1;
    }
    int soff=init;
    vm.resettop();
    do {
      int res;
      ms.reset();
      if ((res=ms.match(soff,poff)) != -1) {
        if (find) {
          vm.pushinteger(soff + 1);
          vm.pushinteger(res);
          ms.push_captures(false,soff,res);
        }
 else {
          ms.push_captures(true,soff,res);
        }
        return -1;
      }
    }
 while (soff++ < s.length() && !anchor);
  }
  vm.pushnil();
  return 1;
}","/** 
 * This utility method implements both string.find and string.match.
 */
static int str_find_aux(LuaState vm,boolean find){
  LString s=vm.checklstring(1);
  LString pat=vm.checklstring(2);
  int init=vm.optint(3,1);
  if (init > 0) {
    init=Math.min(init - 1,s.length());
  }
 else   if (init < 0) {
    init=Math.max(0,s.length() + init);
  }
  boolean fastMatch=find && (vm.toboolean(4) || pat.indexOfAny(SPECIALS) == -1);
  if (fastMatch) {
    int result=s.indexOf(pat,init);
    if (result != -1) {
      vm.pushinteger(result + 1);
      vm.pushinteger(result + pat.length());
      return 2;
    }
  }
 else {
    MatchState ms=new MatchState(vm,s,pat);
    boolean anchor=false;
    int poff=0;
    if (pat.luaByte(0) == '^') {
      anchor=true;
      poff=1;
    }
    int soff=init;
    vm.resettop();
    do {
      int res;
      ms.reset();
      if ((res=ms.match(soff,poff)) != -1) {
        if (find) {
          vm.pushinteger(soff + 1);
          vm.pushinteger(res);
          ms.push_captures(false,soff,res);
        }
 else {
          ms.push_captures(true,soff,res);
        }
        return -1;
      }
    }
 while (soff++ < s.length() && !anchor);
  }
  vm.pushnil();
  return 1;
}",0.9991783073130648
43965,"private void getmetatable(LuaState vm){
  LValue object=vm.topointer(2);
  vm.resettop();
  vm.pushlvalue(object.luaGetMetatable());
}","private void getmetatable(LuaState vm){
  LValue object=vm.topointer(2);
  vm.resettop();
  LValue mt=object.luaGetMetatable();
  if (mt != null)   vm.pushlvalue(object.luaGetMetatable());
 else   vm.pushnil();
}",0.7745664739884393
43966,"private void setmetatable(LuaState vm){
  LValue object=vm.topointer(2);
  LValue table=vm.totable(3);
  object.luaSetMetatable(table);
  vm.resettop();
  vm.pushlvalue(object);
}","private void setmetatable(LuaState vm){
  LValue object=vm.topointer(2);
  try {
    if (!vm.isnoneornil(3))     object.luaSetMetatable(vm.checktable(3));
 else     object.luaSetMetatable(null);
    vm.resettop();
    vm.pushboolean(true);
  }
 catch (  LuaErrorException e) {
    vm.resettop();
    vm.pushboolean(false);
    vm.pushstring(e.toString());
  }
}",0.2888888888888888
43967,"private void getupvalue(LuaState vm){
  LFunction func=vm.checkfunction(2);
  int up=vm.checkint(3);
  vm.resettop();
  if (func instanceof LClosure) {
    LClosure c=(LClosure)func;
    if (c.upVals != null && up > 0 && up < c.upVals.length) {
      vm.pushlvalue(c.upVals[up].getValue());
      return;
    }
  }
  vm.pushnil();
}","private void getupvalue(LuaState vm){
  LFunction func=vm.checkfunction(2);
  int up=vm.checkint(3);
  vm.resettop();
  if (func instanceof LClosure) {
    LClosure c=(LClosure)func;
    LString name=findupvalue(c,up);
    if (name != null) {
      vm.pushlstring(name);
      vm.pushlvalue(c.upVals[up - 1].getValue());
      return;
    }
  }
  vm.pushnil();
}",0.7118155619596542
43968,"private void setupvalue(LuaState vm){
  LFunction func=vm.checkfunction(2);
  int up=vm.checkint(3);
  LValue value=vm.topointer(4);
  vm.resettop();
  if (func instanceof LClosure) {
    LClosure c=(LClosure)func;
    if (c.upVals != null && up > 0 && up < c.upVals.length) {
      c.upVals[up].setValue(value);
      if (c.p.upvalues != null && up < c.p.upvalues.length)       vm.pushlvalue(c.p.upvalues[up]);
 else       vm.pushstring(""String_Node_Str"" + up + ""String_Node_Str"");
      return;
    }
  }
  vm.pushnil();
}","private void setupvalue(LuaState vm){
  LFunction func=vm.checkfunction(2);
  int up=vm.checkint(3);
  LValue value=vm.topointer(4);
  vm.resettop();
  if (func instanceof LClosure) {
    LClosure c=(LClosure)func;
    LString name=findupvalue(c,up);
    if (name != null) {
      c.upVals[up - 1].setValue(value);
      vm.pushlstring(name);
      return;
    }
  }
  vm.pushnil();
}",0.5154185022026432
43969,"/** 
 * Valid for tables 
 * @param the new LTable, or null or LNil.NIL to reset the metatable to none
 * @return this if unchanged, or new LTable if copied using weak table 
 */
public LTable luaSetMetatable(LValue metatable){
  throw new LuaErrorException(""String_Node_Str"" + metatable.luaGetTypeName());
}","/** 
 * Valid for tables 
 * @param the new LTable, or null or LNil.NIL to reset the metatable to none
 * @return this if unchanged, or new LTable if copied using weak table 
 */
public LTable luaSetMetatable(LValue metatable){
  throw new LuaErrorException(""String_Node_Str"" + this.luaGetTypeName());
}",0.9787234042553192
43970,"private void getfenv(LuaState vm){
  LValue object=vm.topointer(2);
  LValue env=object.luaGetEnv(null);
  vm.pushlvalue(env != null ? env : LNil.NIL);
}","private void getfenv(LuaState vm){
  LValue object=vm.topointer(2);
  LValue env=object.luaGetEnv(null);
  vm.resettop();
  vm.pushlvalue(env != null ? env : LNil.NIL);
}",0.9473684210526316
43971,"private void setfenv(LuaState vm){
  LValue object=vm.topointer(2);
  LTable table=vm.checktable(3);
  object.luaSetEnv(table);
}","private void setfenv(LuaState vm){
  LValue object=vm.topointer(2);
  LTable table=vm.checktable(3);
  object.luaSetEnv(table);
  vm.settop(1);
}",0.9416058394160584
43972,"private void getlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue value=LNil.NIL;
  LValue name=LNil.NIL;
  if (local >= 0 && local < ci.top - ci.base) {
    value=threadVm.stack[ci.base + local];
    LocVars[] vars=ci.closure.p.locvars;
    if (vars != null && local >= 0 && local < vars.length)     name=vars[local].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
  vm.pushlvalue(value);
}","private void getlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue value=LNil.NIL;
  LValue name=LNil.NIL;
  LocVars[] vars=ci.closure.p.locvars;
  if (local > 0 && local <= ci.top - ci.base) {
    value=threadVm.stack[ci.base + local - 1];
    if (vars != null && local > 0 && local <= vars.length)     name=vars[local - 1].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
  vm.pushlvalue(value);
}",0.9216354344122658
43973,"public static void install(LuaState vm){
  LTable debug=new LTable();
  for (int i=0; i < NAMES.length; i++)   debug.put(NAMES[i],new DebugLib(i + 1));
  vm._G.put(""String_Node_Str"",debug);
  PackageLib.setIsLoaded(""String_Node_Str"",debug);
}","public static void install(LuaState vm){
  LTable debug=new LTable();
  for (int i=1; i < NAMES.length; i++)   debug.put(NAMES[i],new DebugLib(i));
  vm._G.put(""String_Node_Str"",debug);
  PackageLib.setIsLoaded(""String_Node_Str"",debug);
}",0.9875
43974,"private void setlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 4) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  LValue value=vm.topointer(4);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue name=LNil.NIL;
  if (local >= 0 && local < ci.top - ci.base) {
    threadVm.stack[ci.base + local]=value;
    LocVars[] vars=ci.closure.p.locvars;
    if (vars != null && local >= 0 && local < vars.length)     name=vars[local].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
}","private void setlocal(LuaState vm){
  LuaState threadVm=vm;
  if (vm.gettop() >= 5) {
    threadVm=vm.checkthread(2).vm;
    vm.remove(2);
  }
  int level=vm.checkint(2);
  int local=vm.checkint(3);
  LValue value=vm.topointer(4);
  CallInfo ci=getcallinfo(vm,threadVm,level);
  LValue name=LNil.NIL;
  LocVars[] vars=ci.closure.p.locvars;
  if (local > 0 && local <= ci.top - ci.base) {
    threadVm.stack[ci.base + local - 1]=value;
    if (vars != null && local > 0 && local <= vars.length)     name=vars[local - 1].varname;
  }
  vm.resettop();
  vm.pushlvalue(name);
}",0.9175438596491228
43975,"private CallInfo getcallinfo(LuaState vm,LuaState threadVm,int level){
  if (level <= 0 || level > threadVm.cc)   vm.error(""String_Node_Str"");
  int cc=threadVm.cc - (level - 1);
  return threadVm.calls[cc];
}","private CallInfo getcallinfo(LuaState vm,LuaState threadVm,int level){
  --level;
  if (level < 0 || level > threadVm.cc)   vm.error(""String_Node_Str"");
  int cc=threadVm.cc - level;
  return threadVm.calls[cc];
}",0.933649289099526
43976,"public static void main(String[] args) throws IOException {
  Platform.setInstance(new J2sePlatform());
  LuaC.install();
  LuaState vm=Platform.newLuaState();
  boolean interactive=(args.length == 0);
  boolean versioninfo=false;
  boolean processing=true;
  try {
    for (int i=0; i < args.length; i++) {
      if (!processing || !args[i].startsWith(""String_Node_Str"")) {
        break;
      }
 else       if (args[i].length() <= 1) {
        break;
      }
 else {
switch (args[i].charAt(1)) {
case 'e':
          if (++i >= args.length)           usageExit();
        break;
case 'l':
      if (++i >= args.length)       usageExit();
    loadLibrary(vm,args[i]);
  break;
case 'i':
interactive=true;
break;
case 'v':
versioninfo=true;
break;
case '-':
if (args[i].length() > 2) usageExit();
processing=false;
break;
default :
usageExit();
break;
}
}
}
if (versioninfo) System.out.println(version);
processing=true;
for (int i=0; i < args.length; i++) {
if (!processing || !args[i].startsWith(""String_Node_Str"")) {
processScript(vm,new FileInputStream(args[i]),args[i],args,i + 1);
break;
}
 else if (args[i].length() <= 1) {
processScript(vm,System.in,""String_Node_Str"",args,i + 1);
break;
}
 else {
switch (args[i].charAt(1)) {
case 'e':
++i;
processScript(vm,new ByteArrayInputStream(args[i].getBytes()),args[i],null,0);
break;
case '-':
processing=false;
break;
}
}
}
if (interactive) interactiveMode(vm);
}
 catch (IOException ioe) {
System.err.println(ioe.toString());
System.exit(-2);
}
}","public static void main(String[] args) throws IOException {
  Platform.setInstance(new J2sePlatform());
  LuaC.install();
  LuaState vm=Platform.newLuaState();
  boolean interactive=(args.length == 0);
  boolean versioninfo=false;
  boolean processing=true;
  try {
    for (int i=0; i < args.length; i++) {
      if (!processing || !args[i].startsWith(""String_Node_Str"")) {
        break;
      }
 else       if (args[i].length() <= 1) {
        break;
      }
 else {
switch (args[i].charAt(1)) {
case 'e':
          if (++i >= args.length)           usageExit();
        break;
case 'l':
      if (++i >= args.length)       usageExit();
    loadLibrary(vm,args[i]);
  break;
case 'i':
interactive=true;
break;
case 'v':
versioninfo=true;
break;
case '-':
if (args[i].length() > 2) usageExit();
processing=false;
break;
default :
usageExit();
break;
}
}
}
if (versioninfo) System.out.println(version);
processing=true;
for (int i=0; i < args.length; i++) {
if (!processing || !args[i].startsWith(""String_Node_Str"")) {
processScript(vm,new FileInputStream(args[i]),args[i],args,i + 1);
break;
}
 else if (args[i].length() <= 1) {
processScript(vm,System.in,""String_Node_Str"",args,i + 1);
break;
}
 else {
switch (args[i].charAt(1)) {
case 'l':
++i;
break;
case 'e':
++i;
processScript(vm,new ByteArrayInputStream(args[i].getBytes()),args[i],null,0);
break;
case '-':
processing=false;
break;
}
}
}
if (interactive) interactiveMode(vm);
}
 catch (IOException ioe) {
System.err.println(ioe.toString());
System.exit(-2);
}
}",0.9927200529450696
43977,"protected void runTest(String testName) throws IOException, InterruptedException {
  Platform.setInstance(new J2sePlatform());
  LuaState state=Platform.newLuaState();
  LuaC.install();
  LPrototype p=loadScript(state,testName);
  p.source=LString.valueOf(""String_Node_Str"");
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  BaseLib.redirectOutput(outputStream);
  try {
    LClosure c=p.newClosure(state._G);
    state.pushlvalue(c);
    state.call(0,0);
    final String actualOutput=new String(outputStream.toByteArray());
    final String expectedOutput=getExpectedOutput(testName);
    assertEquals(expectedOutput,actualOutput);
  }
  finally {
    BaseLib.restoreStandardOutput();
    outputStream.close();
  }
}","protected void runTest(String testName) throws IOException, InterruptedException {
  Platform.setInstance(new J2sePlatform());
  LuaState state=Platform.newLuaState();
  LuaC.install();
  DebugLib.install(state);
  LPrototype p=loadScript(state,testName);
  p.source=LString.valueOf(""String_Node_Str"");
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  BaseLib.redirectOutput(outputStream);
  try {
    LClosure c=p.newClosure(state._G);
    state.pushlvalue(c);
    state.call(0,0);
    final String actualOutput=new String(outputStream.toByteArray());
    final String expectedOutput=getExpectedOutput(testName);
    assertEquals(expectedOutput,actualOutput);
  }
  finally {
    BaseLib.restoreStandardOutput();
    outputStream.close();
  }
}",0.9820119920053296
43978,"/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    debugHooks(ci.pc);
    i=code[ci.pc++];
    o=(i >> POS_OP) & MAX_OP;
    a=(i >> POS_A) & MAXARG_A;
switch (o) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
val=this.luaV_gettable(rkb,rkc);
this.stack[base + a]=val;
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
ByteArrayOutputStream baos=new ByteArrayOutputStream();
for (int j=b, l=0; j <= c; j++, l++) {
this.stack[base + j].luaConcatTo(baos);
}
this.stack[base + a]=new LString(baos.toByteArray());
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + b);
c=LuaState.GETARG_C(i);
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) luaV_adjusttop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
luaV_settop_fillabove(base + b);
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (ci.nresults >= 0) luaV_adjusttop(base + ci.nresults);
return;
}
case LuaState.OP_RETURN:
{
closeUpVals(base);
b=LuaState.GETARG_B(i) - 1;
if (b >= 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
debugAssert(ci.resultbase + b <= top);
luaV_settop_fillabove(ci.resultbase + b);
if (ci.nresults >= 0) luaV_adjusttop(ci.resultbase + ci.nresults);
--cc;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a].luaToNumber();
limit=this.stack[base + a + 1].luaToNumber();
step=this.stack[base + a + 2].luaToNumber();
if (init.isNil()) error(""String_Node_Str"");
if (limit.isNil()) error(""String_Node_Str"");
if (step.isNil()) error(""String_Node_Str"");
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
this.stack[base + a + 1]=limit;
this.stack[base + a + 2]=step;
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
luaV_settop_fillabove(cb + 3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
luaV_adjusttop(cb + c);
if (!this.stack[cb].isNil()) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
tbl.arrayPresize(offset + b);
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(base + a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=proto.newClosure(cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
luaV_settop_fillabove(base + a + b);
continue;
}
}
}
}","/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    debugHooks(ci.pc);
    i=code[ci.pc++];
    o=(i >> POS_OP) & MAX_OP;
    a=(i >> POS_A) & MAXARG_A;
switch (o) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
val=this.luaV_gettable(table,key);
this.stack[base + a]=val;
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
this.luaV_settable(table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
val=this.luaV_gettable(rkb,rkc);
this.stack[base + a]=val;
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
ByteArrayOutputStream baos=new ByteArrayOutputStream();
for (int j=b, l=0; j <= c; j++, l++) {
this.stack[base + j].luaConcatTo(baos);
}
this.stack[base + a]=new LString(baos.toByteArray());
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + b);
c=LuaState.GETARG_C(i);
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) luaV_adjusttop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b != 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
luaV_settop_fillabove(base + b);
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (ci.nresults >= 0) luaV_adjusttop(base + ci.nresults);
return;
}
case LuaState.OP_RETURN:
{
closeUpVals(base);
b=LuaState.GETARG_B(i) - 1;
if (b >= 0) luaV_settop_fillabove(base + a + b);
 else b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
debugAssert(ci.resultbase + b <= top);
luaV_settop_fillabove(ci.resultbase + b);
if (ci.nresults >= 0) luaV_adjusttop(ci.resultbase + ci.nresults);
calls[cc--]=null;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a].luaToNumber();
limit=this.stack[base + a + 1].luaToNumber();
step=this.stack[base + a + 2].luaToNumber();
if (init.isNil()) error(""String_Node_Str"");
if (limit.isNil()) error(""String_Node_Str"");
if (step.isNil()) error(""String_Node_Str"");
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
this.stack[base + a + 1]=limit;
this.stack[base + a + 2]=step;
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
luaV_settop_fillabove(cb + 3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
luaV_adjusttop(cb + c);
if (!this.stack[cb].isNil()) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
tbl.arrayPresize(offset + b);
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(base + a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=proto.newClosure(cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
luaV_settop_fillabove(base + a + b);
continue;
}
}
}
}",0.9989137813985064
43979,"protected LValue normalizeGet(Object val){
  if (val instanceof WeakReference)   val=((WeakReference)val).get();
 else   if (val != null) {
    LUserData ud=(LUserData)val;
    Object o=((WeakReference)ud.m_instance).get();
    if (o != null)     val=new LUserData(o,ud.m_metatable);
 else     val=LNil.NIL;
  }
  return val == null ? LNil.NIL : (LValue)val;
}","protected LValue normalizeGet(Object val){
  if (val instanceof WeakReference)   val=((WeakReference)val).get();
 else   if (val instanceof LUserData) {
    LUserData ud=(LUserData)val;
    Object o=((WeakReference)ud.m_instance).get();
    if (o != null)     val=new LUserData(o,ud.m_metatable);
 else     val=LNil.NIL;
  }
  return val == null ? LNil.NIL : (LValue)val;
}",0.9631650750341064
43980,"public int compareTo(LString o){
  final byte[] a=this.m_bytes;
  final byte[] b=o.m_bytes;
  int i=this.m_offset;
  int j=o.m_offset;
  final int imax=i + m_length;
  final int jmax=j + o.m_length;
  if (a == b && i == j && imax == jmax)   return 0;
  while (i < imax && j < jmax) {
    if (a[i] != b[i]) {
      return (((int)a[i]) & 0x0FF) - (((int)b[j]) & 0x0FF);
    }
    i++;
    j++;
  }
  return m_length - o.m_length;
}","public int compareTo(LString o){
  final byte[] a=this.m_bytes;
  final byte[] b=o.m_bytes;
  int i=this.m_offset;
  int j=o.m_offset;
  final int imax=i + m_length;
  final int jmax=j + o.m_length;
  if (a == b && i == j && imax == jmax)   return 0;
  while (i < imax && j < jmax) {
    if (a[i] != b[j]) {
      return (((int)a[i]) & 0x0FF) - (((int)b[j]) & 0x0FF);
    }
    i++;
    j++;
  }
  return m_length - o.m_length;
}",0.9976689976689976
43981,"/** 
 * This needs to leave any values returned by yield in the coroutine  on the calling vm stack
 * @param vm
 * @param nargs 
 */
public void resumeFrom(LuaState vm,int nargs){
synchronized (this) {
    if (status == STATUS_DEAD) {
      vm.resettop();
      vm.pushboolean(false);
      vm.pushstring(""String_Node_Str"");
      return;
    }
    LThread prior=running;
    try {
      if (prior != null)       prior.status=STATUS_NORMAL;
      running=this;
      status=STATUS_RUNNING;
      if (thread == null) {
        vm.xmove(threadVm,nargs);
        threadVm.prepStackCall();
        thread=new Thread(this);
        thread.start();
      }
 else {
        threadVm.resettop();
        vm.xmove(threadVm,nargs);
      }
      this.notify();
      this.wait();
      vm.resettop();
      vm.pushboolean(true);
      if (threadVm.cc >= 0) {
        threadVm.xmove(vm,threadVm.gettop() - 1);
      }
 else {
        threadVm.base=0;
        threadVm.xmove(vm,threadVm.gettop());
      }
    }
 catch (    Throwable t) {
      status=STATUS_DEAD;
      vm.resettop();
      vm.pushboolean(false);
      vm.pushstring(""String_Node_Str"" + t);
      this.notify();
    }
 finally {
      running=prior;
    }
  }
}","/** 
 * This needs to leave any values returned by yield in the coroutine  on the calling vm stack
 * @param vm
 * @param nargs 
 */
public void resumeFrom(LuaState vm,int nargs){
synchronized (this) {
    if (status == STATUS_DEAD) {
      vm.resettop();
      vm.pushboolean(false);
      vm.pushstring(""String_Node_Str"");
      return;
    }
    LThread prior=running;
    try {
      if (prior != null)       prior.status=STATUS_NORMAL;
      running=this;
      status=STATUS_RUNNING;
      if (thread == null) {
        vm.xmove(threadVm,nargs);
        threadVm.prepStackCall();
        thread=new Thread(this);
        thread.start();
      }
 else {
        threadVm.resettop();
        vm.xmove(threadVm,nargs);
      }
      this.notify();
      this.wait();
      vm.resettop();
      if (threadVm.cc >= 0) {
        vm.pushboolean(status != STATUS_DEAD);
        threadVm.xmove(vm,threadVm.gettop() - 1);
      }
 else {
        vm.pushboolean(true);
        threadVm.base=0;
        threadVm.xmove(vm,threadVm.gettop());
      }
    }
 catch (    Throwable t) {
      status=STATUS_DEAD;
      vm.resettop();
      vm.pushboolean(false);
      vm.pushstring(""String_Node_Str"" + t);
      this.notify();
    }
 finally {
      running=prior;
    }
  }
}",0.8111155859846959
43982,"private void rehash(){
  final int oldCapacity=hashKeys.length;
  final int newCapacity=(oldCapacity > 0) ? 2 * oldCapacity : MIN_HASH_CAPACITY;
  final LValue[] oldKeys=hashKeys;
  final Object[] oldValues=hashValues;
  hashKeys=new LValue[newCapacity];
  hashValues=new Object[newCapacity];
  for (int i=0; i < oldCapacity; ++i) {
    final LValue k=oldKeys[i];
    if (k != null) {
      final Object v=oldValues[i];
      final int slot=hashFindSlot(k);
      hashKeys[slot]=k;
      hashValues[slot]=v;
    }
  }
}","protected void rehash(){
  final int oldCapacity=hashKeys.length;
  final int newCapacity=(oldCapacity > 0) ? 2 * oldCapacity : MIN_HASH_CAPACITY;
  final LValue[] oldKeys=hashKeys;
  final Object[] oldValues=hashValues;
  hashKeys=new LValue[newCapacity];
  hashValues=new Object[newCapacity];
  for (int i=0; i < oldCapacity; ++i) {
    final LValue k=oldKeys[i];
    if (k != null) {
      final Object v=oldValues[i];
      final int slot=hashFindSlot(k);
      hashKeys[slot]=k;
      hashValues[slot]=v;
    }
  }
}",0.9884615384615384
43983,"private boolean checkLoadFactor(){
  final int hashCapacity=hashKeys.length;
  return (hashCapacity >> 1) >= (hashCapacity - hashEntries);
}","protected boolean checkLoadFactor(){
  final int hashCapacity=hashKeys.length;
  return (hashCapacity >> 1) >= (hashCapacity - hashEntries);
}",0.9716312056737588
43984,"private void hashClearSlot(int i){
  if (hashKeys[i] != null) {
    int j=i;
    int n=hashKeys.length;
    while (hashKeys[j=((j + 1) % n)] != null) {
      final int k=((hashKeys[j].hashCode()) & 0x7FFFFFFF) % n;
      if ((j > i && (k <= i || k > j)) || (j < i && (k <= i && k > j))) {
        hashKeys[i]=hashKeys[j];
        hashValues[i]=hashValues[j];
        i=j;
      }
    }
    --hashEntries;
    hashKeys[i]=null;
    hashValues[i]=null;
    if (hashEntries == 0) {
      hashKeys=NONE;
      hashValues=null;
    }
  }
}","protected void hashClearSlot(int i){
  if (hashKeys[i] != null) {
    int j=i;
    int n=hashKeys.length;
    while (hashKeys[j=((j + 1) % n)] != null) {
      final int k=((hashKeys[j].hashCode()) & 0x7FFFFFFF) % n;
      if ((j > i && (k <= i || k > j)) || (j < i && (k <= i && k > j))) {
        hashKeys[i]=hashKeys[j];
        hashValues[i]=hashValues[j];
        i=j;
      }
    }
    --hashEntries;
    hashKeys[i]=null;
    hashValues[i]=null;
    if (hashEntries == 0) {
      hashKeys=NONE;
      hashValues=null;
    }
  }
}",0.988785046728972
43985,"protected LValue normalizeGet(Object val){
  if (val != null)   val=((WeakReference)val).get();
  return val == null ? LNil.NIL : (LValue)val;
}","protected LValue normalizeGet(Object val){
  if (val instanceof WeakReference)   val=((WeakReference)val).get();
 else   if (val != null) {
    LUserData ud=(LUserData)val;
    Object o=((WeakReference)ud.m_instance).get();
    if (o != null)     val=new LUserData(o,ud.m_metatable);
 else     val=LNil.NIL;
  }
  return val == null ? LNil.NIL : (LValue)val;
}",0.4166666666666667
43986,"protected Object normalizePut(LValue val){
  return val == LNil.NIL ? null : new WeakReference(val);
}","protected Object normalizePut(LValue val){
  if (val.isNil()) {
    return null;
  }
 else   if (val.isUserData()) {
    LUserData ud=(LUserData)val;
    return new LUserData(new WeakReference(ud.m_instance),ud.m_metatable);
  }
 else {
    return new WeakReference(val);
  }
}",0.337730870712401
43987,"/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    debugHooks(ci.pc);
    i=code[ci.pc++];
    a=LuaState.GETARG_A(i);
switch (LuaState.GET_OPCODE(i)) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
top=base + a;
table.luaGetTable(this,table,key);
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
top=base + a;
table.luaGetTable(this,table,key);
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
table.luaSetTable(this,table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
table.luaSetTable(this,table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
top=base + a;
rkb.luaGetTable(this,rkb,rkc);
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
o=LuaState.GET_OPCODE(i);
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
LString[] strings=new LString[numValues];
for (int j=b, l=0; j <= c; j++, l++) {
LString s=this.stack[base + j].luaAsString();
strings[l]=s;
}
this.stack[base + a]=LString.concat(strings);
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
o=LuaState.GET_OPCODE(i);
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) top=base + b;
c=LuaState.GETARG_C(i);
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) adjustTop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b == 0) b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
this.top=base + b;
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (this.nresults >= 0) adjustTop(base + nresults);
return;
}
case LuaState.OP_RETURN:
{
b=LuaState.GETARG_B(i) - 1;
if (b == -1) b=top - (base + a);
closeUpVals(base);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
top=ci.resultbase + b;
if (ci.nresults >= 0) adjustTop(ci.resultbase + ci.nresults);
--cc;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
top=base + a + 3+ 1;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a];
step=this.stack[base + a + 2];
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
adjustTop(cb + 3);
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
adjustTop(cb + c);
if (this.stack[cb] != LNil.NIL) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
top=base + a - 1;
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=new LClosure(proto,cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(proto.upvalues[j],base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
top=base + a + b;
continue;
}
}
}
}","/** 
 * execute instructions up to a yield, return, or call 
 */
public void exec(){
  if (cc < 0)   return;
  int i, a, b, c, o, n, cb;
  LValue rkb, rkc, nvarargs, key, val;
  LValue i0, step, idx, limit, init, table;
  boolean back, body;
  LPrototype proto;
  LClosure newClosure;
  CallInfo ci=calls[cc];
  LClosure cl=ci.closure;
  LPrototype p=cl.p;
  int[] code=p.code;
  LValue[] k=p.k;
  this.base=ci.base;
  while (true) {
    debugAssert(ci == calls[cc]);
    ci.top=top;
    debugHooks(ci.pc);
    i=code[ci.pc++];
    a=LuaState.GETARG_A(i);
switch (LuaState.GET_OPCODE(i)) {
case LuaState.OP_MOVE:
{
        b=LuaState.GETARG_B(i);
        this.stack[base + a]=this.stack[base + b];
        continue;
      }
case LuaState.OP_LOADK:
{
      b=LuaState.GETARG_Bx(i);
      this.stack[base + a]=k[b];
      continue;
    }
case LuaState.OP_LOADBOOL:
{
    b=LuaState.GETARG_B(i);
    c=LuaState.GETARG_C(i);
    this.stack[base + a]=(b != 0 ? LBoolean.TRUE : LBoolean.FALSE);
    if (c != 0)     ci.pc++;
    continue;
  }
case LuaState.OP_LOADNIL:
{
  b=LuaState.GETARG_B(i);
  do {
    this.stack[base + b]=LNil.NIL;
  }
 while ((--b) >= a);
  continue;
}
case LuaState.OP_GETUPVAL:
{
b=LuaState.GETARG_B(i);
this.stack[base + a]=cl.upVals[b].getValue();
continue;
}
case LuaState.OP_GETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
table=cl.env;
top=base + a;
table.luaGetTable(this,table,key);
continue;
}
case LuaState.OP_GETTABLE:
{
b=LuaState.GETARG_B(i);
key=GETARG_RKC(k,i);
table=this.stack[base + b];
top=base + a;
table.luaGetTable(this,table,key);
continue;
}
case LuaState.OP_SETGLOBAL:
{
b=LuaState.GETARG_Bx(i);
key=k[b];
val=this.stack[base + a];
table=cl.env;
table.luaSetTable(this,table,key,val);
continue;
}
case LuaState.OP_SETUPVAL:
{
b=LuaState.GETARG_B(i);
cl.upVals[b].setValue(this.stack[base + a]);
continue;
}
case LuaState.OP_SETTABLE:
{
key=GETARG_RKB(k,i);
val=GETARG_RKC(k,i);
table=this.stack[base + a];
table.luaSetTable(this,table,key,val);
continue;
}
case LuaState.OP_NEWTABLE:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
this.stack[base + a]=new LTable(b,c);
continue;
}
case LuaState.OP_SELF:
{
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
top=base + a;
rkb.luaGetTable(this,rkb,rkc);
this.stack[base + a + 1]=rkb;
continue;
}
case LuaState.OP_ADD:
case LuaState.OP_SUB:
case LuaState.OP_MUL:
case LuaState.OP_DIV:
case LuaState.OP_MOD:
case LuaState.OP_POW:
{
o=LuaState.GET_OPCODE(i);
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
this.stack[base + a]=rkc.luaBinOpUnknown(o,rkb);
continue;
}
case LuaState.OP_UNM:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=rkb.luaUnaryMinus();
continue;
}
case LuaState.OP_NOT:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=(!rkb.toJavaBoolean() ? LBoolean.TRUE : LBoolean.FALSE);
continue;
}
case LuaState.OP_LEN:
{
rkb=GETARG_RKB(k,i);
this.stack[base + a]=LInteger.valueOf(rkb.luaLength());
continue;
}
case LuaState.OP_CONCAT:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int numValues=c - b + 1;
LString[] strings=new LString[numValues];
for (int j=b, l=0; j <= c; j++, l++) {
LString s=this.stack[base + j].luaAsString();
strings[l]=s;
}
this.stack[base + a]=LString.concat(strings);
continue;
}
case LuaState.OP_JMP:
{
ci.pc+=LuaState.GETARG_sBx(i);
continue;
}
case LuaState.OP_EQ:
case LuaState.OP_LT:
case LuaState.OP_LE:
{
o=LuaState.GET_OPCODE(i);
rkb=GETARG_RKB(k,i);
rkc=GETARG_RKC(k,i);
boolean test=rkc.luaBinCmpUnknown(o,rkb);
if (test == (a == 0)) ci.pc++;
continue;
}
case LuaState.OP_TEST:
{
c=LuaState.GETARG_C(i);
if (this.stack[base + a].toJavaBoolean() != (c != 0)) ci.pc++;
continue;
}
case LuaState.OP_TESTSET:
{
rkb=GETARG_RKB(k,i);
c=LuaState.GETARG_C(i);
if (rkb.toJavaBoolean() != (c != 0)) ci.pc++;
 else this.stack[base + a]=rkb;
continue;
}
case LuaState.OP_CALL:
{
this.base+=a;
b=LuaState.GETARG_B(i);
if (b != 0) top=base + b;
c=LuaState.GETARG_C(i);
this.nresults=c - 1;
if (this.stack[base].luaStackCall(this)) return;
if (c > 0) adjustTop(base + c - 1);
base=ci.base;
continue;
}
case LuaState.OP_TAILCALL:
{
closeUpVals(base);
b=LuaState.GETARG_B(i);
if (b == 0) b=top - (base + a);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
this.base=ci.resultbase;
this.top=base + b;
this.nresults=ci.nresults;
--cc;
try {
if (this.stack[base].luaStackCall(this)) {
return;
}
}
 catch (LuaErrorException e) {
cc++;
throw e;
}
if (this.nresults >= 0) adjustTop(base + nresults);
return;
}
case LuaState.OP_RETURN:
{
b=LuaState.GETARG_B(i) - 1;
if (b == -1) b=top - (base + a);
closeUpVals(base);
System.arraycopy(stack,base + a,stack,ci.resultbase,b);
top=ci.resultbase + b;
if (ci.nresults >= 0) adjustTop(ci.resultbase + ci.nresults);
--cc;
return;
}
case LuaState.OP_FORLOOP:
{
i0=this.stack[base + a];
step=this.stack[base + a + 2];
idx=step.luaBinOpUnknown(Lua.OP_ADD,i0);
limit=this.stack[base + a + 1];
back=step.luaBinCmpInteger(Lua.OP_LT,0);
body=(back ? idx.luaBinCmpUnknown(Lua.OP_LE,limit) : limit.luaBinCmpUnknown(Lua.OP_LE,idx));
if (body) {
this.stack[base + a]=idx;
this.stack[base + a + 3]=idx;
top=base + a + 3+ 1;
ci.pc+=LuaState.GETARG_sBx(i);
}
continue;
}
case LuaState.OP_FORPREP:
{
init=this.stack[base + a];
step=this.stack[base + a + 2];
this.stack[base + a]=step.luaBinOpUnknown(Lua.OP_SUB,init);
b=LuaState.GETARG_sBx(i);
ci.pc+=b;
continue;
}
case LuaState.OP_TFORLOOP:
{
cb=base + a + 3;
base=cb;
adjustTop(cb + 3);
System.arraycopy(this.stack,cb - 3,this.stack,cb,3);
c=LuaState.GETARG_C(i);
this.nresults=c;
if (this.stack[cb].luaStackCall(this)) execute();
base=ci.base;
adjustTop(cb + c);
if (this.stack[cb] != LNil.NIL) {
this.stack[cb - 1]=this.stack[cb];
}
 else {
ci.pc++;
}
continue;
}
case LuaState.OP_SETLIST:
{
b=LuaState.GETARG_B(i);
c=LuaState.GETARG_C(i);
int listBase=base + a;
if (b == 0) {
b=top - listBase - 1;
}
if (c == 0) {
c=code[ci.pc++];
}
int offset=(c - 1) * LFIELDS_PER_FLUSH;
LTable tbl=(LTable)this.stack[base + a];
for (int j=1; j <= b; j++) {
tbl.put(offset + j,stack[listBase + j]);
}
top=base + a - 1;
continue;
}
case LuaState.OP_CLOSE:
{
closeUpVals(base + a);
continue;
}
case LuaState.OP_CLOSURE:
{
b=LuaState.GETARG_Bx(i);
proto=cl.p.p[b];
newClosure=new LClosure(proto,cl.env);
for (int j=0; j < newClosure.upVals.length; j++, ci.pc++) {
i=code[ci.pc];
o=LuaState.GET_OPCODE(i);
b=LuaState.GETARG_B(i);
if (o == LuaState.OP_GETUPVAL) {
newClosure.upVals[j]=cl.upVals[b];
}
 else if (o == LuaState.OP_MOVE) {
newClosure.upVals[j]=findUpVal(proto.upvalues[j],base + b);
}
 else {
throw new java.lang.IllegalArgumentException(""String_Node_Str"" + o);
}
}
this.stack[base + a]=newClosure;
continue;
}
case LuaState.OP_VARARG:
{
b=LuaState.GETARG_B(i) - 1;
nvarargs=this.stack[base - 1];
n=nvarargs.toJavaInt();
if (b == LuaState.LUA_MULTRET) {
b=n;
}
checkstack(a + b);
for (int j=0; j < b; j++) this.stack[base + a + j]=(j < n ? this.stack[base - n + j - 1] : LNil.NIL);
top=base + a + b;
continue;
}
}
}
}",0.9994925697716563
43988,"public boolean luaStackCall(LuaState vm){
switch (id) {
case INSTALL:
    install(vm._G);
  break;
case CONCAT:
{
  int n=vm.gettop();
  LTable table=vm.totable(2);
  LString sep=(n >= 3 ? vm.tolstring(3) : null);
  int i=vm.tointeger(4);
  int j=vm.tointeger(5);
  int len=table.luaLength();
  if (i == 0)   i=1;
  if (j == 0)   j=len;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    for (int k=i; k <= j; k++) {
      LValue v=table.get(k);
      v.luaAsString().write(baos);
      if (k < j && sep != null)       sep.write(baos);
    }
    vm.resettop();
    vm.pushlstring(baos.toByteArray());
  }
 catch (  IOException e) {
    vm.error(e.getMessage());
  }
  break;
}
case FOREACH:
case FOREACHI:
{
LTable table=vm.totable(2);
LFunction function=vm.tojavafunction(3);
LValue result=table.foreach(vm,function,id == FOREACHI);
vm.resettop();
vm.pushlvalue(result);
break;
}
case GETN:
{
LTable table=vm.totable(2);
vm.resettop();
vm.pushinteger(table.luaLength());
break;
}
case INSERT:
{
int n=vm.gettop();
LTable table=vm.totable(2);
int pos=(n >= 4 ? vm.tointeger(3) : 0);
LValue value=vm.topointer(-1);
table.luaInsertPos(pos,value);
break;
}
case MAXN:
{
LTable table=vm.totable(2);
vm.resettop();
vm.pushinteger(table.luaMaxN());
break;
}
case REMOVE:
{
int n=vm.gettop();
LTable table=vm.totable(2);
int pos=(n >= 3 ? vm.tointeger(3) : 0);
vm.resettop();
vm.pushlvalue(table.luaRemovePos(pos));
break;
}
case SORT:
{
LTable table=vm.totable(2);
LValue compare=vm.topointer(3);
table.luaSort(vm,compare);
vm.resettop();
break;
}
default :
LuaState.vmerror(""String_Node_Str"");
}
return false;
}","public boolean luaStackCall(LuaState vm){
switch (id) {
case INSTALL:
    install(vm._G);
  break;
case CONCAT:
{
  int n=vm.gettop();
  LTable table=vm.totable(2);
  LString sep=(n >= 3 ? vm.tolstring(3) : null);
  int i=vm.tointeger(4);
  int j=vm.tointeger(5);
  int len=table.luaLength();
  if (i == 0)   i=1;
  if (j == 0)   j=len;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    for (int k=i; k <= j; k++) {
      LValue v=table.get(k);
      v.luaAsString().write(baos);
      if (k < j && sep != null)       sep.write(baos);
    }
    vm.resettop();
    vm.pushlstring(baos.toByteArray());
  }
 catch (  IOException e) {
    vm.error(e.getMessage());
  }
  break;
}
case FOREACH:
case FOREACHI:
{
LTable table=vm.totable(2);
LFunction function=vm.tojavafunction(3);
LValue result=table.foreach(vm,function,id == FOREACHI);
vm.resettop();
vm.pushlvalue(result);
break;
}
case GETN:
{
LTable table=vm.totable(2);
vm.resettop();
vm.pushinteger(table.luaLength());
break;
}
case INSERT:
{
int n=vm.gettop();
LTable table=vm.totable(2);
int pos=(n >= 4 ? vm.tointeger(3) : 0);
LValue value=vm.topointer(-1);
table.luaInsertPos(pos,value);
break;
}
case MAXN:
{
LTable table=vm.totable(2);
vm.resettop();
vm.pushlvalue(table.luaMaxN());
break;
}
case REMOVE:
{
int n=vm.gettop();
LTable table=vm.totable(2);
int pos=(n >= 3 ? vm.tointeger(3) : 0);
vm.resettop();
vm.pushlvalue(table.luaRemovePos(pos));
break;
}
case SORT:
{
LTable table=vm.totable(2);
LValue compare=vm.topointer(3);
table.luaSort(vm,compare);
vm.resettop();
break;
}
default :
LuaState.vmerror(""String_Node_Str"");
}
return false;
}",0.9959987688519544
43989,"public int luaMaxN(){
  return m_arrayEntries;
}","public LValue luaMaxN(){
  LValue result=LInteger.valueOf(0);
  for (int i=m_vector.length - 1; i >= 0; i--) {
    if (m_vector[i] != LNil.NIL) {
      result=LInteger.valueOf(i + 1);
      break;
    }
  }
  if (m_hashKeys != null) {
    final int hlen=m_hashKeys.length;
    for (int i=0; i < hlen; ++i) {
      LValue k=m_hashKeys[i];
      if (k != null && k.luaGetType() == Lua.LUA_TNUMBER) {
        if (k.luaBinCmpUnknown(Lua.OP_LT,result)) {
          result=k;
        }
      }
    }
  }
  return result;
}",0.0886524822695035
43990,"private void resize(int newCapacity){
  final int oldCapacity=m_vector.length;
  LValue[] newVector=new LValue[newCapacity];
  System.arraycopy(m_vector,0,newVector,0,Math.min(oldCapacity,newCapacity));
  if (newCapacity > oldCapacity) {
    if (m_hashKeys != null) {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        int slot=findSlot(i + 1);
        if (m_hashKeys[slot] != null) {
          newVector[i]=m_hashValues[slot];
          m_hashKeys[slot]=null;
          --m_hashEntries;
        }
 else {
          newVector[i]=LNil.NIL;
        }
      }
      if (m_hashEntries == 0) {
        m_hashKeys=null;
        m_hashValues=null;
      }
    }
 else {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        newVector[i]=LNil.NIL;
      }
    }
  }
 else {
    for (int i=newCapacity; i < oldCapacity; ++i) {
      LValue v=m_vector[i];
      if (v != LNil.NIL) {
        if (checkLoadFactor())         rehash();
        final int slot=findSlot(i + 1);
        m_hashKeys[slot]=LInteger.valueOf(i + 1);
        m_hashValues[slot]=v;
        ++m_hashEntries;
      }
    }
  }
  m_vector=newVector;
}","private void resize(int newCapacity){
  final int oldCapacity=m_vector.length;
  LValue[] newVector=new LValue[newCapacity];
  System.arraycopy(m_vector,0,newVector,0,Math.min(oldCapacity,newCapacity));
  if (newCapacity > oldCapacity) {
    for (int i=oldCapacity; i < newCapacity; ++i) {
      if (m_hashKeys != null) {
        int slot=findSlot(i + 1);
        if (m_hashKeys[slot] != null) {
          newVector[i]=m_hashValues[slot];
          clearSlot(slot);
          continue;
        }
      }
      newVector[i]=LNil.NIL;
    }
  }
 else {
    for (int i=newCapacity; i < oldCapacity; ++i) {
      LValue v=m_vector[i];
      if (v != LNil.NIL) {
        if (checkLoadFactor())         rehash();
        final int slot=findSlot(i + 1);
        m_hashKeys[slot]=LInteger.valueOf(i + 1);
        m_hashValues[slot]=v;
        ++m_hashEntries;
      }
    }
  }
  m_vector=newVector;
}",0.5821782178217821
43991,"private void indexError(LuaState vm,LValue nontable){
  vm.error(""String_Node_Str"" + nontable.luaGetTypeName() + ""String_Node_Str"",2);
}","private void indexError(LuaState vm,LValue nontable){
  vm.error(""String_Node_Str"" + nontable.luaGetTypeName() + ""String_Node_Str"",1);
}",0.9926470588235294
43992,"private void resize(int newCapacity){
  final int oldCapacity=m_vector.length;
  LValue[] newVector=new LValue[newCapacity];
  System.arraycopy(m_vector,0,newVector,0,Math.min(oldCapacity,newCapacity));
  if (newCapacity > oldCapacity) {
    if (m_hashKeys != null) {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        int slot=findSlot(i + 1);
        if (m_hashKeys[slot] != null) {
          newVector[i]=m_hashValues[slot];
          m_hashKeys[i]=null;
          --m_hashEntries;
        }
 else {
          newVector[i]=LNil.NIL;
        }
      }
    }
 else {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        newVector[i]=LNil.NIL;
      }
    }
  }
 else {
    for (int i=newCapacity; i < oldCapacity; ++i) {
      LValue v=m_vector[i];
      if (v != LNil.NIL) {
        if (checkLoadFactor())         rehash();
        final int slot=findSlot(i + 1);
        m_hashKeys[slot]=LInteger.valueOf(i + 1);
        m_hashValues[slot]=v;
        ++m_hashEntries;
      }
    }
  }
  m_vector=newVector;
}","private void resize(int newCapacity){
  final int oldCapacity=m_vector.length;
  LValue[] newVector=new LValue[newCapacity];
  System.arraycopy(m_vector,0,newVector,0,Math.min(oldCapacity,newCapacity));
  if (newCapacity > oldCapacity) {
    if (m_hashKeys != null) {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        int slot=findSlot(i + 1);
        if (m_hashKeys[slot] != null) {
          newVector[i]=m_hashValues[slot];
          m_hashKeys[slot]=null;
          --m_hashEntries;
        }
 else {
          newVector[i]=LNil.NIL;
        }
      }
      if (m_hashEntries == 0) {
        m_hashKeys=null;
        m_hashValues=null;
      }
    }
 else {
      for (int i=oldCapacity; i < newCapacity; ++i) {
        newVector[i]=LNil.NIL;
      }
    }
  }
 else {
    for (int i=newCapacity; i < oldCapacity; ++i) {
      LValue v=m_vector[i];
      if (v != LNil.NIL) {
        if (checkLoadFactor())         rehash();
        final int slot=findSlot(i + 1);
        m_hashKeys[slot]=LInteger.valueOf(i + 1);
        m_hashValues[slot]=v;
        ++m_hashEntries;
      }
    }
  }
  m_vector=newVector;
}",0.9550717924965262
43993,"protected void init(LuaState state){
  state.installStandardLibs();
  LuajavaLib.install(state._G);
  LuaC.install();
  if (luaPath != null && luaPath.trim().length() > 0) {
    PackageLib.setLuaPath(luaPath);
  }
}","protected void init(LuaState state){
  state.installStandardLibs();
  LuajavaLib.install(state._G);
  LuaC.install();
  String luaPath=getLuaPath();
  if (luaPath != null && luaPath.trim().length() > 0) {
    PackageLib.setLuaPath(luaPath);
  }
}",0.9327548806941433
43994,"void parse(String[] args) throws ParseException {
  if (args == null || args.length < 1) {
    throw new ParseException(""String_Node_Str"");
  }
  int index=0;
  if (args[index] != null && args[index].startsWith(""String_Node_Str"")) {
    if (args.length < 2) {
      throw new ParseException(""String_Node_Str"");
    }
    this.isDebugMode=true;
    System.setProperty(LuaState.PROPERTY_LUAJ_DEBUG,""String_Node_Str"");
    String debugOptions=args[index];
    debugOptions=debugOptions.substring(2);
    String[] options=debugOptions.split(""String_Node_Str"");
    for (int i=0; options != null && i < options.length; i++) {
      if (options[i].startsWith(CMD_LINE_DEBUG_OPTION_PORT)) {
        String portString=options[i].substring(CMD_LINE_DEBUG_OPTION_PORT.length());
        try {
          this.debugPort=Integer.parseInt(portString);
          System.setProperty(DebugLuaState.PROPERTY_LUAJ_DEBUG_PORT,String.valueOf(debugPort));
          if (this.debugPort <= 0) {
            throw new ParseException(""String_Node_Str"");
          }
        }
 catch (        NumberFormatException e) {
          throw new ParseException(""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (options[i].startsWith(CMD_LINE_DEBUG_OPTION_SUSPEND_ON_START)) {
        String suspendOnStartStr=options[i].substring(CMD_LINE_DEBUG_OPTION_SUSPEND_ON_START.length());
        if (!suspendOnStartStr.equalsIgnoreCase(""String_Node_Str"") && !suspendOnStartStr.equalsIgnoreCase(""String_Node_Str"")) {
          throw new ParseException(""String_Node_Str"");
        }
        this.bSuspendOnStart=Boolean.parseBoolean(suspendOnStartStr);
        System.setProperty(DebugLuaState.PROPERTY_LUAJ_DEBUG_SUSPEND_AT_START,suspendOnStartStr);
      }
 else {
        throw new ParseException(""String_Node_Str"" + debugOptions);
      }
    }
    if (this.debugPort == -1) {
      throw new ParseException(""String_Node_Str"");
    }
    index++;
  }
  if (args[index] != null && args[index].startsWith(""String_Node_Str"")) {
    luaPath=args[index].substring(2);
    index++;
  }
  String[] scriptArgStrs;
  if (index != 0) {
    int scriptArgsCount=args.length - index;
    scriptArgStrs=new String[scriptArgsCount];
    System.arraycopy(args,index,scriptArgStrs,0,scriptArgsCount);
  }
 else {
    scriptArgStrs=args;
  }
  parseScriptArgs(scriptArgStrs);
}","void parse(String[] args) throws ParseException {
  if (args == null || args.length < 1) {
    throw new ParseException(""String_Node_Str"");
  }
  int index=0;
  if (args[index] != null && args[index].startsWith(""String_Node_Str"")) {
    if (args.length < 2) {
      throw new ParseException(""String_Node_Str"");
    }
    this.isDebugMode=true;
    System.setProperty(LuaState.PROPERTY_LUAJ_DEBUG,""String_Node_Str"");
    String debugOptions=args[index];
    debugOptions=debugOptions.substring(2);
    String[] options=debugOptions.split(""String_Node_Str"");
    for (int i=0; options != null && i < options.length; i++) {
      if (options[i].startsWith(CMD_LINE_DEBUG_OPTION_PORT)) {
        String portString=options[i].substring(CMD_LINE_DEBUG_OPTION_PORT.length());
        try {
          this.debugPort=Integer.parseInt(portString);
          System.setProperty(DebugLuaState.PROPERTY_LUAJ_DEBUG_PORT,String.valueOf(debugPort));
          if (this.debugPort <= 0) {
            throw new ParseException(""String_Node_Str"");
          }
        }
 catch (        NumberFormatException e) {
          throw new ParseException(""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (options[i].startsWith(CMD_LINE_DEBUG_OPTION_SUSPEND_ON_START)) {
        String suspendOnStartStr=options[i].substring(CMD_LINE_DEBUG_OPTION_SUSPEND_ON_START.length());
        if (!suspendOnStartStr.equalsIgnoreCase(""String_Node_Str"") && !suspendOnStartStr.equalsIgnoreCase(""String_Node_Str"")) {
          throw new ParseException(""String_Node_Str"");
        }
        this.bSuspendOnStart=Boolean.parseBoolean(suspendOnStartStr);
        System.setProperty(DebugLuaState.PROPERTY_LUAJ_DEBUG_SUSPEND_AT_START,suspendOnStartStr);
      }
 else {
        throw new ParseException(""String_Node_Str"" + debugOptions);
      }
    }
    if (this.debugPort == -1) {
      throw new ParseException(""String_Node_Str"");
    }
    index++;
  }
  String[] scriptArgStrs;
  if (index != 0) {
    int scriptArgsCount=args.length - index;
    scriptArgStrs=new String[scriptArgsCount];
    System.arraycopy(args,index,scriptArgStrs,0,scriptArgsCount);
  }
 else {
    scriptArgStrs=args;
  }
  parseScriptArgs(scriptArgStrs);
}",0.9716670327256752
43995,"String getLuaPath(){
  return this.luaPath;
}","String getLuaPath(){
  return System.getProperty(""String_Node_Str"");
}",0.6260869565217392
43996,"public void run(){
  try {
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.connection=(SocketConnection)Connector.open(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.inStream=connection.openDataInputStream();
    this.outStream=connection.openDataOutputStream();
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.redirectOutputStream=new RedirectOutputStream(this);
    BaseLib.redirectOutput(redirectOutputStream);
    while (!isDisconnected()) {
      byte[] data=null;
      int size=inStream.readInt();
      data=new byte[size];
      inStream.readFully(data);
      DebugMessage request=(DebugMessage)SerializationHelper.deserialize(data);
      if (TRACE)       System.out.println(""String_Node_Str"" + request.toString());
      handleRequest(request);
    }
  }
 catch (  EOFException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
    handleRequest(new DebugMessage(DebugMessageType.reset));
    debugSupport.disconnect(1);
  }
 finally {
    if (redirectOutputStream != null) {
      try {
        redirectOutputStream.close();
      }
 catch (      IOException ignore) {
      }
      BaseLib.restoreStandardOutput();
    }
    dispose();
  }
}","public void run(){
  try {
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.connection=(SocketConnection)Connector.open(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.inStream=connection.openDataInputStream();
    this.outStream=connection.openDataOutputStream();
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.redirectOutputStream=new RedirectOutputStream(this);
    BaseLib.redirectOutput(redirectOutputStream);
    while (!isDisconnected()) {
      byte[] data=null;
      int size=inStream.readInt();
      data=new byte[size];
      inStream.readFully(data);
      DebugMessage request=(DebugMessage)SerializationHelper.deserialize(data);
      if (TRACE)       System.out.println(""String_Node_Str"" + request.toString());
      handleRequest(request);
    }
  }
 catch (  EOFException e) {
    handleRequest(new DebugMessage(DebugMessageType.reset));
  }
catch (  IOException e) {
    e.printStackTrace();
    handleRequest(new DebugMessage(DebugMessageType.reset));
    debugSupport.disconnect(1);
  }
 finally {
    if (redirectOutputStream != null) {
      try {
        redirectOutputStream.close();
      }
 catch (      IOException ignore) {
      }
      BaseLib.restoreStandardOutput();
    }
    dispose();
  }
}",0.9767972613160898
43997,"public void testCommandLineParse(){
  String[] args=null;
  StandardLuaJVM vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertFalse(1044 == vm.getDebugPort());
    assertFalse(true == vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertTrue(1044 == vm.getDebugPort());
    assertFalse(true == vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    vm.run();
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    vm.run();
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(false,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(""String_Node_Str"",vm.getLuaPath());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(""String_Node_Str"",vm.getLuaPath());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
}","public void testCommandLineParse(){
  String[] args=null;
  StandardLuaJVM vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertFalse(1044 == vm.getDebugPort());
    assertFalse(true == vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertTrue(1044 == vm.getDebugPort());
    assertFalse(true == vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    vm.run();
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    vm.run();
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(true,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(false,vm.getSuspendOnStart());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  args=new String[]{""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(""String_Node_Str"",vm.getLuaPath());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  vm=new StandardLuaJVM();
  try {
    vm.parse(args);
    assertEquals(1044,vm.getDebugPort());
    assertEquals(""String_Node_Str"",vm.getLuaPath());
    assertEquals(""String_Node_Str"",vm.getScript());
  }
 catch (  ParseException e) {
    fail(""String_Node_Str"");
  }
}",0.9817837709959782
43998,"public LValue luaBinOpUnknown(int opcode,LValue lhs){
  return arithmeticError(lhs.luaGetTypeName());
}","public LValue luaBinOpUnknown(int opcode,LValue lhs){
  return arithmeticError(luaGetTypeName());
}",0.9801980198019802
43999,"public void run(){
  try {
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.connection=(SocketConnection)Connector.open(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.inStream=connection.openDataInputStream();
    this.outStream=connection.openDataOutputStream();
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.redirectOutputStream=new RedirectOutputStream(this);
    BaseLib.redirectOutput(redirectOutputStream);
    while (!isDisconnected()) {
      byte[] data=null;
      int size=inStream.readInt();
      data=new byte[size];
      inStream.readFully(data);
      DebugMessage request=(DebugMessage)SerializationHelper.deserialize(data);
      if (TRACE)       System.out.println(""String_Node_Str"" + request.toString());
      handleRequest(request);
    }
  }
 catch (  EOFException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
    handleRequest(new DebugMessage(DebugMessageType.reset));
    debugSupport.disconnect(1);
  }
 finally {
    try {
      redirectOutputStream.close();
    }
 catch (    IOException ignore) {
    }
    BaseLib.restoreStandardOutput();
    dispose();
  }
}","public void run(){
  try {
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.connection=(SocketConnection)Connector.open(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.inStream=connection.openDataInputStream();
    this.outStream=connection.openDataOutputStream();
    if (TRACE)     System.out.println(""String_Node_Str"" + host + ""String_Node_Str""+ port);
    this.redirectOutputStream=new RedirectOutputStream(this);
    BaseLib.redirectOutput(redirectOutputStream);
    while (!isDisconnected()) {
      byte[] data=null;
      int size=inStream.readInt();
      data=new byte[size];
      inStream.readFully(data);
      DebugMessage request=(DebugMessage)SerializationHelper.deserialize(data);
      if (TRACE)       System.out.println(""String_Node_Str"" + request.toString());
      handleRequest(request);
    }
  }
 catch (  EOFException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
    handleRequest(new DebugMessage(DebugMessageType.reset));
    debugSupport.disconnect(1);
  }
 finally {
    if (redirectOutputStream != null) {
      try {
        redirectOutputStream.close();
      }
 catch (      IOException ignore) {
      }
      BaseLib.restoreStandardOutput();
    }
    dispose();
  }
}",0.9665338645418328
44000,"public boolean luaStackCall(LuaState vm){
switch (id) {
case PRINT:
{
      int n=vm.gettop();
      for (int i=2; i <= n; i++) {
        if (i > 2)         stdout.print(""String_Node_Str"");
        stdout.print(vm.tostring(i));
      }
      stdout.println();
      vm.resettop();
      break;
    }
case PAIRS:
case IPAIRS:
{
    checkargtype(vm,2,Lua.LUA_TTABLE);
    LTable v=vm.totable(2);
    LValue r=v.luaPairs(id == PAIRS);
    vm.resettop();
    vm.pushlvalue(r);
    break;
  }
case GETMETATABLE:
{
  checkargexists(vm,2,Lua.LUA_TVALUE);
  if (!vm.getmetatable(2)) {
    vm.resettop();
    vm.pushnil();
  }
 else {
    vm.insert(1);
    vm.settop(1);
  }
  break;
}
case SETMETATABLE:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
vm.setmetatable(2);
vm.remove(1);
break;
}
case TYPE:
{
if (vm.gettop() < 2) vm.error(""String_Node_Str"");
LValue v=vm.topointer(2);
vm.resettop();
vm.pushlstring(v.luaGetTypeName());
break;
}
case PCALL:
{
int n=vm.gettop();
int s=vm.pcall(n - 2,Lua.LUA_MULTRET,0);
if (s == 0) {
vm.remove(1);
vm.pushboolean(true);
vm.insert(1);
}
 else {
vm.pushboolean(false);
vm.insert(1);
}
break;
}
case ERROR:
{
vm.error(vm.tostring(2),vm.gettop() >= 3 ? vm.tointeger(3) : 1);
break;
}
case ASSERT:
{
if (!vm.toboolean(2)) vm.error(vm.gettop() > 2 ? vm.tostring(3) : ""String_Node_Str"",0);
vm.remove(1);
break;
}
case LOADFILE:
loadfile(vm,vm.tostring(2));
break;
case TONUMBER:
{
checkargexists(vm,2,Lua.LUA_TVALUE);
switch (vm.type(2)) {
case Lua.LUA_TNUMBER:
break;
case Lua.LUA_TSTRING:
LString s=vm.tolstring(2);
int base=10;
if (vm.isnumber(3)) {
base=vm.tolnumber(3).toJavaInt();
if (base < 2 || base > 36) vm.error(""String_Node_Str"");
}
vm.pushlvalue(s.luaToNumber(base));
break;
default :
vm.pushnil();
break;
}
vm.insert(1);
vm.settop(1);
break;
}
case RAWGET:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
checkargexists(vm,3,Lua.LUA_TVALUE);
LTable t=vm.totable(2);
LValue k=vm.topointer(3);
vm.resettop();
vm.pushlvalue(t.get(k));
}
break;
case RAWSET:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
checkargexists(vm,3,Lua.LUA_TVALUE);
checkargexists(vm,4,Lua.LUA_TVALUE);
LTable t=vm.totable(2);
LValue k=vm.topointer(3);
LValue v=vm.topointer(4);
t.put(k,v);
vm.resettop();
vm.pushlvalue(t);
}
break;
case GETFENV:
{
if (vm.isfunction(2)) {
vm.getfenv(-1);
}
 else {
int i=(vm.isnil(2) ? 1 : vm.tointeger(2));
if (i <= 0) vm.pushlvalue(vm._G);
 else if (i - 1 <= vm.cc) vm.pushlvalue(vm.getStackFrame(i - 1).closure.env);
 else vm.pushnil();
}
vm.insert(1);
vm.settop(1);
break;
}
case SETFENV:
{
LTable t=vm.totable(-1);
if (vm.setfenv(2) != 0) {
vm.remove(1);
break;
}
int i=vm.tointeger(2);
if (i == 0) {
vm._G=t;
vm.resettop();
}
 else {
LClosure c=vm.getStackFrame(i - 1).closure;
c.luaSetEnv(t);
vm.resettop();
vm.pushlvalue(c);
}
break;
}
case SELECT:
{
checkargexists(vm,2,Lua.LUA_TNUMBER);
int n=vm.gettop();
if (vm.isnumber(2)) {
int index=vm.tolnumber(2).toJavaInt();
if (index < 0) index+=n - 1;
if (index <= 0) vm.error(""String_Node_Str"");
if (index >= n) vm.resettop();
 else {
for (int i=0; i <= index; i++) vm.remove(1);
}
}
 else if (vm.tostring(2).equals(""String_Node_Str"")) {
vm.resettop();
vm.pushnumber(n - 2);
}
 else {
vm.error(""String_Node_Str"" + vm.typename(2) + ""String_Node_Str"");
}
break;
}
case COLLECTGARBAGE:
{
String s=vm.tostring(2);
int result=0;
vm.resettop();
if (""String_Node_Str"".equals(s)) System.gc();
 else {
Runtime rt=Runtime.getRuntime();
long used=rt.totalMemory() - rt.freeMemory();
result=(int)(used >> 10);
}
vm.pushnumber(result);
break;
}
case DOFILE:
dofile(vm);
break;
case LOADSTRING:
loadstring(vm,vm.topointer(2),vm.tostring(3));
break;
case LOAD:
load(vm,vm.topointer(2),vm.tostring(3));
break;
case TOSTRING:
{
checkargexists(vm,2,Lua.LUA_TVALUE);
LValue v=vm.topointer(2);
vm.resettop();
vm.pushlvalue(v.luaAsString());
break;
}
case UNPACK:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
LTable list=vm.totable(2);
int n=vm.gettop();
int i=1, j;
if (n >= 3) {
checkargtype(vm,3,Lua.LUA_TNUMBER);
i=vm.tolnumber(3).toJavaInt();
}
if (n >= 4) {
checkargtype(vm,4,Lua.LUA_TNUMBER);
j=vm.tolnumber(4).toJavaInt();
}
 else {
j=list.luaLength();
}
vm.resettop();
vm.checkstack(j + 1 - i);
for (int k=i; k <= j; k++) vm.pushlvalue(list.get(k));
break;
}
case NEXT:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
LTable t=vm.totable(2);
LValue v=vm.topointer(3);
vm.resettop();
t.next(vm,v);
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + id);
}
return false;
}","public boolean luaStackCall(LuaState vm){
switch (id) {
case PRINT:
{
      int n=vm.gettop();
      for (int i=2; i <= n; i++) {
        if (i > 2)         stdout.print(""String_Node_Str"");
        stdout.print(vm.tostring(i));
      }
      stdout.println();
      vm.resettop();
      break;
    }
case PAIRS:
case IPAIRS:
{
    checkargtype(vm,2,Lua.LUA_TTABLE);
    LTable v=vm.totable(2);
    LValue r=v.luaPairs(id == PAIRS);
    vm.resettop();
    vm.pushlvalue(r);
    break;
  }
case GETMETATABLE:
{
  checkargexists(vm,2,Lua.LUA_TVALUE);
  if (!vm.getmetatable(2)) {
    vm.resettop();
    vm.pushnil();
  }
 else {
    vm.insert(1);
    vm.settop(1);
  }
  break;
}
case SETMETATABLE:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
vm.setmetatable(2);
vm.remove(1);
break;
}
case TYPE:
{
if (vm.gettop() < 2) vm.error(""String_Node_Str"");
LValue v=vm.topointer(2);
vm.resettop();
vm.pushlstring(v.luaGetTypeName());
break;
}
case PCALL:
{
int n=vm.gettop();
int s=vm.pcall(n - 2,Lua.LUA_MULTRET,0);
if (s == 0) {
vm.remove(1);
vm.pushboolean(true);
vm.insert(1);
}
 else {
vm.pushboolean(false);
vm.insert(1);
}
break;
}
case ERROR:
{
vm.error(vm.tostring(2),vm.gettop() >= 3 ? vm.tointeger(3) : 1);
break;
}
case ASSERT:
{
if (!vm.toboolean(2)) vm.error(vm.gettop() > 2 ? vm.tostring(3) : ""String_Node_Str"",0);
vm.remove(1);
break;
}
case LOADFILE:
loadfile(vm,vm.tostring(2));
break;
case TONUMBER:
{
checkargexists(vm,2,Lua.LUA_TVALUE);
switch (vm.type(2)) {
case Lua.LUA_TNUMBER:
break;
case Lua.LUA_TSTRING:
LString s=vm.tolstring(2);
int base=10;
if (vm.isnumber(3)) {
base=vm.tolnumber(3).toJavaInt();
if (base < 2 || base > 36) vm.error(""String_Node_Str"");
}
vm.pushlvalue(s.luaToNumber(base));
break;
default :
vm.pushnil();
break;
}
vm.insert(1);
vm.settop(1);
break;
}
case RAWGET:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
checkargexists(vm,3,Lua.LUA_TVALUE);
LTable t=vm.totable(2);
LValue k=vm.topointer(3);
vm.resettop();
vm.pushlvalue(t.get(k));
}
break;
case RAWSET:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
checkargexists(vm,3,Lua.LUA_TVALUE);
checkargexists(vm,4,Lua.LUA_TVALUE);
LTable t=vm.totable(2);
LValue k=vm.topointer(3);
LValue v=vm.topointer(4);
t.put(k,v);
vm.resettop();
vm.pushlvalue(t);
}
break;
case GETFENV:
{
if (vm.isfunction(2)) {
vm.getfenv(-1);
}
 else {
int i=(vm.isnil(2) ? 1 : vm.tointeger(2));
if (i <= 0) vm.pushlvalue(vm._G);
 else if (i - 1 <= vm.cc) vm.pushlvalue(vm.getStackFrame(i - 1).closure.env);
 else vm.pushnil();
}
vm.insert(1);
vm.settop(1);
break;
}
case SETFENV:
{
LTable t=vm.totable(-1);
if (vm.setfenv(2) != 0) {
vm.remove(1);
break;
}
int i=vm.tointeger(2);
if (i == 0) {
vm._G=t;
vm.resettop();
}
 else {
LClosure c=vm.getStackFrame(i - 1).closure;
c.luaSetEnv(t);
vm.resettop();
vm.pushlvalue(c);
}
break;
}
case SELECT:
{
checkargexists(vm,2,Lua.LUA_TNUMBER);
int n=vm.gettop();
if (vm.isnumber(2)) {
int index=vm.tolnumber(2).toJavaInt();
if (index < 0) index+=n - 1;
if (index <= 0) vm.error(""String_Node_Str"");
if (index >= n) vm.resettop();
 else {
for (int i=0; i <= index; i++) vm.remove(1);
}
}
 else if (vm.tostring(2).equals(""String_Node_Str"")) {
vm.resettop();
vm.pushnumber(n - 2);
}
 else {
vm.error(""String_Node_Str"" + vm.typename(2) + ""String_Node_Str"");
}
break;
}
case COLLECTGARBAGE:
{
String s=vm.tostring(2);
int result=0;
vm.resettop();
if (""String_Node_Str"".equals(s)) System.gc();
 else {
Runtime rt=Runtime.getRuntime();
long used=rt.totalMemory() - rt.freeMemory();
result=(int)(used >> 10);
}
vm.pushnumber(result);
break;
}
case DOFILE:
dofile(vm);
break;
case LOADSTRING:
loadstring(vm,vm.topointer(2),vm.tostring(3));
break;
case LOAD:
load(vm,vm.topointer(2),vm.tostring(3));
break;
case TOSTRING:
{
checkargexists(vm,2,Lua.LUA_TVALUE);
LValue v=vm.topointer(2);
vm.resettop();
vm.pushlvalue(v.luaAsString());
break;
}
case UNPACK:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
LTable list=vm.totable(2);
int n=vm.gettop();
int i=1, j;
if (n >= 3) {
checkargtype(vm,3,Lua.LUA_TNUMBER);
i=vm.tolnumber(3).toJavaInt();
}
if (n >= 4) {
checkargtype(vm,4,Lua.LUA_TNUMBER);
j=vm.tolnumber(4).toJavaInt();
}
 else {
j=list.luaLength();
}
vm.resettop();
vm.checkstack(j + 1 - i);
for (int k=i; k <= j; k++) vm.pushlvalue(list.get(k));
break;
}
case NEXT:
{
checkargtype(vm,2,Lua.LUA_TTABLE);
LTable t=vm.totable(2);
LValue v=vm.topointer(3);
vm.resettop();
t.next(vm,v);
break;
}
default :
LuaState.vmerror(""String_Node_Str"");
}
return false;
}",0.9946862634256642
