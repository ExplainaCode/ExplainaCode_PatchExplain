record_number,buggy_code,fixed_code,code_similarity
108001,"/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    definition.resetAttributeType(attr);
    definition.resetHierarchy(attr);
    definition.resetHierarchyBuilder(attr);
    definition.resetMaximumGeneralization(attr);
    definition.resetMicroAggregationFunction(attr);
    definition.resetMinimumGeneralization(attr);
    if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
      definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
    }
 else {
      definition.setHierarchy(attr,(HierarchyBuilder<?>)null);
    }
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy != null && hierarchy.getHierarchy() != null) {
      definition.setHierarchy(attr,hierarchy);
    }
    definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      definition.setMicroAggregationFunction(attr,null);
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min != null) {
        definition.setMinimumGeneralization(attr,min);
      }
      if (max != null) {
        definition.setMaximumGeneralization(attr,max);
      }
    }
  }
  if (this.differentialPrivacyModel != null && this.differentialPrivacyModel.isEnabled()) {
    config.addCriterion(this.differentialPrivacyModel.getCriterion(this));
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.kMapModel != null && this.kMapModel.isEnabled()) {
    config.addCriterion(this.kMapModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  Entry<String,ModelDDisclosurePrivacyCriterion> entry : this.dDisclosurePrivacyModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class) || !config.containsCriterion(KMap.class)) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    definition.resetAttributeType(attr);
    definition.resetHierarchy(attr);
    definition.resetHierarchyBuilder(attr);
    definition.resetMaximumGeneralization(attr);
    definition.resetMicroAggregationFunction(attr);
    definition.resetMinimumGeneralization(attr);
    if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
      definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
    }
 else {
      definition.setHierarchy(attr,(HierarchyBuilder<?>)null);
    }
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy != null && hierarchy.getHierarchy() != null) {
      definition.setHierarchy(attr,hierarchy);
    }
    definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      definition.setMicroAggregationFunction(attr,null);
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min != null) {
        definition.setMinimumGeneralization(attr,min);
      }
      if (max != null) {
        definition.setMaximumGeneralization(attr,max);
      }
    }
  }
  if (this.differentialPrivacyModel != null && this.differentialPrivacyModel.isEnabled()) {
    config.addCriterion(this.differentialPrivacyModel.getCriterion(this));
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.kMapModel != null && this.kMapModel.isEnabled()) {
    config.addCriterion(this.kMapModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  Entry<String,ModelDDisclosurePrivacyCriterion> entry : this.dDisclosurePrivacyModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class) || !config.containsCriterion(KMap.class) || (config.containsCriterion(KMap.class) && !config.getCriterion(KMap.class).isAccurate())) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9887944834380002
108002,"@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.input=input;
  c.min=new HashMap<String,Integer>(min);
  c.max=new HashMap<String,Integer>(max);
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  if (this.containsCriterion(DPresence.class)) {
    c.researchSubset=this.getCriterion(DPresence.class).getSubset().getSet();
  }
 else   if (this.containsCriterion(KMap.class)) {
    c.researchSubset=this.getCriterion(KMap.class).getSubset().getSet();
  }
 else {
    c.researchSubset=this.researchSubset.clone();
  }
  c.suppressionWeight=this.suppressionWeight;
  c.microAggregationFunctions=new HashMap<String,MicroAggregationFunctionDescription>(microAggregationFunctions);
  c.microAggregationIgnoreMissingData=new HashMap<String,Boolean>(microAggregationIgnoreMissingData);
  c.transformationModes=new HashMap<String,ModelTransformationMode>(transformationModes);
  return c;
}","@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.input=input;
  c.min=new HashMap<String,Integer>(min);
  c.max=new HashMap<String,Integer>(max);
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  if (this.containsCriterion(DPresence.class)) {
    c.researchSubset=this.getCriterion(DPresence.class).getSubset().getSet();
  }
 else   if (this.containsCriterion(KMap.class) && this.getCriterion(KMap.class).isAccurate()) {
    c.researchSubset=this.getCriterion(KMap.class).getSubset().getSet();
  }
 else {
    c.researchSubset=this.researchSubset.clone();
  }
  c.suppressionWeight=this.suppressionWeight;
  c.microAggregationFunctions=new HashMap<String,MicroAggregationFunctionDescription>(microAggregationFunctions);
  c.microAggregationIgnoreMissingData=new HashMap<String,Boolean>(microAggregationIgnoreMissingData);
  c.transformationModes=new HashMap<String,ModelTransformationMode>(transformationModes);
  return c;
}",0.9769076305220884
108003,"/** 
 * Creates a new instance
 * @param k
 */
public ModelKMapCriterion(int k){
  super();
  this.k=k;
}","/** 
 * Creates a new instance
 * @param k
 */
public ModelKMapCriterion(int k){
  super();
  this.k=k;
  this.estimator=null;
}",0.9012875536480688
108004,"@Override public PrivacyCriterion getCriterion(Model model){
  DataSubset subset=DataSubset.create(model.getInputConfig().getInput(),model.getInputConfig().getResearchSubset());
  return new KMap(k,subset);
}","@Override public PrivacyCriterion getCriterion(Model model){
  if (estimator == null) {
    DataSubset subset=DataSubset.create(model.getInputConfig().getInput(),model.getInputConfig().getResearchSubset());
    return new KMap(k,subset);
  }
 else {
    ModelRisk riskModel=model.getRiskModel();
    return new KMap(k,significanceLevel,riskModel.getPopulationModel(),estimator);
  }
}",0.7027027027027027
108005,"@Override public ModelKMapCriterion clone(){
  ModelKMapCriterion result=new ModelKMapCriterion();
  result.k=this.k;
  result.setEnabled(this.isEnabled());
  return result;
}","@Override public ModelKMapCriterion clone(){
  ModelKMapCriterion result=new ModelKMapCriterion();
  result.k=this.k;
  result.setEnabled(this.isEnabled());
  result.setEstimator(this.estimator);
  return result;
}",0.8997429305912596
108006,"@Override public String toString(){
  return SWTUtil.getPrettyString(k) + Resources.getMessage(""String_Node_Str"");
}","@Override public String toString(){
  String value=SWTUtil.getPrettyString(k) + Resources.getMessage(""String_Node_Str"");
  if (estimator != null) {
    value+=""String_Node_Str"" + estimator + ""String_Node_Str""+ SWTUtil.getPrettyString(significanceLevel)+ ""String_Node_Str"";
  }
  return value;
}",0.5317073170731708
108007,"@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelKMapCriterion)) {
    return;
  }
  ModelKMapCriterion other=(ModelKMapCriterion)criterion;
  this.k=other.k;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelKMapCriterion)) {
    return;
  }
  ModelKMapCriterion other=(ModelKMapCriterion)criterion;
  this.k=other.k;
  this.setEnabled(other.isEnabled());
  this.setEstimator(other.estimator);
  this.significanceLevel=other.significanceLevel;
}",0.8528428093645485
108008,"/** 
 * Returns whether local recoding can be applied to the given handle
 * @param handle
 * @return
 */
public boolean isOptimizable(DataHandle handle){
  if (!(handle instanceof DataHandleOutput)) {
    return false;
  }
  DataHandleOutput output=(DataHandleOutput)handle;
  if (output.getInputBuffer() == null || !output.getInputBuffer().equals(this.checker.getInputBuffer())) {
    return false;
  }
  Set<Class<?>> supportedModels=getOptimizablePrivacyModels();
  for (  PrivacyCriterion c : config.getCriteria()) {
    if (!supportedModels.contains(c.getClass())) {
      return false;
    }
  }
  int outliers=0;
  for (int row=0; row < output.getNumRows(); row++) {
    if (output.isOutlier(row)) {
      outliers++;
    }
  }
  if (config.getMinimalGroupSize() != Integer.MAX_VALUE && outliers < config.getMinimalGroupSize()) {
    return false;
  }
  return true;
}","/** 
 * Returns whether local recoding can be applied to the given handle
 * @param handle
 * @return
 */
public boolean isOptimizable(DataHandle handle){
  if (!(handle instanceof DataHandleOutput)) {
    return false;
  }
  DataHandleOutput output=(DataHandleOutput)handle;
  if (output.getInputBuffer() == null || !output.getInputBuffer().equals(this.checker.getInputBuffer())) {
    return false;
  }
  Set<Class<?>> supportedModels=getOptimizablePrivacyModels();
  for (  PrivacyCriterion c : config.getCriteria()) {
    if (!supportedModels.contains(c.getClass())) {
      return false;
    }
  }
  int outliers=0;
  for (int row=0; row < output.getNumRows(); row++) {
    if (output.isOutlier(row)) {
      outliers++;
    }
  }
  if (config.getMinimalGroupSize() != Integer.MAX_VALUE && outliers < config.getMinimalGroupSize()) {
    return false;
  }
  if (outliers == 0) {
    return false;
  }
  return true;
}",0.9604897050639956
108009,"/** 
 * Clones this config and projects everything onto the given subset.<br> - All privacy models will be cloned<br> - Subsets in d-presence will be projected accordingly<br> - Utility measures will be cloned<br>
 * @param gsFactor 
 * @return
 */
protected ARXConfiguration getSubsetInstance(RowSet rowset,double gsFactor){
  ARXConfiguration result=this.clone();
  result.aCriteria=null;
  HashSet<PrivacyCriterion> criteria=new HashSet<PrivacyCriterion>();
  for (  PrivacyCriterion criterion : result.criteria) {
    PrivacyCriterion clone=null;
    if (criterion instanceof Inclusion) {
      clone=new Inclusion(((Inclusion)criterion).getSubset().getSubsetInstance(rowset));
    }
 else     if (criterion instanceof DPresence) {
      clone=new DPresence(((DPresence)criterion).getDMin(),((DPresence)criterion).getDMax(),((DPresence)criterion).getSubset().getSubsetInstance(rowset));
    }
 else     if (criterion instanceof KMap && ((KMap)criterion).isAccurate()) {
      clone=new KMap(((KMap)criterion).getK(),((KMap)criterion).getSubset().getSubsetInstance(rowset));
    }
 else {
      clone=criterion.clone();
    }
    criteria.add(clone);
  }
  result.criteria=criteria;
  MetricConfiguration utilityConfig=result.getMetric().getConfiguration();
  utilityConfig.setGsFactor(gsFactor);
  result.metric=result.getMetric().getDescription().createInstance(utilityConfig);
  return result;
}","/** 
 * Clones this config and projects everything onto the given subset.<br> - All privacy models will be cloned<br> - Subsets in d-presence will be projected accordingly<br> - Utility measures will be cloned<br> - Replaces estimated k-map with according k-anonymity<br>
 * @param gsFactor 
 * @return
 */
protected ARXConfiguration getSubsetInstance(RowSet rowset,double gsFactor){
  ARXConfiguration result=this.clone();
  result.aCriteria=null;
  HashSet<PrivacyCriterion> criteria=new HashSet<PrivacyCriterion>();
  for (  PrivacyCriterion criterion : result.criteria) {
    PrivacyCriterion clone=null;
    if (criterion instanceof Inclusion) {
      clone=new Inclusion(((Inclusion)criterion).getSubset().getSubsetInstance(rowset));
    }
 else     if (criterion instanceof DPresence) {
      clone=new DPresence(((DPresence)criterion).getDMin(),((DPresence)criterion).getDMax(),((DPresence)criterion).getSubset().getSubsetInstance(rowset));
    }
 else     if (criterion instanceof KMap) {
      if (((KMap)criterion).isAccurate()) {
        clone=new KMap(((KMap)criterion).getK(),((KMap)criterion).getSubset().getSubsetInstance(rowset));
      }
 else {
        clone=new KAnonymity(((KMap)criterion).getDerivedK());
      }
    }
 else {
      clone=criterion.clone();
    }
    criteria.add(clone);
  }
  result.criteria=criteria;
  MetricConfiguration utilityConfig=result.getMetric().getConfiguration();
  utilityConfig.setGsFactor(gsFactor);
  result.metric=result.getMetric().getDescription().createInstance(utilityConfig);
  return result;
}",0.9442379182156134
108010,"/** 
 * Creates a new instance
 */
void CellSizeEstimator(String label){
  this.label=label;
}","/** 
 * Creates a new instance 
 */
void CellSizeEstimator(String label){
  this.label=label;
}",0.9947089947089948
108011,"/** 
 * Calculates k, based on Zero-truncated Poisson distribution. https://en.wikipedia.org/wiki/Zero-truncated_Poisson_distribution
 * @param lambda
 * @return
 */
private int calculateKZeroPoisson(double lambda){
  final double threshold=1d - this.significanceLevel;
  final PoissonDistribution distribution=new PoissonDistribution(lambda);
  final double v2=1d - distribution.cumulativeProbability(0);
  int counter=0;
  double value=0;
  while (value < threshold) {
    value=distribution.cumulativeProbability(counter) / v2;
    counter++;
  }
  this.type1Error=1d - value;
  return counter + 1;
}","/** 
 * Calculates k, based on Zero-truncated Poisson distribution. https://en.wikipedia.org/wiki/Zero-truncated_Poisson_distribution
 * @param lambda
 * @return
 */
private int calculateKZeroPoisson(double lambda){
  final double threshold=1d - this.significanceLevel;
  final PoissonDistribution distribution=new PoissonDistribution(lambda);
  final double v2=1d - distribution.probability(0);
  int counter=1;
  double value=0d;
  while (value < threshold) {
    value+=distribution.probability(counter) / v2;
    counter++;
  }
  this.type1Error=1d - value;
  return counter;
}",0.920608108108108
108012,"@Override public void reset(){
  if (stack != null)   stack.setLayer(0);
  if (cmbType != null && cmbType.getItemCount() != 0)   cmbType.select(0);
  if (cmbMode != null && cmbMode.getItemCount() != 0)   cmbMode.select(0);
  if (cmbMin != null && cmbMin.getItemCount() != 0)   cmbMin.select(0);
  if (cmbMax != null && cmbMax.getItemCount() != 0)   cmbMax.select(cmbMax.getItemCount() - 1);
  if (cmbFunction != null && cmbFunction.getItemCount() != 0)   cmbFunction.select(0);
  if (hierarchy != null)   hierarchy.actionClear();
  SWTUtil.disable(root);
}","@Override public void reset(){
  if (stack != null)   stack.setLayer(0);
  if (cmbType != null && cmbType.getItemCount() != 0)   cmbType.select(0);
  if (cmbMode != null && cmbMode.getItemCount() != 0)   cmbMode.select(0);
  if (cmbMin != null && cmbMin.getItemCount() != 0)   cmbMin.select(0);
  if (cmbMax != null && cmbMax.getItemCount() != 0)   cmbMax.select(cmbMax.getItemCount() - 1);
  if (cmbFunction != null && cmbFunction.getItemCount() != 0)   cmbFunction.select(0);
  if (hierarchy != null)   hierarchy.actionReset();
  SWTUtil.disable(root);
}",0.9910071942446044
108013,"/** 
 * @return
 */
@Parameters(name=""String_Node_Str"") public static Collection<Object[]> cases(){
  return Arrays.asList(new Object[][]{{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.5458823600135303,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.5678822604487141,new int[]{1,3,1,2,2,2,2,2,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.24946764318372394,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.31533166356032827,new int[]{1,2,1,1,2,1,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.48108529511189313,new int[]{1,2,1,1,2,1,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.45968085397145253,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.3927633276919862,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.5214350040632107,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.8600566149273767,new int[]{2,2,0,1,0,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.583207075673521,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.8600566149273767,new int[]{2,2,0,1,0,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.5449600312561718,new int[]{3,2,1,1,1,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.48692660053630354,new int[]{2,1,1,1,0,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.29200173854856404,new int[]{4,2,2,2,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.3265073816878079,new int[]{2,1,1,1,0,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.31414347743722537,new int[]{3,1,2,2,1,1,2,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.42130683838030025,new int[]{4,2,2,2,1,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.22028022469834752,new int[]{3,1,2,2,1,1,2,1},false)}});
}","/** 
 * Create tests
 * @return
 */
@Parameters(name=""String_Node_Str"") public static Collection<Object[]> cases(){
  return Arrays.asList(new Object[][]{{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.6820705793543056,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.8112222411559193,new int[]{1,3,1,2,2,2,2,2,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.7437618217405468,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.6092780386290699,new int[]{1,2,1,1,2,1,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.5968589299712612,new int[]{1,2,1,1,2,1,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.6856395441402736,new int[]{0,2,0,1,1,1,1,1,0},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.8261910998091719,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.8499906952842589,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",1.0000000000000004,new int[]{2,2,0,1,0,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.7606582708058056,new int[]{3,2,1,1,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",1.0000000000000004,new int[]{2,2,0,1,0,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.839519540778112,new int[]{3,2,1,1,1,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(2d,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.5814200080206713,new int[]{2,1,1,1,0,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN2,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.6800577425519756,new int[]{4,2,2,2,1,2,2,2},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-7d,DataGeneralizationScheme.create(GeneralizationDegree.LOW_MEDIUM),true)),""String_Node_Str"",0.5864014933190864,new int[]{2,1,1,1,0,1,1,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.0d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.5d,1E-8d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM),true)),""String_Node_Str"",0.43090885593016726,new int[]{3,1,2,2,1,1,2,1},false)},{new ARXAnonymizationTestCase(ARXConfiguration.create(1d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(LN3,1E-5d,DataGeneralizationScheme.create(GeneralizationDegree.HIGH),true)),""String_Node_Str"",0.6796862034370221,new int[]{4,2,2,2,1,2,2,2},true)},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createLossMetric()).addCriterion(new EDDifferentialPrivacy(1.0d,1E-6d,DataGeneralizationScheme.create(GeneralizationDegree.MEDIUM_HIGH),true)),""String_Node_Str"",0.40463191801066123,new int[]{3,1,2,2,1,1,2,1},false)}});
}",0.9534635188963372
108014,"@Override protected void doUpdate(final AnalysisContextClassification context){
  final StatisticsBuilderInterruptible builder=context.handle.getStatistics().getInterruptibleInstance();
  final StatisticsBuilderInterruptible sourcebuilder=context.model.getInputConfig().getInput().getHandle().getStatistics().getInterruptibleInstance();
  final String[] features=context.model.getSelectedFeatures().toArray(new String[0]);
  final String[] classes=context.model.getSelectedClasses().toArray(new String[0]);
  final double fraction=context.handle.getNumRows() > context.model.getClassificationModel().getMaximalNumberOfRecords() ? (double)context.model.getClassificationModel().getMaximalNumberOfRecords() / (double)context.handle.getNumRows() : 1d;
  final Integer seed=context.model.getClassificationModel().getSeed();
  final boolean ignoreSuppressedRecords=context.model.getClassificationModel().isIgnoreSuppressedRecords();
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private List<Double> accuracies=new ArrayList<>();
    private List<Double> baselineAccuracies=new ArrayList<>();
    private List<Integer> classNumbers=new ArrayList<>();
    private List<Integer> baselineClassNumbers=new ArrayList<>();
    private int progress=0;
    @Override public int getProgress(){
      return (int)((double)progress / (double)classes.length / 4d * 100d);
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : table.getItems()) {
        i.dispose();
      }
      for (int i=0; i < classes.length; i++) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,classes[i]);
        item.setText(1,String.valueOf(classNumbers.get(i)));
        item.setData(""String_Node_Str"",(double)classNumbers.get(i) / (double)baselineClassNumbers.get(i) - 1d);
        item.setData(""String_Node_Str"",accuracies.get(i));
        item.setData(""String_Node_Str"",(double)accuracies.get(i) / (double)baselineAccuracies.get(i) - 1d);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      for (      String clazz : classes) {
        accuracies.add(builder.getClassificationPerformance(features,clazz,seed,ignoreSuppressedRecords,fraction).getFractionCorrect());
        progress++;
        if (stopped) {
          break;
        }
        baselineAccuracies.add(sourcebuilder.getClassificationPerformance(features,clazz,seed,ignoreSuppressedRecords,fraction).getFractionCorrect());
        progress++;
        if (stopped) {
          break;
        }
        baselineClassNumbers.add(sourcebuilder.getDistinctValues(context.handle.getColumnIndexOf(clazz)).length);
        progress++;
        if (stopped) {
          break;
        }
        classNumbers.add(builder.getDistinctValues(context.handle.getColumnIndexOf(clazz)).length);
        progress++;
        if (stopped) {
          break;
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      sourcebuilder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextClassification context){
  final StatisticsBuilderInterruptible builder=context.handle.getStatistics().getInterruptibleInstance();
  final DataHandle sourceHandle;
  if (context.handle instanceof DataHandleSubset) {
    sourceHandle=context.model.getInputConfig().getInput().getHandle().getView();
  }
 else {
    sourceHandle=context.model.getInputConfig().getInput().getHandle();
  }
  final StatisticsBuilderInterruptible sourcebuilder=sourceHandle.getStatistics().getInterruptibleInstance();
  final String[] features=context.model.getSelectedFeatures().toArray(new String[0]);
  final String[] classes=context.model.getSelectedClasses().toArray(new String[0]);
  final double fraction=context.handle.getNumRows() > context.model.getClassificationModel().getMaximalNumberOfRecords() ? (double)context.model.getClassificationModel().getMaximalNumberOfRecords() / (double)context.handle.getNumRows() : 1d;
  final Integer seed=context.model.getClassificationModel().getSeed();
  final boolean ignoreSuppressedRecords=context.model.getClassificationModel().isIgnoreSuppressedRecords();
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private List<Double> accuracies=new ArrayList<>();
    private List<Double> baselineAccuracies=new ArrayList<>();
    private List<Integer> classNumbers=new ArrayList<>();
    private List<Integer> baselineClassNumbers=new ArrayList<>();
    private int progress=0;
    @Override public int getProgress(){
      return (int)((double)progress / (double)classes.length / 4d * 100d);
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : table.getItems()) {
        i.dispose();
      }
      for (int i=0; i < classes.length; i++) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,classes[i]);
        item.setText(1,String.valueOf(classNumbers.get(i)));
        item.setData(""String_Node_Str"",(double)classNumbers.get(i) / (double)baselineClassNumbers.get(i) - 1d);
        item.setData(""String_Node_Str"",accuracies.get(i));
        item.setData(""String_Node_Str"",(double)accuracies.get(i) / (double)baselineAccuracies.get(i) - 1d);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      for (      String clazz : classes) {
        accuracies.add(builder.getClassificationPerformance(features,clazz,seed,ignoreSuppressedRecords,fraction).getFractionCorrect());
        progress++;
        if (stopped) {
          break;
        }
        baselineAccuracies.add(sourcebuilder.getClassificationPerformance(features,clazz,seed,ignoreSuppressedRecords,fraction).getFractionCorrect());
        progress++;
        if (stopped) {
          break;
        }
        baselineClassNumbers.add(sourcebuilder.getDistinctValues(context.handle.getColumnIndexOf(clazz)).length);
        progress++;
        if (stopped) {
          break;
        }
        classNumbers.add(builder.getDistinctValues(context.handle.getColumnIndexOf(clazz)).length);
        progress++;
        if (stopped) {
          break;
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      sourcebuilder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.957957957957958
108015,"/** 
 * Registers a new view
 * @param view
 * @param helpid
 */
private void registerView(ViewStatistics<?> view,String helpid){
  types.put(view.getParent(),view.getType());
  helpids.put(view.getParent(),helpid);
}","/** 
 * Registers a new view
 * @param view
 * @param helpid
 */
private void registerView(ViewStatisticsBasic view,String helpid){
  types.put(view.getParent(),view.getType());
  helpids.put(view.getParent(),helpid);
}",0.981651376146789
108016,"/** 
 * Creates the view.
 * @param group
 */
private void create(final Composite group){
  Tree tree=new Tree(group,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  tree.setHeaderVisible(true);
  treeViewer=new TreeViewer(tree);
  tree.setMenu(new ClipboardHandlerTree(treeViewer).getMenu());
  final TreeColumn column1=new TreeColumn(tree,SWT.LEFT);
  tree.setLinesVisible(true);
  column1.setAlignment(SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(160);
  final TreeColumn column2=new TreeColumn(tree,SWT.RIGHT);
  column2.setAlignment(SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(100);
  final TreeColumn column6=new TreeColumn(tree,SWT.RIGHT);
  column6.setAlignment(SWT.LEFT);
  column6.setText(Resources.getMessage(""String_Node_Str""));
  column6.setWidth(100);
  final TreeColumn column7=new TreeColumn(tree,SWT.RIGHT);
  column7.setAlignment(SWT.LEFT);
  column7.setText(Resources.getMessage(""String_Node_Str""));
  column7.setWidth(80);
  final TreeColumn column3=new TreeColumn(tree,SWT.RIGHT);
  column3.setAlignment(SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(50);
  final TreeColumn column4=new TreeColumn(tree,SWT.RIGHT);
  column4.setAlignment(SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(50);
  final TreeColumn column5=new TreeColumn(tree,SWT.RIGHT);
  column5.setAlignment(SWT.LEFT);
  column5.setText(Resources.getMessage(""String_Node_Str""));
  column5.setWidth(50);
  final TreeColumn column8=new TreeColumn(tree,SWT.RIGHT);
  column8.setAlignment(SWT.LEFT);
  column8.setText(Resources.getMessage(""String_Node_Str""));
  column8.setWidth(50);
  final TreeColumn column9=new TreeColumn(tree,SWT.RIGHT);
  column9.setAlignment(SWT.LEFT);
  column9.setText(Resources.getMessage(""String_Node_Str""));
  column9.setWidth(50);
  treeViewer.setContentProvider(new InputContentProvider());
  treeViewer.setLabelProvider(new InputLabelProvider());
  treeViewer.setInput(roots);
  treeViewer.expandAll();
}","/** 
 * Creates the view.
 * @param root
 */
private void create(final Composite root){
  root.setLayout(new FillLayout());
  Tree tree=new Tree(root,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  tree.setHeaderVisible(true);
  treeViewer=new TreeViewer(tree);
  tree.setMenu(new ClipboardHandlerTree(treeViewer).getMenu());
  final TreeColumn column1=new TreeColumn(tree,SWT.LEFT);
  tree.setLinesVisible(true);
  column1.setAlignment(SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(160);
  final TreeColumn column2=new TreeColumn(tree,SWT.RIGHT);
  column2.setAlignment(SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(100);
  final TreeColumn column6=new TreeColumn(tree,SWT.RIGHT);
  column6.setAlignment(SWT.LEFT);
  column6.setText(Resources.getMessage(""String_Node_Str""));
  column6.setWidth(100);
  final TreeColumn column7=new TreeColumn(tree,SWT.RIGHT);
  column7.setAlignment(SWT.LEFT);
  column7.setText(Resources.getMessage(""String_Node_Str""));
  column7.setWidth(80);
  final TreeColumn column3=new TreeColumn(tree,SWT.RIGHT);
  column3.setAlignment(SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(50);
  final TreeColumn column4=new TreeColumn(tree,SWT.RIGHT);
  column4.setAlignment(SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(50);
  final TreeColumn column5=new TreeColumn(tree,SWT.RIGHT);
  column5.setAlignment(SWT.LEFT);
  column5.setText(Resources.getMessage(""String_Node_Str""));
  column5.setWidth(50);
  final TreeColumn column8=new TreeColumn(tree,SWT.RIGHT);
  column8.setAlignment(SWT.LEFT);
  column8.setText(Resources.getMessage(""String_Node_Str""));
  column8.setWidth(50);
  final TreeColumn column9=new TreeColumn(tree,SWT.RIGHT);
  column9.setAlignment(SWT.LEFT);
  column9.setText(Resources.getMessage(""String_Node_Str""));
  column9.setWidth(50);
  treeViewer.setContentProvider(new InputContentProvider());
  treeViewer.setLabelProvider(new InputLabelProvider());
  treeViewer.setInput(roots);
  treeViewer.expandAll();
}",0.985046285307382
108017,"/** 
 * Creates the view.
 * @param group
 */
private void create(final Composite group){
  final Tree tree=new Tree(group,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  tree.setHeaderVisible(true);
  treeViewer=new TreeViewer(tree);
  tree.setMenu(new ClipboardHandlerTree(treeViewer).getMenu());
  final TreeColumn column1=new TreeColumn(tree,SWT.LEFT);
  tree.setLinesVisible(true);
  column1.setAlignment(SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(160);
  final TreeColumn column2=new TreeColumn(tree,SWT.RIGHT);
  column2.setAlignment(SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(100);
  treeViewer.setContentProvider(new OutputContentProvider());
  treeViewer.setLabelProvider(new OutputLabelProvider());
  treeViewer.setInput(roots);
  treeViewer.expandAll();
}","/** 
 * Creates the view.
 * @param root
 */
private void create(final Composite root){
  root.setLayout(new FillLayout());
  final Tree tree=new Tree(root,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  tree.setHeaderVisible(true);
  treeViewer=new TreeViewer(tree);
  tree.setMenu(new ClipboardHandlerTree(treeViewer).getMenu());
  final TreeColumn column1=new TreeColumn(tree,SWT.LEFT);
  tree.setLinesVisible(true);
  column1.setAlignment(SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(160);
  final TreeColumn column2=new TreeColumn(tree,SWT.RIGHT);
  column2.setAlignment(SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(100);
  treeViewer.setContentProvider(new OutputContentProvider());
  treeViewer.setLabelProvider(new OutputLabelProvider());
  treeViewer.setInput(roots);
  treeViewer.expandAll();
}",0.9639794168096056
108018,"@Override public void reset(){
  if (stack != null)   stack.setLayer(0);
  if (cmbType != null && cmbType.getItemCount() != 0)   cmbType.select(0);
  if (cmbMode != null && cmbMode.getItemCount() != 0)   cmbMode.select(0);
  if (cmbMin != null && cmbMin.getItemCount() != 0)   cmbMin.select(0);
  if (cmbMax != null && cmbMax.getItemCount() != 0)   cmbMax.select(cmbMax.getItemCount() - 1);
  if (cmbFunction != null && cmbFunction.getItemCount() != 0)   cmbFunction.select(0);
  SWTUtil.disable(root);
}","@Override public void reset(){
  if (stack != null)   stack.setLayer(0);
  if (cmbType != null && cmbType.getItemCount() != 0)   cmbType.select(0);
  if (cmbMode != null && cmbMode.getItemCount() != 0)   cmbMode.select(0);
  if (cmbMin != null && cmbMin.getItemCount() != 0)   cmbMin.select(0);
  if (cmbMax != null && cmbMax.getItemCount() != 0)   cmbMax.select(cmbMax.getItemCount() - 1);
  if (cmbFunction != null && cmbFunction.getItemCount() != 0)   cmbFunction.select(0);
  if (hierarchy != null)   hierarchy.actionClear();
  SWTUtil.disable(root);
}",0.9509433962264152
108019,"/** 
 * Returns the k-map model.
 * @return
 */
public ModelKMapCriterion getKMapModel(){
  if (kMapModel != null) {
    kMapModel=new ModelKMapCriterion();
  }
  return kMapModel;
}","/** 
 * Returns the k-map model.
 * @return
 */
public ModelKMapCriterion getKMapModel(){
  if (kMapModel == null) {
    kMapModel=new ModelKMapCriterion();
  }
  return kMapModel;
}",0.9945054945054944
108020,"/** 
 * Performs k-fold cross validation
 * @param handle
 * @param map
 * @param maps 
 * @param k
 * @param random
 * @param samplingFraction 
 * @return
 * @throws ParseException 
 */
private double getAccuracyAccordingToKFoldCrossValidation(DataHandleStatistics handle,Map<String,Integer> map,Map<String,Integer>[] maps,int k,Random random,double samplingFraction) throws ParseException {
  ConstantValueEncoder interceptEncoder=new ConstantValueEncoder(""String_Node_Str"");
  StaticWordValueEncoder featureEncoder=new StaticWordValueEncoder(""String_Node_Str"");
  List<Integer> rows=new ArrayList<>();
  for (int row=0; row < handle.getNumRows(); row++) {
    rows.add(row);
  }
  Collections.shuffle(rows,random);
  List<List<Integer>> folds=new ArrayList<>();
  int size=handle.getNumRows() / k;
  size=size > 1 ? size : 1;
  for (int i=0; i < k; i++) {
    checkInterrupt();
    int min=i * size;
    int max=(i + 1) * size;
    if (i == k - 1) {
      max=handle.getNumRows();
    }
    List<Integer> fold=new ArrayList<>();
    for (int j=min; j < max; j++) {
      if (random.nextDouble() <= samplingFraction) {
        fold.add(rows.get(j));
      }
    }
    folds.add(fold);
  }
  rows.clear();
  rows=null;
  double correct=0d;
  double total=0d;
  for (int i=0; i < folds.size(); i++) {
    Classifier classifier=new MultiClassLogisticRegression(indexes.length - 1,map.size());
    try {
      for (int j=0; j < folds.size(); j++) {
        if (j != i) {
          List<Integer> trainingset=folds.get(i);
          for (          int row : trainingset) {
            checkInterrupt();
            classifier.train(getFeatures(handle,row,maps,interceptEncoder,featureEncoder),getClass(handle,row,map));
          }
        }
      }
      List<Integer> validationset=folds.get(i);
      for (      int row : validationset) {
        checkInterrupt();
        total++;
        correct+=getClass(handle,row,map) == classifier.classify(getFeatures(handle,row,maps,interceptEncoder,featureEncoder)) ? 1 : 0;
      }
    }
 catch (    Exception e) {
      throw (e);
    }
 finally {
      classifier.close();
    }
  }
  return correct / total;
}","/** 
 * Performs k-fold cross validation
 * @param handle
 * @param map
 * @param maps 
 * @param k
 * @param random
 * @param samplingFraction 
 * @return
 * @throws ParseException 
 */
private double getAccuracyAccordingToKFoldCrossValidation(DataHandleStatistics handle,Map<String,Integer> map,Map<String,Integer>[] maps,int k,Random random,double samplingFraction) throws ParseException {
  ConstantValueEncoder interceptEncoder=new ConstantValueEncoder(""String_Node_Str"");
  StaticWordValueEncoder featureEncoder=new StaticWordValueEncoder(""String_Node_Str"");
  List<Integer> rows=new ArrayList<>();
  for (int row=0; row < handle.getNumRows(); row++) {
    rows.add(row);
  }
  Collections.shuffle(rows,random);
  List<List<Integer>> folds=new ArrayList<>();
  int size=handle.getNumRows() / k;
  size=size > 1 ? size : 1;
  for (int i=0; i < k; i++) {
    checkInterrupt();
    int min=i * size;
    int max=(i + 1) * size;
    if (i == k - 1) {
      max=handle.getNumRows();
    }
    List<Integer> fold=new ArrayList<>();
    for (int j=min; j < max; j++) {
      if (random.nextDouble() <= samplingFraction) {
        fold.add(rows.get(j));
      }
    }
    folds.add(fold);
  }
  rows.clear();
  rows=null;
  double correct=0d;
  double total=0d;
  for (int i=0; i < folds.size(); i++) {
    Classifier classifier=new MultiClassLogisticRegression(indexes.length - 1,map.size());
    try {
      for (int j=0; j < folds.size(); j++) {
        if (j != i) {
          for (          int row : folds.get(j)) {
            checkInterrupt();
            classifier.train(getFeatures(handle,row,maps,interceptEncoder,featureEncoder),getClass(handle,row,map));
          }
        }
      }
      for (      int row : folds.get(i)) {
        checkInterrupt();
        total++;
        correct+=getClass(handle,row,map) == classifier.classify(getFeatures(handle,row,maps,interceptEncoder,featureEncoder)) ? 1 : 0;
      }
    }
 catch (    Exception e) {
      throw (e);
    }
 finally {
      classifier.close();
    }
  }
  return correct / total;
}",0.9539411206077872
108021,"/** 
 * For backwards compatibility only.
 * @param dimensions
 */
protected void initialize(int dimensions){
  this.weights=new double[dimensions];
  Arrays.fill(weights,1d);
}","/** 
 * For backwards compatibility only.
 * @param dimensions
 */
protected void initialize(int dimensions){
  this.weights=new double[dimensions];
  Arrays.fill(weights,1d);
  this.dimensions=dimensions;
}",0.921875
108022,"@Override public Entry next(){
  if (_internal == null)   return null;
  Entry e=_internal.next();
  e.frequency=_entries.get(e);
  return e;
}","@Override public Entry next(){
  if (_internal == null)   return null;
  Entry e=_internal.next();
  e.frequency=(double)_entries.get(e) / (double)count;
  return e;
}",0.9225806451612903
108023,"/** 
 * Returns a frequency distribution for the values in the given column. The order for string data items is derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public StatisticsFrequencyDistribution getFrequencyDistribution(int column,Hierarchy hierarchy){
  interrupt=false;
  String[] values=getDistinctValuesOrdered(column,hierarchy);
  double[] frequencies=new double[values.length];
  Map<String,Integer> indexes=new HashMap<String,Integer>();
  for (int i=0; i < values.length; i++) {
    checkInterrupt();
    indexes.put(values[i],i);
  }
  for (int row=0; row < handle.getNumRows(); row++) {
    checkInterrupt();
    String value=handle.getValue(row,column);
    frequencies[indexes.get(value)]++;
  }
  int count=handle.getNumRows();
  for (int i=0; i < frequencies.length; i++) {
    checkInterrupt();
    frequencies[i]/=(double)count;
  }
  return new StatisticsFrequencyDistribution(values,frequencies,count);
}","/** 
 * Returns a frequency distribution for the values in the given column. The order for string data items is derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public StatisticsFrequencyDistribution getFrequencyDistribution(int column,String[][] hierarchy){
  interrupt=false;
  String[] values=getDistinctValuesOrdered(column,hierarchy);
  double[] frequencies=new double[values.length];
  Map<String,Integer> indexes=new HashMap<String,Integer>();
  for (int i=0; i < values.length; i++) {
    checkInterrupt();
    indexes.put(values[i],i);
  }
  for (int row=0; row < handle.getNumRows(); row++) {
    checkInterrupt();
    String value=handle.getValue(row,column);
    frequencies[indexes.get(value)]++;
  }
  int count=handle.getNumRows();
  for (int i=0; i < frequencies.length; i++) {
    checkInterrupt();
    frequencies[i]/=(double)count;
  }
  return new StatisticsFrequencyDistribution(values,frequencies,count);
}",0.9905425584868094
108024,"/** 
 * Returns an ordered list of the distinct set of data items from the given column. This method assumes that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  interrupt=false;
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype,handle.getSuppressionString());
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      checkInterrupt();
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute),handle.getSuppressionString());
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      checkInterrupt();
      baseOrder.put(baseArray[i],i);
    }
    int lower=handle.isOptimized() ? 1 : level;
    int upper=handle.isOptimized() ? _hierarchy[0].length : level + 1;
    for (int i=0; i < _hierarchy.length; i++) {
      checkInterrupt();
      for (int j=lower; j < upper; j++) {
        if (!order.containsKey(_hierarchy[i][j])) {
          Integer position=baseOrder.get(_hierarchy[i][0]);
          if (position != null) {
            order.put(_hierarchy[i][j],position);
            max=Math.max(position,max) + 1;
          }
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}","/** 
 * Returns an ordered list of the distinct set of data items from the given column. This method assumes that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,String[][] hierarchy){
  interrupt=false;
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  if (hierarchy == null || level == 0) {
    sort(list,datatype,handle.getSuppressionString());
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < hierarchy.length; i++) {
      String element=hierarchy[i][0];
      checkInterrupt();
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute),handle.getSuppressionString());
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      checkInterrupt();
      baseOrder.put(baseArray[i],i);
    }
    int lower=handle.isOptimized() ? 1 : level;
    int upper=handle.isOptimized() ? hierarchy[0].length : level + 1;
    for (int i=0; i < hierarchy.length; i++) {
      checkInterrupt();
      for (int j=lower; j < upper; j++) {
        if (!order.containsKey(hierarchy[i][j])) {
          Integer position=baseOrder.get(hierarchy[i][0]);
          if (position != null) {
            order.put(hierarchy[i][j],position);
            max=Math.max(position,max) + 1;
          }
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}",0.746311280342694
108025,"/** 
 * Returns a contingency table for the given columns. This method assumes that the order of string data items can (and should) be derived from the hierarchies provided in the data definition (if any)
 * @param column1 The first column
 * @param size1 The maximal size in this dimension
 * @param column2 The second column
 * @param size2 The maximal size in this dimension
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,int size1,int column2,int size2){
  return getContingencyTable(column1,size1,true,column2,size2,true);
}","/** 
 * Returns a contingency table for the given columns. The order for string data items is derived from the provided hierarchies
 * @param column1 The first column
 * @param hierarchy1 The hierarchy for the first column, may be null
 * @param column2 The second column
 * @param hierarchy2 The hierarchy for the second column, may be null
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,String[][] hierarchy1,int column2,String[][] hierarchy2){
  interrupt=false;
  String[] values1=getDistinctValuesOrdered(column1,hierarchy1);
  String[] values2=getDistinctValuesOrdered(column2,hierarchy2);
  Map<String,Integer> indexes1=new HashMap<String,Integer>();
  for (int i=0; i < values1.length; i++) {
    checkInterrupt();
    indexes1.put(values1[i],i);
  }
  Map<String,Integer> indexes2=new HashMap<String,Integer>();
  for (int i=0; i < values2.length; i++) {
    checkInterrupt();
    indexes2.put(values2[i],i);
  }
  int max=Integer.MIN_VALUE;
  final Map<Entry,Integer> entries=new HashMap<Entry,Integer>();
  for (int row=0; row < handle.getNumRows(); row++) {
    checkInterrupt();
    int index1=indexes1.get(handle.getValue(row,column1));
    int index2=indexes2.get(handle.getValue(row,column2));
    Entry entry=new Entry(index1,index2);
    Integer previous=entries.get(entry);
    int value=previous != null ? previous + 1 : 1;
    max=Math.max(max,value);
    entries.put(entry,value);
  }
  final int count=handle.getNumRows();
  final Iterator<Entry> internal=entries.keySet().iterator();
  final Iterator<Entry> iterator=new Iterator<Entry>(){
    private Map<Entry,Integer> _entries=entries;
    private Iterator<Entry> _internal=internal;
    @Override public boolean hasNext(){
      if (_internal == null)       return false;
      boolean result=_internal.hasNext();
      if (!result) {
        _internal=null;
        _entries=null;
      }
      return result;
    }
    @Override public Entry next(){
      if (_internal == null)       return null;
      Entry e=_internal.next();
      e.frequency=(double)_entries.get(e) / (double)count;
      return e;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  return new StatisticsContingencyTable(values1,values2,count,(double)max / (double)count,iterator);
}",0.1350883269830273
108026,"/** 
 * Returns a summary statistics object for the given attribute
 * @param generalization
 * @param dataType
 * @param baseDataType
 * @param hierarchy
 * @return
 */
private <U,V>StatisticsSummaryOrdinal getSummaryStatisticsOrdinal(final int generalization,final DataType<U> dataType,final DataType<V> baseDataType,final Hierarchy hierarchy){
  if (generalization == 0 || !(dataType instanceof ARXString)) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else   if (baseDataType instanceof ARXString) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else   if (hierarchy == null) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else {
    final String[][] array=hierarchy.getHierarchy();
    final Map<String,String> map=new HashMap<String,String>();
    for (int i=0; i < array.length; i++) {
      map.put(array[i][generalization],array[i][0]);
    }
    return new StatisticsSummaryOrdinal(new Comparator<String>(){
      public int compare(      String o1,      String o2){
        V _o1=null;
        try {
          _o1=baseDataType.parse(map.get(o1));
        }
 catch (        Exception e) {
        }
        V _o2=null;
        try {
          _o2=baseDataType.parse(map.get(o2));
        }
 catch (        Exception e) {
        }
        try {
          return baseDataType.compare(_o1,_o2);
        }
 catch (        Exception e) {
          return 0;
        }
      }
    }
);
  }
}","/** 
 * Returns a summary statistics object for the given attribute
 * @param generalization
 * @param dataType
 * @param baseDataType
 * @param hierarchy
 * @return
 */
private <U,V>StatisticsSummaryOrdinal getSummaryStatisticsOrdinal(final int generalization,final DataType<U> dataType,final DataType<V> baseDataType,final String[][] hierarchy){
  if (generalization == 0 || !(dataType instanceof ARXString)) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else   if (baseDataType instanceof ARXString) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else   if (hierarchy == null) {
    return new StatisticsSummaryOrdinal(dataType);
  }
 else {
    final Map<String,String> map=new HashMap<String,String>();
    for (int i=0; i < hierarchy.length; i++) {
      map.put(hierarchy[i][generalization],hierarchy[i][0]);
    }
    return new StatisticsSummaryOrdinal(new Comparator<String>(){
      public int compare(      String o1,      String o2){
        V _o1=null;
        try {
          _o1=baseDataType.parse(map.get(o1));
        }
 catch (        Exception e) {
        }
        V _o2=null;
        try {
          _o2=baseDataType.parse(map.get(o2));
        }
 catch (        Exception e) {
        }
        try {
          return baseDataType.compare(_o1,_o2);
        }
 catch (        Exception e) {
          return 0;
        }
      }
    }
);
  }
}",0.7359829666430092
108027,"/** 
 * Returns the appropriate hierarchy, if any.
 * @param column
 * @param orderFromDefinition
 * @return
 */
private Hierarchy getHierarchy(int column,boolean orderFromDefinition){
  final String attribute=handle.getAttributeName(column);
  final AttributeType type=handle.getDefinition().getAttributeType(attribute);
  final DataType<?> datatype=handle.getDataType(attribute);
  final Hierarchy hierarchy;
  if (orderFromDefinition && datatype instanceof ARXString && type instanceof Hierarchy) {
    hierarchy=((Hierarchy)type);
  }
 else {
    hierarchy=null;
  }
  return hierarchy;
}","/** 
 * Returns the appropriate hierarchy, if any.
 * @param column
 * @param orderFromDefinition
 * @return
 */
private String[][] getHierarchy(int column,boolean orderFromDefinition){
  final String attribute=handle.getAttributeName(column);
  final String[][] hierarchy=handle.getDefinition().getHierarchy(attribute);
  final DataType<?> datatype=handle.getDataType(attribute);
  if (orderFromDefinition && datatype instanceof ARXString && hierarchy != null) {
    return hierarchy;
  }
 else {
    return null;
  }
}",0.7535971223021583
108028,"public int compare(ARXNode o1,ARXNode o2){
  boolean unknown2=o2.getMinimumInformationLoss().compareTo(o2.getMaximumInformationLoss()) != 0 && asRelativeValue(o2.getMinimumInformationLoss()) == 0d;
  boolean unknown1=o1.getMinimumInformationLoss().compareTo(o1.getMaximumInformationLoss()) != 0 && asRelativeValue(o1.getMinimumInformationLoss()) == 0d;
  if (unknown1 && unknown2)   return 0;
 else   if (unknown1 && !unknown2)   return +1;
 else   if (!unknown1 && unknown2)   return -1;
 else {
    int c1=o1.getMinimumInformationLoss().compareTo(o2.getMinimumInformationLoss());
    return c1 != 0 ? c1 : o1.getMaximumInformationLoss().compareTo(o2.getMaximumInformationLoss());
  }
}","public int compare(ARXNode o1,ARXNode o2){
  boolean unknown2=o2.getMinimumInformationLoss().compareTo(o2.getMaximumInformationLoss()) != 0 && asRelativeValue(o2.getMinimumInformationLoss()) == 0d;
  boolean unknown1=o1.getMinimumInformationLoss().compareTo(o1.getMaximumInformationLoss()) != 0 && asRelativeValue(o1.getMinimumInformationLoss()) == 0d;
  if (unknown1 && unknown2)   return 0;
 else   if (unknown1 && !unknown2)   return +1;
 else   if (!unknown1 && unknown2)   return -1;
 else {
    try {
      int c1=o1.getMinimumInformationLoss().compareTo(o2.getMinimumInformationLoss());
      return c1 != 0 ? c1 : o1.getMaximumInformationLoss().compareTo(o2.getMaximumInformationLoss());
    }
 catch (    Exception e) {
      return 0;
    }
  }
}",0.9521829521829522
108029,"/** 
 * Constructor
 * @param parent
 * @param controller
 */
public ViewTiles(final Composite parent,final Controller controller){
  super(parent,controller);
  tiles=new Tiles<ARXNode>(super.getPrimaryComposite(),SWT.BORDER);
  tiles.setLayoutData(SWTUtil.createFillGridData());
  tiles.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      ViewTiles.this.actionSelectNode(tiles.getSelectedItem());
    }
  }
);
  tiles.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=tiles.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewTiles.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  tiles.setTileLayout(new TileLayoutDynamic(NUM_COLUMNS,NUM_ROWS,MARGIN,MARGIN));
  tiles.setComparator(new Comparator<ARXNode>(){
    public int compare(    ARXNode o1,    ARXNode o2){
      boolean unknown2=o2.getMinimumInformationLoss().compareTo(o2.getMaximumInformationLoss()) != 0 && asRelativeValue(o2.getMinimumInformationLoss()) == 0d;
      boolean unknown1=o1.getMinimumInformationLoss().compareTo(o1.getMaximumInformationLoss()) != 0 && asRelativeValue(o1.getMinimumInformationLoss()) == 0d;
      if (unknown1 && unknown2)       return 0;
 else       if (unknown1 && !unknown2)       return +1;
 else       if (!unknown1 && unknown2)       return -1;
 else {
        int c1=o1.getMinimumInformationLoss().compareTo(o2.getMinimumInformationLoss());
        return c1 != 0 ? c1 : o1.getMaximumInformationLoss().compareTo(o2.getMaximumInformationLoss());
      }
    }
  }
);
  tiles.setFilter(new Filter<ARXNode>(){
    public boolean accepts(    ARXNode arg0){
      return true;
    }
  }
);
  tiles.setDecoratorLabel(new DecoratorString<ARXNode>(){
    @Override public String decorate(    ARXNode node){
      String text=Arrays.toString(node.getTransformation());
      text=text.substring(1,text.length() - 1);
      return trimLabel(text);
    }
  }
);
  tiles.setDecoratorBackgroundColor(createDecoratorBackgroundColor());
  tiles.setDecoratorTooltip(super.getTooltipDecorator());
  tiles.setDecoratorLineColor(createDecoratorLineColor());
  tiles.setDecoratorLineWidth(createDecoratorLineWidth());
  tiles.setBackground(tiles.getDisplay().getSystemColor(SWT.COLOR_LIST_BACKGROUND));
  tiles.update();
}","/** 
 * Constructor
 * @param parent
 * @param controller
 */
public ViewTiles(final Composite parent,final Controller controller){
  super(parent,controller);
  tiles=new Tiles<ARXNode>(super.getPrimaryComposite(),SWT.BORDER);
  tiles.setLayoutData(SWTUtil.createFillGridData());
  tiles.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      ViewTiles.this.actionSelectNode(tiles.getSelectedItem());
    }
  }
);
  tiles.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=tiles.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewTiles.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  tiles.setTileLayout(new TileLayoutDynamic(NUM_COLUMNS,NUM_ROWS,MARGIN,MARGIN));
  tiles.setComparator(new Comparator<ARXNode>(){
    public int compare(    ARXNode o1,    ARXNode o2){
      boolean unknown2=o2.getMinimumInformationLoss().compareTo(o2.getMaximumInformationLoss()) != 0 && asRelativeValue(o2.getMinimumInformationLoss()) == 0d;
      boolean unknown1=o1.getMinimumInformationLoss().compareTo(o1.getMaximumInformationLoss()) != 0 && asRelativeValue(o1.getMinimumInformationLoss()) == 0d;
      if (unknown1 && unknown2)       return 0;
 else       if (unknown1 && !unknown2)       return +1;
 else       if (!unknown1 && unknown2)       return -1;
 else {
        try {
          int c1=o1.getMinimumInformationLoss().compareTo(o2.getMinimumInformationLoss());
          return c1 != 0 ? c1 : o1.getMaximumInformationLoss().compareTo(o2.getMaximumInformationLoss());
        }
 catch (        Exception e) {
          return 0;
        }
      }
    }
  }
);
  tiles.setFilter(new Filter<ARXNode>(){
    public boolean accepts(    ARXNode arg0){
      return true;
    }
  }
);
  tiles.setDecoratorLabel(new DecoratorString<ARXNode>(){
    @Override public String decorate(    ARXNode node){
      String text=Arrays.toString(node.getTransformation());
      text=text.substring(1,text.length() - 1);
      return trimLabel(text);
    }
  }
);
  tiles.setDecoratorBackgroundColor(createDecoratorBackgroundColor());
  tiles.setDecoratorTooltip(super.getTooltipDecorator());
  tiles.setDecoratorLineColor(createDecoratorLineColor());
  tiles.setDecoratorLineWidth(createDecoratorLineWidth());
  tiles.setBackground(tiles.getDisplay().getSystemColor(SWT.COLOR_LIST_BACKGROUND));
  tiles.update();
}",0.98288790617189
108030,"/** 
 * Returns the d-disclosure privacy model.
 * @return
 */
public Map<String,ModelDDisclosurePrivacyCriterion> getDDisclosurePrivacyModel(){
  if (this.dDisclosurePrivacyModel == null) {
    this.dDisclosurePrivacyModel=new HashMap<String,ModelDDisclosurePrivacyCriterion>();
  }
  return dDisclosurePrivacyModel;
}","/** 
 * Returns the d-disclosure privacy model.
 * @return
 */
public Map<String,ModelDDisclosurePrivacyCriterion> getDDisclosurePrivacyModel(){
  if (this.dDisclosurePrivacyModel == null) {
    this.dDisclosurePrivacyModel=new HashMap<String,ModelDDisclosurePrivacyCriterion>();
    DataHandle handle=inputConfig.getInput().getHandle();
    for (int col=0; col < handle.getNumColumns(); col++) {
      String attribute=handle.getAttributeName(col);
      dDisclosurePrivacyModel.put(attribute,new ModelDDisclosurePrivacyCriterion(attribute));
    }
  }
  return dDisclosurePrivacyModel;
}",0.6321585903083701
108031,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final DynamicTable table=SWTUtil.createTableDynamic(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=200;
  table.setLayoutData(d);
  DynamicTableColumn column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  Image symbolL=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolT=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolK=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolD=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolR=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolDP=controller.getResources().getManagedImage(""String_Node_Str"");
  for (  ModelCriterion c : elements) {
    TableItem item=new TableItem(table,SWT.NONE);
    if (c instanceof ModelLDiversityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelLDiversityCriterion)c).getAttribute()});
      item.setImage(0,symbolL);
    }
 else     if (c instanceof ModelTClosenessCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelTClosenessCriterion)c).getAttribute()});
      item.setImage(0,symbolT);
    }
 else     if (c instanceof ModelDDisclosurePrivacyCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelTClosenessCriterion)c).getAttribute()});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelKAnonymityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolK);
    }
 else     if (c instanceof ModelDPresenceCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelRiskBasedCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolR);
    }
 else     if (c instanceof ModelDifferentialPrivacyCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolDP);
    }
  }
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        selection=elements.get(table.getSelectionIndex());
        if (edit)         ok.setEnabled(true);
        update();
      }
 else {
        selection=null;
        if (edit)         ok.setEnabled(false);
        update();
      }
    }
  }
);
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getManagedImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      if (editor != null) {
        DialogDefaultParameters dialog=new DialogDefaultParameters(DialogCriterionUpdate.this.getShell(),controller,editor.getTypicalParameters());
        dialog.create();
        if (dialog.open() == Window.OK) {
          editor.parseDefault(dialog.getSelection());
        }
      }
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.root=folder.createItem(Resources.getMessage(""String_Node_Str""),null);
  this.root.setLayout(SWTUtil.createGridLayout(1));
  folder.setSelection(0);
  if (selection != null) {
    table.setSelection(elements.indexOf(selection));
  }
 else   if (table.getItemCount() != 0) {
    table.setSelection(0);
    selection=elements.get(0);
  }
  update();
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final DynamicTable table=SWTUtil.createTableDynamic(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=200;
  table.setLayoutData(d);
  DynamicTableColumn column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  Image symbolL=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolT=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolK=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolD=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolR=controller.getResources().getManagedImage(""String_Node_Str"");
  Image symbolDP=controller.getResources().getManagedImage(""String_Node_Str"");
  for (  ModelCriterion c : elements) {
    TableItem item=new TableItem(table,SWT.NONE);
    if (c instanceof ModelLDiversityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelLDiversityCriterion)c).getAttribute()});
      item.setImage(0,symbolL);
    }
 else     if (c instanceof ModelTClosenessCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelTClosenessCriterion)c).getAttribute()});
      item.setImage(0,symbolT);
    }
 else     if (c instanceof ModelDDisclosurePrivacyCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelDDisclosurePrivacyCriterion)c).getAttribute()});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelKAnonymityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolK);
    }
 else     if (c instanceof ModelDPresenceCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelRiskBasedCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolR);
    }
 else     if (c instanceof ModelDifferentialPrivacyCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolDP);
    }
  }
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        selection=elements.get(table.getSelectionIndex());
        if (edit)         ok.setEnabled(true);
        update();
      }
 else {
        selection=null;
        if (edit)         ok.setEnabled(false);
        update();
      }
    }
  }
);
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getManagedImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      if (editor != null) {
        DialogDefaultParameters dialog=new DialogDefaultParameters(DialogCriterionUpdate.this.getShell(),controller,editor.getTypicalParameters());
        dialog.create();
        if (dialog.open() == Window.OK) {
          editor.parseDefault(dialog.getSelection());
        }
      }
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.root=folder.createItem(Resources.getMessage(""String_Node_Str""),null);
  this.root.setLayout(SWTUtil.createGridLayout(1));
  folder.setSelection(0);
  if (selection != null) {
    table.setSelection(elements.indexOf(selection));
  }
 else   if (table.getItemCount() != 0) {
    table.setSelection(0);
    selection=elements.get(0);
  }
  update();
  return parent;
}",0.9968116602140742
108032,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewAttributeWeights(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.defaultColorProfile=KnobColorProfile.createDefaultSystemProfile(parent.getDisplay());
  this.focusedColorProfile=KnobColorProfile.createFocusedBlueRedProfile(parent.getDisplay());
  this.root=new ScrolledComposite(parent,SWT.H_SCROLL);
  this.root.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent arg0){
      if (defaultColorProfile != null && !defaultColorProfile.isDisposed()) {
        defaultColorProfile.dispose();
      }
      if (focusedColorProfile != null && !focusedColorProfile.isDisposed()) {
        focusedColorProfile.dispose();
      }
    }
  }
);
  root.pack();
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewAttributeWeights(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.defaultColorProfile=KnobColorProfile.createDefaultSystemProfile(parent.getDisplay());
  this.focusedColorProfile=KnobColorProfile.createFocusedBlueRedProfile(parent.getDisplay());
  this.root=new ScrolledComposite(parent,SWT.H_SCROLL);
  this.root.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent arg0){
      if (defaultColorProfile != null && !defaultColorProfile.isDisposed()) {
        defaultColorProfile.dispose();
      }
      if (focusedColorProfile != null && !focusedColorProfile.isDisposed()) {
        focusedColorProfile.dispose();
      }
    }
  }
);
  this.root.getHorizontalBar().addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      root.redraw();
    }
  }
);
  root.pack();
}",0.9182448036951502
108033,"/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int key=index * 2;
    final int attributeType=inverseMap[key];
    final int indexMap=inverseMap[key + 1];
    if (attributeType == AttributeTypeInternal.IDENTIFYING)     return 0;
    int cmp=0;
    try {
      String s1=internalGetValue(row1,index);
      String s2=internalGetValue(row2,index);
      cmp=(s1 == suppressionString && s2 == suppressionString) ? 0 : (s1 == suppressionString ? +1 : (s2 == suppressionString ? -1 : dataTypes[attributeType][indexMap].compare(s1,s2)));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      return ascending ? cmp : -cmp;
    }
  }
  return 0;
}","/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int key=index * 2;
    final int attributeType=inverseMap[key];
    final int indexMap=inverseMap[key + 1];
    if (attributeType == AttributeTypeInternal.IDENTIFYING) {
      continue;
    }
    int cmp=0;
    try {
      String s1=internalGetValue(row1,index);
      String s2=internalGetValue(row2,index);
      cmp=(s1 == suppressionString && s2 == suppressionString) ? 0 : (s1 == suppressionString ? +1 : (s2 == suppressionString ? -1 : dataTypes[attributeType][indexMap].compare(s1,s2)));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      return ascending ? cmp : -cmp;
    }
  }
  return 0;
}",0.9858333333333332
108034,"/** 
 * Returns a new instance that is projected onto the given subset
 * @param rowset
 * @return
 */
public Data getSubsetInstance(RowSet rowset){
  List<int[]> newdata=new ArrayList<int[]>();
  for (int row=0; row < this.data.length; row++) {
    if (rowset.contains(row)) {
      newdata.add(data[row]);
    }
  }
  int[][] array=new int[newdata.size()][];
  for (int i=0; i < newdata.size(); i++) {
    array[i]=newdata.get(i);
  }
  return new Data(array,header,map,dictionary);
}","/** 
 * Returns a new instance that is projected onto the given subset
 * @param rowset
 * @return
 */
public Data getSubsetInstance(RowSet rowset){
  int[][] array=null;
  if (this.data != null) {
    List<int[]> newdata=new ArrayList<int[]>();
    for (int row=0; row < this.data.length; row++) {
      if (rowset.contains(row)) {
        newdata.add(data[row]);
      }
    }
    array=new int[newdata.size()][];
    for (int i=0; i < newdata.size(); i++) {
      array[i]=newdata.get(i);
    }
  }
  return new Data(array,header,map,dictionary);
}",0.8775313404050145
108035,"/** 
 * Applies local recoding
 */
public void actionLocalRecoding(){
  final WorkerLocalRecode worker=new WorkerLocalRecode(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof OutOfMemoryError) {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else     if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    return;
  }
  update(new ModelEvent(this,ModelPart.OUTPUT,model.getOutput()));
  if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
    this.model.getViewConfig().setMode(Mode.GROUPED);
    this.updateViewConfig(true);
  }
 else {
    this.model.getViewConfig().setMode(Mode.UNSORTED);
    this.updateViewConfig(true);
  }
  this.update(new ModelEvent(this,ModelPart.SELECTED_VIEW_CONFIG,model.getOutput()));
}","/** 
 * Applies local recoding
 */
public void actionLocalRecoding(){
  final WorkerLocalRecode worker=new WorkerLocalRecode(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof RollbackRequiredException) {
      this.actionApplySelectedTransformation();
    }
 else     if (t instanceof OutOfMemoryError) {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else     if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    return;
  }
  update(new ModelEvent(this,ModelPart.OUTPUT,model.getOutput()));
  if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
    this.model.getViewConfig().setMode(Mode.GROUPED);
    this.updateViewConfig(true);
  }
 else {
    this.model.getViewConfig().setMode(Mode.UNSORTED);
    this.updateViewConfig(true);
  }
  this.update(new ModelEvent(this,ModelPart.SELECTED_VIEW_CONFIG,model.getOutput()));
}",0.9617790132036136
108036,"/** 
 * This method optimizes the given data output with local recoding to improve its utility
 * @param handle
 * @throws IOException 
 */
public void optimize(DataHandle handle){
  if (!(handle instanceof DataHandleOutput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DataHandleOutput output=(DataHandleOutput)handle;
  if (output.getInputBuffer() == null || !output.getInputBuffer().equals(this.checker.getInputBuffer())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<Class<?>> supportedModels=new HashSet<Class<?>>();
  supportedModels.add(KAnonymity.class);
  supportedModels.add(DistinctLDiversity.class);
  supportedModels.add(RecursiveCLDiversity.class);
  supportedModels.add(EntropyLDiversity.class);
  supportedModels.add(HierarchicalDistanceTCloseness.class);
  supportedModels.add(EqualDistanceTCloseness.class);
  supportedModels.add(Inclusion.class);
  for (  PrivacyCriterion c : config.getCriteria()) {
    if (!supportedModels.contains(c.getClass())) {
      throw new UnsupportedOperationException(""String_Node_Str"" + c.getClass().getSimpleName());
    }
  }
  RowSet rowset=RowSet.create(output.getNumRows());
  for (int row=0; row < output.getNumRows(); row++) {
    if (output.isOutlier(row)) {
      rowset.add(row);
    }
  }
  ARXConfiguration config=this.config.getSubsetInstance(rowset);
  DataDefinition definition=this.definition.clone();
  DataManager manager=this.manager.getSubsetInstance(rowset);
  ARXAnonymizer anonymizer=new ARXAnonymizer();
  Result result=null;
  try {
    result=anonymizer.anonymize(manager,definition,config);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (result.optimum == null) {
    return;
  }
  TransformedData data=result.checker.applyTransformation(result.optimum,output.getOutputBufferMicroaggregated().getDictionary());
  int newIndex=-1;
  int[][] oldGeneralized=output.getOutputBufferGeneralized().getArray();
  int[][] oldMicroaggregated=output.getOutputBufferMicroaggregated().getArray();
  int[][] newGeneralized=data.bufferGeneralized.getArray();
  int[][] newMicroaggregated=data.bufferMicroaggregated.getArray();
  for (int oldIndex=0; oldIndex < rowset.length(); oldIndex++) {
    if (rowset.contains(oldIndex)) {
      newIndex++;
      System.arraycopy(newGeneralized[newIndex],0,oldGeneralized[oldIndex],0,newGeneralized[newIndex].length);
      System.arraycopy(newMicroaggregated[newIndex],0,oldMicroaggregated[oldIndex],0,newMicroaggregated[newIndex].length);
    }
  }
}","/** 
 * This method optimizes the given data output with local recoding to improve its utility
 * @param handle
 * @throws IOException 
 */
public void optimize(DataHandle handle){
  if (!(handle instanceof DataHandleOutput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  DataHandleOutput output=(DataHandleOutput)handle;
  if (output.getInputBuffer() == null || !output.getInputBuffer().equals(this.checker.getInputBuffer())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<Class<?>> supportedModels=new HashSet<Class<?>>();
  supportedModels.add(KAnonymity.class);
  supportedModels.add(DistinctLDiversity.class);
  supportedModels.add(RecursiveCLDiversity.class);
  supportedModels.add(EntropyLDiversity.class);
  supportedModels.add(HierarchicalDistanceTCloseness.class);
  supportedModels.add(EqualDistanceTCloseness.class);
  supportedModels.add(Inclusion.class);
  for (  PrivacyCriterion c : config.getCriteria()) {
    if (!supportedModels.contains(c.getClass())) {
      throw new UnsupportedOperationException(""String_Node_Str"" + c.getClass().getSimpleName());
    }
  }
  RowSet rowset=RowSet.create(output.getNumRows());
  for (int row=0; row < output.getNumRows(); row++) {
    if (output.isOutlier(row)) {
      rowset.add(row);
    }
  }
  ARXConfiguration config=this.config.getSubsetInstance(rowset);
  DataDefinition definition=this.definition.clone();
  DataManager manager=this.manager.getSubsetInstance(rowset);
  ARXAnonymizer anonymizer=new ARXAnonymizer();
  Result result=null;
  try {
    result=anonymizer.anonymize(manager,definition,config);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (result.optimum == null) {
    return;
  }
  TransformedData data=result.checker.applyTransformation(result.optimum,output.getOutputBufferMicroaggregated().getDictionary());
  int newIndex=-1;
  int[][] oldGeneralized=output.getOutputBufferGeneralized().getArray();
  int[][] oldMicroaggregated=output.getOutputBufferMicroaggregated().getArray();
  int[][] newGeneralized=data.bufferGeneralized.getArray();
  int[][] newMicroaggregated=data.bufferMicroaggregated.getArray();
  for (int oldIndex=0; oldIndex < rowset.length(); oldIndex++) {
    if (rowset.contains(oldIndex)) {
      newIndex++;
      if (oldGeneralized != null && oldGeneralized.length != 0) {
        System.arraycopy(newGeneralized[newIndex],0,oldGeneralized[oldIndex],0,newGeneralized[newIndex].length);
      }
      if (oldMicroaggregated != null && oldMicroaggregated.length != 0) {
        System.arraycopy(newMicroaggregated[newIndex],0,oldMicroaggregated[oldIndex],0,newMicroaggregated[newIndex].length);
      }
    }
  }
}",0.9695470118005328
108037,"/** 
 * Instantiates.
 * @param ignoreMissingData
 */
public DistributionAggregateFunctionGeometricMean(boolean ignoreMissingData){
  super(ignoreMissingData,true);
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 * @param descriptiveStatistics
 */
private DistributionAggregateFunctionGeometricMean(boolean ignoreMissingData,double minimum,double maximum,DescriptiveStatistics descriptiveStatistics){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
  this.stats=descriptiveStatistics;
}",0.2692998204667863
108038,"/** 
 * Instantiates.
 * @param ignoreMissingData
 */
public DistributionAggregateFunctionArithmeticMean(boolean ignoreMissingData){
  super(ignoreMissingData,true);
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 * @param descriptiveStatistics
 */
private DistributionAggregateFunctionArithmeticMean(boolean ignoreMissingData,double minimum,double maximum,DescriptiveStatistics descriptiveStatistics){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
  this.stats=descriptiveStatistics;
}",0.2683363148479427
108039,"/** 
 * Instantiates.
 * @param ignoreMissingData
 */
public DistributionAggregateFunctionMode(boolean ignoreMissingData){
  super(ignoreMissingData,true);
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionMode(boolean ignoreMissingData,double minimum,double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}",0.48711943793911
108040,"/** 
 * Instantiates.
 * @param ignoreMissingData
 */
public DistributionAggregateFunctionMedian(boolean ignoreMissingData){
  super(ignoreMissingData,true);
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionMedian(boolean ignoreMissingData,double minimum,double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}",0.4918793503480278
108041,"/** 
 * Returns an ordered list of the distinct set of data items from the given column. This method assumes that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  interrupt=false;
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype,handle.getSuppressionString());
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      checkInterrupt();
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute),handle.getSuppressionString());
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      checkInterrupt();
      baseOrder.put(baseArray[i],i);
    }
    int lower=handle.isOptimized() ? 1 : level;
    int upper=handle.isOptimized() ? _hierarchy[0].length : level;
    for (int i=0; i < _hierarchy.length; i++) {
      checkInterrupt();
      for (int j=lower; j < upper; j++) {
        if (!order.containsKey(_hierarchy[i][j])) {
          Integer position=baseOrder.get(_hierarchy[i][0]);
          if (position != null) {
            order.put(_hierarchy[i][j],position);
            max=Math.max(position,max) + 1;
          }
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}","/** 
 * Returns an ordered list of the distinct set of data items from the given column. This method assumes that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  interrupt=false;
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype,handle.getSuppressionString());
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      checkInterrupt();
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute),handle.getSuppressionString());
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      checkInterrupt();
      baseOrder.put(baseArray[i],i);
    }
    int lower=handle.isOptimized() ? 1 : level;
    int upper=handle.isOptimized() ? _hierarchy[0].length : level + 1;
    for (int i=0; i < _hierarchy.length; i++) {
      checkInterrupt();
      for (int j=lower; j < upper; j++) {
        if (!order.containsKey(_hierarchy[i][j])) {
          Integer position=baseOrder.get(_hierarchy[i][0]);
          if (position != null) {
            order.put(_hierarchy[i][j],position);
            max=Math.max(position,max) + 1;
          }
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}",0.9990671641791044
108042,"/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 * @param descriptiveStatistics
 */
private DistributionAggregateFunctionGeometricMean(boolean ignoreMissingData,double minimum,double maximum,DescriptiveStatistics descriptiveStatistics){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
  this.stats=descriptiveStatistics;
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionGeometricMean(boolean ignoreMissingData,Double minimum,Double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}",0.7761194029850746
108043,"/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 * @param descriptiveStatistics
 */
private DistributionAggregateFunctionArithmeticMean(boolean ignoreMissingData,double minimum,double maximum,DescriptiveStatistics descriptiveStatistics){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
  this.stats=descriptiveStatistics;
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionArithmeticMean(boolean ignoreMissingData,Double minimum,Double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}",0.7767857142857143
108044,"/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionMedian(boolean ignoreMissingData,double minimum,double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}","/** 
 * Clone constructor
 * @param ignoreMissingData
 * @param minimum
 * @param maximum
 */
private DistributionAggregateFunctionMedian(boolean ignoreMissingData,Double minimum,Double maximum){
  this(ignoreMissingData);
  this.minimum=minimum;
  this.maximum=maximum;
}",0.9926470588235294
108045,"@Override public DataDefinition clone(){
  final DataDefinition d=new DataDefinition();
  for (  final String attr : attributeTypes.keySet()) {
    d.attributeTypes.put(attr,attributeTypes.get(attr).clone());
  }
  for (  final String attr : dataTypes.keySet()) {
    d.dataTypes.put(attr,dataTypes.get(attr).clone());
  }
  for (  final String attr : hierarchies.keySet()) {
    d.hierarchies.put(attr,hierarchies.get(attr));
  }
  for (  final String attr : functions.keySet()) {
    d.functions.put(attr,functions.get(attr).clone());
  }
  for (  final String attr : minGeneralization.keySet()) {
    d.minGeneralization.put(attr,minGeneralization.get(attr));
  }
  for (  final String attr : maxGeneralization.keySet()) {
    d.maxGeneralization.put(attr,maxGeneralization.get(attr));
  }
  for (  final String attr : builders.keySet()) {
    d.builders.put(attr,builders.get(attr));
  }
  d.setLocked(this.isLocked());
  return d;
}","@Override public DataDefinition clone(){
  final DataDefinition d=new DataDefinition();
  for (  final String attr : attributeTypes.keySet()) {
    d.attributeTypes.put(attr,attributeTypes.get(attr).clone());
  }
  for (  final String attr : dataTypes.keySet()) {
    d.dataTypes.put(attr,dataTypes.get(attr).clone());
  }
  for (  final String attr : hierarchies.keySet()) {
    d.hierarchies.put(attr,hierarchies.get(attr));
  }
  for (  final String attr : functions.keySet()) {
    d.functions.put(attr,functions.get(attr) == null ? null : functions.get(attr).clone());
  }
  for (  final String attr : minGeneralization.keySet()) {
    d.minGeneralization.put(attr,minGeneralization.get(attr));
  }
  for (  final String attr : maxGeneralization.keySet()) {
    d.maxGeneralization.put(attr,maxGeneralization.get(attr));
  }
  for (  final String attr : builders.keySet()) {
    d.builders.put(attr,builders.get(attr));
  }
  d.setLocked(this.isLocked());
  return d;
}",0.9806384092098378
108046,"/** 
 * Clones this config.
 * @return
 */
public ARXConfiguration clone(){
  ARXConfiguration result=new ARXConfiguration();
  result.practicalMonotonicity=this.practicalMonotonicity;
  result.relMaxOutliers=this.relMaxOutliers;
  result.absMaxOutliers=this.absMaxOutliers;
  result.aCriteria=this.aCriteria.clone();
  result.criteria=new HashSet<PrivacyCriterion>(this.criteria);
  result.requirements=this.requirements;
  result.metric=this.metric;
  result.snapshotLength=this.snapshotLength;
  result.suppressionString=this.suppressionString;
  result.suppressionAlwaysEnabled=this.suppressionAlwaysEnabled;
  result.suppressedAttributeTypes=this.suppressedAttributeTypes;
  result.heuristicSearchForSampleBasedCriteria=this.heuristicSearchForSampleBasedCriteria;
  if (this.attributeWeights != null) {
    result.attributeWeights=new HashMap<String,Double>(this.attributeWeights);
  }
 else {
    result.attributeWeights=null;
  }
  return result;
}","/** 
 * Clones this config.
 * @return
 */
public ARXConfiguration clone(){
  ARXConfiguration result=new ARXConfiguration();
  result.practicalMonotonicity=this.practicalMonotonicity;
  result.relMaxOutliers=this.relMaxOutliers;
  result.absMaxOutliers=this.absMaxOutliers;
  result.aCriteria=this.aCriteria.clone();
  result.criteria=new HashSet<PrivacyCriterion>(this.criteria);
  result.requirements=this.requirements;
  result.metric=this.metric;
  result.snapshotLength=this.snapshotLength;
  result.suppressionString=this.suppressionString;
  result.suppressionAlwaysEnabled=this.suppressionAlwaysEnabled;
  result.suppressedAttributeTypes=this.suppressedAttributeTypes;
  result.heuristicSearchForSampleBasedCriteria=this.heuristicSearchForSampleBasedCriteria;
  result.heuristicSearchEnabled=this.heuristicSearchEnabled;
  result.heuristicSearchThreshold=this.heuristicSearchThreshold;
  result.heuristicSearchTimeLimit=this.heuristicSearchTimeLimit;
  result.utilityBasedMicroaggregation=this.utilityBasedMicroaggregation;
  if (this.attributeWeights != null) {
    result.attributeWeights=new HashMap<String,Double>(this.attributeWeights);
  }
 else {
    result.attributeWeights=null;
  }
  return result;
}",0.8785648574057038
108047,"/** 
 * Builds the component
 * @param parent
 * @return
 */
private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  d2.grabExcessVerticalSpace=true;
  d2.verticalAlignment=GridData.CENTER;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.horizontalSpan=3;
  d30.verticalAlignment=GridData.CENTER;
  d30.grabExcessVerticalSpace=true;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  d22.grabExcessVerticalSpace=true;
  d22.verticalAlignment=GridData.CENTER;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel4=new Label(mBase,SWT.PUSH);
  mLabel4.setText(Resources.getMessage(""String_Node_Str""));
  GridData d24=new GridData();
  d24.heightHint=LABEL_HEIGHT;
  d24.minimumHeight=LABEL_HEIGHT;
  d24.grabExcessVerticalSpace=true;
  d24.verticalAlignment=GridData.CENTER;
  mLabel4.setLayoutData(d24);
  utilityBasedMicroaggregation=new Button(mBase,SWT.CHECK);
  utilityBasedMicroaggregation.setText(Resources.getMessage(""String_Node_Str""));
  utilityBasedMicroaggregation.setSelection(false);
  utilityBasedMicroaggregation.setEnabled(false);
  utilityBasedMicroaggregation.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  utilityBasedMicroaggregation.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setUseUtilityBasedMicroaggregation(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  d23.grabExcessVerticalSpace=true;
  d23.verticalAlignment=GridData.CENTER;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.READ_ONLY);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.horizontalSpan=3;
  d31.grabExcessVerticalSpace=true;
  d31.verticalAlignment=GridData.CENTER;
  comboAggregate.setLayoutData(d31);
  comboAggregate.setEnabled(false);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}","/** 
 * Builds the component
 * @param parent
 * @return
 */
private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  d2.grabExcessVerticalSpace=true;
  d2.verticalAlignment=GridData.CENTER;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.horizontalSpan=3;
  d30.verticalAlignment=GridData.CENTER;
  d30.grabExcessVerticalSpace=true;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  d22.grabExcessVerticalSpace=true;
  d22.verticalAlignment=GridData.CENTER;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel4=new Label(mBase,SWT.PUSH);
  mLabel4.setText(Resources.getMessage(""String_Node_Str""));
  GridData d24=new GridData();
  d24.heightHint=LABEL_HEIGHT;
  d24.minimumHeight=LABEL_HEIGHT;
  d24.grabExcessVerticalSpace=true;
  d24.verticalAlignment=GridData.CENTER;
  mLabel4.setLayoutData(d24);
  utilityBasedMicroaggregation=new Button(mBase,SWT.CHECK);
  utilityBasedMicroaggregation.setText(Resources.getMessage(""String_Node_Str""));
  utilityBasedMicroaggregation.setSelection(false);
  utilityBasedMicroaggregation.setEnabled(false);
  utilityBasedMicroaggregation.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  utilityBasedMicroaggregation.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setUseUtilityBasedMicroaggregation(utilityBasedMicroaggregation.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  d23.grabExcessVerticalSpace=true;
  d23.verticalAlignment=GridData.CENTER;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.READ_ONLY);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.horizontalSpan=3;
  d31.grabExcessVerticalSpace=true;
  d31.verticalAlignment=GridData.CENTER;
  comboAggregate.setLayoutData(d31);
  comboAggregate.setEnabled(false);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}",0.9945945945945946
108048,"/** 
 * Update function
 */
private void updateFunction(){
  if (model != null && model.getInputConfig() != null && model.getInputDefinition() != null) {
    DataScale scale=model.getInputDefinition().getDataType(attribute).getDescription().getScale();
    List<String> functions=new ArrayList<String>();
    for (    MicroAggregationFunctionDescription function : FUNCTIONS) {
      if (scale.provides(function.getRequiredScale())) {
        functions.add(function.getLabel());
      }
    }
    this.cmbFunction.setItems(functions.toArray(new String[functions.size()]));
    int index=functions.indexOf(model.getInputConfig().getMicroAggregationFunction(attribute));
    if (index == -1) {
      this.cmbFunction.select(0);
      this.model.getInputConfig().setMicroAggregationFunction(attribute,getMicroAggregationFunction(functions.get(0)));
    }
 else {
      this.cmbFunction.select(index);
      this.model.getInputConfig().setMicroAggregationFunction(attribute,getMicroAggregationFunction(functions.get(index)));
    }
    this.btnMissing.setSelection(this.model.getInputConfig().getMicroAggregationIgnoreMissingData(attribute));
  }
}","/** 
 * Update function
 */
private void updateFunction(){
  if (model != null && model.getInputConfig() != null && model.getInputDefinition() != null) {
    DataScale scale=model.getInputDefinition().getDataType(attribute).getDescription().getScale();
    List<String> functions=new ArrayList<String>();
    for (    MicroAggregationFunctionDescription function : FUNCTIONS) {
      if (scale.provides(function.getRequiredScale())) {
        functions.add(function.getLabel());
      }
    }
    this.cmbFunction.setItems(functions.toArray(new String[functions.size()]));
    MicroAggregationFunctionDescription description=model.getInputConfig().getMicroAggregationFunction(attribute);
    int index=description == null ? -1 : functions.indexOf(description.getLabel());
    if (index == -1) {
      this.cmbFunction.select(0);
      this.model.getInputConfig().setMicroAggregationFunction(attribute,getMicroAggregationFunction(functions.get(0)));
    }
 else {
      this.cmbFunction.select(index);
      this.model.getInputConfig().setMicroAggregationFunction(attribute,getMicroAggregationFunction(functions.get(index)));
    }
    this.btnMissing.setSelection(this.model.getInputConfig().getMicroAggregationIgnoreMissingData(attribute));
  }
}",0.9075700543705564
108049,"/** 
 * Action.
 */
private void actionReset(){
  if (filter != null) {
    DataDefinition definition=model.getOutputDefinition();
    if (definition == null) {
      reset();
      return;
    }
    List<String> attributes=new ArrayList<String>();
    attributes.addAll(definition.getQuasiIdentifyingAttributes());
    Collections.sort(attributes,new Comparator<String>(){
      public int compare(      String arg0,      String arg1){
        return model.getOutput().getColumnIndexOf(arg0) - model.getOutput().getColumnIndexOf(arg1);
      }
    }
);
    int dimension=0;
    for (    String attribute : attributes) {
      int attributeMin=definition.getMinimumGeneralization(attribute);
      int attributeMax=definition.getMaximumGeneralization(attribute);
      for (int i=attributeMin; i <= attributeMax; i++) {
        filter.allowGeneralization(dimension,i);
      }
      dimension++;
    }
    filter.allowAllInformationLoss();
    filter.allowAnonymous();
    filter.allowNonAnonymous();
    filter.allowUnknown();
    update();
    fireModelEvent();
  }
}","/** 
 * Action.
 */
private void actionReset(){
  if (filter != null) {
    DataDefinition definition=model.getOutputDefinition();
    if (definition == null) {
      reset();
      return;
    }
    List<String> attributes=new ArrayList<String>();
    attributes.addAll(definition.getQuasiIdentifiersWithGeneralization());
    Collections.sort(attributes,new Comparator<String>(){
      public int compare(      String arg0,      String arg1){
        return model.getOutput().getColumnIndexOf(arg0) - model.getOutput().getColumnIndexOf(arg1);
      }
    }
);
    int dimension=0;
    for (    String attribute : attributes) {
      int attributeMin=definition.getMinimumGeneralization(attribute);
      int attributeMax=definition.getMaximumGeneralization(attribute);
      for (int i=attributeMin; i <= attributeMax; i++) {
        filter.allowGeneralization(dimension,i);
      }
      dimension++;
    }
    filter.allowAllInformationLoss();
    filter.allowAnonymous();
    filter.allowNonAnonymous();
    filter.allowUnknown();
    update();
    fireModelEvent();
  }
}",0.983224603914259
108050,"/** 
 * Sets the input config.
 * @param config
 */
public void setInputConfig(final ModelConfiguration config){
  this.inputConfig=config;
  this.metricConfig=config.getMetric().getConfiguration();
  this.metricDescription=config.getMetric().getDescription();
}","/** 
 * Sets the input config.
 * @param config
 */
public void setInputConfig(final ModelConfiguration config){
  this.inputConfig=config;
}",0.6997518610421837
108051,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final DynamicTable table=SWTUtil.createTableDynamic(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  GridData data=SWTUtil.createFillGridData();
  data.heightHint=300;
  table.setLayoutData(data);
  DynamicTableColumn column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  for (  String attribute : attributes) {
    TableItem item=new TableItem(table,SWT.NONE);
    item.setText(new String[]{attribute,""String_Node_Str"",hierarchies.get(attribute)[0][0]});
  }
  final Menu menu=new Menu(table);
  table.setMenu(menu);
  menu.addMenuListener(new MenuAdapter(){
    public void menuShown(    MenuEvent e){
      MenuItem[] items=menu.getItems();
      for (int i=0; i < items.length; i++) {
        items[i].dispose();
      }
      if (attribute != null) {
        for (int i=0; i < hierarchies.get(attribute)[0].length; i++) {
          MenuItem newItem=new MenuItem(menu,SWT.NONE);
          newItem.setText(""String_Node_Str"" + i);
          final int level=i;
          newItem.addSelectionListener(new SelectionAdapter(){
            @Override public void widgetSelected(            SelectionEvent arg0){
              selection.put(attribute,level);
              item.setText(1,String.valueOf(level));
              item.setText(2,hierarchies.get(attribute)[0][level]);
            }
          }
);
        }
      }
    }
  }
);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        item=table.getItems()[table.getSelectionIndex()];
        attribute=item.getText(0);
      }
 else {
        item=null;
        attribute=null;
      }
    }
  }
);
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final DynamicTable table=SWTUtil.createTableDynamic(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  GridData data=SWTUtil.createFillGridData();
  data.heightHint=300;
  table.setLayoutData(data);
  DynamicTableColumn column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  for (  String attribute : attributes) {
    TableItem item=new TableItem(table,SWT.NONE);
    int level=selection.get(attribute);
    item.setText(new String[]{attribute,String.valueOf(level),hierarchies.get(attribute)[0][level]});
  }
  final Menu menu=new Menu(table);
  table.setMenu(menu);
  menu.addMenuListener(new MenuAdapter(){
    public void menuShown(    MenuEvent e){
      MenuItem[] items=menu.getItems();
      for (int i=0; i < items.length; i++) {
        items[i].dispose();
      }
      if (attribute != null) {
        for (int i=0; i < hierarchies.get(attribute)[0].length; i++) {
          MenuItem newItem=new MenuItem(menu,SWT.NONE);
          newItem.setText(""String_Node_Str"" + i);
          final int level=i;
          newItem.addSelectionListener(new SelectionAdapter(){
            @Override public void widgetSelected(            SelectionEvent arg0){
              selection.put(attribute,level);
              item.setText(1,String.valueOf(level));
              item.setText(2,hierarchies.get(attribute)[0][level]);
            }
          }
);
        }
      }
    }
  }
);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        item=table.getItems()[table.getSelectionIndex()];
        attribute=item.getText(0);
      }
 else {
        item=null;
        attribute=null;
      }
    }
  }
);
  return parent;
}",0.9827018121911038
108052,"/** 
 * Returns the minimum and maximum value
 * @param dictionary
 * @param type
 * @return
 */
protected <T>double[] getMinMax(String[] dictionary,DataTypeWithRatioScale<T> type){
  T min=null;
  T max=null;
  for (  String string : dictionary) {
    T value=type.parse(string);
    min=min == null || type.compare(min,value) > 0 ? value : min;
    max=max == null || type.compare(max,value) < 0 ? value : max;
  }
  return new double[]{type.toDouble(min),type.toDouble(max)};
}","/** 
 * Returns the minimum and maximum value
 * @param dictionary
 * @param type
 * @return
 */
protected <T>double[] getMinMax(String[] dictionary,DataTypeWithRatioScale<T> type){
  T min=null;
  T max=null;
  for (  String string : dictionary) {
    T value=type.parse(string);
    if (!ignoreMissingData || value != null) {
      min=min == null || type.compare(min,value) > 0 ? value : min;
      max=max == null || type.compare(max,value) < 0 ? value : max;
    }
  }
  Double _min=type.toDouble(min);
  Double _max=type.toDouble(max);
  _min=_min != null ? _min : 0d;
  _max=_max != null ? _max : 0d;
  return new double[]{_min,_max};
}",0.7640249332146037
108053,"/** 
 * Parse
 * @param other
 */
public abstract void parse(ModelCriterion other);","/** 
 * Parse
 * @param other
 * @param _default Defines whether the model represents a typical parameter configuration for the criterion
 */
public abstract void parse(ModelCriterion other,boolean _default);",0.570446735395189
108054,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelDPresenceCriterion)) {
    return;
  }
  ModelDPresenceCriterion other=(ModelDPresenceCriterion)criterion;
  this.dmax=other.dmax;
  this.dmin=other.dmin;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelDPresenceCriterion)) {
    return;
  }
  ModelDPresenceCriterion other=(ModelDPresenceCriterion)criterion;
  this.dmax=other.dmax;
  this.dmin=other.dmin;
  this.setEnabled(other.isEnabled());
}",0.9708404802744426
108055,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelDifferentialPrivacyCriterion)) {
    return;
  }
  ModelDifferentialPrivacyCriterion other=(ModelDifferentialPrivacyCriterion)criterion;
  this.epsilon=other.epsilon;
  this.delta=other.delta;
  this.generalization=other.generalization.clone();
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelDifferentialPrivacyCriterion)) {
    return;
  }
  ModelDifferentialPrivacyCriterion other=(ModelDifferentialPrivacyCriterion)criterion;
  this.epsilon=other.epsilon;
  this.delta=other.delta;
  if (!_default) {
    this.generalization=other.generalization.clone();
  }
  this.setEnabled(other.isEnabled());
}",0.9467005076142132
108056,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelKAnonymityCriterion)) {
    return;
  }
  ModelKAnonymityCriterion other=(ModelKAnonymityCriterion)criterion;
  this.k=other.k;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelKAnonymityCriterion)) {
    return;
  }
  ModelKAnonymityCriterion other=(ModelKAnonymityCriterion)criterion;
  this.k=other.k;
  this.setEnabled(other.isEnabled());
}",0.9678638941398866
108057,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelLDiversityCriterion)) {
    return;
  }
  ModelLDiversityCriterion other=(ModelLDiversityCriterion)criterion;
  this.l=other.l;
  this.c=other.c;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelLDiversityCriterion)) {
    return;
  }
  ModelLDiversityCriterion other=(ModelLDiversityCriterion)criterion;
  this.l=other.l;
  this.c=other.c;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}",0.9728
108058,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelRiskBasedCriterion)) {
    return;
  }
  ModelRiskBasedCriterion other=(ModelRiskBasedCriterion)criterion;
  this.threshold=other.threshold;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelRiskBasedCriterion)) {
    return;
  }
  ModelRiskBasedCriterion other=(ModelRiskBasedCriterion)criterion;
  this.threshold=other.threshold;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}",0.9723577235772358
108059,"@Override public void parse(ModelCriterion criterion){
  if (!(criterion instanceof ModelTClosenessCriterion)) {
    return;
  }
  ModelTClosenessCriterion other=(ModelTClosenessCriterion)criterion;
  this.t=other.t;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}","@Override public void parse(ModelCriterion criterion,boolean _default){
  if (!(criterion instanceof ModelTClosenessCriterion)) {
    return;
  }
  ModelTClosenessCriterion other=(ModelTClosenessCriterion)criterion;
  this.t=other.t;
  this.variant=other.variant;
  this.setEnabled(other.isEnabled());
}",0.9711375212224108
108060,"/** 
 * Parse method
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public void parseDefault(ModelCriterion model){
  this.parse((T)model,true);
  this.model.parse(model);
}","/** 
 * Parse method
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public void parseDefault(ModelCriterion model){
  this.parse((T)model,true);
  this.model.parse(model,true);
}",0.9865229110512128
108061,"/** 
 * Creates a new instance for the given data set.
 * @param data
 * @param subset
 */
@SuppressWarnings(""String_Node_Str"") public CardinalitiesGeneric(HashGroupify groupify){
  this.cardinalities=null;
  this.maps=new Map[groupify.getFirstEquivalenceClass().key.length];
  for (int i=0; i < maps.length; i++) {
    this.maps[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=groupify.getFirstEquivalenceClass();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < maps.length; i++) {
        int key=m.isNotOutlier ? m.key[i] : -1;
        Integer count=this.maps[i].get(key);
        this.maps[i].put(key,count == null ? 1 : count + 1);
      }
    }
    m=m.nextOrdered;
  }
}","/** 
 * Creates a new instance for the given data set.
 * @param data
 * @param subset
 */
@SuppressWarnings(""String_Node_Str"") public CardinalitiesGeneric(HashGroupify groupify){
  this.cardinalities=null;
  this.maps=new Map[groupify.getFirstEquivalenceClass().key.length];
  for (int i=0; i < maps.length; i++) {
    this.maps[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=groupify.getFirstEquivalenceClass();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < maps.length; i++) {
        int key=m.isNotOutlier ? m.key[i] : -1;
        Integer count=this.maps[i].get(key);
        this.maps[i].put(key,count == null ? m.count : count + m.count);
      }
    }
    m=m.nextOrdered;
  }
}",0.98884239888424
108062,"/** 
 * Build an ARX lattice for a completely classified solution space
 * @param optimum
 * @param headermap
 */
private void buildComplete(final Transformation optimum,Map<String,Integer> headermap){
  this.size=(int)solutions.getSize();
  int[] offsets=solutions.getMultipliersForLowDimensionalData();
  int[] maxLevels=solutions.getTop().getGeneralization();
  int[] minLevels=solutions.getBottom().getGeneralization();
  int topLevel=solutions.getTop().getLevel();
  int[] levelsizes=new int[topLevel + 1];
  ARXNode[] cache=new ARXNode[size];
  for (int identifier=0; identifier < cache.length; identifier++) {
    Transformation transformation=solutions.getTransformation(identifier);
    cache[identifier]=new ARXNode(this,this.solutions,transformation,headermap);
    if (identifier == optimum.getIdentifier()) {
      this.optimum=cache[identifier];
    }
    int numSuccessors=0;
    int numPredecessors=0;
    int[] generalization=transformation.getGeneralization();
    for (int dimension=0; dimension < generalization.length; dimension++) {
      numPredecessors+=generalization[dimension] > minLevels[dimension] ? 1 : 0;
      numSuccessors+=generalization[dimension] < maxLevels[dimension] ? 1 : 0;
    }
    levelsizes[transformation.getLevel()]++;
    cache[identifier].successors=new ARXNode[numSuccessors];
    cache[identifier].predecessors=new ARXNode[numPredecessors];
  }
  this.levels=new ARXNode[topLevel + 1][];
  for (int i=0; i < levels.length; i++) {
    levels[i]=new ARXNode[levelsizes[i]];
  }
  int[] successorIndices=new int[size];
  int[] predecessorIndices=new int[size];
  for (int identifier=0; identifier < cache.length; identifier++) {
    ARXNode node=cache[identifier];
    int level=node.getTotalGeneralizationLevel();
    --levelsizes[level];
    levels[level][levels[level].length - 1 - levelsizes[level]]=node;
    int[] generalization=node.getTransformation();
    for (int dimension=0; dimension < generalization.length; dimension++) {
      if (generalization[dimension] < maxLevels[dimension]) {
        int successorIdentifier=identifier + offsets[dimension];
        ARXNode successor=cache[successorIdentifier];
        node.successors[successorIndices[identifier]++]=successor;
        successor.predecessors[predecessorIndices[successorIdentifier]++]=node;
      }
    }
  }
}","/** 
 * Build an ARX lattice for a completely classified solution space
 * @param optimum
 * @param headermap
 */
private void buildComplete(final Transformation optimum,Map<String,Integer> headermap){
  this.size=(int)solutions.getSize();
  int[] offsets=solutions.getMultipliersForLowDimensionalData();
  int[] maxLevels=solutions.getTop().getGeneralization();
  int[] minLevels=solutions.getBottom().getGeneralization();
  int topLevel=solutions.getTop().getLevel();
  int[] levelsizes=new int[topLevel + 1];
  ARXNode[] cache=new ARXNode[size];
  for (int identifier=0; identifier < cache.length; identifier++) {
    Transformation transformation=solutions.getTransformation(identifier);
    cache[identifier]=new ARXNode(this,this.solutions,transformation,headermap);
    if (optimum != null && identifier == optimum.getIdentifier()) {
      this.optimum=cache[identifier];
    }
    int numSuccessors=0;
    int numPredecessors=0;
    int[] generalization=transformation.getGeneralization();
    for (int dimension=0; dimension < generalization.length; dimension++) {
      numPredecessors+=generalization[dimension] > minLevels[dimension] ? 1 : 0;
      numSuccessors+=generalization[dimension] < maxLevels[dimension] ? 1 : 0;
    }
    levelsizes[transformation.getLevel()]++;
    cache[identifier].successors=new ARXNode[numSuccessors];
    cache[identifier].predecessors=new ARXNode[numPredecessors];
  }
  this.levels=new ARXNode[topLevel + 1][];
  for (int i=0; i < levels.length; i++) {
    levels[i]=new ARXNode[levelsizes[i]];
  }
  int[] successorIndices=new int[size];
  int[] predecessorIndices=new int[size];
  for (int identifier=0; identifier < cache.length; identifier++) {
    ARXNode node=cache[identifier];
    int level=node.getTotalGeneralizationLevel();
    --levelsizes[level];
    levels[level][levels[level].length - 1 - levelsizes[level]]=node;
    int[] generalization=node.getTransformation();
    for (int dimension=0; dimension < generalization.length; dimension++) {
      if (generalization[dimension] < maxLevels[dimension]) {
        int successorIdentifier=identifier + offsets[dimension];
        ARXNode successor=cache[successorIdentifier];
        node.successors[successorIndices[identifier]++]=successor;
        successor.predecessors[predecessorIndices[successorIdentifier]++]=node;
      }
    }
  }
}",0.9959427717275252
108063,"/** 
 * Returns whether the privacy model is monotonic
 * @return
 */
public Monotonicity getMonotonicityOfPrivacy(){
  if (this.isPracticalMonotonicity()) {
    return Monotonicity.FULL;
  }
  if (this.getMaxOutliers() == 0d) {
    for (    PrivacyCriterion criterion : this.getCriteria()) {
      if (!criterion.isMonotonicWithSuppression() || !criterion.isMonotonicWithGeneralization()) {
        if (this.getMinimalGroupSize() != Integer.MAX_VALUE) {
          return Monotonicity.PARTIAL;
        }
 else {
          return Monotonicity.NONE;
        }
      }
    }
  }
 else {
    for (    PrivacyCriterion criterion : this.getCriteria()) {
      if (!criterion.isMonotonicWithGeneralization()) {
        if (this.getMinimalGroupSize() != Integer.MAX_VALUE) {
          return Monotonicity.PARTIAL;
        }
 else {
          return Monotonicity.NONE;
        }
      }
    }
  }
  return Monotonicity.FULL;
}","/** 
 * Returns whether the privacy model is monotonic
 * @return
 */
public Monotonicity getMonotonicityOfPrivacy(){
  if (this.isPracticalMonotonicity()) {
    return Monotonicity.FULL;
  }
  if (this.getMaxOutliers() == 0d) {
    for (    PrivacyCriterion criterion : this.getCriteria()) {
      if (!criterion.isMonotonicWithGeneralization()) {
        if (this.getMinimalGroupSize() != Integer.MAX_VALUE) {
          return Monotonicity.PARTIAL;
        }
 else {
          return Monotonicity.NONE;
        }
      }
    }
  }
 else {
    for (    PrivacyCriterion criterion : this.getCriteria()) {
      if (!criterion.isMonotonicWithSuppression() || !criterion.isMonotonicWithGeneralization()) {
        if (this.getMinimalGroupSize() != Integer.MAX_VALUE) {
          return Monotonicity.PARTIAL;
        }
 else {
          return Monotonicity.NONE;
        }
      }
    }
  }
  return Monotonicity.FULL;
}",0.9531079607415486
108064,"/** 
 * Constructor.
 * @param solutions The solution space
 * @param complete Is the solution space characterized by an optimal algorithm
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final boolean complete,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.solutions=solutions;
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.complete=complete;
  this.virtualSize=solutions.getSize();
  this.uncertainty=config.isPracticalMonotonicity() && (config.getMonotonicityOfUtility() != Monotonicity.FULL || config.getMonotonicityOfPrivacy() != Monotonicity.FULL);
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(transformation.getIdentifier(),node);
    levels.get(transformation.getLevel()).add(node);
    if (optimum != null && transformation.getIdentifier() == optimum.getIdentifier()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
    size++;
  }
  if (!complete) {
    Transformation top=solutions.getTop();
    Transformation bottom=solutions.getBottom();
    if (!map.containsKey(top.getIdentifier())) {
      if (!levels.containsKey(top.getLevel())) {
        levels.put(top.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,top,headermap);
      map.put(top.getIdentifier(),node);
      levels.get(top.getLevel()).add(node);
      maxlevel=top.getLevel();
      size++;
    }
    if (!map.containsKey(bottom.getIdentifier())) {
      if (!levels.containsKey(bottom.getLevel())) {
        levels.put(bottom.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,bottom,headermap);
      map.put(bottom.getIdentifier(),node);
      levels.get(bottom.getLevel()).add(node);
      size++;
    }
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    createRelationships(solutions,map,iterator.next());
  }
  if (!complete) {
    createRelationships(solutions,map,solutions.getTop().getIdentifier());
    createRelationships(solutions,map,solutions.getBottom().getIdentifier());
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}","/** 
 * Constructor.
 * @param solutions The solution space
 * @param complete Is the solution space characterized by an optimal algorithm
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final boolean complete,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.solutions=solutions;
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.complete=complete;
  this.virtualSize=solutions.getSize();
  this.uncertainty=config.isPracticalMonotonicity();
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(transformation.getIdentifier(),node);
    levels.get(transformation.getLevel()).add(node);
    if (optimum != null && transformation.getIdentifier() == optimum.getIdentifier()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
    size++;
  }
  if (!complete) {
    Transformation top=solutions.getTop();
    Transformation bottom=solutions.getBottom();
    if (!map.containsKey(top.getIdentifier())) {
      if (!levels.containsKey(top.getLevel())) {
        levels.put(top.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,top,headermap);
      map.put(top.getIdentifier(),node);
      levels.get(top.getLevel()).add(node);
      maxlevel=top.getLevel();
      size++;
    }
    if (!map.containsKey(bottom.getIdentifier())) {
      if (!levels.containsKey(bottom.getLevel())) {
        levels.put(bottom.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,bottom,headermap);
      map.put(bottom.getIdentifier(),node);
      levels.get(bottom.getLevel()).add(node);
      size++;
    }
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    createRelationships(solutions,map,iterator.next());
  }
  if (!complete) {
    createRelationships(solutions,map,solutions.getTop().getIdentifier());
    createRelationships(solutions,map,solutions.getBottom().getIdentifier());
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}",0.9851347946586042
108065,"@Parameters(name=""String_Node_Str"") public static Collection<Object[]> cases() throws IOException {
  return Arrays.asList(new Object[][]{{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new EntropyLDiversity(""String_Node_Str"",5)),""String_Node_Str"",""String_Node_Str"",228878.2039109517,new int[]{1,0,1,1,2,2,2,1},false,new int[]{4320,2249,367,3374,0,0,367})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new RecursiveCLDiversity(""String_Node_Str"",4d,5)),""String_Node_Str"",""String_Node_Str"",3536911.5162082445,new int[]{0,4,0,0,2,0,1,2},true,new int[]{8748,150,77,71,685,7915,77})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new KAnonymity(100)),""String_Node_Str"",1994002.8308631124,new int[]{3,4,1,1,0,4,4,4},false,new int[]{45000,2041,2733,41577,0,0,1809})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.05d,Metric.createEntropyMetric(false)).addCriterion(new DPresence(0.0,0.2,DataSubset.create(Data.create(""String_Node_Str"",';'),Data.create(""String_Node_Str"",';')))),""String_Node_Str"",""String_Node_Str"",128068.07605943311,new int[]{2,4,1,1,0,3,4},false,new int[]{9000,8992,1862,7130,0,0,1862})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new EqualDistanceTCloseness(""String_Node_Str"",0.2d)).addCriterion(new KAnonymity(5)),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new int[]{0,0,0,3,4,2,0,1},true,new int[]{12960,28,6,21,102,12831,6})}});
}","@Parameters(name=""String_Node_Str"") public static Collection<Object[]> cases() throws IOException {
  return Arrays.asList(new Object[][]{{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new EntropyLDiversity(""String_Node_Str"",5)),""String_Node_Str"",""String_Node_Str"",228878.2039109517,new int[]{1,0,1,1,2,2,2,1},false,new int[]{4320,2249,367,3374,0,0,367})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new RecursiveCLDiversity(""String_Node_Str"",4d,5)),""String_Node_Str"",""String_Node_Str"",3536911.5162082445,new int[]{0,4,0,0,2,0,1,2},true,new int[]{8748,150,78,72,684,7914,78})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new KAnonymity(100)),""String_Node_Str"",1994002.8308631124,new int[]{3,4,1,1,0,4,4,4},false,new int[]{45000,2041,2733,41577,0,0,1809})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.05d,Metric.createEntropyMetric(false)).addCriterion(new DPresence(0.0,0.2,DataSubset.create(Data.create(""String_Node_Str"",';'),Data.create(""String_Node_Str"",';')))),""String_Node_Str"",""String_Node_Str"",128068.07605943311,new int[]{2,4,1,1,0,3,4},false,new int[]{9000,8992,1862,7130,0,0,1862})},{new ARXAnonymizationTestCase(ARXConfiguration.create(0.04d,Metric.createEntropyMetric(false)).addCriterion(new EqualDistanceTCloseness(""String_Node_Str"",0.2d)).addCriterion(new KAnonymity(5)),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new int[]{0,0,0,3,4,2,0,1},true,new int[]{12960,28,6,22,102,12830,6})}});
}",0.989480198019802
108066,"@Override protected void initializeInternal(final DataManager manager,final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(manager,definition,input,hierarchies,config);
  this.upper=super.getUpperBounds();
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  Arrays.fill(min,1d);
  super.setMax(max);
  super.setMin(min);
}","@Override protected void initializeInternal(final DataManager manager,final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(manager,definition,input,hierarchies,config);
  this.upper=super.getUpperBounds();
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  Arrays.fill(max,1d);
  super.setMax(max);
  super.setMin(min);
}",0.9959016393442623
108067,"@Override public boolean isInstance(Metric<?> metric){
  return (metric instanceof MetricMDPrecision) || (metric instanceof MetricMDNMPrecision);
}","@Override public boolean isInstance(Metric<?> metric){
  return (metric instanceof MetricSDNMAmbiguity);
}",0.7747035573122529
108068,"@Override public Metric<?> createInstance(MetricConfiguration config){
  return createPrecisionMetric(config.isMonotonic(),config.getAggregateFunction());
}","@Override public Metric<?> createInstance(MetricConfiguration config){
  return createAmbiguityMetric();
}",0.7557251908396947
108069,"/** 
 * Returns a list of all available metrics for information loss.
 * @return
 */
public static List<MetricDescription> list(){
  return Arrays.asList(new MetricDescription[]{new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    private static final long serialVersionUID=5194477380451716051L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAECSMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDAECS);
    }
  }
,new MetricDescription(""String_Node_Str"",true,false,false,false,false){
    private static final long serialVersionUID=183842500322023095L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createDiscernabilityMetric(config.isMonotonic());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDDiscernability) || (metric instanceof MetricSDNMDiscernability);
    }
  }
,new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    /** 
 * SVUID 
 */
    private static final long serialVersionUID=9125639204133496116L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAmbiguityMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDNMAmbiguity);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,false,true){
    private static final long serialVersionUID=9125639204133496116L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createHeightMetric(config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDHeight);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,true,true,true){
    private static final long serialVersionUID=4274885123814166707L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedLossMetric(config.getPrecomputationThreshold(),config.getGsFactor(),config.getAggregateFunction());
      }
 else {
        return createLossMetric(config.getGsFactor(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNMLoss) || (metric instanceof MetricMDNMLossPrecomputed) || (metric instanceof MetricMDNMLossPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,true,true){
    private static final long serialVersionUID=2578476174209277258L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedEntropyMetric(config.getPrecomputationThreshold(),config.isMonotonic(),config.getAggregateFunction());
      }
 else {
        return createEntropyMetric(config.isMonotonic(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNUEntropy) || (metric instanceof MetricMDNUEntropyPrecomputed) || (metric instanceof MetricMDNUEntropyPotentiallyPrecomputed)|| (metric instanceof MetricMDNUNMEntropy)|| (metric instanceof MetricMDNUNMEntropyPrecomputed)|| (metric instanceof MetricMDNUNMEntropyPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,false,true){
    private static final long serialVersionUID=2992096817427174514L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createPrecisionMetric(config.isMonotonic(),config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDPrecision) || (metric instanceof MetricMDNMPrecision);
    }
  }
});
}","/** 
 * Returns a list of all available metrics for information loss.
 * @return
 */
public static List<MetricDescription> list(){
  return Arrays.asList(new MetricDescription[]{new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    private static final long serialVersionUID=5194477380451716051L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAECSMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDAECS);
    }
  }
,new MetricDescription(""String_Node_Str"",true,false,false,false,false){
    private static final long serialVersionUID=183842500322023095L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createDiscernabilityMetric(config.isMonotonic());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDDiscernability) || (metric instanceof MetricSDNMDiscernability);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,false,true){
    private static final long serialVersionUID=9125639204133496116L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createHeightMetric(config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDHeight);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,true,true,true){
    private static final long serialVersionUID=4274885123814166707L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedLossMetric(config.getPrecomputationThreshold(),config.getGsFactor(),config.getAggregateFunction());
      }
 else {
        return createLossMetric(config.getGsFactor(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNMLoss) || (metric instanceof MetricMDNMLossPrecomputed) || (metric instanceof MetricMDNMLossPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,true,true){
    private static final long serialVersionUID=2578476174209277258L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedEntropyMetric(config.getPrecomputationThreshold(),config.isMonotonic(),config.getAggregateFunction());
      }
 else {
        return createEntropyMetric(config.isMonotonic(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNUEntropy) || (metric instanceof MetricMDNUEntropyPrecomputed) || (metric instanceof MetricMDNUEntropyPotentiallyPrecomputed)|| (metric instanceof MetricMDNUNMEntropy)|| (metric instanceof MetricMDNUNMEntropyPrecomputed)|| (metric instanceof MetricMDNUNMEntropyPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,false,true){
    private static final long serialVersionUID=2992096817427174514L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createPrecisionMetric(config.isMonotonic(),config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDPrecision) || (metric instanceof MetricMDNMPrecision);
    }
  }
,new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    /** 
 * SVUID 
 */
    private static final long serialVersionUID=3549715700376537750L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAmbiguityMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDNMAmbiguity);
    }
  }
});
}",0.8904282115869018
108070,"@Override protected ILSingleDimensional getLowerBoundInternal(Transformation node,HashGroupify g){
  int[] transformation=node.getGeneralization();
  double result=0d;
  HashGroupifyEntry m=g.getFirstEquivalenceClass();
  while (m != null) {
    if (m.count > 0) {
      double classResult=1d;
      for (int dimension=0; dimension < transformation.length; dimension++) {
        int value=m.key[dimension];
        int level=transformation[dimension];
        double share=shares[dimension].getShare(value,level);
        classResult*=share * shares[dimension].getDomainSize();
      }
      classResult*=m.count;
      result+=classResult;
    }
  }
  return new ILSingleDimensional(result);
}","@Override protected ILSingleDimensional getLowerBoundInternal(Transformation node,HashGroupify g){
  int[] transformation=node.getGeneralization();
  double result=0d;
  HashGroupifyEntry m=g.getFirstEquivalenceClass();
  while (m != null) {
    if (m.count > 0) {
      double classResult=1d;
      for (int dimension=0; dimension < transformation.length; dimension++) {
        int value=m.key[dimension];
        int level=transformation[dimension];
        double share=shares[dimension].getShare(value,level);
        classResult*=share * shares[dimension].getDomainSize();
      }
      classResult*=m.count;
      result+=classResult;
    }
    m=m.nextOrdered;
  }
  return new ILSingleDimensional(result);
}",0.9851169383416016
108071,"/** 
 * Returns a list of all available metrics for information loss.
 * @return
 */
public static List<MetricDescription> list(){
  return Arrays.asList(new MetricDescription[]{new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    private static final long serialVersionUID=5194477380451716051L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAECSMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDAECS);
    }
  }
,new MetricDescription(""String_Node_Str"",true,false,false,false,false){
    private static final long serialVersionUID=183842500322023095L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createDiscernabilityMetric(config.isMonotonic());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDDiscernability) || (metric instanceof MetricSDNMDiscernability);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,false,true){
    private static final long serialVersionUID=9125639204133496116L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createHeightMetric(config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDHeight);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,true,true,true){
    private static final long serialVersionUID=4274885123814166707L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedLossMetric(config.getPrecomputationThreshold(),config.getGsFactor(),config.getAggregateFunction());
      }
 else {
        return createLossMetric(config.getGsFactor(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNMLoss) || (metric instanceof MetricMDNMLossPrecomputed) || (metric instanceof MetricMDNMLossPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,true,true){
    private static final long serialVersionUID=2578476174209277258L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedEntropyMetric(config.getPrecomputationThreshold(),config.isMonotonic(),config.getAggregateFunction());
      }
 else {
        return createEntropyMetric(config.isMonotonic(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNUEntropy) || (metric instanceof MetricMDNUEntropyPrecomputed) || (metric instanceof MetricMDNUEntropyPotentiallyPrecomputed)|| (metric instanceof MetricMDNUNMEntropy)|| (metric instanceof MetricMDNUNMEntropyPrecomputed)|| (metric instanceof MetricMDNUNMEntropyPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,false,true){
    private static final long serialVersionUID=2992096817427174514L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createPrecisionMetric(config.isMonotonic(),config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDPrecision) || (metric instanceof MetricMDNMPrecision);
    }
  }
,new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    /** 
 * SVUID 
 */
    private static final long serialVersionUID=3549715700376537750L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAmbiguityMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDNMAmbiguity);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,true,true){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=8536219303137546137L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedNormalizedEntropyMetric(config.getPrecomputationThreshold(),config.getAggregateFunction());
      }
 else {
        return createNormalizedEntropyMetric(config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNUNMNormalizedEntropy) || (metric instanceof MetricMDNUNMNormalizedEntropyPrecomputed) || (metric instanceof MetricMDNUNMNormalizedEntropyPotentiallyPrecomputed);
    }
  }
});
}","/** 
 * Returns a list of all available metrics for information loss.
 * @return
 */
public static List<MetricDescription> list(){
  return Arrays.asList(new MetricDescription[]{new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    private static final long serialVersionUID=5194477380451716051L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAECSMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDAECS);
    }
  }
,new MetricDescription(""String_Node_Str"",true,false,false,false,false){
    private static final long serialVersionUID=183842500322023095L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createDiscernabilityMetric(config.isMonotonic());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDDiscernability) || (metric instanceof MetricSDNMDiscernability);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,false,true){
    private static final long serialVersionUID=9125639204133496116L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createHeightMetric(config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDHeight);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,true,true,true){
    private static final long serialVersionUID=4274885123814166707L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedLossMetric(config.getPrecomputationThreshold(),config.getGsFactor(),config.getAggregateFunction());
      }
 else {
        return createLossMetric(config.getGsFactor(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNMLoss) || (metric instanceof MetricMDNMLossPrecomputed) || (metric instanceof MetricMDNMLossPotentiallyPrecomputed);
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,true,true){
    private static final long serialVersionUID=2578476174209277258L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedEntropyMetric(config.getPrecomputationThreshold(),config.isMonotonic(),config.getAggregateFunction());
      }
 else {
        return createEntropyMetric(config.isMonotonic(),config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return ((metric instanceof MetricMDNUEntropy) || (metric instanceof MetricMDNUEntropyPrecomputed) || (metric instanceof MetricMDNUEntropyPotentiallyPrecomputed)|| (metric instanceof MetricMDNUNMEntropy)|| (metric instanceof MetricMDNUNMEntropyPrecomputed)|| (metric instanceof MetricMDNUNMEntropyPotentiallyPrecomputed)) && !((metric instanceof MetricMDNUNMNormalizedEntropy) || (metric instanceof MetricMDNUNMNormalizedEntropyPrecomputed) || (metric instanceof MetricMDNUNMNormalizedEntropyPotentiallyPrecomputed));
    }
  }
,new MetricDescription(""String_Node_Str"",true,true,false,false,true){
    private static final long serialVersionUID=2992096817427174514L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createPrecisionMetric(config.isMonotonic(),config.getAggregateFunction());
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDPrecision) || (metric instanceof MetricMDNMPrecision);
    }
  }
,new MetricDescription(""String_Node_Str"",false,false,false,false,false){
    /** 
 * SVUID 
 */
    private static final long serialVersionUID=3549715700376537750L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      return createAmbiguityMetric();
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricSDNMAmbiguity);
    }
  }
,new MetricDescription(""String_Node_Str"",false,true,false,true,true){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=8536219303137546137L;
    @Override public Metric<?> createInstance(    MetricConfiguration config){
      if (config.isPrecomputed()) {
        return createPrecomputedNormalizedEntropyMetric(config.getPrecomputationThreshold(),config.getAggregateFunction());
      }
 else {
        return createNormalizedEntropyMetric(config.getAggregateFunction());
      }
    }
    @Override public boolean isInstance(    Metric<?> metric){
      return (metric instanceof MetricMDNUNMNormalizedEntropy) || (metric instanceof MetricMDNUNMNormalizedEntropyPrecomputed) || (metric instanceof MetricMDNUNMNormalizedEntropyPotentiallyPrecomputed);
    }
  }
});
}",0.9796970009275482
108072,"private void collectAll(){
  DeviceData info=display.getDeviceData();
  if (!info.tracking) {
    MessageBox dialog=new MessageBox(shell,SWT.ICON_WARNING | SWT.OK);
    dialog.setText(shell.getText());
    dialog.setMessage(""String_Node_Str"");
    dialog.open();
  }
  newObjects=info.objects;
  newErrors=info.errors;
  Map<String,Integer> objectTypesTimes=new TreeMap<String,Integer>();
  Map<String,Object> objectSameStackTrace=new HashMap<String,Object>();
  final Map<Object,Integer> objectSameStackTraceTimes=new HashMap<Object,Integer>();
  Map<Object,Integer> objectSameStackTraceIDX=new HashMap<Object,Integer>();
  for (int i=0; i < newObjects.length; i++) {
    String className=newObjects[i].getClass().getSimpleName();
    Integer count=objectTypesTimes.get(className);
    if (count == null) {
      objectTypesTimes.put(className,1);
    }
 else {
      objectTypesTimes.put(className,count + 1);
    }
    String stackTrace=getStackTrace(newErrors[i]);
    if (!objectSameStackTrace.containsKey(stackTrace)) {
      objectSameStackTrace.put(stackTrace,newObjects[i]);
      objectSameStackTraceTimes.put(newObjects[i],1);
      objectSameStackTraceIDX.put(newObjects[i],i);
    }
 else {
      Object object=objectSameStackTrace.get(stackTrace);
      objectSameStackTraceTimes.put(object,objectSameStackTraceTimes.get(object) + 1);
    }
  }
  equalObjects=new Object[objectSameStackTrace.size()];
  equalErrors=new Error[objectSameStackTrace.size()];
  int idx=0;
  for (  Entry<String,Object> entry : objectSameStackTrace.entrySet()) {
    equalObjects[idx++]=entry.getValue();
  }
  Arrays.sort(equalObjects,new Comparator<Object>(){
    @Override public int compare(    Object o1,    Object o2){
      return objectSameStackTraceTimes.get(o2) - objectSameStackTraceTimes.get(o1);
    }
  }
);
  for (int i=0; i < equalErrors.length; i++) {
    equalErrors[i]=newErrors[objectSameStackTraceIDX.get(equalObjects[i])];
  }
  StringBuilder statistics=new StringBuilder();
  for (  Entry<String,Integer> entry : objectTypesTimes.entrySet()) {
    statistics.append(entry.getKey());
    statistics.append(""String_Node_Str"");
    statistics.append(entry.getValue());
    statistics.append(""String_Node_Str"");
  }
  statistics.append(""String_Node_Str"");
  statistics.append(newObjects.length);
  statistics.append(""String_Node_Str"");
  listNewObjects.removeAll();
  for (int i=0; i < newObjects.length; i++) {
    listNewObjects.add(newObjects[i].getClass().getSimpleName() + ""String_Node_Str"" + newObjects[i].hashCode()+ ""String_Node_Str"");
  }
  listEqualObjects.removeAll();
  for (int i=0; i < equalObjects.length; i++) {
    listEqualObjects.add(equalObjects[i].getClass().getSimpleName() + ""String_Node_Str"" + equalObjects[i].hashCode()+ ""String_Node_Str""+ ""String_Node_Str""+ objectSameStackTraceTimes.get(equalObjects[i])+ ""String_Node_Str"");
  }
  objectStatistics.setText(statistics.toString());
}","private void collectAll(){
  DeviceData info=display.getDeviceData();
  if (!info.tracking) {
    MessageBox dialog=new MessageBox(shell,SWT.ICON_WARNING | SWT.OK);
    dialog.setText(shell.getText());
    dialog.setMessage(""String_Node_Str"");
    dialog.open();
  }
  newObjects=info.objects;
  newErrors=info.errors;
  Map<String,Integer> objectTypesTimes=new TreeMap<String,Integer>();
  Map<String,Integer> objectSameStackTrace=new HashMap<String,Integer>();
  final Map<Integer,Integer> objectSameStackTraceTimes=new HashMap<Integer,Integer>();
  for (int i=0; i < newObjects.length; i++) {
    String className=newObjects[i].getClass().getSimpleName();
    Integer count=objectTypesTimes.get(className);
    if (count == null) {
      objectTypesTimes.put(className,1);
    }
 else {
      objectTypesTimes.put(className,count + 1);
    }
    String stackTrace=getStackTrace(newErrors[i]);
    if (!objectSameStackTrace.containsKey(stackTrace)) {
      objectSameStackTrace.put(stackTrace,i);
      objectSameStackTraceTimes.put(i,1);
    }
 else {
      Integer objectIDX=objectSameStackTrace.get(stackTrace);
      objectSameStackTraceTimes.put(objectIDX,objectSameStackTraceTimes.get(objectIDX) + 1);
    }
  }
  equalObjects=new Object[objectSameStackTrace.size()];
  equalErrors=new Error[objectSameStackTrace.size()];
  final int[] equalOccurrence=new int[objectSameStackTrace.size()];
  int idx=0;
  for (  Entry<String,Integer> entry : objectSameStackTrace.entrySet()) {
    equalObjects[idx]=newObjects[entry.getValue()];
    equalErrors[idx]=newErrors[entry.getValue()];
    equalOccurrence[idx]=objectSameStackTraceTimes.get(entry.getValue());
    idx++;
  }
  final IntComparator c=new IntComparator(){
    @Override public int compare(    final int arg0,    final int arg1){
      return equalOccurrence[arg1] - equalOccurrence[arg0];
    }
  }
;
  final Swapper s=new Swapper(){
    @Override public void swap(    final int arg0,    final int arg1){
      Object tempObject=equalObjects[arg0];
      equalObjects[arg0]=equalObjects[arg1];
      equalObjects[arg1]=tempObject;
      Error tempError=equalErrors[arg0];
      equalErrors[arg0]=equalErrors[arg1];
      equalErrors[arg1]=tempError;
      int tempOccurence=equalOccurrence[arg0];
      equalOccurrence[arg0]=equalOccurrence[arg1];
      equalOccurrence[arg1]=tempOccurence;
    }
  }
;
  GenericSorting.mergeSort(0,equalObjects.length,c,s);
  StringBuilder statistics=new StringBuilder();
  for (  Entry<String,Integer> entry : objectTypesTimes.entrySet()) {
    statistics.append(entry.getKey());
    statistics.append(""String_Node_Str"");
    statistics.append(entry.getValue());
    statistics.append(""String_Node_Str"");
  }
  statistics.append(""String_Node_Str"");
  statistics.append(newObjects.length);
  statistics.append(""String_Node_Str"");
  listNewObjects.removeAll();
  for (int i=0; i < newObjects.length; i++) {
    listNewObjects.add(newObjects[i].getClass().getSimpleName() + ""String_Node_Str"" + newObjects[i].hashCode()+ ""String_Node_Str"");
  }
  listEqualObjects.removeAll();
  for (int i=0; i < equalObjects.length; i++) {
    listEqualObjects.add(equalObjects[i].getClass().getSimpleName() + ""String_Node_Str"" + equalObjects[i].hashCode()+ ""String_Node_Str""+ ""String_Node_Str""+ equalOccurrence[i]+ ""String_Node_Str"");
  }
  objectStatistics.setText(statistics.toString());
}",0.296567069294342
108073,"@Override public int compare(Object o1,Object o2){
  return objectSameStackTraceTimes.get(o2) - objectSameStackTraceTimes.get(o1);
}","@Override public int compare(final int arg0,final int arg1){
  return equalOccurrence[arg1] - equalOccurrence[arg0];
}",0.512
108074,"@Override public void traverse(){
  FLASHPhaseConfiguration outerLoopConfiguration;
  if (config.isBinaryPhaseRequired()) {
    outerLoopConfiguration=config.getBinaryPhaseConfiguration();
  }
 else {
    outerLoopConfiguration=config.getLinearPhaseConfiguration();
  }
  checker.getHistory().setStorageStrategy(config.getSnapshotStorageStrategy());
  PriorityQueue<Integer> queue=new PriorityQueue<Integer>(solutionSpace.getTop().getLevel(),strategy);
  Transformation bottom=solutionSpace.getBottom();
  Transformation top=solutionSpace.getTop();
  NodeChecker.Result result=checker.check(bottom);
  bottom.setProperty(solutionSpace.getPropertyForceSnapshot());
  bottom.setData(result);
  for (int level=bottom.getLevel(); level <= top.getLevel(); level++) {
    for (    int transformation : getSortedUnprocessedNodes(level,outerLoopConfiguration.getTriggerSkip())) {
      if (config.isBinaryPhaseRequired()) {
        binarySearch(transformation,queue);
      }
 else {
        linearSearch(transformation);
      }
    }
  }
  computeUtilityForMonotonicMetrics(bottom);
  computeUtilityForMonotonicMetrics(top);
  bottom.setData(null);
  if (potentiallyInsufficientUtility != null) {
    potentiallyInsufficientUtility.clear();
  }
}","@Override public void traverse(){
  FLASHPhaseConfiguration outerLoopConfiguration;
  if (config.isBinaryPhaseRequired()) {
    outerLoopConfiguration=config.getBinaryPhaseConfiguration();
  }
 else {
    outerLoopConfiguration=config.getLinearPhaseConfiguration();
  }
  checker.getHistory().setStorageStrategy(config.getSnapshotStorageStrategy());
  PriorityQueue<Integer> queue=new PriorityQueue<Integer>(solutionSpace.getTop().getLevel() + 1,strategy);
  Transformation bottom=solutionSpace.getBottom();
  Transformation top=solutionSpace.getTop();
  NodeChecker.Result result=checker.check(bottom);
  bottom.setProperty(solutionSpace.getPropertyForceSnapshot());
  bottom.setData(result);
  for (int level=bottom.getLevel(); level <= top.getLevel(); level++) {
    for (    int transformation : getSortedUnprocessedNodes(level,outerLoopConfiguration.getTriggerSkip())) {
      if (config.isBinaryPhaseRequired()) {
        binarySearch(transformation,queue);
      }
 else {
        linearSearch(transformation);
      }
    }
  }
  computeUtilityForMonotonicMetrics(bottom);
  computeUtilityForMonotonicMetrics(top);
  bottom.setData(null);
  if (potentiallyInsufficientUtility != null) {
    potentiallyInsufficientUtility.clear();
  }
}",0.998389694041868
108075,"/** 
 * Registers an image for a tool item. Generates a version of the image that renders well on windows toolbars, when disabled.
 * @param item
 * @param image
 */
public static void createDisabledImage(ToolItem item){
  item.setDisabledImage(new Image(item.getDisplay(),item.getImage(),SWT.IMAGE_GRAY));
}","/** 
 * Registers an image for a tool item. Generates a version of the image that renders well on windows toolbars, when disabled.
 * @param item
 * @param image
 */
public static void createDisabledImage(ToolItem item){
  final Image image=new Image(item.getDisplay(),item.getImage(),SWT.IMAGE_GRAY);
  item.setDisabledImage(image);
  item.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent arg0){
      if (image != null && !image.isDisposed()) {
        image.dispose();
      }
    }
  }
);
}",0.6682297772567409
108076,"/** 
 * Shows a question dialog.
 * @param shell
 * @param header
 * @param text
 * @return
 */
public boolean actionShowQuestionDialog(final Shell shell,final String header,final String text){
  return main.showQuestionDialog(shell,header,text);
}","/** 
 * Shows a question dialog.
 * @param header
 * @param text
 * @return
 */
public boolean actionShowQuestionDialog(final String header,final String text){
  return main.showQuestionDialog(this.main.getShell(),header,text);
}",0.80083857442348
108077,"/** 
 * Update mode
 */
private void updateMode(){
  if (model == null || model.getInputConfig() == null || model.getInputDefinition() == null) {
    reset();
    return;
  }
  if (model.getInputDefinition().getQuasiIdentifyingAttributes().contains(attribute) && model != null && model.getInputConfig() != null) {
    if (model.getInputConfig().getTransformationMode(attribute) == ModelTransformationMode.GENERALIZATION) {
      stack.setLayer(0);
      cmbMode.select(0);
    }
 else {
      stack.setLayer(1);
      cmbMode.select(1);
    }
  }
 else {
    stack.setLayer(0);
  }
}","/** 
 * Update mode
 */
private void updateMode(){
  if (model == null || model.getInputConfig() == null || model.getInputDefinition() == null) {
    reset();
    return;
  }
  if (model.getInputDefinition().getQuasiIdentifyingAttributes().contains(attribute) && model != null && model.getInputConfig() != null) {
    if (model.getInputConfig().getTransformationMode(attribute) == ModelTransformationMode.GENERALIZATION) {
      stack.setLayer(0);
      cmbMode.select(0);
    }
 else {
      stack.setLayer(1);
      cmbMode.select(1);
    }
  }
 else {
    cmbMode.select(0);
    stack.setLayer(0);
  }
}",0.9806560134566864
108078,"/** 
 * Returns all predeccessors of the transformation with the given identifier
 * @param transformation
 * @return
 */
public LongArrayList getPredecessors(long identifier){
  LongArrayList result=new LongArrayList();
  for (Iterator<Long> iter=lattice.space().indexIteratorToIdIterator(lattice.nodes().listPredecessors(lattice.space().toIndex(identifier))); iter.hasNext(); ) {
    result.add(iter.next());
  }
  int lower=0;
  int upper=result.size() - 1;
  while (lower < upper) {
    long temp=result.get(lower);
    result.set(lower,result.get(upper));
    result.set(upper,temp);
    lower++;
    upper--;
  }
  return result;
}","/** 
 * Returns all predeccessors of the transformation with the given identifier
 * @param transformation
 * @return
 */
public LongArrayList getPredecessors(long identifier){
  LongArrayList result=new LongArrayList();
  for (Iterator<Long> iter=lattice.space().indexIteratorToIdIterator(lattice.nodes().listPredecessors(lattice.space().toIndex(identifier))); iter.hasNext(); ) {
    result.add(iter.next());
  }
  return result;
}",0.7850467289719626
108079,"/** 
 * Sets the hierarchy displayed by this component. Call with null to reset.
 * @param hierarchy
 */
public void setHierarchy(final Hierarchy hierarchy){
  this.hierarchy=(hierarchy == null ? null : hierarchy.getHierarchy());
  this.table.refresh();
  this.triggerChangedEvent();
}","/** 
 * Sets the hierarchy displayed by this component. Call with null to reset.
 * @param hierarchy
 */
public void setHierarchy(final Hierarchy hierarchy){
  this.hierarchy=(hierarchy == null ? null : hierarchy.getHierarchy());
  this.table.refresh();
}",0.9444444444444444
108080,"/** 
 * Creates all components required for making the table editable.
 */
private void createMenu(){
  this.menu=new Menu(hierarchy.getControl());
  itemInsertRow=new MenuItem(menu,SWT.NONE);
  itemInsertRow.setText(Resources.getMessage(""String_Node_Str""));
  itemInsertRow.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionInsertRow();
    }
  }
);
  itemDeleteRow=new MenuItem(menu,SWT.NONE);
  itemDeleteRow.setText(Resources.getMessage(""String_Node_Str""));
  itemDeleteRow.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionDeleteRow();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemInsertColumn=new MenuItem(menu,SWT.NONE);
  itemInsertColumn.setText(Resources.getMessage(""String_Node_Str""));
  itemInsertColumn.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionInsertColumn();
    }
  }
);
  itemDeleteColumn=new MenuItem(menu,SWT.NONE);
  itemDeleteColumn.setText(Resources.getMessage(""String_Node_Str""));
  itemDeleteColumn.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionDeleteColumn();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemMoveRowUp=new MenuItem(menu,SWT.NONE);
  itemMoveRowUp.setText(Resources.getMessage(""String_Node_Str""));
  itemMoveRowUp.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionMoveRowUp();
    }
  }
);
  itemMoveRowDown=new MenuItem(menu,SWT.NONE);
  itemMoveRowDown.setText(Resources.getMessage(""String_Node_Str""));
  itemMoveRowDown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionMoveRowDown();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemEditItem=new MenuItem(menu,SWT.NONE);
  itemEditItem.setText(Resources.getMessage(""String_Node_Str""));
  itemEditItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      String value=getUserValue();
      if (value != null) {
        hierarchy.actionEditItem(value);
      }
    }
  }
);
  itemRenameItem=new MenuItem(menu,SWT.NONE);
  itemRenameItem.setText(Resources.getMessage(""String_Node_Str""));
  itemRenameItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      String value=getUserValue();
      if (value != null) {
        hierarchy.actionRenameItem(value);
      }
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemClear=new MenuItem(menu,SWT.NONE);
  itemClear.setText(Resources.getMessage(""String_Node_Str""));
  itemClear.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionClear();
    }
  }
);
  itemInitialize=new MenuItem(menu,SWT.NONE);
  itemInitialize.setText(Resources.getMessage(""String_Node_Str""));
  itemInitialize.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      Hierarchy initial=getInitialHierarchy();
      if (initial != null) {
        hierarchy.setHierarchy(initial);
      }
    }
  }
);
}","/** 
 * Creates all components required for making the table editable.
 */
private void createMenu(){
  this.menu=new Menu(hierarchy.getControl());
  itemInsertRow=new MenuItem(menu,SWT.NONE);
  itemInsertRow.setText(Resources.getMessage(""String_Node_Str""));
  itemInsertRow.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionInsertRow();
    }
  }
);
  itemDeleteRow=new MenuItem(menu,SWT.NONE);
  itemDeleteRow.setText(Resources.getMessage(""String_Node_Str""));
  itemDeleteRow.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionDeleteRow();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemInsertColumn=new MenuItem(menu,SWT.NONE);
  itemInsertColumn.setText(Resources.getMessage(""String_Node_Str""));
  itemInsertColumn.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionInsertColumn();
    }
  }
);
  itemDeleteColumn=new MenuItem(menu,SWT.NONE);
  itemDeleteColumn.setText(Resources.getMessage(""String_Node_Str""));
  itemDeleteColumn.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionDeleteColumn();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemMoveRowUp=new MenuItem(menu,SWT.NONE);
  itemMoveRowUp.setText(Resources.getMessage(""String_Node_Str""));
  itemMoveRowUp.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionMoveRowUp();
    }
  }
);
  itemMoveRowDown=new MenuItem(menu,SWT.NONE);
  itemMoveRowDown.setText(Resources.getMessage(""String_Node_Str""));
  itemMoveRowDown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionMoveRowDown();
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemEditItem=new MenuItem(menu,SWT.NONE);
  itemEditItem.setText(Resources.getMessage(""String_Node_Str""));
  itemEditItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      String value=getUserValue();
      if (value != null) {
        hierarchy.actionEditItem(value);
      }
    }
  }
);
  itemRenameItem=new MenuItem(menu,SWT.NONE);
  itemRenameItem.setText(Resources.getMessage(""String_Node_Str""));
  itemRenameItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      String value=getUserValue();
      if (value != null) {
        hierarchy.actionRenameItem(value);
      }
    }
  }
);
  new MenuItem(menu,SWT.SEPARATOR);
  itemClear=new MenuItem(menu,SWT.NONE);
  itemClear.setText(Resources.getMessage(""String_Node_Str""));
  itemClear.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      hierarchy.actionClear();
    }
  }
);
  itemInitialize=new MenuItem(menu,SWT.NONE);
  itemInitialize.setText(Resources.getMessage(""String_Node_Str""));
  itemInitialize.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      if (hierarchy.isRowSelected() || hierarchy.isColumnSelected() || hierarchy.isCellSelected()|| model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null || model.getSelectedAttribute() == null) {
        return;
      }
      controller.actionInitializeHierarchy();
    }
  }
);
}",0.9505145918511207
108081,"@Override public void widgetSelected(final SelectionEvent e){
  Hierarchy initial=getInitialHierarchy();
  if (initial != null) {
    hierarchy.setHierarchy(initial);
  }
}","@Override public void widgetSelected(final SelectionEvent e){
  if (hierarchy.isRowSelected() || hierarchy.isColumnSelected() || hierarchy.isCellSelected()|| model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null || model.getSelectedAttribute() == null) {
    return;
  }
  controller.actionInitializeHierarchy();
}",0.2971428571428571
108082,"/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataAnalyzed.getArray();
  final int index=indexesSensitive.get(attribute);
  final int[][] hierarchy=hierarchiesSensitive.get(attribute).map;
  final int totalElementsP=subset == null ? data.length : subsetSize;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.contains(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    IntOpenHashSet children=new IntOpenHashSet();
    int level=0;
    int offset=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final IntObjectOpenHashMap<TNode> nodes=new IntObjectOpenHashMap<TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i];
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1]);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        final int[] keys=node.children.keys;
        final boolean[] allocated=node.children.allocated;
        for (int i=0; i < allocated.length; i++) {
          if (allocated[i]) {
            treeList.add(node.level == 1 ? keys[i] + offsetsExtras : nodes.get(keys[i]).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}","/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataAnalyzed.getArray();
  final int index=indexesSensitive.get(attribute);
  final int[][] hierarchy=hierarchiesSensitive.get(attribute).map;
  final int totalElementsP=subset == null ? data.length : subsetSize;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.contains(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    IntOpenHashSet children=new IntOpenHashSet();
    int level=0;
    int offset=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final IntObjectOpenHashMap<TNode> nodes=new IntObjectOpenHashMap<TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i] + i * hierarchy.length;
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1] + (i - 1) * hierarchy.length);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        final int[] keys=node.children.keys;
        final boolean[] allocated=node.children.allocated;
        for (int i=0; i < allocated.length; i++) {
          if (allocated[i]) {
            treeList.add(node.level == 1 ? keys[i] + offsetsExtras : nodes.get(keys[i]).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}",0.9907801418439716
108083,"/** 
 * Internal method that subtracts the offsets
 * @param transformation
 * @return
 */
protected int[] toJHPL(int[] transformation){
  int[] result=new int[transformation.length];
  for (int i=0; i < result.length; i++) {
    result[i]=transformation[transformation.length - i - 1] - offsetIndices[transformation.length - i - 1];
  }
  return result;
}","/** 
 * Internal method that subtracts the offsets
 * @param transformation
 * @return
 */
protected int[] toJHPL(int[] transformation){
  int[] result=new int[transformation.length];
  for (int i=0; i < result.length; i++) {
    result[i]=transformation[transformation.length - i - 1] - offsetIndices[i];
  }
  return result;
}",0.956140350877193
108084,"/** 
 * Creates a new solution space
 * @param minLevels
 * @param maxLevels
 */
public SolutionSpace(int[] minLevels,int[] maxLevels){
  minLevels=reverse(minLevels);
  maxLevels=reverse(maxLevels);
  this.offsetIndices=reverse(minLevels);
  int lvl=0;
  for (  int i : offsetIndices)   lvl+=i;
  this.offsetLevel=lvl;
  Integer[][] elements=new Integer[minLevels.length][];
  for (int i=0; i < elements.length; i++) {
    Integer[] element=new Integer[maxLevels[i] - minLevels[i] + 1];
    int idx=0;
    for (int j=minLevels[i]; j <= maxLevels[i]; j++) {
      element[idx++]=j;
    }
    elements[i]=element;
  }
  this.lattice=new Lattice<Integer,Integer>(elements);
}","/** 
 * Creates a new solution space
 * @param minLevels
 * @param maxLevels
 */
public SolutionSpace(int[] minLevels,int[] maxLevels){
  minLevels=reverse(minLevels);
  maxLevels=reverse(maxLevels);
  this.offsetIndices=minLevels.clone();
  int lvl=0;
  for (  int i : offsetIndices)   lvl+=i;
  this.offsetLevel=lvl;
  Integer[][] elements=new Integer[minLevels.length][];
  for (int i=0; i < elements.length; i++) {
    Integer[] element=new Integer[maxLevels[i] - minLevels[i] + 1];
    int idx=0;
    for (int j=minLevels[i]; j <= maxLevels[i]; j++) {
      element[idx++]=j;
    }
    elements[i]=element;
  }
  this.lattice=new Lattice<Integer,Integer>(elements);
}",0.97546468401487
108085,"/** 
 * Internal method that adds the offsets
 * @param transformation
 * @return
 */
protected int[] fromJHPL(int[] transformation){
  int[] result=new int[transformation.length];
  for (int i=0; i < result.length; i++) {
    result[i]=transformation[transformation.length - i - 1]+=offsetIndices[transformation.length - i - 1];
  }
  return result;
}","/** 
 * Internal method that adds the offsets
 * @param transformation
 * @return
 */
protected int[] fromJHPL(int[] transformation){
  int[] result=new int[transformation.length];
  for (int i=0; i < result.length; i++) {
    result[i]=transformation[transformation.length - i - 1] + offsetIndices[transformation.length - i - 1];
  }
  return result;
}",0.9957446808510638
108086,"/** 
 * Checks and tags the given transformation.
 * @param transformation
 * @param configuration
 */
private void checkAndTag(Transformation transformation,FLASHPhaseConfiguration configuration){
  if (configuration.getTriggerEvaluate().appliesTo(transformation)) {
    InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(transformation,(HashGroupify)null);
    transformation.setInformationLoss(loss.getInformationLoss());
    transformation.setLowerBound(loss.getLowerBound());
    if (loss.getLowerBound() == null) {
      transformation.setLowerBound(checker.getMetric().getLowerBound(transformation));
    }
  }
 else   if (configuration.getTriggerCheck().appliesTo(transformation)) {
    transformation.setChecked(checker.check(transformation));
    listener.progress((double)++checked / (double)solutionSpace.getSize());
  }
  trackOptimum(transformation);
  configuration.getTriggerTag().apply(transformation);
  prune(transformation);
}","/** 
 * Checks and tags the given transformation.
 * @param transformation
 * @param configuration
 */
private void checkAndTag(Transformation transformation,FLASHPhaseConfiguration configuration){
  if (configuration.getTriggerEvaluate().appliesTo(transformation)) {
    InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(transformation,(HashGroupify)null);
    transformation.setInformationLoss(loss.getInformationLoss());
    transformation.setLowerBound(loss.getLowerBound());
    if (loss.getLowerBound() == null) {
      transformation.setLowerBound(checker.getMetric().getLowerBound(transformation));
    }
  }
 else   if (configuration.getTriggerCheck().appliesTo(transformation)) {
    transformation.setChecked(checker.check(transformation));
    progress((double)++checked / (double)solutionSpace.getSize());
  }
  trackOptimum(transformation);
  configuration.getTriggerTag().apply(transformation);
  prune(transformation);
}",0.9953246753246752
108087,"/** 
 * Constructor
 * @param space
 * @param checker
 * @param timeLimit
 */
private LIGHTNINGAlgorithm(SolutionSpace space,NodeChecker checker,int timeLimit){
  super(space,checker);
  this.checker.getHistory().setStorageStrategy(StorageStrategy.ALL);
  int stepping=space.getTop().getLevel();
  this.stepping=stepping > 0 ? stepping : 1;
  this.propertyChecked=space.getPropertyChecked();
  this.propertyExpanded=space.getPropertyExpanded();
  this.solutionSpace.setAnonymityPropertyPredictable(false);
  this.timeLimit=timeLimit;
}","/** 
 * Constructor
 * @param space
 * @param checker
 * @param timeLimit
 */
private LIGHTNINGAlgorithm(SolutionSpace space,NodeChecker checker,int timeLimit){
  super(space,checker);
  this.checker.getHistory().setStorageStrategy(StorageStrategy.ALL);
  int stepping=space.getTop().getLevel();
  this.stepping=stepping > 0 ? stepping : 1;
  this.propertyChecked=space.getPropertyChecked();
  this.propertyExpanded=space.getPropertyExpanded();
  this.solutionSpace.setAnonymityPropertyPredictable(false);
  this.timeLimit=timeLimit;
  if (timeLimit <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9248055315471044
108088,"/** 
 * Makes sure that the given Transformation has been checked
 * @param transformation
 */
private void assureChecked(final Transformation transformation){
  if (!transformation.hasProperty(propertyChecked)) {
    transformation.setChecked(checker.check(transformation,true));
    trackOptimum(transformation);
    listener.progress((double)(System.currentTimeMillis() - timeStart) / (double)timeLimit);
  }
}","/** 
 * Makes sure that the given Transformation has been checked
 * @param transformation
 */
private void assureChecked(final Transformation transformation){
  if (!transformation.hasProperty(propertyChecked)) {
    transformation.setChecked(checker.check(transformation,true));
    trackOptimum(transformation);
    progress((double)(System.currentTimeMillis() - timeStart) / (double)timeLimit);
  }
}",0.988984088127295
108089,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_ATTRIBUTE) {
    if (model != null) {
      SWTUtil.enable(root);
      attribute=model.getSelectedAttribute();
      updateAttributeType();
      updateFunction();
      updateMode();
      updateMinMax();
      hierarchy.setHierarchy(getHierarchy());
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    SWTUtil.enable(root);
    model=(Model)event.data;
    attribute=model.getSelectedAttribute();
    updateAttributeType();
    updateFunction();
    updateMode();
    updateMinMax();
    hierarchy.setHierarchy(getHierarchy());
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    SWTUtil.enable(root);
    final String attr=(String)event.data;
    if (attr.equals(attribute)) {
      updateAttributeType();
    }
  }
 else   if (event.part == ModelPart.HIERARCHY) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      hierarchy.setHierarchy(getHierarchy());
      updateMinMax();
    }
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    attribute=model.getSelectedAttribute();
    updateAttributeType();
    updateMode();
    updateMinMax();
    hierarchy.setHierarchy(getHierarchy());
  }
 else   if (event.part == ModelPart.DATA_TYPE) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      updateFunction();
      updateMode();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_VALUE) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      hierarchy.setHierarchy(getHierarchy());
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_ATTRIBUTE) {
    if (model != null) {
      SWTUtil.enable(root);
      attribute=model.getSelectedAttribute();
      updateAttributeType();
      updateFunction();
      updateMode();
      updateMinMax();
      hierarchy.setHierarchy(getHierarchy());
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    SWTUtil.enable(root);
    model=(Model)event.data;
    attribute=model.getSelectedAttribute();
    updateAttributeType();
    updateFunction();
    updateMode();
    updateMinMax();
    hierarchy.setHierarchy(getHierarchy());
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    SWTUtil.enable(root);
    final String attr=(String)event.data;
    if (attr.equals(attribute)) {
      updateAttributeType();
    }
  }
 else   if (event.part == ModelPart.HIERARCHY) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      hierarchy.setHierarchy(getHierarchy());
      updateMinMax();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_VALUE) {
    SWTUtil.enable(root);
    AuditTrailEntryFindReplace entry=(AuditTrailEntryFindReplace)event.data;
    if (entry.getAttribute().equals(attribute)) {
      hierarchy.setHierarchy(getHierarchy());
    }
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    attribute=model.getSelectedAttribute();
    updateAttributeType();
    updateMode();
    updateMinMax();
    hierarchy.setHierarchy(getHierarchy());
  }
 else   if (event.part == ModelPart.DATA_TYPE) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      updateFunction();
      updateMode();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_VALUE) {
    SWTUtil.enable(root);
    if (attribute.equals(model.getSelectedAttribute())) {
      hierarchy.setHierarchy(getHierarchy());
    }
  }
}",0.9260089686098656
108090,"/** 
 * Constructor.
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeTransformation(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.controller.addListener(ModelPart.DATA_TYPE,this);
  this.controller.addListener(ModelPart.HIERARCHY,this);
  this.controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  root=new Composite(parent,SWT.NULL);
  root.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  root.setLayout(groupInputGridLayout);
  final Composite innerGroup=new Composite(root,SWT.NULL);
  innerGroup.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=4;
  innerGroup.setLayout(typeInputGridLayout);
  final Label kLabel=new Label(innerGroup,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  cmbType=new Combo(innerGroup,SWT.READ_ONLY);
  cmbType.setLayoutData(SWTUtil.createFillGridData());
  cmbType.setItems(COMBO1_VALUES);
  cmbType.select(0);
  cmbType.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionAttributeTypeChanged();
    }
  }
);
  final Label fLabel2=new Label(innerGroup,SWT.PUSH);
  fLabel2.setText(Resources.getMessage(""String_Node_Str""));
  cmbMode=new Combo(innerGroup,SWT.READ_ONLY);
  cmbMode.setLayoutData(SWTUtil.createFillGridData());
  cmbMode.setItems(new String[]{Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")});
  cmbMode.select(0);
  cmbMode.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionTransformationModeChanged();
    }
  }
);
  stack=new ComponentMultiStack(innerGroup);
  Composite first=stack.create(SWTUtil.createGridData());
  Composite compositeLabelMin=new Composite(first,SWT.NONE);
  GridLayout compositeLabelMinLayout=new GridLayout();
  compositeLabelMinLayout.numColumns=1;
  compositeLabelMinLayout.marginLeft=0;
  compositeLabelMinLayout.marginRight=0;
  compositeLabelMinLayout.marginWidth=0;
  compositeLabelMin.setLayout(compositeLabelMinLayout);
  Label labelMin=new Label(compositeLabelMin,SWT.PUSH);
  labelMin.setText(Resources.getMessage(""String_Node_Str""));
  Composite compositelabelFunction=new Composite(first,SWT.NONE);
  GridLayout compositelabelFunctionLayout=new GridLayout();
  compositelabelFunctionLayout.numColumns=1;
  compositelabelFunctionLayout.marginLeft=0;
  compositelabelFunctionLayout.marginRight=0;
  compositelabelFunctionLayout.marginWidth=0;
  compositelabelFunction.setLayout(compositelabelFunctionLayout);
  final Label labelFunction=new Label(compositelabelFunction,SWT.PUSH);
  labelFunction.setText(Resources.getMessage(""String_Node_Str""));
  Composite second=stack.create(SWTUtil.createFillHorizontallyGridData());
  this.cmbMin=new Combo(second,SWT.READ_ONLY);
  this.cmbMin.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.cmbMin.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMinChanged();
    }
  }
);
  this.cmbFunction=new Combo(second,SWT.READ_ONLY);
  this.cmbFunction.setLayoutData(SWTUtil.createFillGridData());
  this.cmbFunction.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionFunctionChanged();
    }
  }
);
  Composite third=stack.create(SWTUtil.createGridData());
  Composite compositelabelMax=new Composite(third,SWT.NONE);
  GridLayout compositelabelMaxLayout=new GridLayout();
  compositelabelMaxLayout.numColumns=1;
  compositelabelMaxLayout.marginLeft=0;
  compositelabelMaxLayout.marginRight=0;
  compositelabelMaxLayout.marginWidth=0;
  compositelabelMax.setLayout(compositelabelMaxLayout);
  Label labelMax=new Label(compositelabelMax,SWT.PUSH);
  labelMax.setText(Resources.getMessage(""String_Node_Str""));
  Composite compositelabelMissing=new Composite(third,SWT.NONE);
  GridLayout compositelabelMissingLayout=new GridLayout();
  compositelabelMissingLayout.numColumns=1;
  compositelabelMissingLayout.marginLeft=0;
  compositelabelMissingLayout.marginRight=0;
  compositelabelMissingLayout.marginWidth=0;
  compositelabelMissing.setLayout(compositelabelMissingLayout);
  Label labelMissing=new Label(compositelabelMissing,SWT.PUSH);
  labelMissing.setText(Resources.getMessage(""String_Node_Str""));
  Composite fourth=stack.create(SWTUtil.createFillHorizontallyGridData());
  this.cmbMax=new Combo(fourth,SWT.READ_ONLY);
  this.cmbMax.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.cmbMax.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMaxChanged();
    }
  }
);
  btnMissing=new Button(fourth,SWT.CHECK);
  GridData btnMissingData=SWTUtil.createFillGridData();
  btnMissingData.horizontalSpan=2;
  btnMissing.setLayoutData(btnMissingData);
  btnMissing.setText(Resources.getMessage(""String_Node_Str""));
  btnMissing.setSelection(true);
  btnMissing.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMissingChanged();
    }
  }
);
  stack.pack();
  stack.setLayer(0);
  this.hierarchy=new ComponentHierarchy(root,new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      actionHierarchyChanged((Hierarchy)arg0.data);
    }
  }
);
  this.menu=new ComponentHierarchyMenu(hierarchy,controller);
}","/** 
 * Constructor.
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeTransformation(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_VALUE,this);
  this.controller.addListener(ModelPart.DATA_TYPE,this);
  this.controller.addListener(ModelPart.HIERARCHY,this);
  this.controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  root=new Composite(parent,SWT.NULL);
  root.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  root.setLayout(groupInputGridLayout);
  final Composite innerGroup=new Composite(root,SWT.NULL);
  innerGroup.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=4;
  innerGroup.setLayout(typeInputGridLayout);
  final Label kLabel=new Label(innerGroup,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  cmbType=new Combo(innerGroup,SWT.READ_ONLY);
  cmbType.setLayoutData(SWTUtil.createFillGridData());
  cmbType.setItems(COMBO1_VALUES);
  cmbType.select(0);
  cmbType.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionAttributeTypeChanged();
    }
  }
);
  final Label fLabel2=new Label(innerGroup,SWT.PUSH);
  fLabel2.setText(Resources.getMessage(""String_Node_Str""));
  cmbMode=new Combo(innerGroup,SWT.READ_ONLY);
  cmbMode.setLayoutData(SWTUtil.createFillGridData());
  cmbMode.setItems(new String[]{Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")});
  cmbMode.select(0);
  cmbMode.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionTransformationModeChanged();
    }
  }
);
  stack=new ComponentMultiStack(innerGroup);
  Composite first=stack.create(SWTUtil.createGridData());
  Composite compositeLabelMin=new Composite(first,SWT.NONE);
  GridLayout compositeLabelMinLayout=new GridLayout();
  compositeLabelMinLayout.numColumns=1;
  compositeLabelMinLayout.marginLeft=0;
  compositeLabelMinLayout.marginRight=0;
  compositeLabelMinLayout.marginWidth=0;
  compositeLabelMin.setLayout(compositeLabelMinLayout);
  Label labelMin=new Label(compositeLabelMin,SWT.PUSH);
  labelMin.setText(Resources.getMessage(""String_Node_Str""));
  Composite compositelabelFunction=new Composite(first,SWT.NONE);
  GridLayout compositelabelFunctionLayout=new GridLayout();
  compositelabelFunctionLayout.numColumns=1;
  compositelabelFunctionLayout.marginLeft=0;
  compositelabelFunctionLayout.marginRight=0;
  compositelabelFunctionLayout.marginWidth=0;
  compositelabelFunction.setLayout(compositelabelFunctionLayout);
  final Label labelFunction=new Label(compositelabelFunction,SWT.PUSH);
  labelFunction.setText(Resources.getMessage(""String_Node_Str""));
  Composite second=stack.create(SWTUtil.createFillHorizontallyGridData());
  this.cmbMin=new Combo(second,SWT.READ_ONLY);
  this.cmbMin.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.cmbMin.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMinChanged();
    }
  }
);
  this.cmbFunction=new Combo(second,SWT.READ_ONLY);
  this.cmbFunction.setLayoutData(SWTUtil.createFillGridData());
  this.cmbFunction.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionFunctionChanged();
    }
  }
);
  Composite third=stack.create(SWTUtil.createGridData());
  Composite compositelabelMax=new Composite(third,SWT.NONE);
  GridLayout compositelabelMaxLayout=new GridLayout();
  compositelabelMaxLayout.numColumns=1;
  compositelabelMaxLayout.marginLeft=0;
  compositelabelMaxLayout.marginRight=0;
  compositelabelMaxLayout.marginWidth=0;
  compositelabelMax.setLayout(compositelabelMaxLayout);
  Label labelMax=new Label(compositelabelMax,SWT.PUSH);
  labelMax.setText(Resources.getMessage(""String_Node_Str""));
  Composite compositelabelMissing=new Composite(third,SWT.NONE);
  GridLayout compositelabelMissingLayout=new GridLayout();
  compositelabelMissingLayout.numColumns=1;
  compositelabelMissingLayout.marginLeft=0;
  compositelabelMissingLayout.marginRight=0;
  compositelabelMissingLayout.marginWidth=0;
  compositelabelMissing.setLayout(compositelabelMissingLayout);
  Label labelMissing=new Label(compositelabelMissing,SWT.PUSH);
  labelMissing.setText(Resources.getMessage(""String_Node_Str""));
  Composite fourth=stack.create(SWTUtil.createFillHorizontallyGridData());
  this.cmbMax=new Combo(fourth,SWT.READ_ONLY);
  this.cmbMax.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.cmbMax.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMaxChanged();
    }
  }
);
  btnMissing=new Button(fourth,SWT.CHECK);
  GridData btnMissingData=SWTUtil.createFillGridData();
  btnMissingData.horizontalSpan=2;
  btnMissing.setLayoutData(btnMissingData);
  btnMissing.setText(Resources.getMessage(""String_Node_Str""));
  btnMissing.setSelection(true);
  btnMissing.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      actionMissingChanged();
    }
  }
);
  stack.pack();
  stack.setLayer(0);
  this.hierarchy=new ComponentHierarchy(root,new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      actionHierarchyChanged((Hierarchy)arg0.data);
    }
  }
);
  this.menu=new ComponentHierarchyMenu(hierarchy,controller);
}",0.9946514984294084
108091,"/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataAnalyzed.getArray();
  final int index=indexesSensitive.get(attribute);
  final int[][] hierarchy=hierarchiesSensitive.get(attribute).map;
  final int totalElementsP=subset == null ? data.length : subsetSize;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.contains(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    IntOpenHashSet children=new IntOpenHashSet();
    int level=0;
    int offset=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final IntObjectOpenHashMap<TNode> nodes=new IntObjectOpenHashMap<TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i] + i * hierarchy.length;
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1] + (i - 1) * hierarchy.length);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        final int[] keys=node.children.keys;
        final boolean[] allocated=node.children.allocated;
        for (int i=0; i < allocated.length; i++) {
          if (allocated[i]) {
            treeList.add(node.level == 1 ? keys[i] + offsetsExtras : nodes.get(keys[i]).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}","/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataAnalyzed.getArray();
  final int index=indexesSensitive.get(attribute);
  final int[][] hierarchy=hierarchiesSensitive.get(attribute).map;
  final int totalElementsP=subset == null ? data.length : subsetSize;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.contains(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    IntOpenHashSet children=new IntOpenHashSet();
    int level=0;
    int offset=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final IntObjectOpenHashMap<TNode> nodes=new IntObjectOpenHashMap<TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  int offset=dataAnalyzed.getDictionary().getMapping()[index].length;
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i] + i * offset;
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1] + (i - 1) * offset);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        final int[] keys=node.children.keys;
        final boolean[] allocated=node.children.allocated;
        for (int i=0; i < allocated.length; i++) {
          if (allocated[i]) {
            treeList.add(node.level == 1 ? keys[i] + offsetsExtras : nodes.get(keys[i]).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}",0.980146290491118
108092,"@Override public void updatePage(){
  textMaximalLength.setText(model.getMaxValueLength() == null ? ""String_Node_Str"" : String.valueOf(model.getMaxValueLength()));
  textAlphabetSize.setText(model.getAlphabetSize() == null ? ""String_Node_Str"" : String.valueOf(model.getAlphabetSize()));
  textDomainSize.setText(model.getDomainSize() == null ? ""String_Node_Str"" : String.valueOf(model.getDomainSize()));
  buttonLeftAlign.setSelection(model.getAlignmentOrder() == Order.LEFT_TO_RIGHT);
  buttonRightAlign.setSelection(model.getAlignmentOrder() == Order.RIGHT_TO_LEFT);
  buttonLeftRedact.setSelection(model.getAlignmentOrder() == Order.LEFT_TO_RIGHT);
  buttonRightRedact.setSelection(model.getAlignmentOrder() == Order.RIGHT_TO_LEFT);
  comboPaddingChar.select(indexOf(comboPaddingChar,model.getPaddingCharacter()));
  comboRedactionChar.select(indexOf(comboRedactionChar,model.getRedactionCharacter()));
}","@Override public void updatePage(){
  textMaximalLength.setText(model.getMaxValueLength() == null ? ""String_Node_Str"" : String.valueOf(model.getMaxValueLength()));
  textAlphabetSize.setText(model.getAlphabetSize() == null ? ""String_Node_Str"" : String.valueOf(model.getAlphabetSize()));
  textDomainSize.setText(model.getDomainSize() == null ? ""String_Node_Str"" : String.valueOf(model.getDomainSize()));
  buttonLeftAlign.setSelection(model.getAlignmentOrder() == Order.LEFT_TO_RIGHT);
  buttonRightAlign.setSelection(model.getAlignmentOrder() == Order.RIGHT_TO_LEFT);
  buttonLeftRedact.setSelection(model.getRedactionOrder() == Order.LEFT_TO_RIGHT);
  buttonRightRedact.setSelection(model.getRedactionOrder() == Order.RIGHT_TO_LEFT);
  comboPaddingChar.select(indexOf(comboPaddingChar,model.getPaddingCharacter()));
  comboRedactionChar.select(indexOf(comboRedactionChar,model.getRedactionCharacter()));
}",0.980154355016538
108093,"/** 
 * Updates the combos.
 */
private void updateMinMax(){
  if (model == null || model.getInputConfig() == null || cmbMin == null || cmbMin.isDisposed()) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  int length=0;
  Hierarchy hierarchy=model.getInputConfig().getHierarchy(attribute);
  if (!(hierarchy == null || hierarchy.getHierarchy() == null || hierarchy.getHierarchy()[0] == null || hierarchy.getHierarchy()[0].length == 0)) {
    length=hierarchy.getHierarchy()[0].length;
  }
  for (int i=0; i < length; i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  int minIndex=minModel != null ? minModel + 1 : 0;
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  int maxIndex=maxModel != null ? maxModel : maxItems.size() - 1;
  maxIndex=maxIndex > maxItems.size() - 1 ? maxItems.size() - 1 : maxIndex;
  maxIndex=maxIndex < 0 ? maxItems.size() - 1 : maxIndex;
  minIndex=minIndex > minItems.size() - 1 ? minItems.size() - 1 : minIndex;
  minIndex=minIndex < 0 ? 0 : minIndex;
  minIndex=minIndex > (maxIndex + 1) ? maxIndex + 1 : minIndex;
  cmbMin.setItems(minItems.toArray(new String[minItems.size()]));
  cmbMax.setItems(maxItems.toArray(new String[maxItems.size()]));
  cmbMin.select(minIndex);
  cmbMax.select(maxIndex);
  actionMinChanged();
  actionMaxChanged();
}","/** 
 * Updates the combos.
 */
private void updateMinMax(){
  if (model == null || model.getInputConfig() == null || cmbMin == null || cmbMin.isDisposed()) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  int length=0;
  Hierarchy hierarchy=model.getInputConfig().getHierarchy(attribute);
  if (!(hierarchy == null || hierarchy.getHierarchy() == null || hierarchy.getHierarchy().length == 0 || hierarchy.getHierarchy()[0] == null || hierarchy.getHierarchy()[0].length == 0)) {
    length=hierarchy.getHierarchy()[0].length;
  }
  for (int i=0; i < length; i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  int minIndex=minModel != null ? minModel + 1 : 0;
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  int maxIndex=maxModel != null ? maxModel : maxItems.size() - 1;
  maxIndex=maxIndex > maxItems.size() - 1 ? maxItems.size() - 1 : maxIndex;
  maxIndex=maxIndex < 0 ? maxItems.size() - 1 : maxIndex;
  minIndex=minIndex > minItems.size() - 1 ? minItems.size() - 1 : minIndex;
  minIndex=minIndex < 0 ? 0 : minIndex;
  minIndex=minIndex > (maxIndex + 1) ? maxIndex + 1 : minIndex;
  cmbMin.setItems(minItems.toArray(new String[minItems.size()]));
  cmbMax.setItems(maxItems.toArray(new String[maxItems.size()]));
  cmbMin.select(minIndex);
  cmbMax.select(maxIndex);
  actionMinChanged();
  actionMaxChanged();
}",0.9873096446700508
108094,"/** 
 * Update the view.
 */
protected void update(){
  AnalysisData context=getContext().getData();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  StatisticsEquivalenceClasses statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMinimalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMaximalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getAverageEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
  }
  if (node.getMaximumInformationLoss().getValue().equals(node.getMinimumInformationLoss().getValue())) {
    final String infoloss=node.getMinimumInformationLoss().toString() + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.getAnonymity() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
    Set<RiskBasedCriterion> criteria=context.config.getCriteria(RiskBasedCriterion.class);
    for (    RiskBasedCriterion criterion : criteria) {
      String type=""String_Node_Str"";
      if (criterion instanceof AverageReidentificationRisk) {
        type=Resources.getMessage(""String_Node_Str"");
      }
 else       if (criterion instanceof PopulationUniqueness) {
        type=Resources.getMessage(""String_Node_Str"");
      }
 else       if (criterion instanceof SampleUniqueness) {
        type=Resources.getMessage(""String_Node_Str"");
      }
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{type});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getRiskThreshold())});
      if (criterion instanceof PopulationUniqueness) {
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(((PopulationUniqueness)criterion).getPopulationModel().getSamplingFraction(context.handle))});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{((PopulationUniqueness)criterion).getStatisticalModel().toString()});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view.
 */
protected void update(){
  AnalysisData context=getContext().getData();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  StatisticsEquivalenceClasses statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMinimalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMaximalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getAverageEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
  }
  if (node.getMaximumInformationLoss().getValue().equals(node.getMinimumInformationLoss().getValue())) {
    final String infoloss=node.getMinimumInformationLoss().toString() + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.getAnonymity() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
    Set<RiskBasedCriterion> criteria=context.config.getCriteria(RiskBasedCriterion.class);
    for (    RiskBasedCriterion criterion : criteria) {
      String type=""String_Node_Str"";
      if (criterion instanceof AverageReidentificationRisk) {
        type=Resources.getMessage(""String_Node_Str"");
      }
 else       if (criterion instanceof PopulationUniqueness) {
        type=Resources.getMessage(""String_Node_Str"");
      }
 else       if (criterion instanceof SampleUniqueness) {
        type=Resources.getMessage(""String_Node_Str"");
      }
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{type});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getRiskThreshold())});
      if (criterion instanceof PopulationUniqueness) {
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(((PopulationUniqueness)criterion).getPopulationModel().getSamplingFraction(context.handle))});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{((PopulationUniqueness)criterion).getStatisticalModel().toString()});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9985350912238647
108095,"/** 
 * Instantiates a new handle.
 * @param result
 * @param registry
 * @param manager
 * @param outputGeneralized
 * @param outputMicroaggregated
 * @param node
 * @param statistics
 * @param definition
 * @param config
 */
protected DataHandleOutput(final ARXResult result,final DataRegistry registry,final DataManager manager,final Data outputGeneralized,final Data outputMicroaggregated,final ARXNode node,final StatisticsEquivalenceClasses statistics,final DataDefinition definition,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.suppressionString=config.getSuppressionString();
  this.suppressedAttributeTypes=convert(config.getSuppressedAttributeTypes());
  this.result=result;
  this.definition=definition;
  this.statistics=new StatisticsBuilder(new DataHandleStatistics(this),statistics);
  this.node=node;
  this.outputGeneralized=outputGeneralized;
  this.outputMicroaggregated=outputMicroaggregated;
  this.inputAnalyzed=manager.getDataAnalyzed();
  this.inputStatic=manager.getDataStatic();
  this.header=manager.getHeader();
  this.microaggregationStartIndex=manager.getMicroaggregationStartIndex();
  this.inverseMap=new int[header.length * 2];
  for (int i=0; i < this.inverseMap.length; i+=2) {
    this.inverseMap[i]=AttributeTypeInternal.IDENTIFYING;
    this.inverseMap[i + 1]=-1;
  }
  for (int i=0; i < this.outputGeneralized.getMap().length; i++) {
    final int pos=outputGeneralized.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < this.microaggregationStartIndex; i++) {
    final int pos=inputAnalyzed.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.SENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < outputMicroaggregated.getMap().length; i++) {
    final int pos=outputMicroaggregated.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < inputStatic.getMap().length; i++) {
    final int pos=inputStatic.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.INSENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  this.inverseData=new int[5][][];
  this.inverseData[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getArray();
  this.inverseData[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getArray();
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getArray();
  this.inverseData[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getArray();
  this.inverseDictionaries=new Dictionary[5];
  this.inverseDictionaries[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}","/** 
 * Instantiates a new handle.
 * @param result
 * @param registry
 * @param manager
 * @param outputGeneralized
 * @param outputMicroaggregated
 * @param node
 * @param statistics
 * @param definition
 * @param config
 */
protected DataHandleOutput(final ARXResult result,final DataRegistry registry,final DataManager manager,final Data outputGeneralized,final Data outputMicroaggregated,final ARXNode node,final StatisticsEquivalenceClasses statistics,final DataDefinition definition,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.suppressionString=config.getSuppressionString();
  this.suppressedAttributeTypes=convert(config.getSuppressedAttributeTypes());
  this.result=result;
  this.definition=definition;
  this.statistics=new StatisticsBuilder(new DataHandleStatistics(this),statistics);
  this.node=node;
  this.outputGeneralized=outputGeneralized;
  this.outputMicroaggregated=outputMicroaggregated;
  this.inputAnalyzed=manager.getDataAnalyzed();
  this.inputStatic=manager.getDataStatic();
  this.header=manager.getHeader();
  this.microaggregationStartIndex=manager.getMicroaggregationStartIndex();
  this.inverseMap=new int[header.length * 2];
  for (int i=0; i < this.inverseMap.length; i+=2) {
    this.inverseMap[i]=AttributeTypeInternal.IDENTIFYING;
    this.inverseMap[i + 1]=-1;
  }
  for (int i=0; i < this.outputGeneralized.getMap().length; i++) {
    final int pos=outputGeneralized.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < this.microaggregationStartIndex; i++) {
    final int pos=inputAnalyzed.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.SENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < outputMicroaggregated.getMap().length; i++) {
    final int pos=outputMicroaggregated.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < inputStatic.getMap().length; i++) {
    final int pos=inputStatic.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.INSENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  this.inverseData=new int[5][][];
  this.inverseData[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getArray();
  this.inverseData[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getArray();
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getArray();
  this.inverseData[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getArray();
  this.inverseDictionaries=new Dictionary[5];
  this.inverseDictionaries[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics.getSubsetStatistics());
  this.dataTypes=getDataTypeArray();
}",0.9967589864466706
108096,"/** 
 * Creates a new handle that represents the research subset.
 * @param source
 * @param subset
 */
protected DataHandleSubset(DataHandle source,DataSubset subset){
  this(source,subset,null);
}","/** 
 * Creates a new handle that represents the research subset.
 * @param source
 * @param subset
 * @param eqStatistics
 */
public DataHandleSubset(DataHandle source,DataSubset subset,StatisticsEquivalenceClasses eqStatistics){
  this.source=source;
  this.dataTypes=source.dataTypes;
  this.definition=source.definition;
  this.header=source.header;
  this.subset=subset;
  this.statistics=new StatisticsBuilder(new DataHandleStatistics(this),eqStatistics);
}",0.5234493192133132
108097,"/** 
 * Returns statistics
 * @return
 */
public EquivalenceClassStatistics getEquivalenceClassStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=hashTableFirstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      numberOfEquivalenceClasses++;
      if (!entry.isNotOutlier) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new EquivalenceClassStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","/** 
 * Performs sanitization and object creation
 * @param averageEquivalenceClassSizeCounter
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param numberOfEquivalenceClasses
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 * @param viewStatistics
 * @return
 */
private EquivalenceClassStatistics getEquivalenceClassStatistics(int averageEquivalenceClassSizeCounter,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,int numberOfEquivalenceClasses,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples,EquivalenceClassStatistics viewStatistics){
  double averageEquivalenceClassSize;
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new EquivalenceClassStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples,viewStatistics);
}",0.6562042268256958
108098,"/** 
 * Creates a new instance.
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param averageEquivalenceClassSizeIncludingOutliers
 * @param maximalEquivalenceClassSizeIncludingOutliers
 * @param minimalEquivalenceClassSizeIncludingOutliers
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected EquivalenceClassStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,double averageEquivalenceClassSizeIncludingOutliers,int maximalEquivalenceClassSizeIncludingOutliers,int minimalEquivalenceClassSizeIncludingOutliers,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.averageEquivalenceClassSizeIncludingOutliers=averageEquivalenceClassSizeIncludingOutliers;
  this.maximalEquivalenceClassSizeIncludingOutliers=maximalEquivalenceClassSizeIncludingOutliers;
  this.minimalEquivalenceClassSizeIncludingOutliers=minimalEquivalenceClassSizeIncludingOutliers;
  this.numberOfEquivalenceClasses=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}","/** 
 * Creates a new instance.
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param averageEquivalenceClassSizeIncludingOutliers
 * @param maximalEquivalenceClassSizeIncludingOutliers
 * @param minimalEquivalenceClassSizeIncludingOutliers
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 * @param viewStatistics 
 */
protected EquivalenceClassStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,double averageEquivalenceClassSizeIncludingOutliers,int maximalEquivalenceClassSizeIncludingOutliers,int minimalEquivalenceClassSizeIncludingOutliers,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples,EquivalenceClassStatistics viewStatistics){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.averageEquivalenceClassSizeIncludingOutliers=averageEquivalenceClassSizeIncludingOutliers;
  this.maximalEquivalenceClassSizeIncludingOutliers=maximalEquivalenceClassSizeIncludingOutliers;
  this.minimalEquivalenceClassSizeIncludingOutliers=minimalEquivalenceClassSizeIncludingOutliers;
  this.numberOfEquivalenceClasses=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
  this.statisticsView=viewStatistics;
}",0.9649702577660276
108099,"/** 
 * Makes sure that the given Transformation has been checked
 * @param transformation
 */
private void assureChecked(final Transformation transformation){
  if (!transformation.hasProperty(propertyChecked)) {
    transformation.setChecked(checker.check(transformation));
    trackOptimum(transformation);
    listener.progress((double)(System.currentTimeMillis() - timeStart) / (double)timeLimit);
  }
}","/** 
 * Makes sure that the given Transformation has been checked
 * @param transformation
 */
private void assureChecked(final Transformation transformation){
  if (!transformation.hasProperty(propertyChecked)) {
    transformation.setChecked(checker.check(transformation,true));
    trackOptimum(transformation);
    listener.progress((double)(System.currentTimeMillis() - timeStart) / (double)timeLimit);
  }
}",0.9939098660170524
108100,"/** 
 * Updates the solution space
 * @param solutions
 */
public void setSolutionSpace(SolutionSpace solutions){
  lattice.solutionSpace=solutions;
}","/** 
 * Updates the solution space
 * @param solutions
 */
public void setSolutionSpace(SolutionSpace solutions){
  lattice.solutions=solutions;
}",0.9797297297297296
108101,"/** 
 * Constructor.
 * @param solutions The solution space
 * @param complete Is the solution space characterized by an optimal algorithm
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final boolean complete,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.solutionSpace=solutions;
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.complete=complete;
  this.virtualSize=solutions.getSize();
  this.uncertainty=config.isPracticalMonotonicity() && config.getMaxOutliers() != 0d && (!config.isCriterionMonotonic() || !config.getMetric().isMonotonic());
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(transformation.getIdentifier(),node);
    levels.get(transformation.getLevel()).add(node);
    if (optimum != null && transformation.getIdentifier() == optimum.getIdentifier()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
    size++;
  }
  if (!complete) {
    Transformation top=solutions.getTop();
    Transformation bottom=solutions.getBottom();
    if (!map.containsKey(top.getIdentifier())) {
      if (!levels.containsKey(top.getLevel())) {
        levels.put(top.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,top,headermap);
      map.put(top.getIdentifier(),node);
      levels.get(top.getLevel()).add(node);
      maxlevel=top.getLevel();
      size++;
    }
    if (!map.containsKey(bottom.getIdentifier())) {
      if (!levels.containsKey(bottom.getLevel())) {
        levels.put(bottom.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,bottom,headermap);
      map.put(bottom.getIdentifier(),node);
      levels.get(bottom.getLevel()).add(node);
      size++;
    }
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    createRelationships(solutions,map,iterator.next());
  }
  if (!complete) {
    createRelationships(solutions,map,solutions.getTop().getIdentifier());
    createRelationships(solutions,map,solutions.getBottom().getIdentifier());
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}","/** 
 * Constructor.
 * @param solutions The solution space
 * @param complete Is the solution space characterized by an optimal algorithm
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final boolean complete,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.solutions=solutions;
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.complete=complete;
  this.virtualSize=solutions.getSize();
  this.uncertainty=config.isPracticalMonotonicity() && config.getMaxOutliers() != 0d && (!config.isCriterionMonotonic() || !config.getMetric().isMonotonic());
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(transformation.getIdentifier(),node);
    levels.get(transformation.getLevel()).add(node);
    if (optimum != null && transformation.getIdentifier() == optimum.getIdentifier()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
    size++;
  }
  if (!complete) {
    Transformation top=solutions.getTop();
    Transformation bottom=solutions.getBottom();
    if (!map.containsKey(top.getIdentifier())) {
      if (!levels.containsKey(top.getLevel())) {
        levels.put(top.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,top,headermap);
      map.put(top.getIdentifier(),node);
      levels.get(top.getLevel()).add(node);
      maxlevel=top.getLevel();
      size++;
    }
    if (!map.containsKey(bottom.getIdentifier())) {
      if (!levels.containsKey(bottom.getLevel())) {
        levels.put(bottom.getLevel(),new ArrayList<ARXNode>());
      }
      ARXNode node=new ARXNode(this,solutions,bottom,headermap);
      map.put(bottom.getIdentifier(),node);
      levels.get(bottom.getLevel()).add(node);
      size++;
    }
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=complete ? solutions.unsafeGetAllTransformations() : solutions.getMaterializedTransformations(); iterator.hasNext(); ) {
    createRelationships(solutions,map,iterator.next());
  }
  if (!complete) {
    createRelationships(solutions,map,solutions.getTop().getIdentifier());
    createRelationships(solutions,map,solutions.getBottom().getIdentifier());
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}",0.9992533598805377
108102,"/** 
 * Materializes any non-materialized predecessors and successors
 */
public void expand(ARXNode node){
  if (this.isComplete()) {
    return;
  }
  int[] indices=node.getTransformation();
  Transformation transformation=solutionSpace.getTransformation(indices);
  List<Long> neighbors=new ArrayList<Long>();
  for (Iterator<Long> iter=solutionSpace.getPredecessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  for (Iterator<Long> iter=solutionSpace.getSuccessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  Map<String,Integer> headermap=null;
  LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  Map<Long,ARXNode> existing=new HashMap<Long,ARXNode>();
  Set<Long> missing=new HashSet<Long>();
  missing.addAll(neighbors);
  for (  ARXNode[] level : this.levels) {
    for (    ARXNode candidate : level) {
      Long id=solutionSpace.getTransformation(candidate.getTransformation()).getIdentifier();
      map.put(id,candidate);
      if (headermap == null) {
        headermap=candidate.headermap;
      }
      if (missing.contains(id)) {
        existing.put(id,candidate);
      }
    }
  }
  missing.removeAll(existing.keySet());
  Set<Integer> levels=new HashSet<Integer>();
  for (  long id : missing) {
    transformation=solutionSpace.getTransformation(id);
    ARXNode arxnode=new ARXNode(this,solutionSpace,transformation,headermap);
    map.put(id,arxnode);
    levels.add(transformation.getLevel());
  }
  for (  int level : levels) {
    List<ARXNode> newLevel=new ArrayList<ARXNode>();
    newLevel.addAll(Arrays.asList(this.levels[level]));
    for (    long id : missing) {
      ARXNode arxnode=map.get(id);
      if (arxnode.getTotalGeneralizationLevel() == level) {
        int index=0;
        while (index < newLevel.size() && compareLexicographically(newLevel.get(index),arxnode) < 0) {
          index++;
        }
        index=index == 0 ? 0 : index - 1;
        newLevel.add(index,arxnode);
      }
    }
    this.levels[level]=newLevel.toArray(new ARXNode[newLevel.size()]);
  }
  for (  long id : missing) {
    this.createExpandedRelationships(solutionSpace,map,id);
  }
}","/** 
 * Materializes any non-materialized predecessors and successors
 */
public void expand(ARXNode center){
  if (this.isComplete()) {
    return;
  }
  int[] indices=center.getTransformation();
  Transformation transformation=solutions.getTransformation(indices);
  List<Long> neighbors=new ArrayList<Long>();
  for (Iterator<Long> iter=solutions.getPredecessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  for (Iterator<Long> iter=solutions.getSuccessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  Map<String,Integer> headermap=null;
  LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  Set<Long> missing=new HashSet<Long>(neighbors);
  for (  ARXNode[] level : this.levels) {
    for (    ARXNode node : level) {
      headermap=headermap != null ? headermap : node.headermap;
      Long id=solutions.getTransformation(node.getTransformation()).getIdentifier();
      map.put(id,node);
      missing.remove(id);
    }
  }
  Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  for (  long id : missing) {
    transformation=solutions.getTransformation(id);
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(id,node);
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    levels.get(transformation.getLevel()).add(node);
  }
  for (  int level : levels.keySet()) {
    List<ARXNode> nodes=levels.get(level);
    Collections.sort(nodes,new Comparator<ARXNode>(){
      public int compare(      ARXNode o1,      ARXNode o2){
        return compareLexicographically(o1,o2);
      }
    }
);
    List<ARXNode> list=new ArrayList<ARXNode>();
    int index=0;
    for (    ARXNode node : this.levels[level]) {
      while (index < nodes.size() && compareLexicographically(nodes.get(index),node) < 0) {
        list.add(nodes.get(index++));
      }
      list.add(node);
    }
    this.levels[level]=list.toArray(new ARXNode[list.size()]);
  }
  for (  long id : missing) {
    this.createExpandedRelationships(solutions,map,id);
  }
  this.estimateInformationLoss();
}",0.4209579491792219
108103,"/** 
 * Constructor.
 * @param lattice
 * @param solutions
 * @param transformation
 * @param headermap
 */
private ARXNode(final ARXLattice lattice,final SolutionSpace solutions,final Transformation transformation,final Map<String,Integer> headermap){
  this.lattice=lattice;
  this.headermap=headermap;
  this.transformation=transformation.getGeneralization();
  this.minInformationLoss=transformation.getInformationLoss();
  this.maxInformationLoss=transformation.getInformationLoss();
  this.lowerBound=transformation.getLowerBound();
  this.checked=transformation.hasProperty(solutions.getPropertyChecked());
  if (transformation.hasProperty(solutions.getPropertyChecked())) {
    if (transformation.hasProperty(solutions.getPropertyAnonymous())) {
      this.anonymity=Anonymity.ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotAnonymous())) {
      this.anonymity=Anonymity.NOT_ANONYMOUS;
    }
 else {
      if (!complete) {
        this.anonymity=Anonymity.UNKNOWN;
        this.maxInformationLoss=metric.createMaxInformationLoss();
        this.minInformationLoss=metric.createMinInformationLoss();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
  }
 else {
    if (transformation.hasProperty(solutions.getPropertyAnonymous())) {
      this.anonymity=uncertainty ? Anonymity.PROBABLY_ANONYMOUS : Anonymity.ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotAnonymous())) {
      this.anonymity=uncertainty ? Anonymity.PROBABLY_NOT_ANONYMOUS : Anonymity.NOT_ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotKAnonymous())) {
      this.anonymity=Anonymity.NOT_ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyInsufficientUtility())) {
      this.anonymity=Anonymity.UNKNOWN;
    }
 else {
      if (!complete) {
        this.anonymity=Anonymity.UNKNOWN;
        this.maxInformationLoss=metric.createMaxInformationLoss();
        this.minInformationLoss=metric.createMinInformationLoss();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Constructor.
 * @param lattice
 * @param solutions
 * @param transformation
 * @param headermap
 */
private ARXNode(final ARXLattice lattice,final SolutionSpace solutions,final Transformation transformation,final Map<String,Integer> headermap){
  this.lattice=lattice;
  this.headermap=headermap;
  this.transformation=transformation.getGeneralization();
  this.minInformationLoss=transformation.getInformationLoss();
  this.maxInformationLoss=transformation.getInformationLoss();
  this.lowerBound=transformation.getLowerBound();
  this.checked=transformation.hasProperty(solutions.getPropertyChecked());
  if (transformation.hasProperty(solutions.getPropertyChecked())) {
    if (transformation.hasProperty(solutions.getPropertyAnonymous())) {
      this.anonymity=Anonymity.ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotAnonymous())) {
      this.anonymity=Anonymity.NOT_ANONYMOUS;
    }
 else {
      if (!complete) {
        this.anonymity=Anonymity.UNKNOWN;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
  }
 else {
    if (transformation.hasProperty(solutions.getPropertyAnonymous())) {
      this.anonymity=uncertainty ? Anonymity.PROBABLY_ANONYMOUS : Anonymity.ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotAnonymous())) {
      this.anonymity=uncertainty ? Anonymity.PROBABLY_NOT_ANONYMOUS : Anonymity.NOT_ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyNotKAnonymous())) {
      this.anonymity=Anonymity.NOT_ANONYMOUS;
    }
 else     if (transformation.hasProperty(solutions.getPropertyInsufficientUtility())) {
      this.anonymity=Anonymity.UNKNOWN;
    }
 else {
      if (!complete) {
        this.anonymity=Anonymity.UNKNOWN;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
  }
  if (!complete) {
    if (this.maxInformationLoss == null) {
      this.maxInformationLoss=metric.createMaxInformationLoss();
    }
    if (this.minInformationLoss == null) {
      this.minInformationLoss=metric.createMinInformationLoss();
    }
  }
}",0.8933797909407666
108104,"/** 
 * Constructor
 * @param parent
 * @param controller
 */
public ViewSolutionSpace(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.RESULT,this);
  this.parent=parent;
  this.controller=controller;
  this.format=new DecimalFormat(""String_Node_Str"");
  initializeMenu();
  initializeTooltip();
  this.gradient=new Gradient(parent.getDisplay());
  this.base=new Composite(parent,SWT.NONE);
  this.base.setLayoutData(SWTUtil.createFillGridData());
  this.layout=new StackLayout();
  this.base.setLayout(layout);
  this.primary=new Composite(this.base,SWT.NONE);
  this.primary.setLayout(SWTUtil.createGridLayout(1));
  this.secondary=new Composite(this.base,SWT.NONE);
  this.secondary.setLayout(SWTUtil.createGridLayout(1));
  this.label=new CLabel(this.secondary,SWT.NONE);
  this.label.setLayoutData(GridDataFactory.swtDefaults().align(SWT.CENTER,SWT.CENTER).grab(true,true).minSize(400,200).create());
  this.label.setImage(controller.getResources().getImage(""String_Node_Str""));
  this.label.setText(""String_Node_Str"");
  this.label.setAlignment(SWT.LEFT);
  this.showPrimaryComposite();
}","/** 
 * Constructor
 * @param parent
 * @param controller
 */
public ViewSolutionSpace(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.EXPAND,this);
  this.parent=parent;
  this.controller=controller;
  this.format=new DecimalFormat(""String_Node_Str"");
  initializeMenu();
  initializeTooltip();
  this.gradient=new Gradient(parent.getDisplay());
  this.base=new Composite(parent,SWT.NONE);
  this.base.setLayoutData(SWTUtil.createFillGridData());
  this.layout=new StackLayout();
  this.base.setLayout(layout);
  this.primary=new Composite(this.base,SWT.NONE);
  this.primary.setLayout(SWTUtil.createGridLayout(1));
  this.secondary=new Composite(this.base,SWT.NONE);
  this.secondary.setLayout(SWTUtil.createGridLayout(1));
  this.label=new CLabel(this.secondary,SWT.NONE);
  this.label.setLayoutData(GridDataFactory.swtDefaults().align(SWT.CENTER,SWT.CENTER).grab(true,true).minSize(400,200).create());
  this.label.setImage(controller.getResources().getImage(""String_Node_Str""));
  this.label.setText(""String_Node_Str"");
  this.label.setAlignment(SWT.LEFT);
  this.showPrimaryComposite();
}",0.98131910026687
108105,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    eventNodeSelected();
  }
 else   if (event.part == ModelPart.RESULT) {
    ARXResult result=(ARXResult)event.data;
    if (model != null && result != null && result.getGlobalOptimum() != null) {
      optimum=result.getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(result,model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventResultChanged(result);
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    if (model != null && model.getResult() != null && model.getResult().getGlobalOptimum() != null) {
      optimum=model.getResult().getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventModelChanged();
    }
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null && !isTooLarge(model.getResult(),(ModelNodeFilter)event.data,model.getMaxNodesInViewer())) {
      eventFilterChanged(model.getResult(),(ModelNodeFilter)event.data);
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    eventNodeSelected();
  }
 else   if (event.part == ModelPart.RESULT) {
    ARXResult result=(ARXResult)event.data;
    if (model != null && result != null && result.getGlobalOptimum() != null) {
      optimum=result.getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(result,model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventResultChanged(result);
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    if (model != null && model.getResult() != null && model.getResult().getGlobalOptimum() != null) {
      optimum=model.getResult().getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventModelChanged();
    }
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null && !isTooLarge(model.getResult(),(ModelNodeFilter)event.data,model.getMaxNodesInViewer())) {
      eventFilterChanged(model.getResult(),(ModelNodeFilter)event.data);
    }
  }
 else   if (event.part == ModelPart.EXPAND) {
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventFilterChanged(model.getResult(),model.getNodeFilter());
    }
  }
}",0.9131736526946108
108106,"@Override public void widgetSelected(final SelectionEvent arg0){
  model.setSelectedNode(selectedNode);
  controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
  controller.actionExpand(selectedNode);
  eventFilterChanged(model.getResult(),model.getNodeFilter());
}","@Override public void widgetSelected(final SelectionEvent arg0){
  model.setSelectedNode(selectedNode);
  controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
  controller.actionExpand(selectedNode);
  controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.EXPAND,selectedNode));
  eventFilterChanged(model.getResult(),model.getNodeFilter());
}",0.8709219858156029
108107,"/** 
 * Creates the context menu.
 */
private void initializeMenu(){
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().addToClipboard(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      actionRedraw();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      actionRedraw();
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      controller.actionExpand(selectedNode);
      eventFilterChanged(model.getResult(),model.getNodeFilter());
    }
  }
);
}","/** 
 * Creates the context menu.
 */
private void initializeMenu(){
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().addToClipboard(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      actionRedraw();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      actionRedraw();
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.SELECTED_NODE,selectedNode));
      controller.actionExpand(selectedNode);
      controller.update(new ModelEvent(ViewSolutionSpace.this,ModelPart.EXPAND,selectedNode));
      eventFilterChanged(model.getResult(),model.getNodeFilter());
    }
  }
);
}",0.9717682020802376
108108,"/** 
 * Materializes any non-materialized predecessors and successors
 */
public void expand(ARXNode center){
  if (this.isComplete()) {
    return;
  }
  int[] indices=center.getTransformation();
  Transformation transformation=solutions.getTransformation(indices);
  List<Long> neighbors=new ArrayList<Long>();
  for (Iterator<Long> iter=solutions.getPredecessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  for (Iterator<Long> iter=solutions.getSuccessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  Map<String,Integer> headermap=null;
  LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  Set<Long> missing=new HashSet<Long>(neighbors);
  for (  ARXNode[] level : this.levels) {
    for (    ARXNode node : level) {
      headermap=headermap != null ? headermap : node.headermap;
      Long id=solutions.getTransformation(node.getTransformation()).getIdentifier();
      map.put(id,node);
      missing.remove(id);
    }
  }
  Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  for (  long id : missing) {
    transformation=solutions.getTransformation(id);
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(id,node);
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    levels.get(transformation.getLevel()).add(node);
  }
  for (  int level : levels.keySet()) {
    List<ARXNode> nodes=levels.get(level);
    Collections.sort(nodes,new Comparator<ARXNode>(){
      public int compare(      ARXNode o1,      ARXNode o2){
        return compareLexicographically(o1,o2);
      }
    }
);
    List<ARXNode> list=new ArrayList<ARXNode>();
    int index=0;
    for (    ARXNode node : this.levels[level]) {
      while (index < nodes.size() && compareLexicographically(nodes.get(index),node) < 0) {
        list.add(nodes.get(index++));
      }
      list.add(node);
    }
    this.levels[level]=list.toArray(new ARXNode[list.size()]);
  }
  for (  long id : missing) {
    this.createExpandedRelationships(solutions,map,id);
  }
  this.estimateInformationLoss();
}","/** 
 * Materializes any non-materialized predecessors and successors
 */
public void expand(ARXNode center){
  if (this.isComplete()) {
    return;
  }
  int[] indices=center.getTransformation();
  Transformation transformation=solutions.getTransformation(indices);
  List<Long> neighbors=new ArrayList<Long>();
  for (Iterator<Long> iter=solutions.getPredecessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  for (Iterator<Long> iter=solutions.getSuccessors(transformation.getIdentifier()); iter.hasNext(); ) {
    neighbors.add(iter.next());
  }
  Map<String,Integer> headermap=null;
  LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  Set<Long> missing=new HashSet<Long>(neighbors);
  for (  ARXNode[] level : this.levels) {
    for (    ARXNode node : level) {
      headermap=headermap != null ? headermap : node.headermap;
      Long id=solutions.getTransformation(node.getTransformation()).getIdentifier();
      map.put(id,node);
      missing.remove(id);
    }
  }
  Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  for (  long id : missing) {
    transformation=solutions.getTransformation(id);
    ARXNode node=new ARXNode(this,solutions,transformation,headermap);
    map.put(id,node);
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    levels.get(transformation.getLevel()).add(node);
  }
  for (  int level : levels.keySet()) {
    List<ARXNode> nodes=levels.get(level);
    Collections.sort(nodes,new Comparator<ARXNode>(){
      public int compare(      ARXNode o1,      ARXNode o2){
        return compareLexicographically(o1,o2);
      }
    }
);
    List<ARXNode> list=new ArrayList<ARXNode>();
    int index=0;
    for (    ARXNode node : this.levels[level]) {
      while (index < nodes.size() && compareLexicographically(nodes.get(index),node) < 0) {
        list.add(nodes.get(index++));
      }
      list.add(node);
    }
    while (index < nodes.size()) {
      list.add(nodes.get(index++));
    }
    this.levels[level]=list.toArray(new ARXNode[list.size()]);
  }
  for (  long id : missing) {
    this.createExpandedRelationships(solutions,map,id);
  }
  this.estimateInformationLoss();
}",0.9829759009506964
108109,"/** 
 * Returns whether a quasi-identifier is selected.
 * @return
 */
public boolean isQuasiIdentifierSelected(){
  return (getInputDefinition().getAttributeType(getSelectedAttribute()) instanceof Hierarchy);
}","/** 
 * Returns whether a quasi-identifier is selected.
 * @return
 */
public boolean isQuasiIdentifierSelected(){
  return (getInputDefinition().getAttributeType(getSelectedAttribute()) == AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
}",0.8609865470852018
108110,"/** 
 * Updates the global hierarchy definition.
 */
private void pushHierarchy(){
  if (model == null || model.getInputConfig() == null) {
    return;
  }
  Hierarchy h=Hierarchy.create(hierarchy);
  model.getInputConfig().setHierarchy(attribute,h);
  controller.update(new ModelEvent(this,ModelPart.HIERARCHY,h));
}","/** 
 * Updates the global hierarchy definition.
 */
private void pushHierarchy(){
  if (model == null || model.getInputConfig() == null) {
    return;
  }
  Hierarchy h=null;
  if (hierarchy == null) {
    model.getInputConfig().removeHierarchy(attribute);
  }
 else {
    h=Hierarchy.create(hierarchy);
    model.getInputConfig().setHierarchy(attribute,h);
  }
  controller.update(new ModelEvent(this,ModelPart.HIERARCHY,h));
}",0.7721179624664879
108111,"/** 
 * Returns a generalization hierarchy for the attribute, if available.
 * @param context
 * @param attribute
 * @return
 */
public Hierarchy getHierarchy(AnalysisData context,String attribute){
  if (context.config == null || context.config == model.getInputConfig() || model.getOutputDefinition() == null) {
    return null;
  }
  AttributeType type=model.getOutputDefinition().getAttributeType(attribute);
  if (type instanceof Hierarchy) {
    return (Hierarchy)type;
  }
  for (  HierarchicalDistanceTCloseness t : context.config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    if (t.getAttribute().equals(attribute)) {
      return t.getHierarchy();
    }
  }
  return null;
}","/** 
 * Returns a generalization hierarchy for the attribute, if available.
 * @param context
 * @param attribute
 * @return
 */
public Hierarchy getHierarchy(AnalysisData context,String attribute){
  if (context.config == null || context.config == model.getInputConfig() || model.getOutputDefinition() == null) {
    return null;
  }
  Hierarchy hierarchy=model.getOutputDefinition().getHierarchyObject(attribute);
  if (hierarchy != null) {
    return hierarchy;
  }
  for (  HierarchicalDistanceTCloseness t : context.config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    if (t.getAttribute().equals(attribute)) {
      return t.getHierarchy();
    }
  }
  return null;
}",0.8614938361131255
108112,"/** 
 * Update the attribute type.
 */
private void updateAttributeType(){
  AttributeType type=model.getInputDefinition().getAttributeType(attribute);
  if (type instanceof Hierarchy) {
    type=null;
  }
  for (int i=0; i < COMBO1_TYPES.length; i++) {
    if (type == COMBO1_TYPES[i]) {
      cmbType.select(i);
      break;
    }
  }
}","/** 
 * Update the attribute type.
 */
private void updateAttributeType(){
  AttributeType type=model.getInputDefinition().getAttributeType(attribute);
  for (int i=0; i < COMBO1_TYPES.length; i++) {
    if (type == COMBO1_TYPES[i]) {
      cmbType.select(i);
      break;
    }
  }
}",0.9131832797427653
108113,"/** 
 * Update the column icon.
 */
private void updateIcon(){
  AttributeType type=model.getInputDefinition().getAttributeType(attribute);
  if (type instanceof Hierarchy) {
    tabItem.setImage(IMAGE_QUASI_IDENTIFYING);
  }
 else   if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    tabItem.setImage(IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    tabItem.setImage(IMAGE_SENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    tabItem.setImage(IMAGE_IDENTIFYING);
  }
}","/** 
 * Update the column icon.
 */
private void updateIcon(){
  AttributeType type=model.getInputDefinition().getAttributeType(attribute);
  if (type == AttributeType.QUASI_IDENTIFYING_ATTRIBUTE) {
    tabItem.setImage(IMAGE_QUASI_IDENTIFYING);
  }
 else   if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    tabItem.setImage(IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    tabItem.setImage(IMAGE_SENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    tabItem.setImage(IMAGE_IDENTIFYING);
  }
}",0.5118829981718465
108114,"/** 
 * Reads the data definition from the file.
 * @param config
 * @param definition
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final DataDefinition definition,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            definition.setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            definition.setDataType(attr,DataType.DECIMAL);
          }
 else {
            definition.setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(Resources.getMessage(""String_Node_Str""));
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(Resources.getMessage(""String_Node_Str"") + attr);
          }
          definition.setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.QUASI_IDENTIFYING_ATTRIBUTE.toString())) {
          if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
            MicroAggregationFunction microaggregation=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
            definition.setAttributeType(attr,microaggregation);
          }
 else {
            Hierarchy hierarchy=config.getHierarchy(attr);
            if (hierarchy == null) {
              try {
                hierarchy=readHierarchy(zip,prefix,ref);
              }
 catch (              final IOException e) {
                throw new SAXException(e);
              }
            }
            definition.setAttributeType(attr,hierarchy);
            config.setHierarchy(attr,hierarchy);
            int height=hierarchy.getHierarchy().length > 0 ? hierarchy.getHierarchy()[0].length : 0;
            if (min.equals(""String_Node_Str"")) {
              config.setMinimumGeneralization(attr,null);
              definition.setMinimumGeneralization(attr,0);
            }
 else {
              config.setMinimumGeneralization(attr,Integer.valueOf(min));
              definition.setMinimumGeneralization(attr,Integer.valueOf(min));
            }
            if (max.equals(""String_Node_Str"")) {
              config.setMaximumGeneralization(attr,null);
              definition.setMaximumGeneralization(attr,height - 1);
            }
 else {
              config.setMaximumGeneralization(attr,Integer.valueOf(max));
              definition.setMaximumGeneralization(attr,Integer.valueOf(max));
            }
            if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
              if (config.getMinimumGeneralization(attr) != null && config.getMinimumGeneralization(attr).equals(0)) {
                config.setMinimumGeneralization(attr,null);
              }
              if (config.getMaximumGeneralization(attr) != null && config.getMaximumGeneralization(attr).equals(height - 1)) {
                config.setMaximumGeneralization(attr,null);
              }
            }
          }
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)|| vocabulary.isMicroaggregationFunction(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file.
 * @param config
 * @param definition
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final DataDefinition definition,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            definition.setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            definition.setDataType(attr,DataType.DECIMAL);
          }
 else {
            definition.setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(Resources.getMessage(""String_Node_Str""));
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(Resources.getMessage(""String_Node_Str"") + attr);
          }
          definition.setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.QUASI_IDENTIFYING_ATTRIBUTE.toString())) {
          definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
          if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
            MicroAggregationFunction microaggregation=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
            definition.setMicroAggregationFunction(attr,microaggregation);
          }
          Hierarchy hierarchy=config.getHierarchy(attr);
          if (hierarchy == null) {
            if (ref != null) {
              try {
                hierarchy=readHierarchy(zip,prefix,ref);
              }
 catch (              final IOException e) {
                throw new SAXException(e);
              }
            }
          }
          if (hierarchy != null) {
            config.setHierarchy(attr,hierarchy);
            definition.setHierarchy(attr,hierarchy);
            int height=hierarchy.getHierarchy().length > 0 ? hierarchy.getHierarchy()[0].length : 0;
            if (min.equals(""String_Node_Str"")) {
              config.setMinimumGeneralization(attr,null);
              definition.setMinimumGeneralization(attr,0);
            }
 else {
              config.setMinimumGeneralization(attr,Integer.valueOf(min));
              definition.setMinimumGeneralization(attr,Integer.valueOf(min));
            }
            if (max.equals(""String_Node_Str"")) {
              config.setMaximumGeneralization(attr,null);
              definition.setMaximumGeneralization(attr,height - 1);
            }
 else {
              config.setMaximumGeneralization(attr,Integer.valueOf(max));
              definition.setMaximumGeneralization(attr,Integer.valueOf(max));
            }
            if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
              if (config.getMinimumGeneralization(attr) != null && config.getMinimumGeneralization(attr).equals(0)) {
                config.setMinimumGeneralization(attr,null);
              }
              if (config.getMaximumGeneralization(attr) != null && config.getMaximumGeneralization(attr).equals(height - 1)) {
                config.setMaximumGeneralization(attr,null);
              }
            }
          }
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else       if (vocabulary.isMicroaggregationFunction(localName)) {
        return true;
      }
 else       if (vocabulary.isMicroaggregationIgnoreMissingData(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)|| vocabulary.isMicroaggregationFunction(localName)|| vocabulary.isMicroaggregationIgnoreMissingData(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.9545055093625364
108115,"/** 
 * Returns an XML representation of the data definition.
 * @param config
 * @param handle
 * @param definition
 * @return
 * @throws IOException
 */
private String toXML(final ModelConfiguration config,final DataHandle handle,final DataDefinition definition) throws IOException {
  XMLWriter writer=new XMLWriter();
  writer.indent(vocabulary.getDefinition());
  for (int i=0; i < handle.getNumColumns(); i++) {
    final String attr=handle.getAttributeName(i);
    AttributeType t=definition.getAttributeType(attr);
    DataType<?> dt=definition.getDataType(attr);
    if (t == null)     t=AttributeType.IDENTIFYING_ATTRIBUTE;
    if (dt == null)     dt=DataType.STRING;
    writer.indent(vocabulary.getAssigment());
    writer.write(vocabulary.getName(),attr);
    writer.write(vocabulary.getType(),t.toString());
    writer.write(vocabulary.getDatatype(),dt.getDescription().getLabel());
    if (dt.getDescription().hasFormat()) {
      String format=((DataTypeWithFormat)dt).getFormat();
      if (format != null) {
        writer.write(vocabulary.getFormat(),format);
      }
    }
    if (t instanceof Hierarchy || (t == AttributeType.SENSITIVE_ATTRIBUTE && config.getHierarchy(attr) != null)) {
      writer.write(vocabulary.getRef(),""String_Node_Str"" + toFileName(attr) + ""String_Node_Str"");
      if (t instanceof Hierarchy) {
        Integer min=config.getMinimumGeneralization(attr);
        Integer max=config.getMaximumGeneralization(attr);
        writer.write(vocabulary.getMin(),min == null ? ""String_Node_Str"" : String.valueOf(min));
        writer.write(vocabulary.getMax(),max == null ? ""String_Node_Str"" : String.valueOf(max));
      }
    }
 else     if (t instanceof MicroAggregationFunction) {
      writer.write(vocabulary.getMicroAggregationFunction(),config.getMicroAggregationFunction(attr).getLabel());
      writer.write(vocabulary.getMicroAggregationIgnoreMissingData(),config.getMicroAggregationIgnoreMissingData(attr));
    }
    writer.unindent();
  }
  writer.unindent();
  return writer.toString();
}","/** 
 * Returns an XML representation of the data definition.
 * @param config
 * @param handle
 * @param definition
 * @return
 * @throws IOException
 */
private String toXML(final ModelConfiguration config,final DataHandle handle,final DataDefinition definition) throws IOException {
  XMLWriter writer=new XMLWriter();
  writer.indent(vocabulary.getDefinition());
  for (int i=0; i < handle.getNumColumns(); i++) {
    final String attr=handle.getAttributeName(i);
    AttributeType t=definition.getAttributeType(attr);
    DataType<?> dt=definition.getDataType(attr);
    if (t == null)     t=AttributeType.IDENTIFYING_ATTRIBUTE;
    if (dt == null)     dt=DataType.STRING;
    writer.indent(vocabulary.getAssigment());
    writer.write(vocabulary.getName(),attr);
    writer.write(vocabulary.getType(),t.toString());
    writer.write(vocabulary.getDatatype(),dt.getDescription().getLabel());
    if (dt.getDescription().hasFormat()) {
      String format=((DataTypeWithFormat)dt).getFormat();
      if (format != null) {
        writer.write(vocabulary.getFormat(),format);
      }
    }
    if (definition.getHierarchy(attr) != null && definition.getHierarchy(attr).length != 0 && definition.getHierarchy(attr)[0].length != 0) {
      writer.write(vocabulary.getRef(),""String_Node_Str"" + toFileName(attr) + ""String_Node_Str"");
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      writer.write(vocabulary.getMin(),min == null ? ""String_Node_Str"" : String.valueOf(min));
      writer.write(vocabulary.getMax(),max == null ? ""String_Node_Str"" : String.valueOf(max));
    }
    if (definition.getMicroAggregationFunction(attr) != null) {
      writer.write(vocabulary.getMicroAggregationFunction(),config.getMicroAggregationFunction(attr).getLabel());
      writer.write(vocabulary.getMicroAggregationIgnoreMissingData(),config.getMicroAggregationIgnoreMissingData(attr));
    }
    writer.unindent();
  }
  writer.unindent();
  return writer.toString();
}",0.9340875553369404
108116,"/** 
 * Returns the according hierarchy.
 * @param attribute
 * @return
 */
public String[][] getHierarchy(final String attribute){
  Hierarchy hierarchy=hierarchies.get(attribute);
  return hierarchy == null ? null : hierarchy.getHierarchy();
}","/** 
 * Returns the according hierarchy as String array.
 * @param attribute
 * @return
 */
public String[][] getHierarchy(final String attribute){
  Hierarchy hierarchy=hierarchies.get(attribute);
  return hierarchy == null ? null : hierarchy.getHierarchy();
}",0.9683794466403162
108117,"@Override public void traverse(){
  timeStart=System.currentTimeMillis();
  MinMaxPriorityQueue<Long> queue=new MinMaxPriorityQueue<Long>(MAX_QUEUE_SIZE,new Comparator<Long>(){
    @Override public int compare(    Long arg0,    Long arg1){
      return solutionSpace.getUtility(arg0).compareTo(solutionSpace.getUtility(arg1));
    }
  }
);
  Transformation bottom=solutionSpace.getBottom();
  assureChecked(bottom);
  queue.add(bottom.getIdentifier());
  Transformation next;
  int step=0;
  while ((next=solutionSpace.getTransformation(queue.poll())) != null) {
    if (!prune(next)) {
      step++;
      if (step % stepping == 0) {
        dfs(queue,next);
      }
 else {
        expand(queue,next);
      }
      if (getTime() > timeLimit) {
        return;
      }
    }
  }
}","@Override public void traverse(){
  timeStart=System.currentTimeMillis();
  MinMaxPriorityQueue<Long> queue=new MinMaxPriorityQueue<Long>(MAX_QUEUE_SIZE,new Comparator<Long>(){
    @Override public int compare(    Long arg0,    Long arg1){
      return solutionSpace.getUtility(arg0).compareTo(solutionSpace.getUtility(arg1));
    }
  }
);
  Transformation bottom=solutionSpace.getBottom();
  assureChecked(bottom);
  queue.add(bottom.getIdentifier());
  Transformation next;
  int step=0;
  Long nextId;
  while ((nextId=queue.poll()) != null) {
    next=solutionSpace.getTransformation(nextId);
    if (!prune(next)) {
      step++;
      if (step % stepping == 0) {
        dfs(queue,next);
      }
 else {
        expand(queue,next);
      }
      if (getTime() > timeLimit) {
        return;
      }
    }
  }
}",0.9261576971214016
108118,"/** 
 * Constructor.
 * @param solutions The solution space
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.uncertainty=config.isPracticalMonotonicity() && config.getMaxOutliers() != 0d && (!config.isCriterionMonotonic() || !config.getMetric().isMonotonic());
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=solutions.unsafeGetAllTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(solutions,transformation,headermap);
    size++;
    map.put(transformation.getId(),node);
    levels.get(transformation.getLevel()).add(node);
    if (transformation.getId() == optimum.getId()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=solutions.unsafeGetAllTransformations(); iterator.hasNext(); ) {
    final long id=iterator.next();
    final ARXNode fnode=map.get(id);
    List<ARXNode> successors=new ArrayList<ARXNode>();
    List<ARXNode> predecessors=new ArrayList<ARXNode>();
    for (Iterator<Long> iter1=solutions.getSuccessors(id); iter1.hasNext(); ) {
      ARXNode node=map.get(iter1.next());
      if (node != null) {
        successors.add(node);
      }
    }
    for (Iterator<Long> iter2=solutions.getPredecessors(id); iter2.hasNext(); ) {
      ARXNode node=map.get(iter2.next());
      if (node != null) {
        predecessors.add(node);
      }
    }
    fnode.successors=successors.toArray(new ARXNode[successors.size()]);
    fnode.predecessors=predecessors.toArray(new ARXNode[predecessors.size()]);
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}","/** 
 * Constructor.
 * @param solutions The solution space
 * @param optimum The optimum
 * @param header The header
 * @param config The config
 */
ARXLattice(final SolutionSpace solutions,final Transformation optimum,final String[] header,final ARXConfigurationInternal config){
  this.metric=config.getMetric();
  this.monotonicNonAnonymous=metric.isMonotonic() || !config.isSuppressionAlwaysEnabled();
  this.monotonicAnonymous=metric.isMonotonic() || config.getAbsoluteMaxOutliers() == 0;
  this.uncertainty=config.isPracticalMonotonicity() && config.getMaxOutliers() != 0d && (!config.isCriterionMonotonic() || !config.getMetric().isMonotonic());
  final Map<String,Integer> headermap=new HashMap<String,Integer>();
  int index=0;
  for (int i=0; i < header.length; i++) {
    headermap.put(header[i],index++);
  }
  final LongObjectOpenHashMap<ARXNode> map=new LongObjectOpenHashMap<ARXNode>();
  final IntObjectOpenHashMap<List<ARXNode>> levels=new IntObjectOpenHashMap<List<ARXNode>>();
  int size=0;
  int maxlevel=0;
  for (Iterator<Long> iterator=solutions.unsafeGetAllTransformations(); iterator.hasNext(); ) {
    Transformation transformation=solutions.getTransformation(iterator.next());
    if (!levels.containsKey(transformation.getLevel())) {
      levels.put(transformation.getLevel(),new ArrayList<ARXNode>());
    }
    ARXNode node=new ARXNode(solutions,transformation,headermap);
    size++;
    map.put(transformation.getId(),node);
    levels.get(transformation.getLevel()).add(node);
    if (optimum != null && transformation.getId() == optimum.getId()) {
      this.optimum=node;
    }
    maxlevel=Math.max(maxlevel,transformation.getLevel());
  }
  this.size=size;
  this.levels=new ARXNode[maxlevel + 1][];
  for (int i=0; i < this.levels.length; i++) {
    if (levels.containsKey(i)) {
      this.levels[i]=levels.get(i).toArray(new ARXNode[levels.get(i).size()]);
    }
 else {
      this.levels[i]=new ARXNode[0];
    }
  }
  for (Iterator<Long> iterator=solutions.unsafeGetAllTransformations(); iterator.hasNext(); ) {
    final long id=iterator.next();
    final ARXNode fnode=map.get(id);
    List<ARXNode> successors=new ArrayList<ARXNode>();
    List<ARXNode> predecessors=new ArrayList<ARXNode>();
    for (Iterator<Long> iter1=solutions.getSuccessors(id); iter1.hasNext(); ) {
      ARXNode node=map.get(iter1.next());
      if (node != null) {
        successors.add(node);
      }
    }
    for (Iterator<Long> iter2=solutions.getPredecessors(id); iter2.hasNext(); ) {
      ARXNode node=map.get(iter2.next());
      if (node != null) {
        predecessors.add(node);
      }
    }
    fnode.successors=successors.toArray(new ARXNode[successors.size()]);
    fnode.predecessors=predecessors.toArray(new ARXNode[predecessors.size()]);
  }
  outer:   for (int i=0; i < this.levels.length; i++) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        bottom=node;
        break outer;
      }
    }
  }
  outer:   for (int i=this.levels.length - 1; i >= 0; i--) {
    final ARXNode[] level=this.levels[i];
    for (int j=0; j < level.length; j++) {
      final ARXNode node=level[j];
      if (node != null) {
        top=node;
        break outer;
      }
    }
  }
  estimateInformationLoss();
}",0.9971467187265356
108119,"/** 
 * Creates a microaggregation function using generalization.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createGeneralization(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionGeneralization(ignoreMissingData),false,DataScale.NOMINAL,""String_Node_Str"");
}","/** 
 * Creates a microaggregation function using generalization.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createGeneralization(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionGeneralization(ignoreMissingData),DataScale.NOMINAL,""String_Node_Str"");
}",0.9925373134328358
108120,"/** 
 * Creates a microaggregation function returning the median.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createMedian(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionMedian(ignoreMissingData),true,DataScale.ORDINAL,""String_Node_Str"");
}","/** 
 * Creates a microaggregation function returning the median.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createMedian(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionMedian(ignoreMissingData),DataScale.ORDINAL,""String_Node_Str"");
}",0.993514915693904
108121,"/** 
 * Creates a microaggregation function returning the mode.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createMode(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionMode(ignoreMissingData),true,DataScale.ORDINAL,""String_Node_Str"");
}","/** 
 * Creates a microaggregation function returning the mode.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createMode(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionMode(ignoreMissingData),DataScale.ORDINAL,""String_Node_Str"");
}",0.9934123847167324
108122,"/** 
 * Instantiates a new hierarchy.
 * @param function
 * @param typePreserving
 * @param requiredScale
 * @param label 
 */
private MicroAggregationFunction(DistributionAggregateFunction function,boolean typePreserving,DataScale requiredScale,String label){
  super(ATTR_TYPE_QI);
  this.function=function;
  this.requiredScale=requiredScale;
  this.label=label;
  this.typePreserving=typePreserving;
}","/** 
 * Instantiates a new hierarchy.
 * @param function
 * @param requiredScale
 * @param label 
 */
private MicroAggregationFunction(DistributionAggregateFunction function,DataScale requiredScale,String label){
  super(ATTR_TYPE_QI);
  this.function=function;
  this.requiredScale=requiredScale;
  this.label=label;
}",0.8812154696132597
108123,"/** 
 * Creates a microaggregation function returning the arithmetic mean.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createArithmeticMean(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionArithmeticMean(ignoreMissingData),true,DataScale.INTERVAL,""String_Node_Str"");
}","/** 
 * Creates a microaggregation function returning the arithmetic mean.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createArithmeticMean(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionArithmeticMean(ignoreMissingData),DataScale.INTERVAL,""String_Node_Str"");
}",0.993924665856622
108124,"/** 
 * Creates a microaggregation function returning the geometric mean.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createGeometricMean(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionGeometricMean(ignoreMissingData),true,DataScale.INTERVAL,""String_Node_Str"");
}","/** 
 * Creates a microaggregation function returning the geometric mean.
 * @param ignoreMissingData Should the function ignore missing data. Default is true.
 * @return
 */
public static MicroAggregationFunction createGeometricMean(boolean ignoreMissingData){
  return new MicroAggregationFunction(new DistributionAggregateFunctionGeometricMean(ignoreMissingData),DataScale.INTERVAL,""String_Node_Str"");
}",0.9938800489596084
108125,"/** 
 * Returns whether this is a type-preserving function
 * @return
 */
public boolean isTypePreserving(){
  return typePreserving;
}","/** 
 * Returns whether this is a type-preserving function
 * @return
 */
public boolean isTypePreserving(){
  return function.isTypePreserving();
}",0.9540636042402828
108126,"/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[dataIS.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[dataDI.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=new DataType[dataGH.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=new DataType[dataOT.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFYING]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=dataIS.getHeader();
    break;
case AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED:
  header=dataGH.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=dataDI.getHeader();
break;
case AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED:
header=dataOT.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED) && (node.getTransformation()[j] > 0)) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
return dataTypes;
}","/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[dataIS.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[dataDI.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=new DataType[dataGH.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=new DataType[dataOT.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFYING]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=dataIS.getHeader();
    break;
case AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED:
  header=dataGH.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=dataDI.getHeader();
break;
case AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED:
header=dataOT.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED && node.getTransformation()[j] > 0) || (i == AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED && !definition.getMicroAggregationFunction(header[j]).isTypePreserving())) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
return dataTypes;
}",0.9501238061549344
108127,"/** 
 * Gets the num rows.
 * @return the num rows
 */
@Override public int getNumRows(){
  checkRegistry();
  return dataGH.getDataLength();
}","/** 
 * Gets the num rows.
 * @return the num rows
 */
@Override public int getNumRows(){
  checkRegistry();
  return outputGeneralized.getDataLength();
}",0.9292929292929292
108128,"@Override public boolean hasNext(){
  return row < dataGH.getArray().length;
}","@Override public boolean hasNext(){
  return row < outputGeneralized.getArray().length;
}",0.874251497005988
108129,"/** 
 * Instantiates a new handle.
 * @param result
 * @param registry
 * @param manager
 * @param bufferGH
 * @param bufferOT
 * @param node
 * @param statistics
 * @param definition
 * @param config
 */
protected DataHandleOutput(final ARXResult result,final DataRegistry registry,final DataManager manager,final Data bufferGH,final Data bufferOT,final ARXNode node,final StatisticsEquivalenceClasses statistics,final DataDefinition definition,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.suppressionString=config.getSuppressionString();
  this.suppressedAttributeTypes=convert(config.getSuppressedAttributeTypes());
  this.result=result;
  this.definition=definition;
  this.statistics=new StatisticsBuilder(new DataHandleStatistics(this),statistics);
  this.node=node;
  this.dataGH=bufferGH;
  this.dataOT=bufferOT;
  this.dataDI=manager.getDataAnalyzed();
  this.dataIS=manager.getDataStatic();
  this.header=manager.getHeader();
  this.startIndexMA=manager.getMicroaggregationStartIndex();
  this.inverseMap=new int[header.length * 2];
  for (int i=0; i < this.inverseMap.length; i+=2) {
    this.inverseMap[i]=AttributeTypeInternal.IDENTIFYING;
    this.inverseMap[i + 1]=-1;
  }
  for (int i=0; i < this.dataGH.getMap().length; i++) {
    final int pos=dataGH.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < this.startIndexMA; i++) {
    final int pos=dataDI.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.SENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < dataOT.getMap().length; i++) {
    final int pos=dataOT.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    final int pos=dataIS.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.INSENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  this.inverseData=new int[5][][];
  this.inverseData[AttributeTypeInternal.INSENSITIVE]=this.dataIS.getArray();
  this.inverseData[AttributeTypeInternal.SENSITIVE]=this.dataDI.getArray();
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.dataGH.getArray();
  this.inverseData[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.dataOT.getArray();
  this.inverseDictionaries=new Dictionary[5];
  this.inverseDictionaries[AttributeTypeInternal.INSENSITIVE]=this.dataIS.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.SENSITIVE]=this.dataDI.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.dataGH.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.dataOT.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}","/** 
 * Instantiates a new handle.
 * @param result
 * @param registry
 * @param manager
 * @param outputGeneralized
 * @param outputMicroaggregated
 * @param node
 * @param statistics
 * @param definition
 * @param config
 */
protected DataHandleOutput(final ARXResult result,final DataRegistry registry,final DataManager manager,final Data outputGeneralized,final Data outputMicroaggregated,final ARXNode node,final StatisticsEquivalenceClasses statistics,final DataDefinition definition,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.suppressionString=config.getSuppressionString();
  this.suppressedAttributeTypes=convert(config.getSuppressedAttributeTypes());
  this.result=result;
  this.definition=definition;
  this.statistics=new StatisticsBuilder(new DataHandleStatistics(this),statistics);
  this.node=node;
  this.outputGeneralized=outputGeneralized;
  this.outputMicroaggregated=outputMicroaggregated;
  this.inputAnalyzed=manager.getDataAnalyzed();
  this.inputStatic=manager.getDataStatic();
  this.header=manager.getHeader();
  this.microaggregationStartIndex=manager.getMicroaggregationStartIndex();
  this.inverseMap=new int[header.length * 2];
  for (int i=0; i < this.inverseMap.length; i+=2) {
    this.inverseMap[i]=AttributeTypeInternal.IDENTIFYING;
    this.inverseMap[i + 1]=-1;
  }
  for (int i=0; i < this.outputGeneralized.getMap().length; i++) {
    final int pos=outputGeneralized.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < this.microaggregationStartIndex; i++) {
    final int pos=inputAnalyzed.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.SENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < outputMicroaggregated.getMap().length; i++) {
    final int pos=outputMicroaggregated.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED;
    this.inverseMap[pos + 1]=i;
  }
  for (int i=0; i < inputStatic.getMap().length; i++) {
    final int pos=inputStatic.getMap()[i] * 2;
    this.inverseMap[pos]=AttributeTypeInternal.INSENSITIVE;
    this.inverseMap[pos + 1]=i;
  }
  this.inverseData=new int[5][][];
  this.inverseData[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getArray();
  this.inverseData[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getArray();
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getArray();
  this.inverseData[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseData[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getArray();
  this.inverseDictionaries=new Dictionary[5];
  this.inverseDictionaries[AttributeTypeInternal.INSENSITIVE]=this.inputStatic.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.SENSITIVE]=this.inputAnalyzed.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=this.outputGeneralized.getDictionary();
  this.inverseDictionaries[AttributeTypeInternal.IDENTIFYING]=null;
  this.inverseDictionaries[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=this.outputMicroaggregated.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}",0.8565264293419633
108130,"/** 
 * Releases all resources.
 */
protected void doRelease(){
  result.releaseBuffer(this);
  node=null;
  dataIS=null;
  dataGH=null;
  dataDI=null;
  dataOT=null;
  inverseData=null;
  inverseDictionaries=null;
  inverseMap=null;
  registry=null;
  subset=null;
  dataTypes=null;
  definition=null;
  header=null;
  statistics=null;
  node=null;
}","/** 
 * Releases all resources.
 */
protected void doRelease(){
  result.releaseBuffer(this);
  node=null;
  inputStatic=null;
  outputGeneralized=null;
  inputAnalyzed=null;
  outputMicroaggregated=null;
  inverseData=null;
  inverseDictionaries=null;
  inverseMap=null;
  registry=null;
  subset=null;
  dataTypes=null;
  definition=null;
  header=null;
  statistics=null;
  node=null;
}",0.8162162162162162
108131,"/** 
 * Swap internal.
 * @param row1 the row1
 * @param row2 the row2
 */
protected void internalSwap(final int row1,final int row2){
  int[] temp=dataGH.getArray()[row1];
  dataGH.getArray()[row1]=dataGH.getArray()[row2];
  dataGH.getArray()[row2]=temp;
  temp=dataOT.getArray()[row1];
  dataOT.getArray()[row1]=dataOT.getArray()[row2];
  dataOT.getArray()[row2]=temp;
}","/** 
 * Swap internal.
 * @param row1 the row1
 * @param row2 the row2
 */
protected void internalSwap(final int row1,final int row2){
  int[] temp=outputGeneralized.getArray()[row1];
  outputGeneralized.getArray()[row1]=outputGeneralized.getArray()[row2];
  outputGeneralized.getArray()[row2]=temp;
  if (outputMicroaggregated.getArray().length != 0) {
    temp=outputMicroaggregated.getArray()[row1];
    outputMicroaggregated.getArray()[row1]=outputMicroaggregated.getArray()[row2];
    outputMicroaggregated.getArray()[row2]=temp;
  }
}",0.6403508771929824
108132,"/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[dataIS.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[dataDI.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=new DataType[dataGH.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=new DataType[dataOT.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFYING]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=dataIS.getHeader();
    break;
case AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED:
  header=dataGH.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=dataDI.getHeader();
break;
case AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED:
header=dataOT.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED && node.getTransformation()[j] > 0) || (i == AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED && !definition.getMicroAggregationFunction(header[j]).isTypePreserving())) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
return dataTypes;
}","/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[inputStatic.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[inputAnalyzed.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED]=new DataType[outputGeneralized.getHeader().length];
  dataTypes[AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED]=new DataType[outputMicroaggregated.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFYING]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=inputStatic.getHeader();
    break;
case AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED:
  header=outputGeneralized.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=inputAnalyzed.getHeader();
break;
case AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED:
header=outputMicroaggregated.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.QUASI_IDENTIFYING_GENERALIZED && node.getTransformation()[j] > 0) || (i == AttributeTypeInternal.QUASI_IDENTIFYING_MICROAGGREGATED && !definition.getMicroAggregationFunction(header[j]).isTypePreserving())) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
return dataTypes;
}",0.9407894736842104
108133,"/** 
 * Gets the value.
 * @param row the row
 * @param col the col
 * @return the value
 */
@Override public String getValue(final int row,final int col){
  checkRegistry();
  checkColumn(col);
  checkRow(row,dataGH.getDataLength());
  return internalGetValue(row,col);
}","/** 
 * Gets the value.
 * @param row the row
 * @param col the col
 * @return the value
 */
@Override public String getValue(final int row,final int col){
  checkRegistry();
  checkColumn(col);
  checkRow(row,outputGeneralized.getDataLength());
  return internalGetValue(row,col);
}",0.8324324324324325
108134,"/** 
 * Returns whether the given row is an outlier.
 * @param row
 * @return
 */
protected boolean internalIsOutlier(final int row){
  return ((dataGH.getArray()[row][0] & Data.OUTLIER_MASK) != 0);
}","/** 
 * Returns whether the given row is an outlier.
 * @param row
 * @return
 */
protected boolean internalIsOutlier(final int row){
  return ((outputGeneralized.getArray()[row][0] & Data.OUTLIER_MASK) != 0);
}",0.948905109489051
108135,"/** 
 * Gets the value internal.
 * @param row the row
 * @param col the col
 * @return the value internal
 */
@Override protected String internalGetValue(final int row,final int col){
  final int key=col * 2;
  final int type=inverseMap[key];
switch (type) {
case AttributeTypeInternal.IDENTIFYING:
    return suppressionString;
default :
  final int index=inverseMap[key + 1];
final int[][] data=inverseData[type];
if ((suppressedAttributeTypes & (1 << type)) != 0 && ((dataGH.getArray()[row][0] & Data.OUTLIER_MASK) != 0)) {
return suppressionString;
}
final int value=data[row][index] & Data.REMOVE_OUTLIER_MASK;
final String[][] dictionary=inverseDictionaries[type].getMapping();
return dictionary[index][value];
}
}","/** 
 * Gets the value internal.
 * @param row the row
 * @param col the col
 * @return the value internal
 */
@Override protected String internalGetValue(final int row,final int col){
  final int key=col * 2;
  final int type=inverseMap[key];
switch (type) {
case AttributeTypeInternal.IDENTIFYING:
    return suppressionString;
default :
  final int index=inverseMap[key + 1];
final int[][] data=inverseData[type];
if ((suppressedAttributeTypes & (1 << type)) != 0 && ((outputGeneralized.getArray()[row][0] & Data.OUTLIER_MASK) != 0)) {
return suppressionString;
}
final int value=data[row][index] & Data.REMOVE_OUTLIER_MASK;
final String[][] dictionary=inverseDictionaries[type].getMapping();
return dictionary[index][value];
}
}",0.9855471438403304
108136,"/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
        definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
      }
 else {
        definition.setHierarchy(attr,(HierarchyBuilder<?>)null);
      }
      definition.setMicroAggregationFunction(attr,null);
      Hierarchy hierarchy=config.getHierarchy(attr);
      if (hierarchy != null && hierarchy.getHierarchy() != null) {
        definition.setHierarchy(attr,hierarchy);
      }
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min == null) {
        min=0;
      }
      if (max == null) {
        if (hierarchy.getHierarchy().length == 0) {
          max=0;
        }
 else {
          max=hierarchy.getHierarchy()[0].length - 1;
        }
      }
      definition.setAttributeType(attr,hierarchy);
      definition.setMinimumGeneralization(attr,min);
      definition.setMaximumGeneralization(attr,max);
    }
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    definition.resetAttributeType(attr);
    definition.resetHierarchy(attr);
    definition.resetHierarchyBuilder(attr);
    definition.resetMaximumGeneralization(attr);
    definition.resetMicroAggregationFunction(attr);
    definition.resetMinimumGeneralization(attr);
    if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
      definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
    }
 else {
      definition.setHierarchy(attr,(HierarchyBuilder<?>)null);
    }
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy != null && hierarchy.getHierarchy() != null) {
      definition.setHierarchy(attr,hierarchy);
    }
    definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      definition.setMicroAggregationFunction(attr,null);
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min != null) {
        definition.setMinimumGeneralization(attr,min);
      }
      if (max != null) {
        definition.setMaximumGeneralization(attr,max);
      }
    }
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.2913304972861962
108137,"/** 
 * Returns the node backing the last returned snapshot.
 * @return
 */
public int[] getTransformation(){
  return resultMetadata.transformation;
}","/** 
 * Returns the node backing the last returned snapshot.
 * @return
 */
public int[] getTransformation(){
  if (resultMetadata == null) {
    return null;
  }
 else {
    return resultMetadata.transformation;
  }
}",0.7804878048780488
108138,"/** 
 * Lists all available microaggregation functions
 * @return
 */
public static List<MicroAggregationFunctionDescription> listMicroAggregationFunctions(){
  return Arrays.asList(new MicroAggregationFunctionDescription[]{new MicroAggregationFunctionDescription(DataScale.INTERVAL,""String_Node_Str""){
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createArithmeticMean(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.INTERVAL,""String_Node_Str""){
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createGeometricMean(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.ORDINAL,""String_Node_Str""){
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createMedian(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.ORDINAL,""String_Node_Str""){
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createMode(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.NOMINAL,""String_Node_Str""){
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createGeneralization(ignoreMissingData);
    }
  }
});
}","/** 
 * Lists all available microaggregation functions
 * @return
 */
public static List<MicroAggregationFunctionDescription> listMicroAggregationFunctions(){
  return Arrays.asList(new MicroAggregationFunctionDescription[]{new MicroAggregationFunctionDescription(DataScale.INTERVAL,""String_Node_Str""){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=1L;
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createArithmeticMean(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.INTERVAL,""String_Node_Str""){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=1L;
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createGeometricMean(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.ORDINAL,""String_Node_Str""){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=1L;
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createMedian(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.ORDINAL,""String_Node_Str""){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=1L;
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createMode(ignoreMissingData);
    }
  }
,new MicroAggregationFunctionDescription(DataScale.NOMINAL,""String_Node_Str""){
    /** 
 * SVUID
 */
    private static final long serialVersionUID=1L;
    @Override public MicroAggregationFunction createInstance(    boolean ignoreMissingData){
      return MicroAggregationFunction.createGeneralization(ignoreMissingData);
    }
  }
});
}",0.8925522519870474
108139,"/** 
 * Returns the value at
 * @param values
 * @param frequencies
 * @param index
 * @return
 */
private <T>T getValueAt(List<T> values,List<Integer> frequencies,int index){
  int pointer=0;
  while (frequencies.get(index) < index) {
    pointer++;
  }
  return values.get(pointer);
}","/** 
 * Returns the value at
 * @param values
 * @param frequencies
 * @param index
 * @return
 */
private <T>T getValueAt(List<T> values,List<Integer> frequencies,int index){
  int pointer=0;
  while (frequencies.get(pointer) < index) {
    pointer++;
  }
  return values.get(pointer);
}",0.9790940766550522
108140,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullNone(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PredictiveProperty binaryAnonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PredictiveProperty linearAnonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyNotAnonymous()) || node.hasProperty(solutionSpace.getPropertyVisited());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return checker.getMetric().isIndependent() && !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !checker.getMetric().isIndependent() && !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,true);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullNone(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PhaseAnonymityProperty binaryAnonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PhaseAnonymityProperty linearAnonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyNotAnonymous()) || node.hasProperty(solutionSpace.getPropertyVisited());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return checker.getMetric().isIndependent() && !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !checker.getMetric().isIndependent() && !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,true);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.9722650231124808
108141,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialNone(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PredictiveProperty binaryAnonymityProperty=solutionSpace.getPropertyKAnonymous();
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyKAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyKAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotKAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PredictiveProperty linearAnonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyVisited()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialNone(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PhaseAnonymityProperty binaryAnonymityProperty=PhaseAnonymityProperty.K_ANONYMITY;
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyKAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyKAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotKAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PhaseAnonymityProperty linearAnonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyVisited()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !node.hasProperty(solutionSpace.getPropertyChecked()) && !node.hasProperty(solutionSpace.getPropertyNotKAnonymous());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.9696969696969696
108142,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PredictiveProperty anonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyAnonymous());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createBinaryPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.NON_ANONYMOUS,false,true);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PhaseAnonymityProperty anonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyAnonymous());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotAnonymous());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createBinaryPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.NON_ANONYMOUS,false,true);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.9776119402985076
108143,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createNoneNone(final SolutionSpace solutionSpace,NodeChecker checker,FLASHStrategy strategy){
  PredictiveProperty anonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerTag=new NodeActionConstant(false);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createLinearPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createNoneNone(final SolutionSpace solutionSpace,NodeChecker checker,FLASHStrategy strategy){
  PhaseAnonymityProperty anonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerTag=new NodeActionConstant(false);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createLinearPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.966867469879518
108144,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createNoneFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PredictiveProperty anonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  NodeAction triggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
      node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
      node.setProperty(solutionSpace.getPropertySuccessorsPruned());
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createLinearPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createNoneFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PhaseAnonymityProperty anonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction triggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction triggerEvaluate=new NodeActionConstant(false);
  NodeAction triggerCheck=new NodeActionInverse(triggerSkip);
  NodeAction triggerFireEvent=new NodeActionOR(triggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  NodeAction triggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
      node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
      node.setProperty(solutionSpace.getPropertySuccessorsPruned());
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyAnonymous());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createLinearPhaseConfiguration(new FLASHPhaseConfiguration(anonymityProperty,triggerTag,triggerCheck,triggerEvaluate,triggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.9755434782608696
108145,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PredictiveProperty binaryAnonymityProperty=solutionSpace.getPropertyKAnonymous();
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyKAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyKAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotKAnonymous());
      }
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PredictiveProperty linearAnonymityProperty=solutionSpace.getPropertyAnonymous();
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyVisited()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !node.hasProperty(solutionSpace.getPropertyVisited()) && !node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) && !node.hasProperty(solutionSpace.getPropertyInsufficientUtility())&& !node.hasProperty(solutionSpace.getPropertyChecked());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric.
 * @param solutionSpace
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final SolutionSpace solutionSpace,final NodeChecker checker,final FLASHStrategy strategy){
  PhaseAnonymityProperty binaryAnonymityProperty=PhaseAnonymityProperty.K_ANONYMITY;
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      if (node.hasProperty(solutionSpace.getPropertyKAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyKAnonymous());
      }
 else {
        node.setPropertyToNeighbours(solutionSpace.getPropertyNotKAnonymous());
      }
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyKAnonymous()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyAnonymous());
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  PhaseAnonymityProperty linearAnonymityProperty=PhaseAnonymityProperty.ANONYMITY;
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertyVisited()) || node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) || node.hasProperty(solutionSpace.getPropertyInsufficientUtility());
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Transformation node){
      return !node.hasProperty(solutionSpace.getPropertyVisited()) && !node.hasProperty(solutionSpace.getPropertyNotKAnonymous()) && !node.hasProperty(solutionSpace.getPropertyInsufficientUtility())&& !node.hasProperty(solutionSpace.getPropertyChecked());
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Transformation node){
      node.setProperty(solutionSpace.getPropertyVisited());
      if (node.hasProperty(solutionSpace.getPropertyAnonymous())) {
        node.setPropertyToNeighbours(solutionSpace.getPropertyInsufficientUtility());
        node.setPropertyToNeighbours(solutionSpace.getPropertySuccessorsPruned());
        node.setProperty(solutionSpace.getPropertySuccessorsPruned());
      }
    }
    @Override public boolean appliesTo(    Transformation node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Transformation node){
      return node.hasProperty(solutionSpace.getPropertySuccessorsPruned());
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),triggerFireEvent,StorageStrategy.ALL,true,false);
  return new FLASHAlgorithmImpl(solutionSpace,checker,strategy,config);
}",0.9747301587301588
108146,"/** 
 * Checks a path binary.
 * @param path The path
 * @param triggerSkip
 * @param queue
 * @return
 */
private int checkPath(List<Integer> path,NodeAction triggerSkip,PriorityQueue<Integer> queue){
  PredictiveProperty anonymityProperty=config.getBinaryPhaseConfiguration().getAnonymityProperty();
  int low=0;
  int high=path.size() - 1;
  int lastAnonymousIdentifier=-1;
  while (low <= high) {
    final int mid=(low + high) / 2;
    final int identifier=path.get(mid);
    Transformation transformation=solutionSpace.getTransformation(identifier);
    if (!skip(triggerSkip,transformation)) {
      checkAndTag(transformation,config.getBinaryPhaseConfiguration());
      if (!transformation.hasProperty(anonymityProperty)) {
        for (        final int up : getSortedSuccessors(identifier)) {
          if (!skip(triggerSkip,solutionSpace.getTransformation(up))) {
            queue.add(up);
          }
        }
      }
      if (transformation.hasProperty(anonymityProperty)) {
        lastAnonymousIdentifier=identifier;
        high=mid - 1;
      }
 else {
        low=mid + 1;
      }
    }
 else {
      high=mid - 1;
    }
  }
  return lastAnonymousIdentifier;
}","/** 
 * Checks a path binary.
 * @param path The path
 * @param triggerSkip
 * @param queue
 * @return
 */
private int checkPath(List<Integer> path,NodeAction triggerSkip,PriorityQueue<Integer> queue){
  PredictiveProperty anonymityProperty=config.getBinaryPhaseConfiguration().getAnonymityProperty() == PhaseAnonymityProperty.ANONYMITY ? solutionSpace.getPropertyAnonymous() : solutionSpace.getPropertyKAnonymous();
  int low=0;
  int high=path.size() - 1;
  int lastAnonymousIdentifier=-1;
  while (low <= high) {
    final int mid=(low + high) / 2;
    final int identifier=path.get(mid);
    Transformation transformation=solutionSpace.getTransformation(identifier);
    if (!skip(triggerSkip,transformation)) {
      checkAndTag(transformation,config.getBinaryPhaseConfiguration());
      if (!transformation.hasProperty(anonymityProperty)) {
        for (        final int up : getSortedSuccessors(identifier)) {
          if (!skip(triggerSkip,solutionSpace.getTransformation(up))) {
            queue.add(up);
          }
        }
      }
      if (transformation.hasProperty(anonymityProperty)) {
        lastAnonymousIdentifier=identifier;
        high=mid - 1;
      }
 else {
        low=mid + 1;
      }
    }
 else {
      high=mid - 1;
    }
  }
  return lastAnonymousIdentifier;
}",0.9536103267446552
108147,"/** 
 * Creates a configuration for an active phase.
 * @param anonymityProperty
 * @param triggerTag
 * @param triggerCheck
 * @param triggerEvaluate
 * @param triggerSkip
 */
public FLASHPhaseConfiguration(PredictiveProperty anonymityProperty,NodeAction triggerTag,NodeAction triggerCheck,NodeAction triggerEvaluate,NodeAction triggerSkip){
  this.anonymityProperty=anonymityProperty;
  this.triggerTag=triggerTag;
  this.triggerCheck=triggerCheck;
  this.triggerEvaluate=triggerEvaluate;
  this.triggerSkip=triggerSkip;
}","/** 
 * Creates a configuration for an active phase.
 * @param anonymityProperty
 * @param triggerTag
 * @param triggerCheck
 * @param triggerEvaluate
 * @param triggerSkip
 */
public FLASHPhaseConfiguration(PhaseAnonymityProperty anonymityProperty,NodeAction triggerTag,NodeAction triggerCheck,NodeAction triggerEvaluate,NodeAction triggerSkip){
  this.anonymityProperty=anonymityProperty;
  this.triggerTag=triggerTag;
  this.triggerCheck=triggerCheck;
  this.triggerEvaluate=triggerEvaluate;
  this.triggerSkip=triggerSkip;
}",0.9790874524714828
108148,"/** 
 * Getter: The main anonymity property.
 * @return
 */
public PredictiveProperty getAnonymityProperty(){
  return anonymityProperty;
}","/** 
 * Getter: The main anonymity property.
 * @return
 */
public PhaseAnonymityProperty getAnonymityProperty(){
  return anonymityProperty;
}",0.9432624113475178
108149,"/** 
 * Implements the FLASH algorithm (without outer loop).
 * @param start
 * @param queue
 */
private void binarySearch(int start,PriorityQueue<Integer> queue){
  NodeAction triggerSkip=config.getBinaryPhaseConfiguration().getTriggerSkip();
  queue.add(start);
  while (!queue.isEmpty()) {
    Integer head=queue.poll();
    if (!skip(triggerSkip,solutionSpace.getTransformation(head))) {
      List<Integer> path=findPath(head,triggerSkip);
      head=checkPath(path,triggerSkip,queue);
      if (config.isLinearPhaseRequired() && (head != null)) {
        linearSearch(head);
      }
    }
  }
}","/** 
 * Implements the FLASH algorithm (without outer loop).
 * @param start
 * @param queue
 */
private void binarySearch(int start,PriorityQueue<Integer> queue){
  NodeAction triggerSkip=config.getBinaryPhaseConfiguration().getTriggerSkip();
  queue.add(start);
  while (!queue.isEmpty()) {
    Integer head=queue.poll();
    if (!skip(triggerSkip,solutionSpace.getTransformation(head))) {
      List<Integer> path=findPath(head,triggerSkip);
      head=checkPath(path,triggerSkip,queue);
      if (config.isLinearPhaseRequired() && (head != -1)) {
        linearSearch(head);
      }
    }
  }
}",0.994991652754591
108150,"/** 
 * Sets the property to all neighbors
 * @param property
 */
public void setPropertyToNeighbours(PredictiveProperty property){
  Iterator<int[]> neighbors;
  if (property.getDirection() == Direction.UP) {
    neighbors=lattice.nodes().listSuccessors(transformationJHPL);
  }
 else   if (property.getDirection() == Direction.DOWN) {
    neighbors=lattice.nodes().listPredecessors(transformationJHPL);
  }
 else {
    return;
  }
  for (; neighbors.hasNext(); ) {
    lattice.putProperty(neighbors.next(),property);
  }
}","/** 
 * Sets the property to all neighbors
 * @param property
 */
public void setPropertyToNeighbours(PredictiveProperty property){
  Iterator<Long> neighbors;
  if (property.getDirection() == Direction.UP) {
    neighbors=lattice.space().indexIteratorToIdIterator(lattice.nodes().listSuccessors(transformationJHPL));
  }
 else   if (property.getDirection() == Direction.DOWN) {
    neighbors=lattice.space().indexIteratorToIdIterator(lattice.nodes().listPredecessors(transformationJHPL));
  }
 else {
    return;
  }
  LongArrayList list=new LongArrayList();
  for (; neighbors.hasNext(); ) {
    list.add(neighbors.next());
  }
  for (  long id : list.toArray()) {
    lattice.putProperty(lattice.space().toIndex(id),property);
  }
}",0.8038125496425734
108151,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] + 1d) * weights[i],1.0d / (double)values.length);
  }
  return result - 1d;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] * weights[i] + 1d),1.0d / (double)values.length);
  }
  return result - 1d;
}",0.9535714285714286
108152,"/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
        definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
      }
      definition.setMicroAggregationFunction(attr,null);
      Hierarchy hierarchy=config.getHierarchy(attr);
      if (hierarchy != null && hierarchy.getHierarchy() != null) {
        definition.setHierarchy(attr,hierarchy);
      }
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min == null) {
        min=0;
      }
      if (max == null) {
        if (hierarchy.getHierarchy().length == 0) {
          max=0;
        }
 else {
          max=hierarchy.getHierarchy()[0].length - 1;
        }
      }
      definition.setAttributeType(attr,hierarchy);
      definition.setMinimumGeneralization(attr,min);
      definition.setMaximumGeneralization(attr,max);
    }
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","/** 
 * Creates an ARXConfiguration.
 */
public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  config.setMetric(this.getMetricDescription().createInstance(this.getMetricConfiguration()));
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    if (config.getTransformationMode(attr) == ModelTransformationMode.MICRO_AGGREGATION) {
      MicroAggregationFunction function=config.getMicroAggregationFunction(attr).createInstance(config.getMicroAggregationIgnoreMissingData(attr));
      definition.setAttributeType(attr,AttributeType.QUASI_IDENTIFYING_ATTRIBUTE);
      definition.setMicroAggregationFunction(attr,function);
    }
 else {
      if (this.getUseFunctionalHierarchies() && config.getHierarchyBuilder(attr) != null) {
        definition.setHierarchy(attr,config.getHierarchyBuilder(attr));
      }
 else {
        definition.setHierarchy(attr,(HierarchyBuilder<?>)null);
      }
      definition.setMicroAggregationFunction(attr,null);
      Hierarchy hierarchy=config.getHierarchy(attr);
      if (hierarchy != null && hierarchy.getHierarchy() != null) {
        definition.setHierarchy(attr,hierarchy);
      }
      Integer min=config.getMinimumGeneralization(attr);
      Integer max=config.getMaximumGeneralization(attr);
      if (min == null) {
        min=0;
      }
      if (max == null) {
        if (hierarchy.getHierarchy().length == 0) {
          max=0;
        }
 else {
          max=hierarchy.getHierarchy()[0].length - 1;
        }
      }
      definition.setAttributeType(attr,hierarchy);
      definition.setMinimumGeneralization(attr,min);
      definition.setMaximumGeneralization(attr,max);
    }
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  for (  ModelRiskBasedCriterion entry : this.riskBasedModel) {
    if (entry != null && entry.isEnabled()) {
      PrivacyCriterion criterion=entry.getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (config.getInput() != null && config.getResearchSubset() != null && config.getResearchSubset().size() != config.getInput().getHandle().getNumRows()) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9879050321039272
108153,"/** 
 * Returns the attributes for which generlaization is specified.
 * @return
 */
public Set<String> getGeneralizationAttributes(){
  final Set<String> result=new HashSet<String>();
  for (  final Entry<String,AttributeType> entry : attributeTypes.entrySet()) {
    if (entry.getValue().getType() == AttributeType.ATTR_TYPE_QI && entry.getValue() instanceof Hierarchy) {
      result.add(entry.getKey());
    }
  }
  return result;
}","/** 
 * Returns the attributes for which generlaization is specified.
 * @return
 */
public Set<String> getGeneralizationAttributes(){
  final Set<String> result=new HashSet<String>();
  for (  final Entry<String,AttributeType> entry : attributeTypes.entrySet()) {
    if (entry.getValue().getType() == AttributeType.ATTR_TYPE_QI && !(entry.getValue() instanceof Microaggregation)) {
      result.add(entry.getKey());
    }
  }
  return result;
}",0.9705215419501134
108154,"@Override public void microaggregate(final int[][] data,final Data bufferOT,final int startMA,final int numMA,final MicroaggregateFunction[] functions){
  Map<Distribution,Integer> cache=new HashMap<Distribution,Integer>();
  for (int row=0; row < data.length; row++) {
    if (subset == null || subset.contains(row)) {
      final int[] key=data[row];
      final int hash=HashTableUtil.hashcode(key);
      final int index=hash & (buckets.length - 1);
      HashGroupifyEntry m=buckets[index];
      while ((m != null) && ((m.hashcode != hash) || !equalsIgnoringOutliers(key,m.key))) {
        m=m.next;
      }
      if (m == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      Distribution[] dis=m.distributions;
      int cnt=0;
      for (int i=startMA; i < numMA; i++) {
        if (!cache.containsKey(dis[i])) {
          String result=functions[cnt].aggregate(dis[i]);
          int code=bufferOT.getDictionary().register(cnt,result);
          cache.put(dis[i],code);
        }
        bufferOT.getArray()[row][cnt]=cache.get(dis[i]);
        cnt++;
      }
    }
  }
  bufferOT.getDictionary().finalizeAll();
}","@Override public void microaggregate(final int[][] data,final Data bufferOT,final int startMA,final int numMA,final MicroaggregateFunction[] functions){
  Map<Distribution,Integer> cache=new HashMap<Distribution,Integer>();
  for (int row=0; row < data.length; row++) {
    if (subset == null || subset.contains(row)) {
      final int[] key=data[row];
      final int hash=HashTableUtil.hashcode(key);
      final int index=hash & (buckets.length - 1);
      HashGroupifyEntry m=buckets[index];
      while ((m != null) && ((m.hashcode != hash) || !equalsIgnoringOutliers(key,m.key))) {
        m=m.next;
      }
      if (m == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      Distribution[] dis=m.distributions;
      int cnt=0;
      for (int i=startMA; i < startMA + numMA; i++) {
        if (!cache.containsKey(dis[i])) {
          String result=functions[cnt].aggregate(dis[i]);
          int code=bufferOT.getDictionary().register(cnt,result);
          cache.put(dis[i],code);
        }
        bufferOT.getArray()[row][cnt]=cache.get(dis[i]);
        cnt++;
      }
    }
  }
  bufferOT.getDictionary().finalizeAll();
}",0.9956559513466552
108155,"/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[dataIS.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[dataDI.getHeader().length];
  dataTypes[AttributeTypeInternal.GENERALIZATION]=new DataType[dataGH.getHeader().length];
  dataTypes[AttributeTypeInternal.MICROAGGREGATION]=new DataType[dataOT.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFIER]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=dataIS.getHeader();
    break;
case AttributeTypeInternal.GENERALIZATION:
  header=dataGH.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=dataDI.getHeader();
break;
case AttributeTypeInternal.MICROAGGREGATION:
header=dataOT.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
if (dataTypes[i][j] != null) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.GENERALIZATION) && (node.getTransformation()[j] > 0)) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
}
return dataTypes;
}","/** 
 * Creates the data type array.
 * @return
 */
@Override protected DataType<?>[][] getDataTypeArray(){
  DataType<?>[][] dataTypes=new DataType[5][];
  dataTypes[AttributeTypeInternal.INSENSITIVE]=new DataType[dataIS.getHeader().length];
  dataTypes[AttributeTypeInternal.SENSITIVE]=new DataType[dataDI.getHeader().length];
  dataTypes[AttributeTypeInternal.GENERALIZATION]=new DataType[dataGH.getHeader().length];
  dataTypes[AttributeTypeInternal.MICROAGGREGATION]=new DataType[dataOT.getHeader().length];
  dataTypes[AttributeTypeInternal.IDENTIFIER]=null;
  for (int i=0; i < dataTypes.length; i++) {
    final DataType<?>[] type=dataTypes[i];
    String[] header=null;
switch (i) {
case AttributeTypeInternal.INSENSITIVE:
      header=dataIS.getHeader();
    break;
case AttributeTypeInternal.GENERALIZATION:
  header=dataGH.getHeader();
break;
case AttributeTypeInternal.SENSITIVE:
header=dataDI.getHeader();
break;
case AttributeTypeInternal.MICROAGGREGATION:
header=dataOT.getHeader();
break;
}
if (type != null) {
for (int j=0; j < type.length; j++) {
dataTypes[i][j]=definition.getDataType(header[j]);
if ((i == AttributeTypeInternal.GENERALIZATION) && (node.getTransformation()[j] > 0)) {
dataTypes[i][j]=DataType.STRING;
}
}
}
}
return dataTypes;
}",0.9730784237222004
108156,"/** 
 * Updates the valid functions based on the datatype.
 */
private void updateValidFunctions(){
  List<MicroaggregationFunctionDescription> functions=MicroaggregateFunction.list();
  List<String> items=new ArrayList<String>();
  List<MicroaggregationFunctionDescription> validFunctions=new ArrayList<MicroaggregationFunctionDescription>();
  for (int i=0; i < functions.size(); i++) {
    MicroaggregationFunctionDescription function=functions.get(i);
    if (function.getRequiredScaleOfMeasure().compareTo(model.getInputDefinition().getDataType(attribute).getScaleOfMeasure()) <= 0) {
      items.add(function.getLabel());
      validFunctions.add(function);
    }
  }
  this.validFunctions=validFunctions.toArray(new MicroaggregationFunctionDescription[validFunctions.size()]);
  if (items.size() > 0) {
    functionCombo.setItems(items.toArray(new String[items.size()]));
    functionCombo.setEnabled(true);
    selectfunction(0);
    microaggregationButton.setEnabled(true);
  }
 else {
    functionCombo.setItems(new String[]{""String_Node_Str""});
    functionCombo.setEnabled(false);
    functionCombo.select(0);
    microaggregationButton.setEnabled(false);
  }
}","/** 
 * Updates the valid functions based on the datatype.
 */
private void updateValidFunctions(){
  List<MicroaggregationFunctionDescription> functions=MicroaggregateFunction.list();
  List<String> items=new ArrayList<String>();
  List<MicroaggregationFunctionDescription> validFunctions=new ArrayList<MicroaggregationFunctionDescription>();
  for (int i=0; i < functions.size(); i++) {
    MicroaggregationFunctionDescription function=functions.get(i);
    if (function.getRequiredScaleOfMeasure().compareTo(model.getInputDefinition().getDataType(attribute).getScaleOfMeasure()) <= 0) {
      items.add(function.getLabel());
      validFunctions.add(function);
    }
  }
  this.validFunctions=validFunctions.toArray(new MicroaggregationFunctionDescription[validFunctions.size()]);
  if (items.size() > 0) {
    functionCombo.setItems(items.toArray(new String[items.size()]));
    functionCombo.setEnabled(true);
    restoreStoredFunction();
    microaggregationButton.setEnabled(true);
  }
 else {
    functionCombo.setItems(new String[]{""String_Node_Str""});
    functionCombo.setEnabled(false);
    functionCombo.select(0);
    microaggregationButton.setEnabled(false);
  }
}",0.983843537414966
108157,"@Override public void update(ModelEvent event){
  if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    final String attr=(String)event.data;
    if (attr.equals(attribute)) {
      updateValidFunctions();
      if (model != null && model.getInputConfig() != null) {
        MicroaggregationFunctionDescription restoredFunction=model.getInputConfig().getMicroaggregationFunctionDescription(attribute);
        for (int i=0; i < validFunctions.length; i++) {
          MicroaggregationFunctionDescription function=validFunctions[i];
          if (function.equals(restoredFunction)) {
            selectfunction(i);
            break;
          }
        }
      }
    }
  }
 else   if (event.part == ModelPart.DATA_TYPE) {
    updateValidFunctions();
  }
}","@Override public void update(ModelEvent event){
  if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    final String attr=(String)event.data;
    if (attr.equals(attribute)) {
      updateValidFunctions();
      restoreStoredFunction();
    }
  }
 else   if (event.part == ModelPart.DATA_TYPE) {
    updateValidFunctions();
  }
}",0.5650557620817844
108158,"/** 
 * Returns a table. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static Table createTable(Composite parent,int style){
  return new Table(parent,getTableStyle(style));
}","/** 
 * Returns a table. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static Table createTable(Composite parent,int style){
  Table table=new Table(parent,style);
  fixOSXTableBug(table);
  return table;
}",0.8378947368421052
108159,"@Override public void widgetSelected(SelectionEvent arg0){
  controller.actionShowHelpDialog(id);
}","@Override public void widgetSelected(SelectionEvent arg0){
  table.redraw();
}",0.8135593220338984
108160,"/** 
 * Returns a checkbox table viewer. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static CheckboxTableViewer createTableViewerCheckbox(Composite container,int style){
  return CheckboxTableViewer.newCheckList(container,getTableStyle(style));
}","/** 
 * Returns a checkbox table viewer. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static CheckboxTableViewer createTableViewerCheckbox(Composite container,int style){
  CheckboxTableViewer viewer=CheckboxTableViewer.newCheckList(container,style);
  fixOSXTableBug(viewer.getTable());
  return viewer;
}",0.8351309707241911
108161,"/** 
 * Returns a table viewer. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static TableViewer createTableViewer(Composite container,int style){
  return new TableViewer(container,getTableStyle(style));
}","/** 
 * Returns a table viewer. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static TableViewer createTableViewer(Composite container,int style){
  TableViewer viewer=new TableViewer(container,style);
  fixOSXTableBug(viewer.getTable());
  return viewer;
}",0.8078994614003591
108162,"/** 
 * Returns a dynamic table. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static DynamicTable createTableDynamic(Composite parent,int style){
  return new DynamicTable(parent,getTableStyle(style));
}","/** 
 * Returns a dynamic table. Implements hacks for fixing OSX bugs.
 * @param parent
 * @param style
 * @return
 */
public static DynamicTable createTableDynamic(Composite parent,int style){
  DynamicTable table=new DynamicTable(parent,style);
  fixOSXTableBug(table);
  return table;
}",0.8296296296296296
108163,"@Override protected DataHandle getHandle(){
  if (model != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      handle=handle.getView();
    }
    return handle;
  }
 else {
    return null;
  }
}","@Override protected DataHandle getHandle(){
  if (model != null) {
    Data data=model.getInputConfig().getInput();
    if (data == null) {
      return null;
    }
    DataHandle handle=data.getHandle();
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      handle=handle.getView();
    }
    return handle;
  }
 else {
    return null;
  }
}",0.8253557567917206
108164,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewProperties(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  groupNodeGridLayout.numColumns=1;
  root.setLayout(groupNodeGridLayout);
  table=SWTUtil.createTable(parent,SWT.BORDER);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  final GridData gdata=SWTUtil.createFillGridData();
  table.setLayoutData(gdata);
  table.setMenu(new ClipboardHandlerTable(table).getMenu());
  TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  SWTUtil.createGenericTooltip(table);
  for (  final TableColumn col : table.getColumns()) {
    col.pack();
  }
  reset();
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewProperties(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  groupNodeGridLayout.numColumns=1;
  root.setLayout(groupNodeGridLayout);
  table=SWTUtil.createTable(root,SWT.BORDER);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  final GridData gdata=SWTUtil.createFillGridData();
  table.setLayoutData(gdata);
  table.setMenu(new ClipboardHandlerTable(table).getMenu());
  TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  SWTUtil.createGenericTooltip(table);
  for (  final TableColumn col : table.getColumns()) {
    col.pack();
  }
  reset();
}",0.9968152866242038
108165,"/** 
 * Returns a list of matching data types
 * @param column
 */
public List<Pair<DataType<?>,Double>> getMatchingDataTypes(ImportWizardModelColumn column){
  if (wizardColumns.indexOf(column) == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Data data=Data.create(getPreviewData());
  int columnIndex=((ImportColumnIndexed)column.getColumn()).getIndex();
  return data.getHandle().getMatchingDataTypes(columnIndex,locale,Math.ulp(0d));
}","/** 
 * Returns a list of matching data types
 * @param column
 */
public List<Pair<DataType<?>,Double>> getMatchingDataTypes(ImportWizardModelColumn column){
  if (wizardColumns.indexOf(column) == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Data data=Data.create(getPreviewData());
  int columnIndex=-1;
  ImportColumn c=column.getColumn();
  if (c instanceof ImportColumnIndexed) {
    columnIndex=((ImportColumnIndexed)column.getColumn()).getIndex();
  }
 else   if (column.getColumn() instanceof ImportColumnJDBC) {
    columnIndex=((ImportColumnJDBC)column.getColumn()).getIndex();
  }
  return data.getHandle().getMatchingDataTypes(columnIndex,locale,Math.ulp(0d));
}",0.7079037800687286
108166,"/** 
 * Returns the master function including the object function and the derivative functions
 * @return
 */
private Function<Vector2D,Pair<Vector2D,SquareMatrix2D>> getFunctionsClosed(final int[] classes,final double u,final double n){
  return new Function<Vector2D,Pair<Vector2D,SquareMatrix2D>>(){
    public Pair<Vector2D,SquareMatrix2D> evaluate(    Vector2D input){
      Vector2D object=new Vector2D();
      SquareMatrix2D derivatives=new SquareMatrix2D();
      double t=input.x;
      double a=input.y;
      double val0=u - 1d;
      double val1=Gamma.digamma(val0 + (t / a) + 1d);
      double val2=Gamma.trigamma((a + t + (a * val0)) / a);
      double val3=Gamma.trigamma((t / a) + 1d);
      double val4=Gamma.digamma((t / a) + 1);
      double val5=a * a;
      double d1=(val3 - val2) / (val5);
      double d2=(((a * val1) + (t * val2)) - (a * val4) - (t * val3)) / (val5 * a);
      double d3=(((((val5 * val0) - (t * t * val2)) + (t * t * val3)) - (2 * a * t* val1)) + (2 * a * t* val4)) / (val5 * val5);
      double o2=(val1 - val4) / a;
      double o3=((-t * val1) + (a * val0) + (t * val4)) / (a * a);
      double o4=Gamma.digamma(n + t) - Gamma.digamma(t + 1d);
      checkInterrupt();
      double d4=0;
      double d5=0;
      double o1=0;
      double val6=Gamma.digamma(1d - a);
      double val7=Gamma.trigamma(1d - a);
      for (int i=0; i < classes.length; i+=2) {
        int key=classes[i];
        int value=classes[i + 1];
        double val8=t + key;
        d4+=1d / (val8 * val8);
        d5+=key != 1 ? value * (val7 - Gamma.trigamma(key - a)) : 0;
        o1+=key == 1 ? 0 : value * (Gamma.digamma(key - a) - val6);
        checkInterrupt();
      }
      derivatives.x1=d4 - d1;
      derivatives.x2=0 - d2;
      derivatives.y1=0 - d2;
      derivatives.y2=0 - d3 - d5;
      object.x=o2 - o4;
      object.y=o3 - o1;
      return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
    }
  }
;
}","/** 
 * Returns the master function including the object function and the derivative functions
 * @return
 */
private Function<Vector2D,Pair<Vector2D,SquareMatrix2D>> getFunctionsClosed(final int[] classes,final double u,final double n){
  return new Function<Vector2D,Pair<Vector2D,SquareMatrix2D>>(){
    public Pair<Vector2D,SquareMatrix2D> evaluate(    Vector2D input){
      Vector2D object=new Vector2D();
      SquareMatrix2D derivatives=new SquareMatrix2D();
      double t=input.x;
      double a=input.y;
      double val0=u - 1d;
      double val1=Gamma.digamma(val0 + (t / a) + 1d);
      double val2=Gamma.trigamma((a + t + (a * val0)) / a);
      double val3=Gamma.trigamma((t / a) + 1d);
      double val4=Gamma.digamma((t / a) + 1d);
      double val5=a * a;
      double d1=(val3 - val2) / (val5);
      double d5=(((a * val1) + (t * val2)) - (a * val4) - (t * val3)) / (val5 * a);
      double d3=(((((val5 * val0) - (t * t * val2)) + (t * t * val3)) - (2d * a * t* val1)) + (2d * a * t* val4)) / (val5 * val5);
      double o1=(val1 - val4) / a;
      double o3=((-t * val1) + (a * val0) + (t * val4)) / (a * a);
      double o2=Gamma.digamma(n + t) - Gamma.digamma(t + 1d);
      checkInterrupt();
      double d2=Gamma.trigamma(t + 1d) - Gamma.trigamma(n + t);
      double d4=0;
      double o4=0;
      double val6=Gamma.digamma(1d - a);
      double val7=Gamma.trigamma(1d - a);
      for (int i=0; i < classes.length; i+=2) {
        int key=classes[i];
        int value=classes[i + 1];
        if (key != 1) {
          d4+=value * (val7 - Gamma.trigamma(key - a));
          o4+=value * (Gamma.digamma(key - a) - val6);
        }
        checkInterrupt();
      }
      derivatives.x1=d2 - d1;
      derivatives.x2=0d - d5;
      derivatives.y1=0d - d5;
      derivatives.y2=0d - d3 - d4;
      object.x=o1 - o2;
      object.y=o3 - o4;
      return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
    }
  }
;
}",0.7467899332306112
108167,"/** 
 * Returns the master function including the object function and the derivative functions
 * @return
 */
private Function<Vector2D,Pair<Vector2D,SquareMatrix2D>> getFunctionsIterative(final int[] classes,final double u,final double n){
  return new Function<Vector2D,Pair<Vector2D,SquareMatrix2D>>(){
    public Pair<Vector2D,SquareMatrix2D> evaluate(    Vector2D input){
      Vector2D object=new Vector2D();
      SquareMatrix2D derivatives=new SquareMatrix2D();
      double t=input.x;
      double a=input.y;
      double d1=0;
      double d2=0;
      double d3=0;
      double d4=0;
      double d5=0;
      double o1=0;
      double o2=0;
      double o3=0;
      double o4=0;
      for (int i=1; i < u; i++) {
        double val0=(t + (i * a));
        double val1=1d / val0;
        double val2=i * val1;
        double val3=1d / (val0 * val0);
        double val4=i * val3;
        double val5=i * val4;
        d1+=val3;
        d5+=val4;
        d3+=val5;
        o1+=val1;
        o3+=val2;
      }
      checkInterrupt();
      for (int i=0; i < classes.length; i+=2) {
        int key=classes[i];
        int value=classes[i + 1];
        double val0=t + key;
        d2+=1d / (val0 * val0);
        if (key != 1) {
          double val1=0;
          double val2=0;
          for (int j=1; j < key; j++) {
            double val3=j - a;
            val1+=1d / (val3 * val3);
            val2+=1d / val3;
          }
          d4+=value * val1;
          o4+=value * val2;
        }
        checkInterrupt();
      }
      checkInterrupt();
      for (int i=1; i < n; i++) {
        o2+=1d / (t + i);
      }
      object.x=o1 - o2;
      object.y=o3 - o4;
      derivatives.x1=d2 - d1;
      derivatives.x2=0 - d5;
      derivatives.y1=0 - d5;
      derivatives.y2=0 - d3 - d4;
      return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
    }
  }
;
}","/** 
 * Returns the master function including the object function and the derivative functions
 * @return
 */
private Function<Vector2D,Pair<Vector2D,SquareMatrix2D>> getFunctionsIterative(final int[] classes,final double u,final double n){
  return new Function<Vector2D,Pair<Vector2D,SquareMatrix2D>>(){
    public Pair<Vector2D,SquareMatrix2D> evaluate(    Vector2D input){
      Vector2D object=new Vector2D();
      SquareMatrix2D derivatives=new SquareMatrix2D();
      double t=input.x;
      double a=input.y;
      double d1=0;
      double d2=0;
      double d3=0;
      double d4=0;
      double d5=0;
      double o1=0;
      double o2=0;
      double o3=0;
      double o4=0;
      for (int i=1; i < u; i++) {
        double val0=(t + (i * a));
        double val1=1d / val0;
        double val2=i * val1;
        double val3=1d / (val0 * val0);
        double val4=i * val3;
        double val5=i * val4;
        d1+=val3;
        d5+=val4;
        d3+=val5;
        o1+=val1;
        o3+=val2;
      }
      checkInterrupt();
      for (int i=0; i < classes.length; i+=2) {
        int key=classes[i];
        int value=classes[i + 1];
        if (key != 1) {
          double val1=0;
          double val2=0;
          for (int j=1; j < key; j++) {
            double val3=j - a;
            val1+=1d / (val3 * val3);
            val2+=1d / val3;
          }
          d4+=value * val1;
          o4+=value * val2;
        }
        checkInterrupt();
      }
      checkInterrupt();
      for (int i=1; i < n; i++) {
        double val0=(t + i);
        d2+=1d / (val0 * val0);
        o2+=1d / val0;
      }
      object.x=o1 - o2;
      object.y=o3 - o4;
      derivatives.x1=d2 - d1;
      derivatives.x2=0d - d5;
      derivatives.y1=0d - d5;
      derivatives.y2=0d - d3 - d4;
      return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
    }
  }
;
}",0.9638105375199574
108168,"public Pair<Vector2D,SquareMatrix2D> evaluate(Vector2D input){
  Vector2D object=new Vector2D();
  SquareMatrix2D derivatives=new SquareMatrix2D();
  double t=input.x;
  double a=input.y;
  double val0=u - 1d;
  double val1=Gamma.digamma(val0 + (t / a) + 1d);
  double val2=Gamma.trigamma((a + t + (a * val0)) / a);
  double val3=Gamma.trigamma((t / a) + 1d);
  double val4=Gamma.digamma((t / a) + 1);
  double val5=a * a;
  double d1=(val3 - val2) / (val5);
  double d2=(((a * val1) + (t * val2)) - (a * val4) - (t * val3)) / (val5 * a);
  double d3=(((((val5 * val0) - (t * t * val2)) + (t * t * val3)) - (2 * a * t* val1)) + (2 * a * t* val4)) / (val5 * val5);
  double o2=(val1 - val4) / a;
  double o3=((-t * val1) + (a * val0) + (t * val4)) / (a * a);
  double o4=Gamma.digamma(n + t) - Gamma.digamma(t + 1d);
  checkInterrupt();
  double d4=0;
  double d5=0;
  double o1=0;
  double val6=Gamma.digamma(1d - a);
  double val7=Gamma.trigamma(1d - a);
  for (int i=0; i < classes.length; i+=2) {
    int key=classes[i];
    int value=classes[i + 1];
    double val8=t + key;
    d4+=1d / (val8 * val8);
    d5+=key != 1 ? value * (val7 - Gamma.trigamma(key - a)) : 0;
    o1+=key == 1 ? 0 : value * (Gamma.digamma(key - a) - val6);
    checkInterrupt();
  }
  derivatives.x1=d4 - d1;
  derivatives.x2=0 - d2;
  derivatives.y1=0 - d2;
  derivatives.y2=0 - d3 - d5;
  object.x=o2 - o4;
  object.y=o3 - o1;
  return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
}","public Pair<Vector2D,SquareMatrix2D> evaluate(Vector2D input){
  Vector2D object=new Vector2D();
  SquareMatrix2D derivatives=new SquareMatrix2D();
  double t=input.x;
  double a=input.y;
  double val0=u - 1d;
  double val1=Gamma.digamma(val0 + (t / a) + 1d);
  double val2=Gamma.trigamma((a + t + (a * val0)) / a);
  double val3=Gamma.trigamma((t / a) + 1d);
  double val4=Gamma.digamma((t / a) + 1d);
  double val5=a * a;
  double d1=(val3 - val2) / (val5);
  double d5=(((a * val1) + (t * val2)) - (a * val4) - (t * val3)) / (val5 * a);
  double d3=(((((val5 * val0) - (t * t * val2)) + (t * t * val3)) - (2d * a * t* val1)) + (2d * a * t* val4)) / (val5 * val5);
  double o1=(val1 - val4) / a;
  double o3=((-t * val1) + (a * val0) + (t * val4)) / (a * a);
  double o2=Gamma.digamma(n + t) - Gamma.digamma(t + 1d);
  checkInterrupt();
  double d2=Gamma.trigamma(t + 1d) - Gamma.trigamma(n + t);
  double d4=0;
  double o4=0;
  double val6=Gamma.digamma(1d - a);
  double val7=Gamma.trigamma(1d - a);
  for (int i=0; i < classes.length; i+=2) {
    int key=classes[i];
    int value=classes[i + 1];
    if (key != 1) {
      d4+=value * (val7 - Gamma.trigamma(key - a));
      o4+=value * (Gamma.digamma(key - a) - val6);
    }
    checkInterrupt();
  }
  derivatives.x1=d2 - d1;
  derivatives.x2=0d - d5;
  derivatives.y1=0d - d5;
  derivatives.y2=0d - d3 - d4;
  object.x=o1 - o2;
  object.y=o3 - o4;
  return new Pair<Vector2D,SquareMatrix2D>(object,derivatives);
}",0.8050271739130435
108169,"/** 
 * Compiles the result of the Newton-Rhapson-Algorithm
 * @return
 */
private double getResult(Vector2D result,double p){
  double t=result.x;
  double a=result.y;
  if (Double.isNaN(a) && Double.isNaN(t) && a == 0) {
    return Double.NaN;
  }
  double val1=Double.NaN;
  try {
    val1=Math.exp(Gamma.logGamma(t + 1) - Gamma.logGamma(t + a)) * Math.pow(p,a);
  }
 catch (  Exception e) {
  }
  val1=val1 >= 0d && val1 <= p ? val1 : Double.NaN;
  double val2=Double.NaN;
  try {
    val2=(Gamma.gamma(t + 1) / Gamma.gamma(t + a)) * Math.pow(p,a);
  }
 catch (  Exception e) {
  }
  val2=val2 >= 0d && val2 <= p ? val2 : Double.NaN;
  if (Double.isNaN(val1) && Double.isNaN(val2)) {
    return Double.NaN;
  }
 else   if (!Double.isNaN(val1) && !Double.isNaN(val2)) {
    return Math.max(val1,val2);
  }
 else   if (Double.isNaN(val1)) {
    return val2;
  }
 else {
    return val1;
  }
}","/** 
 * Compiles the result of the Newton-Rhapson-Algorithm
 * @return
 */
private double getResult(Vector2D result,double p){
  double t=result.x;
  double a=result.y;
  if (Double.isNaN(a) || Double.isNaN(t) || a == 0) {
    return Double.NaN;
  }
  double val1=Double.NaN;
  try {
    val1=Math.exp(Gamma.logGamma(t + 1) - Gamma.logGamma(t + a)) * Math.pow(p,a);
  }
 catch (  Exception e) {
  }
  val1=val1 >= 0d && val1 <= p ? val1 : Double.NaN;
  double val2=Double.NaN;
  try {
    val2=(Gamma.gamma(t + 1) / Gamma.gamma(t + a)) * Math.pow(p,a);
  }
 catch (  Exception e) {
  }
  val2=val2 >= 0d && val2 <= p ? val2 : Double.NaN;
  if (Double.isNaN(val1) && Double.isNaN(val2)) {
    return Double.NaN;
  }
 else   if (!Double.isNaN(val1) && !Double.isNaN(val2)) {
    return Math.max(val1,val2);
  }
 else   if (Double.isNaN(val1)) {
    return val2;
  }
 else {
    return val1;
  }
}",0.976510067114094
108170,"/** 
 * Constructor
 * @param handle
 * @param row
 */
private TupleWrapper(DataHandle handle,int[] indices,int row){
  this.handle=handle;
  this.row=row;
  this.indices=indices;
  int result=1;
  for (  int index : indices) {
    result=31 * result + handle.getValue(row,index).hashCode();
  }
  this.hashCode=result;
}","/** 
 * Constructor
 * @param handle
 * @param row
 */
private TupleWrapper(DataHandle handle,int[] indices,int row){
  this.values=new String[indices.length];
  int hashcode=1;
  int idx=0;
  for (  int index : indices) {
    String value=handle.getValue(row,index);
    hashcode=31 * hashcode + value.hashCode();
    values[idx++]=value;
  }
  this.hashcode=hashcode;
}",0.5057803468208093
108171,"@Override public int hashCode(){
  return hashCode;
}","@Override public int hashCode(){
  return hashcode;
}",0.981132075471698
108172,"@Override public boolean equals(Object obj){
  TupleWrapper other=(TupleWrapper)obj;
  for (int i=0; i < indices.length; i++) {
    if (handle.getValue(this.row,i) != handle.getValue(other.row,i)) {
      return false;
    }
  }
  return true;
}","@Override public boolean equals(Object other){
  return Arrays.equals(((TupleWrapper)other).values,this.values);
}",0.4735376044568245
108173,"@Override public void enforce(final HashGroupifyDistribution distribution,final int numMaxSuppressedOutliers){
  distribution.suppressWhileNotFulfilledBinary(new PrivacyCondition(){
    public State isFulfilled(    HashGroupifyDistribution distribution){
      boolean fulfilled=RiskBasedPrivacyCriterion.this.isFulfilled(distribution);
      if (!fulfilled && distribution.getNumOfSuppressedTuples() > numMaxSuppressedOutliers) {
        return State.ABORT;
      }
 else {
        return fulfilled ? State.FULFILLED : State.NOT_FULFILLED;
      }
    }
  }
);
}","@Override public void enforce(final HashGroupifyDistribution distribution,final int numMaxSuppressedOutliers){
  if (RiskBasedPrivacyCriterion.this.isFulfilled(distribution)) {
    return;
  }
  distribution.suppressWhileNotFulfilledBinary(new PrivacyCondition(){
    public State isFulfilled(    HashGroupifyDistribution distribution){
      boolean fulfilled=RiskBasedPrivacyCriterion.this.isFulfilled(distribution);
      if (!fulfilled && distribution.getNumOfSuppressedTuples() > numMaxSuppressedOutliers) {
        return State.ABORT;
      }
 else {
        return fulfilled ? State.FULFILLED : State.NOT_FULFILLED;
      }
    }
  }
);
}",0.9321192052980132
108174,"/** 
 * Returns the current context, consisting of a consistent combination of a configuration and a data handle.
 * @return
 */
public AnalysisData getData(){
  DataHandle handle=null;
  ModelConfiguration config=null;
  DataDefinition definition=null;
  if (model == null)   return null;
  if (target == ModelPart.INPUT) {
    if (model.getOutputConfig() != null && model.getOutputConfig().getInput() != null) {
      config=model.getOutputConfig();
      definition=model.getOutputDefinition();
    }
 else {
      config=model.getInputConfig();
      definition=model.getInputDefinition();
    }
    if (config.getInput() == null)     return null;
    handle=config.getInput().getHandle();
  }
 else {
    definition=model.getOutputDefinition();
    config=model.getOutputConfig();
    handle=model.getOutput();
  }
  if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
    handle=handle.getView();
  }
  return new AnalysisData(config,handle,definition);
}","/** 
 * Returns the current context, consisting of a consistent combination of a configuration and a data handle.
 * @return
 */
public AnalysisData getData(){
  DataHandle handle=null;
  ModelConfiguration config=null;
  DataDefinition definition=null;
  if (model == null)   return null;
  if (target == ModelPart.INPUT) {
    if (model.getOutputConfig() != null && model.getOutputConfig().getInput() != null && model.getOutput() != null) {
      System.out.println(""String_Node_Str"");
      config=model.getOutputConfig();
      definition=model.getOutputDefinition();
    }
 else {
      System.out.println(""String_Node_Str"");
      config=model.getInputConfig();
      definition=model.getInputDefinition();
    }
    if (config.getInput() == null)     return null;
    handle=config.getInput().getHandle();
  }
 else {
    definition=model.getOutputDefinition();
    config=model.getOutputConfig();
    handle=model.getOutput();
  }
  if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
    handle=handle.getView();
  }
  return new AnalysisData(config,handle,definition);
}",0.9463238610735228
108175,"@Override public void stop(){
  builder.interrupt();
  this.stopped=true;
}","@Override public void stop(){
  if (builder != null)   builder.interrupt();
  this.stopped=true;
}",0.8670520231213873
108176,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
        risks=builder.getSampleBasedAttributeRisks();
      break;
case POPULATION_UNIQUENESS_PITMAN:
    risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
  break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}
@Override public void stop(){
builder.interrupt();
this.stopped=true;
}
}
;
this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  final RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
  if (!this.isEnabled() || builder == null) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
        risks=builder.getSampleBasedAttributeRisks();
      break;
case POPULATION_UNIQUENESS_PITMAN:
    risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
  break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}
@Override public void stop(){
if (builder != null) builder.interrupt();
this.stopped=true;
}
}
;
this.manager.start(analysis);
}",0.9379251700680272
108177,"@Override public void stop(){
  builder.interrupt();
  this.stopped=true;
}","@Override public void stop(){
  if (builder != null)   builder.interrupt();
  this.stopped=true;
}",0.8670520231213873
108178,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalPopulationModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      createItem(Resources.getMessage(""String_Node_Str""),getQuasiIdentifiers(context));
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  if (!this.isEnabled() || builder == null) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalPopulationModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      createItem(Resources.getMessage(""String_Node_Str""),getQuasiIdentifiers(context));
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      if (builder != null)       builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9713493530499075
108179,"@Override public void stop(){
  builder.interrupt();
  this.stopped=true;
}","@Override public void stop(){
  if (builder != null)   builder.interrupt();
  this.stopped=true;
}",0.8670520231213873
108180,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  if (!this.isEnabled() || builder == null) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      if (builder != null)       builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9624796084828712
108181,"@Override public void stop(){
  builder.interrupt();
  this.stopped=true;
}","@Override public void stop(){
  if (builder != null)   builder.interrupt();
  this.stopped=true;
}",0.8670520231213873
108182,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  if (!this.isEnabled() || builder == null) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      if (builder != null)       builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9498090561920348
108183,"@Override public void stop(){
  builder.interrupt();
  this.stopped=true;
}","@Override public void stop(){
  if (baseBuilder != null)   baseBuilder.interrupt();
  this.stopped=true;
}",0.8287292817679558
108184,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)builder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=getBuilder(context,ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel());
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        RiskModelPopulationBasedUniquenessRisk populationBasedModel=builder.getPopulationBasedUniquenessRisk();
        dataDankar[idx]=populationBasedModel.getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=populationBasedModel.getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=populationBasedModel.getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=populationBasedModel.getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  final RiskEstimateBuilderInterruptible baseBuilder=getBuilder(context);
  if (!this.isEnabled() || baseBuilder == null) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    private RiskEstimateBuilderInterruptible builder=baseBuilder;
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)baseBuilder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=getBuilder(context,ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel());
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        RiskModelPopulationBasedUniquenessRisk populationBasedModel=builder.getPopulationBasedUniquenessRisk();
        dataDankar[idx]=populationBasedModel.getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=populationBasedModel.getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=populationBasedModel.getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=populationBasedModel.getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      if (baseBuilder != null)       baseBuilder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.978472039905487
108185,"@Override public void run() throws InterruptedException {
  long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
    risks=builder.getPopulationBasedAttributeRisks();
  break;
case POPULATION_UNIQUENESS_PITMAN:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}","@Override public void run() throws InterruptedException {
  long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
    risks=builder.getSampleBasedAttributeRisks();
  break;
case POPULATION_UNIQUENESS_PITMAN:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}",0.9911209766925638
108186,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
        risks=builder.getPopulationBasedAttributeRisks();
      break;
case POPULATION_UNIQUENESS_PITMAN:
    risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
  break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}
@Override public void stop(){
builder.interrupt();
this.stopped=true;
}
}
;
this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
switch (getModel().getRiskModel().getRiskModelForAttributes()) {
case SAMPLE_UNIQUENESS:
        risks=builder.getSampleBasedAttributeRisks();
      break;
case POPULATION_UNIQUENESS_PITMAN:
    risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.PITMAN);
  break;
case POPULATION_UNIQUENESS_ZAYATZ:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.ZAYATZ);
break;
case POPULATION_UNIQUENESS_SNB:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.SNB);
break;
case POPULATION_UNIQUENESS_DANKAR:
risks=builder.getPopulationBasedAttributeRisks(StatisticalPopulationModel.DANKAR);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
Thread.sleep(10);
}
}
@Override public void stop(){
builder.interrupt();
this.stopped=true;
}
}
;
this.manager.start(analysis);
}",0.9965694682675816
108187,"/** 
 * We currently assume that at any time, at least one statistical model converges. This might not be the case, and 0 may be returned instead. That's why we only accept estimates of 0, if the number of equivalence classes of size 1 in the sample is also zero
 * @param distribution
 * @return
 */
protected boolean isFulfilled(HashGroupifyDistribution distribution){
  RiskModelPopulationBasedUniquenessRisk riskModel=new RiskModelPopulationBasedUniquenessRisk(this.populationModel,distribution.getEquivalenceClasses(),distribution.getNumberOfTuples());
  double populationUniques=riskModel.getFractionOfUniqueTuples(this.statisticalModel);
  if (populationUniques > 0d && populationUniques < getRiskThreshold()) {
    return true;
  }
 else   if (populationUniques == 0d && distribution.getFractionOfTuplesInClassesOfSize(1) == 0d) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * We currently assume that at any time, at least one statistical model converges. This might not be the case, and 0 may be returned instead. That's why we only accept estimates of 0, if the number of equivalence classes of size 1 in the sample is also zero
 * @param distribution
 * @return
 */
protected boolean isFulfilled(HashGroupifyDistribution distribution){
  RiskModelPopulationBasedUniquenessRisk riskModel=new RiskModelPopulationBasedUniquenessRisk(this.populationModel,distribution.getEquivalenceClasses(),distribution.getNumberOfTuples());
  double populationUniques=riskModel.getFractionOfUniqueTuples(this.statisticalModel);
  if (populationUniques > 0d && populationUniques <= getRiskThreshold()) {
    return true;
  }
 else   if (populationUniques == 0d && distribution.getFractionOfTuplesInClassesOfSize(1) == 0d) {
    return true;
  }
 else {
    return false;
  }
}",0.9994391475042064
108188,"/** 
 * The method for computing the first derivatives of the object functions evaluated at the iterated solutions.
 * @param iteratedSolution The iterated vector of solutions.
 * @return The first derivatives of the object functions evaluated at theiterated solutions.
 */
@Override protected double[][] firstDerivativeMatrix(final double[] iteratedSolution){
  final double a=iteratedSolution[0];
  final double b=iteratedSolution[1];
  final double[][] result=new double[iteratedSolution.length][iteratedSolution.length];
  final double val0=(b - 1d) * (f - 1d);
  final double val1=val0 - 1d;
  final double val2=1d - val0;
  final double val3=a * val0 / val1 - 1d;
  final double val4=Math.pow(-b / val1,a);
  final double val5=val0 + 2d;
  final double val6=Math.pow(f,2d);
  final double val7=Math.pow(b,a);
  final double val8=val7 * val6 * k;
  final double val9=a * val8;
  final double val10=2d * Math.pow(val2,a + 2d);
  final double val11=Math.pow((val1),2d);
  final double val12=(a - 1d) * val5;
  final double val13=f * k;
  final double val14=f - 1d;
  final double val15=a - 1d;
  final double val16=b - 1d;
  final double val17=val12 * val16;
  result[0][0]=-val13 * Math.log(-b / val1) * val3* val4 - (val13 * val4 * val0) / val1;
  result[0][1]=a * val13 * (1d / val1 - (b * val14) / val11)* val3* Math.pow((-b / val1),val15) - val13 * val4 * ((a * val14) / val1 - (a * val16 * Math.pow(val14,2d)) / val11);
  result[1][0]=(val9 * Math.log(val2) * val17) / val10 - (val9 * Math.pow(val16,2d) * val14) / val10 - (val8 * val17) / val10 - (val9 * Math.log(b) * val17) / val10;
  result[1][1]=-(val9 * val12) / val10 - (Math.pow(a,2d) * Math.pow(b,val15) * val6* k* val17) / val10 - (val9 * val15 * val0) / val10 - (val9 * val12 * (a + 2d)* val0) / (2d * Math.pow(val2,(a + 3d)));
  return result;
}","/** 
 * The method for computing the first derivatives of the object functions evaluated at the iterated solutions.
 * @param iteratedSolution The iterated vector of solutions.
 * @return The first derivatives of the object functions evaluated at theiterated solutions.
 */
@Override protected double[][] firstDerivativeMatrix(final double[] iteratedSolution){
  final double a=iteratedSolution[0];
  final double b=iteratedSolution[1];
  final double[][] result=new double[iteratedSolution.length][iteratedSolution.length];
  final double val0=(b - 1d) * (f - 1d);
  final double val1=val0 - 1d;
  final double val2=1d - val0;
  final double val3=a * val0 / val1 - 1d;
  final double val4=Math.pow(-b / val1,a);
  final double val6=Math.pow(f,2d);
  final double val7=Math.pow(b,a);
  final double val8=val7 * val6 * k;
  final double val9=a * val8;
  final double val10=2d * Math.pow(val2,a + 2d);
  final double val11=Math.pow((val1),2d);
  final double val13=f * k;
  final double val14=f - 1d;
  final double val15=a - 1d;
  final double val16=b - 1d;
  final double val17=val15 * val0;
  final double val18=val6 * k;
  final double val19=(val17 + 2d);
  final double val20=val18 * val19;
  result[0][0]=-val13 * Math.log(-b / val1) * val3* val4 - (val13 * val4 * val0) / val1;
  result[0][1]=a * val13 * (1d / val1 - (b * val14) / val11)* val3* Math.pow((-b / val1),val15) - val13 * val4 * ((a * val14) / val1 - (a * val16 * Math.pow(val14,2d)) / val11);
  result[1][0]=(val9 * Math.log(val2) * val19* val16) / (val10) - (val9 * Math.pow(val16,2d) * val14) / (val10) - (val7 * val20 * val16) / (val10) - (a * val7 * val18* Math.log(b)* val19* val16) / (val10);
  result[1][1]=-(val9 * val19) / (val10) - (Math.pow(a,2d) * Math.pow(b,val15) * val20* val16) / val10 - (a * val7 * val18* val17) / val10 - (a * val7 * val20* (a + 2d)* val0) / (2d * Math.pow((val2),(a + 3d)));
  return result;
}",0.8025855103689739
108189,"/** 
 * Returns the vector of solutions obtained by the Newton-Raphson algorithm.
 * @param initialValue The vector of initial values.
 * @return the vector of solutions.
 * @exception IllegalArgumentException the first derivative matrix of the object functions is singular.
 */
protected double[] getSolution(final double[] initialValue){
  solutionVector=new Matrix(initialValue,initialValue.length);
  differenceVector=new Matrix(initialValue.length,1,100);
  firstDerivativeMatrix=new Matrix(initialValue.length,initialValue.length);
  int iterations=0;
  while (true) {
    checkInterrupt();
    firstDerivativeMatrix=new Matrix(firstDerivativeMatrix(solutionVector.getColumnPackedCopy()));
    double det=firstDerivativeMatrix.det();
    if (!Double.isNaN(det) && det != 0d) {
      differenceVector=firstDerivativeMatrix.inverse().times(new Matrix(objectFunctionVector(solutionVector.getColumnPackedCopy()),initialValue.length));
      solutionVector=solutionVector.minus(differenceVector);
    }
 else {
      return new double[]{Double.NaN,Double.NaN};
    }
    double normF=differenceVector.normF();
    if (Double.isNaN(normF) || normF <= accuracy || iterations++ > maxIterations) {
      break;
    }
  }
  return solutionVector.getColumnPackedCopy();
}","/** 
 * Returns the vector of solutions obtained by the Newton-Raphson algorithm.
 * @param initialValue The vector of initial values.
 * @return the vector of solutions.
 * @exception IllegalArgumentException the first derivative matrix of the object functions is singular.
 */
protected double[] getSolution(final double[] initialValue){
  solutionVector=new Matrix(initialValue,initialValue.length);
  differenceVector=new Matrix(initialValue.length,1,100);
  firstDerivativeMatrix=new Matrix(initialValue.length,initialValue.length);
  int iterations=0;
  while (true) {
    checkInterrupt();
    firstDerivativeMatrix=new Matrix(firstDerivativeMatrix(solutionVector.getColumnPackedCopy()));
    double det=firstDerivativeMatrix.det();
    if (!Double.isNaN(det) && det != 0d) {
      differenceVector=firstDerivativeMatrix.inverse().times(new Matrix(objectFunctionVector(solutionVector.getColumnPackedCopy()),initialValue.length));
      solutionVector=solutionVector.minus(differenceVector);
    }
 else {
      return new double[]{Double.NaN,Double.NaN};
    }
    double normF=differenceVector.normF();
    if (normF <= accuracy) {
      break;
    }
    if (Double.isNaN(normF) || iterations++ > maxIterations) {
      return new double[]{Double.NaN,Double.NaN};
    }
  }
  return solutionVector.getColumnPackedCopy();
}",0.9453004622496148
108190,"/** 
 * @return
 */
public abstract boolean isNull(String value);","/** 
 * Returns whether the given value represent null
 * @param value
 * @return
 */
public boolean isNull(String value){
  return value != null && value.length() == NULL_VALUE.length() && value.toUpperCase().equals(NULL_VALUE);
}",0.3783783783783784
108191,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=row[indexes[i]];
    if (!dataTypes[i].isValid(result[i])) {
      if (config.columns.get(i).isCleansing()) {
        result[i]=null;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (it.hasNext()) {
    row=it.next();
  }
 else {
    row=null;
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=row[indexes[i]];
    if (!dataTypes[i].isValid(result[i])) {
      if (config.columns.get(i).isCleansing()) {
        result[i]=DataType.NULL_VALUE;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (it.hasNext()) {
    row=it.next();
  }
 else {
    row=null;
  }
  return result;
}",0.9867128827267476
108192,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      if (config.columns.get(i).isCleansing()) {
        result[i]=null;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
    try {
      input.close();
    }
 catch (    Exception e) {
    }
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      if (config.columns.get(i).isCleansing()) {
        result[i]=DataType.NULL_VALUE;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
    try {
      input.close();
    }
 catch (    Exception e) {
    }
  }
  return result;
}",0.9891355692017004
108193,"@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        if (config.columns.get(i).isCleansing()) {
          result[i]=null;
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    hasNext=resultSet.next();
    if (!hasNext) {
      try {
        if (!config.getConnection().isClosed()) {
          config.getConnection().close();
        }
      }
 catch (      Exception e) {
      }
    }
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        if (config.columns.get(i).isCleansing()) {
          result[i]=DataType.NULL_VALUE;
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    hasNext=resultSet.next();
    if (!hasNext) {
      try {
        if (!config.getConnection().isClosed()) {
          config.getConnection().close();
        }
      }
 catch (      Exception e) {
      }
    }
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9859154929577464
108194,"/** 
 * Suppresses entries until the condition is fulfilled
 * @param condition
 * @return the number of tuples that have been suppressed
 */
public int suppressWhileNotFulfilledBinary(PrivacyCondition condition){
  int low=0;
  int high=entries.length - 1;
  int mid=(low + high) / 2;
  int initiallySuppressed=this.suppressed;
  State state=State.ABORT;
  for (int i=low; i <= mid; i++) {
    suppressEntry(entries[i]);
  }
  while (low <= high) {
    state=condition.isFulfilled(this);
    if (state == State.ABORT) {
      break;
    }
 else     if (state == State.FULFILLED) {
      high=mid - 1;
      mid=(low + high) / 2;
      for (int i=mid + 1; i < entries.length && !entries[i].isNotOutlier; i++) {
        unSuppressEntry(entries[i]);
      }
    }
 else {
      low=mid + 1;
      mid=(low + high) / 2;
      for (int i=low; i <= mid; i++) {
        suppressEntry(entries[i]);
      }
    }
  }
  if (state != State.ABORT) {
    state=condition.isFulfilled(this);
    if (state == State.NOT_FULFILLED && mid + 1 < entries.length && entries[mid + 1].isNotOutlier) {
      suppressEntry(entries[mid + 1]);
    }
  }
  return this.suppressed - initiallySuppressed;
}","/** 
 * Suppresses entries until the condition is fulfilled
 * @param condition
 * @return the number of tuples that have been suppressed
 */
public int suppressWhileNotFulfilledBinary(PrivacyCondition condition){
  if (entries.length == 0) {
    return this.suppressed;
  }
  int low=0;
  int high=entries.length - 1;
  int mid=(low + high) / 2;
  int initiallySuppressed=this.suppressed;
  State state=State.ABORT;
  for (int i=low; i <= mid; i++) {
    suppressEntry(entries[i]);
  }
  while (low <= high) {
    state=condition.isFulfilled(this);
    if (state == State.ABORT) {
      break;
    }
 else     if (state == State.FULFILLED) {
      high=mid - 1;
      mid=(low + high) / 2;
      for (int i=mid + 1; i < entries.length && !entries[i].isNotOutlier; i++) {
        unSuppressEntry(entries[i]);
      }
    }
 else {
      low=mid + 1;
      mid=(low + high) / 2;
      for (int i=low; i <= mid; i++) {
        suppressEntry(entries[i]);
      }
    }
  }
  if (state != State.ABORT) {
    state=condition.isFulfilled(this);
    if (state == State.NOT_FULFILLED && mid + 1 < entries.length && entries[mid + 1].isNotOutlier) {
      suppressEntry(entries[mid + 1]);
    }
  }
  return this.suppressed - initiallySuppressed;
}",0.9747412008281572
108195,"/** 
 * Generates a version of the image that renders well on windows toolbars, when disabled.
 * @param control
 * @param image
 */
public static Image createDisabledImage(Control control,Image image){
  return new Image(control.getDisplay(),image,SWT.IMAGE_GRAY);
}","/** 
 * Registers an image for a tool item. Generates a version of the image that renders well on windows toolbars, when disabled.
 * @param item
 * @param image
 */
public static void createDisabledImage(ToolItem item){
  item.setDisabledImage(new Image(item.getDisplay(),item.getImage(),SWT.IMAGE_GRAY));
}",0.6295652173913043
108196,"/** 
 * Determine information loss of the given node if it can be used for estimating minimum and maximum information loss for tagged nodes.
 * @param node
 */
protected void computeUtilityForMonotonicMetrics(Node node){
  if ((checker.getMetric().isMonotonic() || (checker.getConfiguration().getMaxOutliers() == 0d)) && (node.getInformationLoss() == null)) {
    if (checker.getMetric().isIndependent()) {
      InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(node,null);
      lattice.setInformationLoss(node,loss.getInformationLoss());
      lattice.setLowerBound(node,loss.getLowerBound());
    }
 else {
      lattice.setChecked(node,checker.check(node,true));
    }
  }
}","/** 
 * Determine information loss of the given node if it can be used for estimating minimum and maximum information loss for tagged nodes.
 * @param node
 */
protected void computeUtilityForMonotonicMetrics(Node node){
  if ((checker.getMetric().isMonotonic() || (checker.getConfiguration().getMaxOutliers() == 0d)) && (node.getInformationLoss() == null)) {
    if (checker.getMetric().isIndependent()) {
      InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(node,(IHashGroupify)null);
      lattice.setInformationLoss(node,loss.getInformationLoss());
      lattice.setLowerBound(node,loss.getLowerBound());
    }
 else {
      lattice.setChecked(node,checker.check(node,true));
    }
  }
}",0.9894142554693014
108197,"/** 
 * Checks and tags the given transformation.
 * @param node
 * @param configuration
 */
private void checkAndTag(Node node,FLASHPhaseConfiguration configuration){
  if (configuration.getTriggerEvaluate().appliesTo(node)) {
    InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(node,null);
    lattice.setInformationLoss(node,loss.getInformationLoss());
    lattice.setLowerBound(node,loss.getLowerBound());
    if (loss.getLowerBound() == null) {
      lattice.setLowerBound(node,checker.getMetric().getLowerBound(node));
    }
  }
 else   if (configuration.getTriggerCheck().appliesTo(node)) {
    lattice.setChecked(node,checker.check(node));
  }
  trackOptimum(node);
  configuration.getTriggerTag().apply(node);
  prune(node);
}","/** 
 * Checks and tags the given transformation.
 * @param node
 * @param configuration
 */
private void checkAndTag(Node node,FLASHPhaseConfiguration configuration){
  if (configuration.getTriggerEvaluate().appliesTo(node)) {
    InformationLossWithBound<?> loss=checker.getMetric().getInformationLoss(node,(IHashGroupify)null);
    lattice.setInformationLoss(node,loss.getInformationLoss());
    lattice.setLowerBound(node,loss.getLowerBound());
    if (loss.getLowerBound() == null) {
      lattice.setLowerBound(node,checker.getMetric().getLowerBound(node));
    }
  }
 else   if (configuration.getTriggerCheck().appliesTo(node)) {
    lattice.setChecked(node,checker.check(node));
  }
  trackOptimum(node);
  configuration.getTriggerTag().apply(node);
  prune(node);
}",0.9902152641878668
108198,"/** 
 * Internal adder method.
 * @param key the key
 * @param hash the hash
 * @param representant
 * @param count
 * @param pcount
 * @return the hash groupify entry
 */
private final HashGroupifyEntry addInternal(final int[] key,final int hash,final int representant,int count,final int pcount){
  if (subset != null && !subset.contains(representant)) {
    count=0;
  }
  int index=hash & (buckets.length - 1);
  HashGroupifyEntry entry=findEntry(key,index,hash);
  if (entry == null) {
    if (++elementCount > threshold) {
      rehash();
      index=hash & (buckets.length - 1);
    }
    entry=createEntry(key,index,hash,representant);
  }
  entry.count+=count;
  if (subset != null) {
    entry.pcount+=pcount;
    if (count > 0 && entry.count == 0) {
      entry.representant=representant;
    }
  }
  if (entry.count >= k) {
    if (!entry.isNotOutlier) {
      entry.isNotOutlier=true;
      currentOutliers-=(entry.count - count);
    }
  }
 else {
    currentOutliers+=count;
  }
  if (subset == null || count > 0) {
    entry.representant=entry.representant < representant ? entry.representant : representant;
  }
  return entry;
}","/** 
 * Internal adder method.
 * @param key the key
 * @param hash the hash
 * @param representant
 * @param count
 * @param pcount
 * @return the hash groupify entry
 */
private final HashGroupifyEntry addInternal(final int[] key,final int hash,final int representant,int count,final int pcount){
  if (subset != null && !subset.contains(representant)) {
    count=0;
  }
  int index=hash & (buckets.length - 1);
  HashGroupifyEntry entry=findEntry(key,index,hash);
  if (entry == null) {
    if (++elementCount > threshold) {
      rehash();
      index=hash & (buckets.length - 1);
    }
    entry=createEntry(key,index,hash,representant);
  }
  entry.count+=count;
  if (subset != null) {
    entry.pcount+=pcount;
    if (count > 0 && entry.count == count) {
      entry.representant=representant;
    }
  }
  if (entry.count >= k) {
    if (!entry.isNotOutlier) {
      entry.isNotOutlier=true;
      currentOutliers-=(entry.count - count);
    }
  }
 else {
    currentOutliers+=count;
  }
  if (subset == null || count > 0) {
    entry.representant=entry.representant < representant ? entry.representant : representant;
  }
  return entry;
}",0.9973867595818816
108199,"/** 
 * Returns the average class size
 * @return
 */
public double getAverageClassSize(){
  return numClasses / numTuples;
}","/** 
 * Returns the average class size
 * @return
 */
public double getAverageClassSize(){
  return numTuples / numClasses;
}",0.944
108200,"public int compare(HashGroupifyEntry o1,HashGroupifyEntry o2){
  return Integer.compare(o1.representant,o2.representant);
}","public int compare(HashGroupifyEntry o1,HashGroupifyEntry o2){
  int cmp=Integer.compare(o1.count,o2.count);
  return cmp != 0 ? cmp : Integer.compare(o1.representant,o2.representant);
}",0.7961165048543689
108201,"/** 
 * Creates a new instance
 * @param entry
 */
HashGroupifyDistribution(HashGroupifyEntry entry){
  List<HashGroupifyEntry> list=new ArrayList<HashGroupifyEntry>();
  while (entry != null) {
    if (entry.isNotOutlier) {
      this.numClasses++;
      addToDistribution(entry.count);
      list.add(entry);
    }
 else {
      this.suppressed+=entry.count;
    }
    numTuples+=entry.count;
    entry=entry.nextOrdered;
  }
  if (suppressed != 0) {
    this.distribution.putOrAdd(suppressed,1,1);
    this.numClasses++;
  }
  Collections.sort(list,new Comparator<HashGroupifyEntry>(){
    public int compare(    HashGroupifyEntry o1,    HashGroupifyEntry o2){
      return Integer.compare(o1.representant,o2.representant);
    }
  }
);
  this.entries=list.toArray(new HashGroupifyEntry[list.size()]);
}","/** 
 * Creates a new instance
 * @param entry
 */
HashGroupifyDistribution(HashGroupifyEntry entry){
  List<HashGroupifyEntry> list=new ArrayList<HashGroupifyEntry>();
  while (entry != null) {
    if (entry.isNotOutlier && entry.count > 0) {
      this.numClasses++;
      addToDistribution(entry.count);
      list.add(entry);
    }
 else {
      this.suppressed+=entry.count;
    }
    numTuples+=entry.count;
    entry=entry.nextOrdered;
  }
  if (suppressed != 0) {
    this.distribution.putOrAdd(suppressed,1,1);
    this.numClasses++;
  }
  Collections.sort(list,new Comparator<HashGroupifyEntry>(){
    public int compare(    HashGroupifyEntry o1,    HashGroupifyEntry o2){
      int cmp=Integer.compare(o1.count,o2.count);
      return cmp != 0 ? cmp : Integer.compare(o1.representant,o2.representant);
    }
  }
);
  this.entries=list.toArray(new HashGroupifyEntry[list.size()]);
}",0.9293286219081272
108202,"/** 
 * Analyzes the content of the hash table. Checks the privacy criteria against each class.
 */
private void analyzeWithEarlyAbort(){
  kAnonymous=(currentOutliers <= absoluteMaxOutliers);
  if (classBasedCriteria.length == 0) {
    anonymous=kAnonymous;
    return;
  }
  if (k != Integer.MAX_VALUE && !kAnonymous) {
    anonymous=false;
    return;
  }
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    int anonymous=isAnonymous(entry);
    if (anonymous != -1) {
      if (dpresence && entry.count == 0 && anonymous == 1) {
        this.anonymous=false;
        return;
      }
      currentOutliers+=entry.count;
      if (currentOutliers > absoluteMaxOutliers) {
        this.anonymous=false;
        return;
      }
    }
    entry.isNotOutlier=entry.count != 0 ? (anonymous == -1) : true;
    entry=entry.nextOrdered;
  }
  this.analyzeSampleBasedCriteria(true);
  this.anonymous=(currentOutliers <= absoluteMaxOutliers);
}","/** 
 * Analyzes the content of the hash table. Checks the privacy criteria against each class.
 */
private void analyzeWithEarlyAbort(){
  kAnonymous=(currentOutliers <= absoluteMaxOutliers);
  if (classBasedCriteria.length == 0 && sampleBasedCriteria.length == 0) {
    anonymous=kAnonymous;
    return;
  }
  if (k != Integer.MAX_VALUE && !kAnonymous) {
    anonymous=false;
    return;
  }
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    int anonymous=isAnonymous(entry);
    if (anonymous != -1) {
      if (dpresence && entry.count == 0 && anonymous == 1) {
        this.anonymous=false;
        return;
      }
      currentOutliers+=entry.count;
      if (currentOutliers > absoluteMaxOutliers) {
        this.anonymous=false;
        return;
      }
    }
    entry.isNotOutlier=entry.count != 0 ? (anonymous == -1) : true;
    entry=entry.nextOrdered;
  }
  this.analyzeSampleBasedCriteria(true);
  this.anonymous=(currentOutliers <= absoluteMaxOutliers);
}",0.9823321554770318
108203,"/** 
 * Creates a new instance
 * @param entry
 */
HashGroupifyDistribution(HashGroupifyEntry entry){
  List<HashGroupifyEntry> list=new ArrayList<HashGroupifyEntry>();
  while (entry != null) {
    if (entry.isNotOutlier && entry.count > 0) {
      this.numClasses++;
      addToDistribution(entry.count);
      list.add(entry);
    }
 else {
      this.suppressed+=entry.count;
    }
    numTuples+=entry.count;
    entry=entry.nextOrdered;
  }
  if (suppressed != 0) {
    this.distribution.putOrAdd(suppressed,1,1);
    this.numClasses++;
  }
  Collections.sort(list,new Comparator<HashGroupifyEntry>(){
    public int compare(    HashGroupifyEntry o1,    HashGroupifyEntry o2){
      int cmp=Integer.compare(o1.count,o2.count);
      return cmp != 0 ? cmp : Integer.compare(o1.representant,o2.representant);
    }
  }
);
  this.entries=list.toArray(new HashGroupifyEntry[list.size()]);
}","/** 
 * Creates a new instance
 * @param entry
 */
HashGroupifyDistribution(HashGroupifyEntry entry){
  List<HashGroupifyEntry> list=new ArrayList<HashGroupifyEntry>();
  while (entry != null) {
    if (entry.isNotOutlier && entry.count > 0) {
      addToDistribution(entry.count);
      list.add(entry);
    }
 else {
      this.suppressed+=entry.count;
    }
    numTuples+=entry.count;
    entry=entry.nextOrdered;
  }
  if (suppressed != 0) {
    addToDistribution(suppressed);
  }
  Collections.sort(list,new Comparator<HashGroupifyEntry>(){
    public int compare(    HashGroupifyEntry o1,    HashGroupifyEntry o2){
      int cmp=Integer.compare(o1.count,o2.count);
      return cmp != 0 ? cmp : Integer.compare(o1.representant,o2.representant);
    }
  }
);
  this.entries=list.toArray(new HashGroupifyEntry[list.size()]);
}",0.8136970400464306
108204,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 * @param layoutCriteria 
 */
public ViewCriteriaList(final Composite parent,final Controller controller,LayoutCriteria layoutCriteria){
  this.controller=controller;
  this.controller.addListener(ModelPart.CRITERION_DEFINITION,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.layout=layoutCriteria;
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  this.symbolR=controller.getResources().getImage(""String_Node_Str"");
  this.root=parent;
  table=new DynamicTable(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  table.setMenu(new ClipboardHandlerTable(table).getMenu());
  table.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      layout.updateButtons();
    }
  }
);
  column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  layout.updateButtons();
  reset();
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 * @param layoutCriteria 
 */
public ViewCriteriaList(final Composite parent,final Controller controller,LayoutCriteria layoutCriteria){
  this.controller=controller;
  this.controller.addListener(ModelPart.CRITERION_DEFINITION,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  this.layout=layoutCriteria;
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  this.symbolR=controller.getResources().getImage(""String_Node_Str"");
  this.root=parent;
  table=new DynamicTable(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  SWTUtil.createGenericTooltip(table);
  table.setMenu(new ClipboardHandlerTable(table).getMenu());
  table.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      layout.updateButtons();
    }
  }
);
  column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  layout.updateButtons();
  reset();
}",0.9801474758933636
108205,"@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      root.setRedraw(false);
      table.removeAll();
      if (model.getKAnonymityModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getKAnonymityModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolK);
        item.setData(model.getKAnonymityModel());
      }
      if (model.getDPresenceModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getDPresenceModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolD);
        item.setData(model.getDPresenceModel());
      }
      List<ModelExplicitCriterion> explicit=new ArrayList<ModelExplicitCriterion>();
      for (      ModelLDiversityCriterion other : model.getLDiversityModel().values()) {
        if (other.isEnabled()) {
          explicit.add(other);
        }
      }
      for (      ModelTClosenessCriterion other : model.getTClosenessModel().values()) {
        if (other.isEnabled()) {
          explicit.add(other);
        }
      }
      Collections.sort(explicit,new Comparator<ModelExplicitCriterion>(){
        public int compare(        ModelExplicitCriterion o1,        ModelExplicitCriterion o2){
          return o1.getAttribute().compareTo(o2.getAttribute());
        }
      }
);
      for (      ModelExplicitCriterion c : explicit) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
        if (c instanceof ModelLDiversityCriterion) {
          item.setImage(0,symbolL);
        }
 else {
          item.setImage(0,symbolT);
        }
        item.setData(c);
      }
      List<ModelRiskBasedCriterion> riskBased=new ArrayList<ModelRiskBasedCriterion>();
      for (      ModelRiskBasedCriterion other : model.getRiskBasedModel()) {
        if (other.isEnabled()) {
          riskBased.add(other);
        }
      }
      Collections.sort(riskBased,new Comparator<ModelRiskBasedCriterion>(){
        public int compare(        ModelRiskBasedCriterion o1,        ModelRiskBasedCriterion o2){
          return o1.getLabel().compareTo(o2.getLabel());
        }
      }
);
      for (      ModelRiskBasedCriterion c : riskBased) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",c.toString(),""String_Node_Str""});
        item.setImage(0,symbolR);
        item.setData(c);
      }
      column1.pack();
      column2.pack();
      column3.pack();
      layout.updateButtons();
      root.setRedraw(true);
      SWTUtil.enable(root);
    }
  }
}","@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      updateTable();
    }
  }
}",0.183159188690842
108206,"@Override public void reset(){
  root.setRedraw(false);
  if (table != null)   table.removeAll();
  root.setRedraw(true);
  SWTUtil.disable(root);
}","@Override public void reset(){
  root.setRedraw(false);
  if (table != null) {
    table.removeAll();
  }
  root.setRedraw(true);
  SWTUtil.disable(root);
}",0.9736842105263158
108207,"/** 
 * Updates the view.
 * @param node
 */
private void update(){
  root.setRedraw(false);
  for (int i=0; i < combo.getItemCount(); i++) {
    if (combo.getItem(i).equals(model.getRiskModel().getRegion().getName())) {
      combo.select(i);
      break;
    }
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
  text2.setText(format.format(model.getRiskModel().getPopulationSize(handle)));
  root.setRedraw(true);
  SWTUtil.enable(root);
}","/** 
 * Updates the view.
 * @param node
 */
private void update(){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return;
  }
  root.setRedraw(false);
  for (int i=0; i < combo.getItemCount(); i++) {
    if (combo.getItem(i).equals(model.getRiskModel().getRegion().getName())) {
      combo.select(i);
      break;
    }
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
  text2.setText(format.format(model.getRiskModel().getPopulationSize(handle)));
  root.setRedraw(true);
  SWTUtil.enable(root);
}",0.9018302828618968
108208,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final Table table=new Table(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=100;
  table.setLayoutData(d);
  TableColumn column1=new TableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  TableColumn column2=new TableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  TableColumn column3=new TableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  this.symbolR=controller.getResources().getImage(""String_Node_Str"");
  for (  ModelCriterion c : elements) {
    TableItem item=new TableItem(table,SWT.NONE);
    if (c instanceof ModelLDiversityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelLDiversityCriterion)c).getAttribute()});
      item.setImage(0,symbolL);
    }
 else     if (c instanceof ModelTClosenessCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelTClosenessCriterion)c).getAttribute()});
      item.setImage(0,symbolT);
    }
 else     if (c instanceof ModelKAnonymityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolK);
    }
 else     if (c instanceof ModelDPresenceCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelRiskBasedCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolR);
    }
  }
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        selection=elements.get(table.getSelectionIndex());
        if (edit)         ok.setEnabled(true);
        update();
      }
 else {
        selection=null;
        if (edit)         ok.setEnabled(false);
        update();
      }
    }
  }
);
  column1.pack();
  column2.pack();
  column3.pack();
  ComponentTitledBorder border=new ComponentTitledBorder(parent,""String_Node_Str"");
  border.setLayoutData(SWTUtil.createFillGridData());
  this.root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  this.root.setLayout(SWTUtil.createGridLayout(1));
  if (selection != null) {
    table.setSelection(elements.indexOf(selection));
  }
 else {
    table.setSelection(0);
    selection=elements.get(0);
  }
  update();
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(SWTUtil.createGridLayout(1));
  final DynamicTable table=new DynamicTable(parent,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=100;
  table.setLayoutData(d);
  DynamicTableColumn column1=new DynamicTableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column2=new DynamicTableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  DynamicTableColumn column3=new DynamicTableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  column1.pack();
  column2.pack();
  column3.pack();
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  this.symbolR=controller.getResources().getImage(""String_Node_Str"");
  for (  ModelCriterion c : elements) {
    TableItem item=new TableItem(table,SWT.NONE);
    if (c instanceof ModelLDiversityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelLDiversityCriterion)c).getAttribute()});
      item.setImage(0,symbolL);
    }
 else     if (c instanceof ModelTClosenessCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),((ModelTClosenessCriterion)c).getAttribute()});
      item.setImage(0,symbolT);
    }
 else     if (c instanceof ModelKAnonymityCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolK);
    }
 else     if (c instanceof ModelDPresenceCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolD);
    }
 else     if (c instanceof ModelRiskBasedCriterion) {
      item.setText(new String[]{""String_Node_Str"",c.getLabel(),""String_Node_Str""});
      item.setImage(0,symbolR);
    }
  }
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      if (table.getSelectionIndex() != -1) {
        selection=elements.get(table.getSelectionIndex());
        if (edit)         ok.setEnabled(true);
        update();
      }
 else {
        selection=null;
        if (edit)         ok.setEnabled(false);
        update();
      }
    }
  }
);
  ComponentTitledBorder border=new ComponentTitledBorder(parent,""String_Node_Str"");
  border.setLayoutData(SWTUtil.createFillGridData());
  this.root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  this.root.setLayout(SWTUtil.createGridLayout(1));
  if (selection != null) {
    table.setSelection(elements.indexOf(selection));
  }
 else {
    table.setSelection(0);
    selection=elements.get(0);
  }
  update();
  return parent;
}",0.9456433555086808
108209,"/** 
 * Updates the view.
 * @param node
 */
private void update(){
  root.setRedraw(false);
  SWTUtil.enable(root);
  ARXPopulationModel popmodel=model.getInputPopulationModel();
  if (model.getOutputPopulationModel() != null) {
    popmodel=model.getOutputPopulationModel();
  }
  for (int i=0; i < list.getItemCount(); i++) {
    if (list.getItem(i).equals(popmodel.getRegion().getName())) {
      list.select(i);
      break;
    }
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  text.setText(format.format(popmodel.getSampleFraction(handle)));
  text.setEnabled(true);
  text2.setText(format.format(popmodel.getPopulationSize(handle)));
  text2.setEnabled(true);
  root.setRedraw(true);
}","/** 
 * Updates the view.
 * @param node
 */
private void update(){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return;
  }
  root.setRedraw(false);
  SWTUtil.enable(root);
  ARXPopulationModel popmodel=model.getInputPopulationModel();
  if (model.getOutputPopulationModel() != null) {
    popmodel=model.getOutputPopulationModel();
  }
  for (int i=0; i < list.getItemCount(); i++) {
    if (list.getItem(i).equals(popmodel.getRegion().getName())) {
      list.select(i);
      break;
    }
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  text.setText(format.format(popmodel.getSampleFraction(handle)));
  text.setEnabled(true);
  text2.setText(format.format(popmodel.getPopulationSize(handle)));
  text2.setEnabled(true);
  root.setRedraw(true);
}",0.924066924066924
108210,"/** 
 * Tries to detect the line break.
 * @throws IOException Signals that an I/O exception has occurred.
 */
private void detectLinebreak() throws IOException {
  BufferedReader r=null;
  final char[] buffer=new char[ImportWizardModel.DETECT_MAX_CHARS];
  int read=0;
  try {
    r=new BufferedReader(new FileReader(new File(comboLocation.getText())));
    read=r.read(buffer);
  }
  finally {
    if (r != null) {
      r.close();
    }
  }
  if (read > 0) {
    for (int i=0; i < buffer.length; i++) {
      char current=buffer[i];
      if (current == '\r') {
        if (i < buffer.length - 1 && buffer[i + 1] == '\n') {
          selectedLinebreak=1;
        }
 else {
          selectedLinebreak=2;
        }
        return;
      }
      if (current == '\n') {
        selectedLinebreak=0;
        return;
      }
    }
  }
}","/** 
 * Tries to detect the line break.
 * @throws IOException Signals that an I/O exception has occurred.
 */
private void detectLinebreak() throws IOException {
  BufferedReader r=null;
  final char[] buffer=new char[ImportWizardModel.DETECT_MAX_CHARS];
  int read=0;
  try {
    r=new BufferedReader(new FileReader(new File(comboLocation.getText())));
    read=r.read(buffer);
  }
  finally {
    if (r != null) {
      r.close();
    }
  }
  if (read > 0) {
    for (int i=0; i < read; i++) {
      char current=buffer[i];
      if (current == '\r') {
        if (i < buffer.length - 1 && buffer[i + 1] == '\n') {
          selectedLinebreak=1;
        }
 else {
          selectedLinebreak=2;
        }
        return;
      }
      if (current == '\n') {
        selectedLinebreak=0;
        return;
      }
    }
  }
}",0.9897528631705846
108211,"/** 
 * Evaluates the page This checks whether the current settings on the page make any sense. If everything is fine, the settings are being put into the appropriate data container   {@link ImportWizardModel} and the  current page is marked ascomplete by invoking  {@link #setPageComplete(boolean)}. Otherwise an error message is set, which will make sure the user is informed about the reason for the error.
 */
private void evaluatePage(){
  setPageComplete(false);
  setErrorMessage(null);
  tablePreview.setVisible(false);
  if (comboLocation.getText().equals(""String_Node_Str"")) {
    return;
  }
  try {
    detectLinebreak();
    comboLinebreak.select(selectedLinebreak);
    if (!customSeparator) {
      detectSeparator();
      comboSeparator.select(selectedSeparator);
    }
    readPreview();
  }
 catch (  IOException|IllegalArgumentException e) {
    setErrorMessage(e.getMessage());
    return;
  }
catch (  RuntimeException e) {
    if (e.getCause() != null) {
      setErrorMessage(e.getCause().getMessage());
    }
 else {
      setErrorMessage(e.getMessage());
    }
    return;
  }
  ImportWizardModel data=wizardImport.getData();
  data.setWizardColumns(wizardColumns);
  data.setPreviewData(previewData);
  data.setFirstRowContainsHeader(btnContainsHeader.getSelection());
  data.setFileLocation(comboLocation.getText());
  data.setCsvSeparator(separators[selectedSeparator]);
  data.setCsvDelimiter(delimiters[selectedDelimiter]);
  data.setCsvEscape(escapes[selectedEscape]);
  data.setCsvLinebreak(linebreaks[selectedLinebreak]);
  setPageComplete(true);
}","/** 
 * Evaluates the page This checks whether the current settings on the page make any sense. If everything is fine, the settings are being put into the appropriate data container   {@link ImportWizardModel} and the  current page is marked ascomplete by invoking  {@link #setPageComplete(boolean)}. Otherwise an error message is set, which will make sure the user is informed about the reason for the error.
 */
private void evaluatePage(){
  setPageComplete(false);
  setErrorMessage(null);
  tablePreview.setVisible(false);
  if (comboLocation.getText().equals(""String_Node_Str"")) {
    return;
  }
  try {
    if (!customLinebreak) {
      detectLinebreak();
      comboLinebreak.select(selectedLinebreak);
    }
    if (!customSeparator) {
      detectSeparator();
      comboSeparator.select(selectedSeparator);
    }
    readPreview();
  }
 catch (  IOException|IllegalArgumentException e) {
    setErrorMessage(e.getMessage());
    return;
  }
catch (  RuntimeException e) {
    if (e.getCause() != null) {
      setErrorMessage(e.getCause().getMessage());
    }
 else {
      setErrorMessage(e.getMessage());
    }
    return;
  }
  ImportWizardModel data=wizardImport.getData();
  data.setWizardColumns(wizardColumns);
  data.setPreviewData(previewData);
  data.setFirstRowContainsHeader(btnContainsHeader.getSelection());
  data.setFileLocation(comboLocation.getText());
  data.setCsvSeparator(separators[selectedSeparator]);
  data.setCsvDelimiter(delimiters[selectedDelimiter]);
  data.setCsvEscape(escapes[selectedEscape]);
  data.setCsvLinebreak(linebreaks[selectedLinebreak]);
  setPageComplete(true);
}",0.9650218613366646
108212,"/** 
 * Creates the design of this page This adds all the controls to the page along with their listeners.
 * @param parent the parent
 * @note {@link #tablePreview} is not visible until a file is loaded.
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(3,false));
  lblLocation=new Label(container,SWT.NONE);
  lblLocation.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblLocation.setText(""String_Node_Str"");
  comboLocation=new Combo(container,SWT.READ_ONLY);
  comboLocation.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboLocation.addSelectionListener(new SelectionAdapter(){
    /** 
 * Resets   {@link customSeparator} and evaluates page
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      lblSeparator.setVisible(true);
      comboSeparator.setVisible(true);
      lblDelimiter.setVisible(true);
      comboDelimiter.setVisible(true);
      lblLinebreak.setVisible(true);
      comboLinebreak.setVisible(true);
      lblEscape.setVisible(true);
      comboEscape.setVisible(true);
      btnContainsHeader.setVisible(true);
      customSeparator=false;
      evaluatePage();
    }
  }
);
  btnChoose=new Button(container,SWT.NONE);
  btnChoose.setText(""String_Node_Str"");
  btnChoose.addSelectionListener(new SelectionAdapter(){
    /** 
 * Opens a file selection dialog for CSV files If a valid CSV file was selected, it is added to  {@link #comboLocation} when it wasn't already there. It is thenpreselected within  {@link #comboLocation} and the page isevaluated  {@see #evaluatePage}.
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      final String path=wizardImport.getController().actionShowOpenFileDialog(getShell(),""String_Node_Str"");
      if (path == null) {
        return;
      }
      if (comboLocation.indexOf(path) == -1) {
        comboLocation.add(path,0);
      }
      comboLocation.select(comboLocation.indexOf(path));
      comboLocation.notifyListeners(SWT.Selection,null);
    }
  }
);
  lblSeparator=new Label(container,SWT.NONE);
  lblSeparator.setVisible(false);
  lblSeparator.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblSeparator.setText(""String_Node_Str"");
  comboSeparator=new Combo(container,SWT.READ_ONLY);
  comboSeparator.setVisible(false);
  for (  final String s : labels) {
    comboSeparator.add(s);
  }
  comboSeparator.select(selectedSeparator);
  comboSeparator.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboSeparator.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and customSeparator and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedSeparator=comboSeparator.getSelectionIndex();
      customSeparator=true;
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblDelimiter=new Label(container,SWT.NONE);
  lblDelimiter.setVisible(false);
  lblDelimiter.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblDelimiter.setText(""String_Node_Str"");
  comboDelimiter=new Combo(container,SWT.READ_ONLY);
  comboDelimiter.setVisible(false);
  for (  final char c : delimiters) {
    comboDelimiter.add(String.valueOf(c));
  }
  comboDelimiter.select(selectedDelimiter);
  comboDelimiter.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboDelimiter.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom delimiter and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedDelimiter=comboDelimiter.getSelectionIndex();
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblEscape=new Label(container,SWT.NONE);
  lblEscape.setVisible(false);
  lblEscape.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblEscape.setText(""String_Node_Str"");
  comboEscape=new Combo(container,SWT.READ_ONLY);
  comboEscape.setVisible(false);
  for (  final char c : escapes) {
    comboEscape.add(String.valueOf(c));
  }
  comboEscape.select(selectedEscape);
  comboEscape.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboEscape.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom delimiter and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedEscape=comboEscape.getSelectionIndex();
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblLinebreak=new Label(container,SWT.NONE);
  lblLinebreak.setVisible(false);
  lblLinebreak.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblLinebreak.setText(""String_Node_Str"");
  comboLinebreak=new Combo(container,SWT.READ_ONLY);
  comboLinebreak.setVisible(false);
  for (  final String c : linebreaklabels) {
    comboLinebreak.add(String.valueOf(c));
  }
  comboLinebreak.select(selectedEscape);
  comboLinebreak.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboLinebreak.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom line break and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedEscape=comboLinebreak.getSelectionIndex();
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  btnContainsHeader=new Button(container,SWT.CHECK);
  btnContainsHeader.setVisible(false);
  btnContainsHeader.setText(""String_Node_Str"");
  btnContainsHeader.setSelection(true);
  btnContainsHeader.addSelectionListener(new SelectionAdapter(){
    /** 
 * (Re-)Evaluate page
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  tableViewerPreview=new TableViewer(container,SWT.BORDER | SWT.FULL_SELECTION);
  tableViewerPreview.setContentProvider(new ArrayContentProvider());
  tablePreview=tableViewerPreview.getTable();
  GridData gd_tablePreview=new GridData(SWT.FILL,SWT.FILL,true,true,3,1);
  gd_tablePreview.heightHint=150;
  tablePreview.setLayoutData(gd_tablePreview);
  tablePreview.setLinesVisible(true);
  tablePreview.setVisible(false);
  setPageComplete(false);
}","/** 
 * Creates the design of this page This adds all the controls to the page along with their listeners.
 * @param parent the parent
 * @note {@link #tablePreview} is not visible until a file is loaded.
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(3,false));
  lblLocation=new Label(container,SWT.NONE);
  lblLocation.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblLocation.setText(""String_Node_Str"");
  comboLocation=new Combo(container,SWT.READ_ONLY);
  comboLocation.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboLocation.addSelectionListener(new SelectionAdapter(){
    /** 
 * Resets   {@link customSeparator} and evaluates page
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      lblSeparator.setVisible(true);
      comboSeparator.setVisible(true);
      lblDelimiter.setVisible(true);
      comboDelimiter.setVisible(true);
      lblLinebreak.setVisible(true);
      comboLinebreak.setVisible(true);
      lblEscape.setVisible(true);
      comboEscape.setVisible(true);
      btnContainsHeader.setVisible(true);
      customSeparator=false;
      customLinebreak=false;
      evaluatePage();
    }
  }
);
  btnChoose=new Button(container,SWT.NONE);
  btnChoose.setText(""String_Node_Str"");
  btnChoose.addSelectionListener(new SelectionAdapter(){
    /** 
 * Opens a file selection dialog for CSV files If a valid CSV file was selected, it is added to  {@link #comboLocation} when it wasn't already there. It is thenpreselected within  {@link #comboLocation} and the page isevaluated  {@see #evaluatePage}.
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      final String path=wizardImport.getController().actionShowOpenFileDialog(getShell(),""String_Node_Str"");
      if (path == null) {
        return;
      }
      if (comboLocation.indexOf(path) == -1) {
        comboLocation.add(path,0);
      }
      comboLocation.select(comboLocation.indexOf(path));
      comboLocation.notifyListeners(SWT.Selection,null);
    }
  }
);
  lblSeparator=new Label(container,SWT.NONE);
  lblSeparator.setVisible(false);
  lblSeparator.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblSeparator.setText(""String_Node_Str"");
  comboSeparator=new Combo(container,SWT.READ_ONLY);
  comboSeparator.setVisible(false);
  for (  final String s : labels) {
    comboSeparator.add(s);
  }
  comboSeparator.select(selectedSeparator);
  comboSeparator.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboSeparator.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and customSeparator and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedSeparator=comboSeparator.getSelectionIndex();
      customSeparator=true;
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblDelimiter=new Label(container,SWT.NONE);
  lblDelimiter.setVisible(false);
  lblDelimiter.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblDelimiter.setText(""String_Node_Str"");
  comboDelimiter=new Combo(container,SWT.READ_ONLY);
  comboDelimiter.setVisible(false);
  for (  final char c : delimiters) {
    comboDelimiter.add(String.valueOf(c));
  }
  comboDelimiter.select(selectedDelimiter);
  comboDelimiter.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboDelimiter.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom delimiter and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedDelimiter=comboDelimiter.getSelectionIndex();
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblEscape=new Label(container,SWT.NONE);
  lblEscape.setVisible(false);
  lblEscape.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblEscape.setText(""String_Node_Str"");
  comboEscape=new Combo(container,SWT.READ_ONLY);
  comboEscape.setVisible(false);
  for (  final char c : escapes) {
    comboEscape.add(String.valueOf(c));
  }
  comboEscape.select(selectedEscape);
  comboEscape.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboEscape.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom delimiter and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedEscape=comboEscape.getSelectionIndex();
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  lblLinebreak=new Label(container,SWT.NONE);
  lblLinebreak.setVisible(false);
  lblLinebreak.setLayoutData(new GridData(SWT.RIGHT,SWT.CENTER,false,false,1,1));
  lblLinebreak.setText(""String_Node_Str"");
  comboLinebreak=new Combo(container,SWT.READ_ONLY);
  comboLinebreak.setVisible(false);
  for (  final String c : linebreaklabels) {
    comboLinebreak.add(String.valueOf(c));
  }
  comboLinebreak.select(selectedLinebreak);
  comboLinebreak.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
  comboLinebreak.addSelectionListener(new SelectionAdapter(){
    /** 
 * Set selection index and custom line break and (re-)evaluates page
 */
    @Override public void widgetSelected(    final SelectionEvent arg0){
      selectedLinebreak=comboLinebreak.getSelectionIndex();
      customLinebreak=true;
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  btnContainsHeader=new Button(container,SWT.CHECK);
  btnContainsHeader.setVisible(false);
  btnContainsHeader.setText(""String_Node_Str"");
  btnContainsHeader.setSelection(true);
  btnContainsHeader.addSelectionListener(new SelectionAdapter(){
    /** 
 * (Re-)Evaluate page
 */
    @Override public void widgetSelected(    SelectionEvent arg0){
      evaluatePage();
    }
  }
);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  new Label(container,SWT.NONE);
  tableViewerPreview=new TableViewer(container,SWT.BORDER | SWT.FULL_SELECTION);
  tableViewerPreview.setContentProvider(new ArrayContentProvider());
  tablePreview=tableViewerPreview.getTable();
  GridData gd_tablePreview=new GridData(SWT.FILL,SWT.FILL,true,true,3,1);
  gd_tablePreview.heightHint=150;
  tablePreview.setLayoutData(gd_tablePreview);
  tablePreview.setLinesVisible(true);
  tablePreview.setVisible(false);
  setPageComplete(false);
}",0.9933318004138882
108213,"public void modifyText(ModifyEvent arg0){
  double value;
  try {
    value=Double.valueOf(text2.getText());
  }
 catch (  Exception e) {
    value=-1;
  }
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return;
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  if (value < handle.getNumRows()) {
    text2.setForeground(GUIHelper.COLOR_RED);
    return;
  }
 else {
    text2.setForeground(GUIHelper.COLOR_BLACK);
  }
  if (value == model.getRiskModel().getPopulationSize(handle)) {
    return;
  }
  model.getRiskModel().setPopulationSize(handle,value);
  for (int i=0; i < list.getItemCount(); i++) {
    if (list.getItem(i).equals(Region.NONE.getName())) {
      list.select(i);
      break;
    }
  }
  text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
  controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
}","public void modifyText(ModifyEvent arg0){
  double value;
  try {
    value=format.parse(text2.getText()).doubleValue();
  }
 catch (  Exception e) {
    value=-1;
  }
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return;
  }
  DataHandle handle=model.getInputConfig().getInput().getHandle();
  if (value < handle.getNumRows()) {
    text2.setForeground(GUIHelper.COLOR_RED);
    return;
  }
 else {
    text2.setForeground(GUIHelper.COLOR_BLACK);
  }
  if (value == model.getRiskModel().getPopulationSize(handle)) {
    return;
  }
  model.getRiskModel().setPopulationSize(handle,value);
  for (int i=0; i < list.getItemCount(); i++) {
    if (list.getItem(i).equals(Region.NONE.getName())) {
      list.select(i);
      break;
    }
  }
  text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
  controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
}",0.9686552072800808
108214,"/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  Label lbl1=new Label(parent,SWT.NONE);
  lbl1.setText(""String_Node_Str"");
  lbl1.setLayoutData(GridDataFactory.swtDefaults().align(SWT.LEFT,SWT.TOP).create());
  list=new List(parent,SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  for (  Region region : Region.values()) {
    list.add(region.getName());
  }
  list.setLayoutData(new GridData(GridData.FILL_BOTH));
  list.setEnabled(false);
  Label lbl2=new Label(parent,SWT.NONE);
  lbl2.setText(""String_Node_Str"");
  text=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text.setText(""String_Node_Str"");
  text.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  Label lbl3=new Label(parent,SWT.NONE);
  lbl3.setText(""String_Node_Str"");
  text2=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text2.setText(""String_Node_Str"");
  text2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
        long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
        long populationSize=-1;
        Region selected=null;
        for (        Region region : Region.values()) {
          if (region.getName().equals(list.getSelection()[0])) {
            populationSize=region.getPopulation();
            selected=region;
            break;
          }
        }
        if (populationSize == -1) {
          return;
        }
        model.getRiskModel().setRegion(selected);
        controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
        text.setText(format.format(model.getRiskModel().getSampleFraction(sampleSize)));
        text2.setText(format.format(model.getRiskModel().getPopulationSize(sampleSize)));
      }
    }
  }
);
  text.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (value <= 0d || value > 1d) {
        text.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text.setForeground(GUIHelper.COLOR_BLACK);
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value == model.getRiskModel().getSampleFraction(handle)) {
        return;
      }
      model.getRiskModel().setSampleFraction(value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text2.setText(format.format(model.getRiskModel().getPopulationSize(handle.getNumRows())));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
    }
  }
);
  text2.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text2.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
        return;
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value < handle.getNumRows()) {
        text2.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text2.setForeground(GUIHelper.COLOR_BLACK);
      }
      if (value == model.getRiskModel().getPopulationSize(handle)) {
        return;
      }
      model.getRiskModel().setPopulationSize(handle,value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
    }
  }
);
}","/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  Label lbl1=new Label(parent,SWT.NONE);
  lbl1.setText(""String_Node_Str"");
  lbl1.setLayoutData(GridDataFactory.swtDefaults().align(SWT.LEFT,SWT.TOP).create());
  list=new List(parent,SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  for (  Region region : Region.values()) {
    list.add(region.getName());
  }
  list.setLayoutData(new GridData(GridData.FILL_BOTH));
  list.setEnabled(false);
  Label lbl2=new Label(parent,SWT.NONE);
  lbl2.setText(""String_Node_Str"");
  text=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text.setText(""String_Node_Str"");
  text.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  Label lbl3=new Label(parent,SWT.NONE);
  lbl3.setText(""String_Node_Str"");
  text2=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text2.setText(""String_Node_Str"");
  text2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
        long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
        long populationSize=-1;
        Region selected=null;
        for (        Region region : Region.values()) {
          if (region.getName().equals(list.getSelection()[0])) {
            populationSize=region.getPopulation();
            selected=region;
            break;
          }
        }
        if (populationSize == -1) {
          return;
        }
        model.getRiskModel().setRegion(selected);
        controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
        text.setText(format.format(model.getRiskModel().getSampleFraction(sampleSize)));
        text2.setText(format.format(model.getRiskModel().getPopulationSize(sampleSize)));
      }
    }
  }
);
  text.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=format.parse(text.getText()).doubleValue();
      }
 catch (      Exception e) {
        value=-1;
      }
      if (value <= 0d || value > 1d) {
        text.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text.setForeground(GUIHelper.COLOR_BLACK);
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value == model.getRiskModel().getSampleFraction(handle)) {
        return;
      }
      model.getRiskModel().setSampleFraction(value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text2.setText(format.format(model.getRiskModel().getPopulationSize(handle.getNumRows())));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
    }
  }
);
  text2.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=format.parse(text2.getText()).doubleValue();
      }
 catch (      Exception e) {
        value=-1;
      }
      if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
        return;
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value < handle.getNumRows()) {
        text2.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text2.setForeground(GUIHelper.COLOR_BLACK);
      }
      if (value == model.getRiskModel().getPopulationSize(handle)) {
        return;
      }
      model.getRiskModel().setPopulationSize(handle,value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text.setText(format.format(model.getRiskModel().getSampleFraction(handle)));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getRiskModel()));
    }
  }
);
}",0.9856941838649156
108215,"/** 
 * @param context
 * @return
 */
protected abstract T createViewConfig(AnalysisContext context);","/** 
 * Creates a view config
 * @param context
 * @return
 */
protected abstract T createViewConfig(AnalysisContext context);",0.8898678414096917
108216,"@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled() || !isValid()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9457364341085271
108217,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9959112149532712
108218,"@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled() || !isValid()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9457364341085271
108219,"@Override protected void doUpdate(AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.997750642673522
108220,"@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled() || !isValid()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9457364341085271
108221,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9971074380165288
108222,"@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled() || !isValid()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9457364341085271
108223,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9961132704053304
108224,"@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled() || !isValid()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9457364341085271
108225,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)builder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=context.handle.getRiskEstimator(ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel()).getInterruptibleInstance();
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        dataDankar[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)builder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled() || !isValid()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=context.handle.getRiskEstimator(ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel()).getInterruptibleInstance();
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        dataDankar[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9981333333333332
108226,"/** 
 * Reads in preview data This goes through up to   {@link ImportWizardModel#PREVIEW_MAX_LINES} lineswithin the appropriate file and reads them in. It uses  {@link ImportAdapter} in combination with {@link ImportConfigurationCSV} to actually read in the data.
 * @throws IOException
 */
private void readPreview() throws IOException {
  previewData.clear();
  final String location=comboLocation.getText();
  final char separator=separators[selectedSeparator];
  final char delimiter=delimiters[selectedDelimiter];
  final char escape=escapes[selectedEscape];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator,delimiter,escape);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  wizardColumns=new ArrayList<ImportWizardModelColumn>();
  ImportConfigurationCSV config=new ImportConfigurationCSV(location,separator,delimiter,escape,containsHeader);
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < firstLine.length; i++) {
    ImportColumn column=new ImportColumnCSV(i,DataType.STRING);
    ImportWizardModelColumn wizardColumn=new ImportWizardModelColumn(column);
    wizardColumns.add(wizardColumn);
    config.addColumn(column);
  }
  ImportAdapter importAdapter=ImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportWizardModel.PREVIEW_MAX_LINES)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  ImportWizardModelColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(((ImportColumnCSV)column.getColumn()).getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getAliasName());
      tableColumn.setToolTipText(""String_Node_Str"" + ((ImportColumnCSV)column.getColumn()).getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}","/** 
 * Reads in preview data This goes through up to   {@link ImportWizardModel#PREVIEW_MAX_LINES} lineswithin the appropriate file and reads them in. It uses  {@link ImportAdapter} in combination with {@link ImportConfigurationCSV} to actually read in the data.
 * @throws IOException
 */
private void readPreview() throws IOException {
  previewData.clear();
  final String location=comboLocation.getText();
  final char separator=separators[selectedSeparator];
  final char delimiter=delimiters[selectedDelimiter];
  final char escape=escapes[selectedEscape];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator,delimiter,escape);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  wizardColumns=new ArrayList<ImportWizardModelColumn>();
  ImportConfigurationCSV config=new ImportConfigurationCSV(location,separator,delimiter,escape,containsHeader);
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    in.close();
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < firstLine.length; i++) {
    ImportColumn column=new ImportColumnCSV(i,DataType.STRING);
    ImportWizardModelColumn wizardColumn=new ImportWizardModelColumn(column);
    wizardColumns.add(wizardColumn);
    config.addColumn(column);
  }
  ImportAdapter importAdapter=ImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportWizardModel.PREVIEW_MAX_LINES)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  ImportWizardModelColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(((ImportColumnCSV)column.getColumn()).getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getAliasName());
      tableColumn.setToolTipText(""String_Node_Str"" + ((ImportColumnCSV)column.getColumn()).getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}",0.9969913501316284
108227,"/** 
 * Reads in preview data This goes through up to   {@link ImportWizardModel#PREVIEW_MAX_LINES} lineswithin the appropriate file and reads them in. It uses  {@link ImportAdapter} in combination with {@link ImportConfigurationCSV} to actually read in the data.
 * @throws IOException
 */
private void readPreview() throws IOException {
  previewData.clear();
  final String location=comboLocation.getText();
  final char separator=separators[selectedSeparator];
  final char delimiter=delimiters[selectedDelimiter];
  final char escape=escapes[selectedEscape];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator,delimiter,escape);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  wizardColumns=new ArrayList<ImportWizardModelColumn>();
  ImportConfigurationCSV config=new ImportConfigurationCSV(location,separator,containsHeader);
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < firstLine.length; i++) {
    ImportColumn column=new ImportColumnCSV(i,DataType.STRING);
    ImportWizardModelColumn wizardColumn=new ImportWizardModelColumn(column);
    wizardColumns.add(wizardColumn);
    config.addColumn(column);
  }
  ImportAdapter importAdapter=ImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportWizardModel.PREVIEW_MAX_LINES)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  ImportWizardModelColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(((ImportColumnCSV)column.getColumn()).getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getAliasName());
      tableColumn.setToolTipText(""String_Node_Str"" + ((ImportColumnCSV)column.getColumn()).getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}","/** 
 * Reads in preview data This goes through up to   {@link ImportWizardModel#PREVIEW_MAX_LINES} lineswithin the appropriate file and reads them in. It uses  {@link ImportAdapter} in combination with {@link ImportConfigurationCSV} to actually read in the data.
 * @throws IOException
 */
private void readPreview() throws IOException {
  previewData.clear();
  final String location=comboLocation.getText();
  final char separator=separators[selectedSeparator];
  final char delimiter=delimiters[selectedDelimiter];
  final char escape=escapes[selectedEscape];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator,delimiter,escape);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  wizardColumns=new ArrayList<ImportWizardModelColumn>();
  ImportConfigurationCSV config=new ImportConfigurationCSV(location,separator,delimiter,escape,containsHeader);
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < firstLine.length; i++) {
    ImportColumn column=new ImportColumnCSV(i,DataType.STRING);
    ImportWizardModelColumn wizardColumn=new ImportWizardModelColumn(column);
    wizardColumns.add(wizardColumn);
    config.addColumn(column);
  }
  ImportAdapter importAdapter=ImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportWizardModel.PREVIEW_MAX_LINES)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  ImportWizardModelColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(((ImportColumnCSV)column.getColumn()).getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getAliasName());
      tableColumn.setToolTipText(""String_Node_Str"" + ((ImportColumnCSV)column.getColumn()).getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}",0.99678334910123
108228,"/** 
 */
private void parse(){
  final String query=text.getText();
  final DataSelector selector;
  try {
    selector=DataSelector.create(data,query);
    selector.build();
  }
 catch (  Exception e) {
    this.status.setText(e.getMessage());
    this.ok.setEnabled(false);
    this.selector=null;
    return;
  }
  this.status.setText(""String_Node_Str"");
  this.queryString=text.getText();
  this.selector=selector;
  this.ok.setEnabled(true);
}","/** 
 */
private void parse(){
synchronized (this) {
    final String query=text.getText();
    final DataSelector selector;
    try {
      selector=DataSelector.create(data,query);
      selector.build();
    }
 catch (    Exception e) {
      this.status.setText(e.getMessage());
      this.ok.setEnabled(false);
      this.selector=null;
      return;
    }
    this.status.setText(""String_Node_Str"");
    this.queryString=text.getText();
    this.selector=selector;
    this.ok.setEnabled(true);
  }
}",0.9224318658280922
108229,"@Override public void onInterrupt(){
  if (stopped || !isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9568627450980391
108230,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (stopped || !isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public int getProgress(){
      return builder.getProgress();
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9967845659163987
108231,"@Override public void onInterrupt(){
  if (stopped || !isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9568627450980391
108232,"@Override protected void doUpdate(AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (stopped || !isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  final RiskEstimateBuilderInterruptible builder=getBuilder(context);
  Analysis analysis=new Analysis(){
    private boolean stopped=false;
    private double lowestRisk;
    private double fractionOfTuplesAffectedByLowestRisk;
    private double averageRisk;
    private double highestRisk;
    private double fractionOfTuplesAffectedByHighestRisk;
    private double fractionOfUniqueTuples;
    private double fractionOfUniqueTuplesDankar;
    private StatisticalModel dankarModel;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      table.setRedraw(false);
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      createItem(Resources.getMessage(""String_Node_Str""),lowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByLowestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),averageRisk);
      createItem(Resources.getMessage(""String_Node_Str""),highestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfTuplesAffectedByHighestRisk);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuples);
      createItem(Resources.getMessage(""String_Node_Str""),fractionOfUniqueTuplesDankar);
      createItem(Resources.getMessage(""String_Node_Str""),dankarModel);
      table.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelSampleBasedReidentificationRisk samReidModel=builder.getSampleBasedReidentificationRisk();
      RiskModelSampleBasedUniquenessRisk samUniqueModel=builder.getSampleBasedUniquenessRisk();
      RiskModelPopulationBasedUniquenessRisk popUniqueModel=builder.getPopulationBasedUniquenessRisk();
      lowestRisk=samReidModel.getLowestRisk();
      fractionOfTuplesAffectedByLowestRisk=samReidModel.getFractionOfTuplesAffectedByLowestRisk();
      averageRisk=samReidModel.getAverageRisk();
      highestRisk=samReidModel.getHighestRisk();
      fractionOfTuplesAffectedByHighestRisk=samReidModel.getFractionOfTuplesAffectedByHighestRisk();
      fractionOfUniqueTuples=samUniqueModel.getFractionOfUniqueTuples();
      fractionOfUniqueTuplesDankar=popUniqueModel.getFractionOfUniqueTuplesDankar();
      dankarModel=popUniqueModel.getDankarModel();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9982317955312652
108233,"@Override public void onInterrupt(){
  if (stopped || !isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9568627450980391
108234,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (stopped || !isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] frequencies;
    private String[] labels;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      chart.setRedraw(false);
      ISeriesSet seriesSet=chart.getSeriesSet();
      IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
      series.getLabel().setVisible(false);
      series.getLabel().setFont(chart.getFont());
      series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
      series.setYSeries(frequencies);
      chart.getLegend().setVisible(false);
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      yAxis.adjustRange();
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setCategorySeries(labels);
      xAxis.adjustRange();
      updateCategories();
      chart.updateLayout();
      chart.update();
      chart.setRedraw(true);
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      int[] distribution=model.getEquivalenceClasses();
      frequencies=new double[distribution.length / 2];
      labels=new String[distribution.length / 2];
      for (int i=0; i < distribution.length; i+=2) {
        frequencies[i / 2]=(double)distribution[i + 1] / model.getNumClasses() * 100d;
        labels[i / 2]=String.valueOf(distribution[i]);
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9977258631383088
108235,"@Override public void onInterrupt(){
  if (stopped || !isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9568627450980391
108236,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (stopped || !isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private int[] distribution;
    private double numClasses;
    @Override public int getProgress(){
      return 0;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (int i=0; i < distribution.length; i+=2) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(0,String.valueOf(distribution[i]));
        item.setText(1,String.valueOf(distribution[i + 1]));
        item.setText(2,format.format((double)distribution[i + 1] / numClasses * 100d));
        items.add(item);
      }
      root.layout();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      RiskModelEquivalenceClasses model=builder.getEquivalenceClassModel();
      distribution=model.getEquivalenceClasses();
      numClasses=model.getNumClasses();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9969435954431788
108237,"@Override public void onInterrupt(){
  if (stopped || !isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}","@Override public void onInterrupt(){
  if (!isEnabled()) {
    setStatusEmpty();
  }
 else {
    setStatusWorking();
  }
}",0.9568627450980391
108238,"@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)builder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (stopped || !isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=context.handle.getRiskEstimator(ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel()).getInterruptibleInstance();
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        dataDankar[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  if (!this.isEnabled()) {
    if (manager != null) {
      manager.stop();
    }
    this.setStatusEmpty();
    return;
  }
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context);
    private boolean stopped=false;
    private double[] dataPitman;
    private double[] dataZayatz;
    private double[] dataSNB;
    private double[] dataDankar;
    private int idx;
    @Override public int getProgress(){
      return (int)Math.round(idx * 100d + (double)builder.getProgress()) / POINTS.length;
    }
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped || !isEnabled()) {
        return;
      }
      resetChart();
      ISeriesSet seriesSet=chart.getSeriesSet();
      if (showAllModels) {
        createSeries(seriesSet,dataPitman,""String_Node_Str"",PlotSymbolType.CIRCLE,GUIHelper.COLOR_BLACK);
        createSeries(seriesSet,dataZayatz,""String_Node_Str"",PlotSymbolType.CROSS,GUIHelper.COLOR_BLUE);
        createSeries(seriesSet,dataSNB,""String_Node_Str"",PlotSymbolType.DIAMOND,GUIHelper.COLOR_RED);
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_DARK_GRAY);
        chart.getLegend().setVisible(true);
      }
 else {
        createSeries(seriesSet,dataDankar,""String_Node_Str"",PlotSymbolType.SQUARE,GUIHelper.COLOR_BLACK);
        chart.getLegend().setVisible(false);
      }
      IAxisSet axisSet=chart.getAxisSet();
      IAxis yAxis=axisSet.getYAxis(0);
      yAxis.setRange(new Range(0d,1d));
      IAxis xAxis=axisSet.getXAxis(0);
      xAxis.setRange(new Range(0d,LABELS.length));
      xAxis.setCategorySeries(LABELS);
      chart.updateLayout();
      chart.update();
      updateCategories();
      chart.layout();
      chart.setRedraw(true);
      chart.redraw();
      setStatusDone();
    }
    @Override public void onInterrupt(){
      if (!isEnabled()) {
        setStatusEmpty();
      }
 else {
        setStatusWorking();
      }
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      dataDankar=new double[POINTS.length];
      if (showAllModels) {
        dataPitman=new double[POINTS.length];
        dataZayatz=new double[POINTS.length];
        dataSNB=new double[POINTS.length];
      }
      for (idx=0; idx < POINTS.length; idx++) {
        if (stopped) {
          throw new InterruptedException();
        }
        builder=context.handle.getRiskEstimator(ARXPopulationModel.create(POINTS[idx]),builder.getEquivalenceClassModel()).getInterruptibleInstance();
        if (idx == 0 && builder.getSampleBasedUniquenessRisk().getFractionOfUniqueTuples() == 0.0d) {
          Arrays.fill(dataDankar,0.0d);
          if (showAllModels) {
            Arrays.fill(dataPitman,0.0d);
            Arrays.fill(dataZayatz,0.0d);
            Arrays.fill(dataSNB,0.0d);
          }
          break;
        }
        dataDankar[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesDankar();
        if (showAllModels) {
          dataPitman[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesPitman();
          dataZayatz[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesZayatz();
          dataSNB[idx]=builder.getPopulationBasedUniquenessRisk().getFractionOfUniqueTuplesSNB();
        }
      }
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.998532746431906
108239,"/** 
 * Reads the clipboard from the file.
 * @param map
 * @param zip
 * @throws SAXException
 * @throws IOException
 */
private void readClipboard(final Map<String,ARXNode> map,final ZipFile zip) throws SAXException, IOException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return;
  }
  model.getClipboard().clearClipboard();
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isClipboard(localName)) {
        return true;
      }
 else       if (vocabulary.isNode(localName)) {
        final ARXNode node=map.get(payload.trim());
        model.getClipboard().addToClipboard(node);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isClipboard(localName) || vocabulary.isNode(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the clipboard from the file.
 * @param map
 * @param zip
 * @throws SAXException
 * @throws IOException
 */
private void readClipboard(final Map<String,ARXNode> map,final ZipFile zip) throws SAXException, IOException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return;
  }
  model.getClipboard().clearClipboard();
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isClipboard(localName)) {
        return true;
      }
 else       if (vocabulary.isNode(localName)) {
        if (payload == null || map == null)         return true;
        final ARXNode node=map.get(payload.trim());
        model.getClipboard().addToClipboard(node);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isClipboard(localName) || vocabulary.isNode(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.976794002142092
108240,"@Override protected void doUpdate(final AnalysisContextRisk context){
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      setStatusDone();
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      setStatusWorking();
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}","@Override protected void doUpdate(final AnalysisContextRisk context){
  Analysis analysis=new Analysis(){
    RiskEstimateBuilderInterruptible builder=getBuilder(context,context.context.getModel().getSelectedQuasiIdentifiers());
    private boolean stopped=false;
    private RiskModelAttributes risks;
    @Override public void onError(){
      setStatusEmpty();
    }
    @Override public void onFinish(){
      if (stopped) {
        return;
      }
      for (      final TableItem i : items) {
        i.dispose();
      }
      items.clear();
      for (      QuasiIdentifierRisks item : risks.getAttributeRisks()) {
        createItem(item);
      }
      for (      final TableColumn col : columns) {
        col.pack();
      }
      if (risks.getAttributeRisks().length == 0) {
        setStatusEmpty();
      }
 else {
        setStatusDone();
      }
      table.layout();
      table.redraw();
    }
    @Override public void onInterrupt(){
      setStatusWorking();
    }
    @Override public void run() throws InterruptedException {
      long time=System.currentTimeMillis();
      risks=builder.getPopulationBasedAttributeRisks();
      while (System.currentTimeMillis() - time < MINIMAL_WORKING_TIME && !stopped) {
        Thread.sleep(10);
      }
    }
    @Override public void stop(){
      builder.interrupt();
      this.stopped=true;
    }
  }
;
  this.manager.start(analysis);
}",0.9619223659889096
108241,"@Override public void onFinish(){
  if (stopped) {
    return;
  }
  for (  final TableItem i : items) {
    i.dispose();
  }
  items.clear();
  for (  QuasiIdentifierRisks item : risks.getAttributeRisks()) {
    createItem(item);
  }
  for (  final TableColumn col : columns) {
    col.pack();
  }
  setStatusDone();
  table.layout();
  table.redraw();
}","@Override public void onFinish(){
  if (stopped) {
    return;
  }
  for (  final TableItem i : items) {
    i.dispose();
  }
  items.clear();
  for (  QuasiIdentifierRisks item : risks.getAttributeRisks()) {
    createItem(item);
  }
  for (  final TableColumn col : columns) {
    col.pack();
  }
  if (risks.getAttributeRisks().length == 0) {
    setStatusEmpty();
  }
 else {
    setStatusDone();
  }
  table.layout();
  table.redraw();
}",0.890840652446675
108242,"public void widgetSelected(SelectionEvent arg0){
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
    long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
    long populationSize=-1;
    Region selected=null;
    for (    Region region : Region.values()) {
      if (region.getName().equals(list.getSelection()[0])) {
        populationSize=region.getPopulation();
        selected=region;
        break;
      }
    }
    if (populationSize == -1) {
      return;
    }
    double sampleFraction=(double)sampleSize / (double)populationSize;
    model.getPopulationModel().setRegion(selected);
    controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    text.setText(format.format(sampleFraction));
    text2.setText(format.format(populationSize));
  }
}","public void widgetSelected(SelectionEvent arg0){
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
    long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
    long populationSize=-1;
    Region selected=null;
    for (    Region region : Region.values()) {
      if (region.getName().equals(list.getSelection()[0])) {
        populationSize=region.getPopulation();
        selected=region;
        break;
      }
    }
    if (populationSize == -1) {
      return;
    }
    model.getPopulationModel().setRegion(selected);
    controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    text.setText(format.format(model.getPopulationModel().getSampleFraction(sampleSize)));
    text2.setText(format.format(model.getPopulationModel().getPopulationSize(sampleSize)));
  }
}",0.9166229680125852
108243,"/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  Label lbl1=new Label(parent,SWT.NONE);
  lbl1.setText(""String_Node_Str"");
  lbl1.setLayoutData(GridDataFactory.swtDefaults().align(SWT.LEFT,SWT.TOP).create());
  list=new List(parent,SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  for (  Region region : Region.values()) {
    list.add(region.getName());
  }
  list.setLayoutData(new GridData(GridData.FILL_BOTH));
  list.setEnabled(false);
  Label lbl2=new Label(parent,SWT.NONE);
  lbl2.setText(""String_Node_Str"");
  text=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text.setText(""String_Node_Str"");
  text.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  Label lbl3=new Label(parent,SWT.NONE);
  lbl3.setText(""String_Node_Str"");
  text2=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text2.setText(""String_Node_Str"");
  text2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
        long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
        long populationSize=-1;
        Region selected=null;
        for (        Region region : Region.values()) {
          if (region.getName().equals(list.getSelection()[0])) {
            populationSize=region.getPopulation();
            selected=region;
            break;
          }
        }
        if (populationSize == -1) {
          return;
        }
        double sampleFraction=(double)sampleSize / (double)populationSize;
        model.getPopulationModel().setRegion(selected);
        controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
        text.setText(format.format(sampleFraction));
        text2.setText(format.format(populationSize));
      }
    }
  }
);
  text.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (value <= 0d || value > 1d) {
        text.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text.setForeground(GUIHelper.COLOR_BLACK);
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value == model.getPopulationModel().getSampleFraction(handle)) {
        return;
      }
      model.getPopulationModel().setSampleFraction(value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text2.setText(format.format(model.getPopulationModel().getPopulationSize(handle.getNumRows())));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    }
  }
);
  text2.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text2.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
        return;
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value < handle.getNumRows()) {
        text2.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text2.setForeground(GUIHelper.COLOR_BLACK);
      }
      if (value == model.getPopulationModel().getPopulationSize(handle)) {
        return;
      }
      model.getPopulationModel().setPopulationSize(handle,value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text.setText(format.format(model.getPopulationModel().getSampleFraction(handle)));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    }
  }
);
}","/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  Label lbl1=new Label(parent,SWT.NONE);
  lbl1.setText(""String_Node_Str"");
  lbl1.setLayoutData(GridDataFactory.swtDefaults().align(SWT.LEFT,SWT.TOP).create());
  list=new List(parent,SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  for (  Region region : Region.values()) {
    list.add(region.getName());
  }
  list.setLayoutData(new GridData(GridData.FILL_BOTH));
  list.setEnabled(false);
  Label lbl2=new Label(parent,SWT.NONE);
  lbl2.setText(""String_Node_Str"");
  text=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text.setText(""String_Node_Str"");
  text.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  Label lbl3=new Label(parent,SWT.NONE);
  lbl3.setText(""String_Node_Str"");
  text2=new Text(parent,SWT.BORDER | SWT.SINGLE);
  text2.setText(""String_Node_Str"");
  text2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      if (model.getInputConfig() != null && model.getInputConfig().getInput() != null && list.getSelection() != null && list.getSelection().length != 0) {
        long sampleSize=model.getInputConfig().getInput().getHandle().getNumRows();
        long populationSize=-1;
        Region selected=null;
        for (        Region region : Region.values()) {
          if (region.getName().equals(list.getSelection()[0])) {
            populationSize=region.getPopulation();
            selected=region;
            break;
          }
        }
        if (populationSize == -1) {
          return;
        }
        model.getPopulationModel().setRegion(selected);
        controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
        text.setText(format.format(model.getPopulationModel().getSampleFraction(sampleSize)));
        text2.setText(format.format(model.getPopulationModel().getPopulationSize(sampleSize)));
      }
    }
  }
);
  text.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (value <= 0d || value > 1d) {
        text.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text.setForeground(GUIHelper.COLOR_BLACK);
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value == model.getPopulationModel().getSampleFraction(handle)) {
        return;
      }
      model.getPopulationModel().setSampleFraction(value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text2.setText(format.format(model.getPopulationModel().getPopulationSize(handle.getNumRows())));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    }
  }
);
  text2.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent arg0){
      double value;
      try {
        value=Double.valueOf(text2.getText());
      }
 catch (      Exception e) {
        value=-1;
      }
      if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
        return;
      }
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (value < handle.getNumRows()) {
        text2.setForeground(GUIHelper.COLOR_RED);
        return;
      }
 else {
        text2.setForeground(GUIHelper.COLOR_BLACK);
      }
      if (value == model.getPopulationModel().getPopulationSize(handle)) {
        return;
      }
      model.getPopulationModel().setPopulationSize(handle,value);
      for (int i=0; i < list.getItemCount(); i++) {
        if (list.getItem(i).equals(Region.NONE.getName())) {
          list.select(i);
          break;
        }
      }
      text.setText(format.format(model.getPopulationModel().getSampleFraction(handle)));
      controller.update(new ModelEvent(ViewRisksPopulationModel.this,ModelPart.POPULATION_MODEL,model.getPopulationModel()));
    }
  }
);
}",0.981132075471698
108244,"public void widgetSelected(SelectionEvent arg0){
  Set<String> selection=new HashSet<String>();
  for (  TableItem item : table.getItems()) {
    if (item.getChecked()) {
      selection.add(item.getText());
    }
  }
  if (model != null) {
    if (selection.size() <= model.getPopulationModel().getMaxQiSize()) {
      model.setSelectedQuasiIdentifiers(selection);
      controller.update(new ModelEvent(ViewRisksQuasiIdentifiers.this,ModelPart.SELECTED_QUASI_IDENTIFIERS,selection));
      label.setText(""String_Node_Str"" + (int)(Math.pow(2,selection.size()) - 1));
      label.setForeground(GUIHelper.COLOR_BLACK);
    }
 else {
      label.setText(""String_Node_Str"" + (int)(Math.pow(2,selection.size()) - 1));
      label.setForeground(GUIHelper.COLOR_RED);
    }
  }
}","public void widgetSelected(SelectionEvent arg0){
  fireEvent();
}",0.152744630071599
108245,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewRisksQuasiIdentifiers(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_QUASI_IDENTIFIERS,this);
  this.controller=controller;
  root=parent;
  root.setLayout(GridLayoutFactory.swtDefaults().numColumns(1).create());
  create(root);
  reset();
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewRisksQuasiIdentifiers(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_QUASI_IDENTIFIERS,this);
  this.controller=controller;
  root=parent;
  root.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
  create(root);
  reset();
}",0.9978813559322034
108246,"/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  table=new Table(parent,SWT.CHECK | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  table.setLayoutData(SWTUtil.createFillGridData());
  label=new Label(parent,SWT.NONE);
  label.setText(""String_Node_Str"");
  label.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  table.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      Set<String> selection=new HashSet<String>();
      for (      TableItem item : table.getItems()) {
        if (item.getChecked()) {
          selection.add(item.getText());
        }
      }
      if (model != null) {
        if (selection.size() <= model.getPopulationModel().getMaxQiSize()) {
          model.setSelectedQuasiIdentifiers(selection);
          controller.update(new ModelEvent(ViewRisksQuasiIdentifiers.this,ModelPart.SELECTED_QUASI_IDENTIFIERS,selection));
          label.setText(""String_Node_Str"" + (int)(Math.pow(2,selection.size()) - 1));
          label.setForeground(GUIHelper.COLOR_BLACK);
        }
 else {
          label.setText(""String_Node_Str"" + (int)(Math.pow(2,selection.size()) - 1));
          label.setForeground(GUIHelper.COLOR_RED);
        }
      }
    }
  }
);
}","/** 
 * Creates the required controls.
 * @param parent
 */
private void create(final Composite parent){
  table=new Table(parent,SWT.CHECK | SWT.V_SCROLL | SWT.H_SCROLL| SWT.BORDER);
  table.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).span(2,1).create());
  Button button=new Button(parent,SWT.PUSH);
  button.setLayoutData(SWTUtil.createGridData());
  button.setText(""String_Node_Str"");
  button.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      for (      TableItem item : table.getItems()) {
        item.setChecked(false);
      }
      fireEvent();
    }
  }
);
  label=new Label(parent,SWT.RIGHT);
  label.setText(""String_Node_Str"");
  label.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  table.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      fireEvent();
    }
  }
);
}",0.4113667117726657
108247,"/** 
 * Update the view.
 */
protected void update(){
  if (model == null) {
    return;
  }
  DataDefinition definition=model.getOutputDefinition();
  if (definition == null)   definition=model.getInputDefinition();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null)   config=model.getInputConfig();
  if (definition == null || config == null || model.getInputConfig().getInput() == null) {
    reset();
    return;
  }
  DataHandle data=model.getInputConfig().getInput().getHandle();
  root.setRedraw(false);
  roots.clear();
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumRows())});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(config.getAllowedOutliers() * 100d) + Resources.getMessage(""String_Node_Str"")});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{config.getMetric().toString()});
  final Property attributes=new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumColumns())});
  final Property identifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getIdentifyingAttributes().size())});
  int index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=definition.getDataType(s).toString();
      new Property(identifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final DecimalFormat format=new DecimalFormat(""String_Node_Str"");
  final Property quasiIdentifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getQuasiIdentifyingAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getQuasiIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (definition.getHierarchy(s) != null) {
        DataType<?> type=definition.getDataType(s);
        values[1]=type.getDescription().getLabel();
        if (type.getDescription().hasFormat() && ((DataTypeWithFormat)type).getFormat() != null) {
          values[2]=((DataTypeWithFormat)type).getFormat();
        }
        int height=0;
        String[][] hierarchy=definition.getHierarchy(s);
        if (hierarchy != null && hierarchy.length != 0 && hierarchy[0] != null) {
          height=hierarchy[0].length;
        }
        values[3]=String.valueOf(height);
        values[4]=String.valueOf(definition.getMinimumGeneralization(s));
        values[5]=String.valueOf(definition.getMaximumGeneralization(s));
      }
      values[6]=format.format(config.getAttributeWeight(s));
      new Property(quasiIdentifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property sensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getSensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getSensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (config.getHierarchy(s) != null) {
        int height=0;
        if (config.getHierarchy(s).getHierarchy().length > 0) {
          height=config.getHierarchy(s).getHierarchy()[0].length;
        }
        values[1]=definition.getDataType(s).toString();
        values[2]=String.valueOf(height);
      }
      new Property(sensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property insensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getInsensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getInsensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=definition.getDataType(s).toString();
      new Property(insensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view.
 */
protected void update(){
  if (model == null) {
    return;
  }
  DataDefinition definition=model.getOutputDefinition();
  if (definition == null)   definition=model.getInputDefinition();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null)   config=model.getInputConfig();
  if (definition == null || config == null || model.getInputConfig().getInput() == null) {
    reset();
    return;
  }
  DataHandle data=model.getInputConfig().getInput().getHandle();
  root.setRedraw(false);
  roots.clear();
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumRows())});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(config.getAllowedOutliers() * 100d) + Resources.getMessage(""String_Node_Str"")});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{config.getMetric().toString()});
  final Property attributes=new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumColumns())});
  final Property identifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getIdentifyingAttributes().size())});
  int index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=definition.getDataType(s).toString();
      new Property(identifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final DecimalFormat format=new DecimalFormat(""String_Node_Str"");
  final Property quasiIdentifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getQuasiIdentifyingAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getQuasiIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (definition.getHierarchy(s) != null) {
        DataType<?> type=definition.getDataType(s);
        values[1]=type.getDescription().getLabel();
        if (type.getDescription().hasFormat() && ((DataTypeWithFormat)type).getFormat() != null) {
          values[2]=((DataTypeWithFormat)type).getFormat();
        }
        int height=0;
        String[][] hierarchy=definition.getHierarchy(s);
        if (hierarchy != null && hierarchy.length != 0 && hierarchy[0] != null) {
          height=hierarchy[0].length;
        }
        values[3]=String.valueOf(height);
        values[4]=String.valueOf(definition.getMinimumGeneralization(s));
        values[5]=String.valueOf(definition.getMaximumGeneralization(s));
      }
      values[6]=format.format(config.getAttributeWeight(s));
      new Property(quasiIdentifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property sensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getSensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getSensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (config.getHierarchy(s) != null && config.getHierarchy(s).getHierarchy() != null) {
        int height=0;
        if (config.getHierarchy(s).getHierarchy().length > 0) {
          height=config.getHierarchy(s).getHierarchy()[0].length;
        }
        values[1]=definition.getDataType(s).toString();
        values[2]=String.valueOf(height);
      }
      new Property(sensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property insensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(definition.getInsensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (definition.getInsensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=definition.getDataType(s).toString();
      new Property(insensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9949416744090016
108248,"/** 
 * Reads the clipboard from the file.
 * @param map
 * @param zip
 * @throws SAXException
 * @throws IOException
 */
private void readClipboard(final Map<String,ARXNode> map,final ZipFile zip) throws SAXException, IOException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return;
  }
  model.getClipboard().clearClipboard();
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isClipboard(localName)) {
        return true;
      }
 else       if (vocabulary.isNode(localName)) {
        final ARXNode node=map.get(payload.trim());
        model.getClipboard().addToClipboard(node);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isClipboard(localName) || vocabulary.isNode(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the clipboard from the file.
 * @param map
 * @param zip
 * @throws SAXException
 * @throws IOException
 */
private void readClipboard(final Map<String,ARXNode> map,final ZipFile zip) throws SAXException, IOException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return;
  }
  model.getClipboard().clearClipboard();
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(new BufferedInputStream(zip.getInputStream(entry)));
  xmlReader.setContentHandler(new XMLHandler(){
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isClipboard(localName)) {
        return true;
      }
 else       if (vocabulary.isNode(localName)) {
        if (payload == null || map == null)         return true;
        final ARXNode node=map.get(payload.trim());
        model.getClipboard().addToClipboard(node);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isClipboard(localName) || vocabulary.isNode(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.976794002142092
108249,"/** 
 * @param hierarchy
 * @throws IOException
 */
public void write(final String[][] hierarchy) throws IOException {
  CsvWriter csvwriter=new CsvWriter(writer,settings);
  csvwriter.writeRowsAndClose(hierarchy);
}","/** 
 * @param hierarchy
 * @throws IOException
 */
public void write(final String[][] hierarchy) throws IOException {
  CsvWriter csvwriter=new CsvWriter(writer,settings);
  for (int i=0; i < hierarchy.length; i++) {
    csvwriter.writeRow((Object[])hierarchy[i]);
  }
  if (close)   csvwriter.close();
 else   csvwriter.flush();
}",0.708029197080292
108250,"/** 
 * Adds input to table viewer once page gets visible.
 * @param visible
 */
@Override public void setVisible(boolean visible){
  super.setVisible(visible);
  if (visible) {
    checkboxTableViewer.setInput(wizardImport.getData().getWizardColumns());
    setPageComplete((wizardImport.getData().getWizardColumns().size() > 0));
  }
}","/** 
 * Adds input to table viewer once page gets visible.
 * @param visible
 */
@Override public void setVisible(boolean visible){
  super.setVisible(visible);
  if (visible) {
    checkboxTableViewer.setInput(wizardImport.getData().getWizardColumns());
    check();
  }
}",0.8754098360655738
108251,"/** 
 * Sets name for given column (  {@link ImportColumn#setAliasName(String)}).
 * @param element
 * @param value
 */
@Override protected void setValue(Object element,Object value){
  ((ImportWizardModelColumn)element).getColumn().setAliasName((String)value);
  getViewer().update(element,null);
}","/** 
 * Sets name for given column (  {@link ImportColumn#setAliasName(String)}).
 * @param element
 * @param value
 */
@Override protected void setValue(Object element,Object value){
  ((ImportWizardModelColumn)element).getColumn().setAliasName((String)value);
  getViewer().update(element,null);
  check();
}",0.9819376026272578
108252,"/** 
 * Sets the enabled status for the given item Using   {@link ImportWizardModelColumn#setEnabled(boolean)} thismethod will set the enabled flag for the given column. Furthermore it makes sure the page is marked as complete once at least one item is selected.
 */
@Override public void checkStateChanged(CheckStateChangedEvent event){
  setPageComplete(false);
  ((ImportWizardModelColumn)event.getElement()).setEnabled(event.getChecked());
  for (  ImportWizardModelColumn column : wizardImport.getData().getWizardColumns()) {
    if (column.isEnabled()) {
      setPageComplete(true);
      return;
    }
  }
}","/** 
 * Sets the enabled status for the given item Using   {@link ImportWizardModelColumn#setEnabled(boolean)} thismethod will set the enabled flag for the given column. Furthermore it makes sure the page is marked as complete once at least one item is selected.
 */
@Override public void checkStateChanged(CheckStateChangedEvent event){
  ((ImportWizardModelColumn)event.getElement()).setEnabled(event.getChecked());
  check();
}",0.6717703349282297
108253,"/** 
 * Creates the design of this page along with the appropriate listeners.
 * @param parent
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(2,false));
  checkboxTableViewer=CheckboxTableViewer.newCheckList(container,SWT.BORDER | SWT.FULL_SELECTION);
  checkboxTableViewer.setContentProvider(new ArrayContentProvider());
  checkboxTableViewer.setCheckStateProvider(new ICheckStateProvider(){
    /** 
 * @return {@link ImportWizardModelColumn#isEnabled()} 
 */
    @Override public boolean isChecked(    Object column){
      return ((ImportWizardModelColumn)column).isEnabled();
    }
    /** 
 * No column should be grayed out 
 */
    @Override public boolean isGrayed(    Object column){
      return false;
    }
  }
);
  checkboxTableViewer.addCheckStateListener(new ICheckStateListener(){
    /** 
 * Sets the enabled status for the given item Using   {@link ImportWizardModelColumn#setEnabled(boolean)} thismethod will set the enabled flag for the given column. Furthermore it makes sure the page is marked as complete once at least one item is selected.
 */
    @Override public void checkStateChanged(    CheckStateChangedEvent event){
      setPageComplete(false);
      ((ImportWizardModelColumn)event.getElement()).setEnabled(event.getChecked());
      for (      ImportWizardModelColumn column : wizardImport.getData().getWizardColumns()) {
        if (column.isEnabled()) {
          setPageComplete(true);
          return;
        }
      }
    }
  }
);
  table=checkboxTableViewer.getTable();
  table.setHeaderVisible(true);
  table.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,2,1));
  table.addSelectionListener(new SelectionAdapter(){
    /** 
 * Makes the buttons for column reordering (un)clickable This checks the current selection and will enable and/or disable the   {@link #btnUp} and {@link #btnDown} if either the first orlast item is currently selected.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      if (table.getSelectionIndex() == 0) {
        btnUp.setEnabled(false);
      }
 else {
        btnUp.setEnabled(true);
      }
      if (table.getSelectionIndex() == table.getItemCount() - 1) {
        btnDown.setEnabled(false);
      }
 else {
        btnDown.setEnabled(true);
      }
    }
  }
);
  tableViewerColumnEnabled=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnEnabled.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Cells within this column should always be empty 
 */
    @Override public String getText(    Object element){
      return null;
    }
  }
);
  tblclmnEnabled=tableViewerColumnEnabled.getColumn();
  tblclmnEnabled.setToolTipText(""String_Node_Str"");
  tblclmnEnabled.setText(""String_Node_Str"");
  tblclmnEnabled.setWidth(40);
  tblclmnEnabled.addSelectionListener(new ColumnEnabledSelectionListener());
  tableViewerColumnName=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnName.setEditingSupport(new NameEditingSupport(checkboxTableViewer));
  tableViewerColumnName.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Gets name of cells from   {@link ImportColumn#getAliasName()}This also makes sure that all column names are unique using  {@link #uniqueColumnNames()}. In case there are duplicates it sets an error message.
 */
    @Override public String getText(    Object element){
      if (!uniqueColumnNames()) {
        setErrorMessage(""String_Node_Str"");
        setPageComplete(false);
      }
 else {
        setErrorMessage(null);
        setPageComplete(true);
      }
      ImportWizardModelColumn column=(ImportWizardModelColumn)element;
      return column.getColumn().getAliasName();
    }
  }
);
  tblclmnName=tableViewerColumnName.getColumn();
  tblclmnName.setToolTipText(""String_Node_Str"");
  tblclmnName.setWidth(300);
  tblclmnName.setText(""String_Node_Str"");
  tableViewerColumnDatatype=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnDatatype.setEditingSupport(new DatatypeEditingSupport(checkboxTableViewer));
  tableViewerColumnDatatype.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Gets string representation for given datatype of column Internally it makes use of   {@link ImportColumn#getDataType()}.
 */
    @Override public String getText(    Object element){
      DataType<?> datatype=((ImportWizardModelColumn)element).getColumn().getDataType();
      for (      DataTypeDescription<?> description : DataType.list()) {
        if (description.newInstance().getClass() == datatype.getClass()) {
          return description.getLabel();
        }
      }
      return null;
    }
  }
);
  tblclmnDatatype=tableViewerColumnDatatype.getColumn();
  tblclmnDatatype.setToolTipText(""String_Node_Str"");
  tblclmnDatatype.setWidth(120);
  tblclmnDatatype.setText(""String_Node_Str"");
  tableViewerColumnFormat=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnFormat.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Returns format string of datatype for column This retrieves the used format string of the chosen datatype for each column.
 * @note In case of simple datatypes without a format specifier anempty string is returned.
 * @param element Column in question
 */
    @Override public String getText(    Object element){
      DataType<?> column=((ImportWizardModelColumn)element).getColumn().getDataType();
      if (column instanceof DataTypeWithFormat) {
        return ((DataTypeWithFormat)column).getFormat();
      }
      return ""String_Node_Str"";
    }
  }
);
  tblclmnFormat=tableViewerColumnFormat.getColumn();
  tblclmnFormat.setWidth(120);
  tblclmnFormat.setToolTipText(""String_Node_Str"");
  tblclmnFormat.setWidth(100);
  tblclmnFormat.setText(""String_Node_Str"");
  btnUp=new Button(container,SWT.NONE);
  btnUp.setText(""String_Node_Str"");
  btnUp.setImage(wizardImport.getController().getResources().getImage(""String_Node_Str""));
  btnUp.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  btnUp.setEnabled(false);
  btnUp.addSelectionListener(new SelectionAdapter(){
    /** 
 * Swaps the current element with the one above This makes also sure that the button is disabled once the top is reached by notifying the appropriate selection listener.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      int current=table.getSelectionIndex();
      if (current > 0) {
        List<ImportWizardModelColumn> columns=wizardImport.getData().getWizardColumns();
        Collections.swap(columns,current,current - 1);
        checkboxTableViewer.setInput(columns);
        table.notifyListeners(SWT.Selection,null);
      }
    }
  }
);
  btnDown=new Button(container,SWT.NONE);
  btnDown.setText(""String_Node_Str"");
  btnDown.setImage(wizardImport.getController().getResources().getImage(""String_Node_Str""));
  btnDown.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  btnDown.setEnabled(false);
  btnDown.addSelectionListener(new SelectionAdapter(){
    /** 
 * Swaps the current element with the one below This makes also sure that the button is disabled once the bottom is reached by notifying the appropriate selection listener.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      int current=table.getSelectionIndex();
      if (current < table.getItemCount() - 1) {
        List<ImportWizardModelColumn> columns=wizardImport.getData().getWizardColumns();
        Collections.swap(columns,current,current + 1);
        checkboxTableViewer.setInput(columns);
        table.notifyListeners(SWT.Selection,null);
      }
    }
  }
);
  setPageComplete(false);
}","/** 
 * Creates the design of this page along with the appropriate listeners.
 * @param parent
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(2,false));
  checkboxTableViewer=CheckboxTableViewer.newCheckList(container,SWT.BORDER | SWT.FULL_SELECTION);
  checkboxTableViewer.setContentProvider(new ArrayContentProvider());
  checkboxTableViewer.setCheckStateProvider(new ICheckStateProvider(){
    /** 
 * @return {@link ImportWizardModelColumn#isEnabled()} 
 */
    @Override public boolean isChecked(    Object column){
      return ((ImportWizardModelColumn)column).isEnabled();
    }
    /** 
 * No column should be grayed out 
 */
    @Override public boolean isGrayed(    Object column){
      return false;
    }
  }
);
  checkboxTableViewer.addCheckStateListener(new ICheckStateListener(){
    /** 
 * Sets the enabled status for the given item Using   {@link ImportWizardModelColumn#setEnabled(boolean)} thismethod will set the enabled flag for the given column. Furthermore it makes sure the page is marked as complete once at least one item is selected.
 */
    @Override public void checkStateChanged(    CheckStateChangedEvent event){
      ((ImportWizardModelColumn)event.getElement()).setEnabled(event.getChecked());
      check();
    }
  }
);
  table=checkboxTableViewer.getTable();
  table.setHeaderVisible(true);
  table.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,2,1));
  table.addSelectionListener(new SelectionAdapter(){
    /** 
 * Makes the buttons for column reordering (un)clickable This checks the current selection and will enable and/or disable the   {@link #btnUp} and {@link #btnDown} if either the first orlast item is currently selected.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      if (table.getSelectionIndex() == 0) {
        btnUp.setEnabled(false);
      }
 else {
        btnUp.setEnabled(true);
      }
      if (table.getSelectionIndex() == table.getItemCount() - 1) {
        btnDown.setEnabled(false);
      }
 else {
        btnDown.setEnabled(true);
      }
    }
  }
);
  tableViewerColumnEnabled=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnEnabled.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Cells within this column should always be empty 
 */
    @Override public String getText(    Object element){
      return null;
    }
  }
);
  tblclmnEnabled=tableViewerColumnEnabled.getColumn();
  tblclmnEnabled.setToolTipText(""String_Node_Str"");
  tblclmnEnabled.setText(""String_Node_Str"");
  tblclmnEnabled.setWidth(40);
  tblclmnEnabled.addSelectionListener(new ColumnEnabledSelectionListener());
  tableViewerColumnName=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnName.setEditingSupport(new NameEditingSupport(checkboxTableViewer));
  tableViewerColumnName.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Gets name of cells from   {@link ImportColumn#getAliasName()}This also makes sure that all column names are unique using  {@link #uniqueColumnNames()}. In case there are duplicates it sets an error message.
 */
    @Override public String getText(    Object element){
      ImportWizardModelColumn column=(ImportWizardModelColumn)element;
      return column.getColumn().getAliasName();
    }
  }
);
  tblclmnName=tableViewerColumnName.getColumn();
  tblclmnName.setToolTipText(""String_Node_Str"");
  tblclmnName.setWidth(300);
  tblclmnName.setText(""String_Node_Str"");
  tableViewerColumnDatatype=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnDatatype.setEditingSupport(new DatatypeEditingSupport(checkboxTableViewer));
  tableViewerColumnDatatype.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Gets string representation for given datatype of column Internally it makes use of   {@link ImportColumn#getDataType()}.
 */
    @Override public String getText(    Object element){
      DataType<?> datatype=((ImportWizardModelColumn)element).getColumn().getDataType();
      for (      DataTypeDescription<?> description : DataType.list()) {
        if (description.newInstance().getClass() == datatype.getClass()) {
          return description.getLabel();
        }
      }
      return null;
    }
  }
);
  tblclmnDatatype=tableViewerColumnDatatype.getColumn();
  tblclmnDatatype.setToolTipText(""String_Node_Str"");
  tblclmnDatatype.setWidth(120);
  tblclmnDatatype.setText(""String_Node_Str"");
  tableViewerColumnFormat=new TableViewerColumn(checkboxTableViewer,SWT.NONE);
  tableViewerColumnFormat.setLabelProvider(new ColumnLabelProvider(){
    /** 
 * Returns format string of datatype for column This retrieves the used format string of the chosen datatype for each column.
 * @note In case of simple datatypes without a format specifier anempty string is returned.
 * @param element Column in question
 */
    @Override public String getText(    Object element){
      DataType<?> column=((ImportWizardModelColumn)element).getColumn().getDataType();
      if (column instanceof DataTypeWithFormat) {
        return ((DataTypeWithFormat)column).getFormat();
      }
      return ""String_Node_Str"";
    }
  }
);
  tblclmnFormat=tableViewerColumnFormat.getColumn();
  tblclmnFormat.setWidth(120);
  tblclmnFormat.setToolTipText(""String_Node_Str"");
  tblclmnFormat.setWidth(100);
  tblclmnFormat.setText(""String_Node_Str"");
  btnUp=new Button(container,SWT.NONE);
  btnUp.setText(""String_Node_Str"");
  btnUp.setImage(wizardImport.getController().getResources().getImage(""String_Node_Str""));
  btnUp.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  btnUp.setEnabled(false);
  btnUp.addSelectionListener(new SelectionAdapter(){
    /** 
 * Swaps the current element with the one above This makes also sure that the button is disabled once the top is reached by notifying the appropriate selection listener.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      int current=table.getSelectionIndex();
      if (current > 0) {
        List<ImportWizardModelColumn> columns=wizardImport.getData().getWizardColumns();
        Collections.swap(columns,current,current - 1);
        checkboxTableViewer.setInput(columns);
        table.notifyListeners(SWT.Selection,null);
      }
    }
  }
);
  btnDown=new Button(container,SWT.NONE);
  btnDown.setText(""String_Node_Str"");
  btnDown.setImage(wizardImport.getController().getResources().getImage(""String_Node_Str""));
  btnDown.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
  btnDown.setEnabled(false);
  btnDown.addSelectionListener(new SelectionAdapter(){
    /** 
 * Swaps the current element with the one below This makes also sure that the button is disabled once the bottom is reached by notifying the appropriate selection listener.
 */
    @Override public void widgetSelected(    SelectionEvent e){
      int current=table.getSelectionIndex();
      if (current < table.getItemCount() - 1) {
        List<ImportWizardModelColumn> columns=wizardImport.getData().getWizardColumns();
        Collections.swap(columns,current,current + 1);
        checkboxTableViewer.setInput(columns);
        table.notifyListeners(SWT.Selection,null);
      }
    }
  }
);
  setPageComplete(false);
}",0.9717025101538052
108254,"@Override protected String[] readRow() throws IOException {
  final String line=reader.readLine();
  if (line == null) {
    reader.close();
    return null;
  }
  if (columns == -1) {
    columns=countColumns(line);
  }
  final String[] tuple=new String[columns];
  int column=0;
  int offset=0;
  int index=0;
  while (column < (columns - 1)) {
    index=line.indexOf(separator,offset);
    if (index < 0) {
      throw new IOException(""String_Node_Str"" + tuple.length + ""String_Node_Str"");
    }
    tuple[column++]=line.substring(offset,index);
    offset=index + 1;
  }
  tuple[column]=line.substring(offset);
  return tuple;
}","@Override protected String[] readRow() throws IOException {
  final String line=reader.readLine();
  if (line == null) {
    reader.close();
    return null;
  }
  if (columns == -1) {
    columns=countColumns(line);
  }
  final String[] tuple=new String[columns];
  int column=0;
  int offset=0;
  int index=0;
  while (column < (columns - 1)) {
    index=line.indexOf(separator,offset);
    if (index < 0) {
      System.out.println(line);
      throw new IOException(""String_Node_Str"" + tuple.length + ""String_Node_Str"");
    }
    tuple[column++]=line.substring(offset,index);
    offset=index + 1;
  }
  tuple[column]=line.substring(offset);
  return tuple;
}",0.9753086419753086
108255,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  if (row.getPhysicalNumberOfCells() > numberOfColumns) {
    throw new IllegalArgumentException(""String_Node_Str"" + currentRow + ""String_Node_Str"");
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
    try {
      input.close();
    }
 catch (    Exception e) {
    }
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index} and contains as many elements as there are columns selected to importfrom  {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @return
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
    try {
      input.close();
    }
 catch (    Exception e) {
    }
  }
  return result;
}",0.9251700680272108
108256,"/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon the configuration   {@link ImportConfigurationExcel#getContainsHeader()} andwhether or not names have been assigned explicitly either the appropriate values will be returned, or names will be made up on the fly following the pattern ""Column #x"", where x is incremented for each column.
 * @return
 */
private String[] createHeader(){
  if (config.getContainsHeader())   this.config.prepare(row);
  this.indexes=getIndexesToImport();
  this.dataTypes=getColumnDatatypes();
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    row.getCell(((ImportColumnExcel)column).getIndex()).setCellType(Cell.CELL_TYPE_STRING);
    String name=row.getCell(((ImportColumnExcel)column).getIndex()).getStringCellValue();
    if (config.getContainsHeader() && !name.equals(""String_Node_Str"")) {
      header[i]=name;
    }
 else {
      header[i]=""String_Node_Str"" + ((ImportColumnExcel)column).getIndex();
    }
    if (column.getAliasName() != null) {
      header[i]=column.getAliasName();
    }
    column.setAliasName(header[i]);
  }
  if (config.getContainsHeader()) {
    if (iterator.hasNext()) {
      row=iterator.next();
      currentRow++;
    }
 else {
      row=null;
    }
  }
  numberOfColumns=header.length;
  return header;
}","/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon the configuration   {@link ImportConfigurationExcel#getContainsHeader()} andwhether or not names have been assigned explicitly either the appropriate values will be returned, or names will be made up on the fly following the pattern ""Column #x"", where x is incremented for each column.
 * @return
 */
private String[] createHeader(){
  if (config.getContainsHeader())   this.config.prepare(row);
  this.indexes=getIndexesToImport();
  this.dataTypes=getColumnDatatypes();
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    row.getCell(((ImportColumnExcel)column).getIndex()).setCellType(Cell.CELL_TYPE_STRING);
    String name=row.getCell(((ImportColumnExcel)column).getIndex()).getStringCellValue();
    if (config.getContainsHeader() && !name.equals(""String_Node_Str"")) {
      header[i]=name;
    }
 else {
      header[i]=""String_Node_Str"" + ((ImportColumnExcel)column).getIndex();
    }
    if (column.getAliasName() != null) {
      header[i]=column.getAliasName();
    }
    column.setAliasName(header[i]);
  }
  if (config.getContainsHeader()) {
    if (iterator.hasNext()) {
      row=iterator.next();
      currentRow++;
    }
 else {
      row=null;
    }
  }
  return header;
}",0.9891767792718924
108257,"/** 
 * Starts the anonymization.
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),""String_Node_Str"",t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clearClipboard();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization.
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),""String_Node_Str"",t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clearClipboard();
    ModelNodeFilter filter=new ModelNodeFilter(result.getLattice().getTop().getTransformation(),model.getInitialNodesInViewer());
    filter.initialize(result);
    model.setNodeFilter(filter);
    update(new ModelEvent(this,ModelPart.FILTER,filter));
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.9588772845953004
108258,"/** 
 * Initializes the view.
 * @param result
 * @param nodeFilter
 */
private void initialize(final ARXResult result,final ModelNodeFilter nodeFilter){
  reset();
  if (result == null || result.getLattice() == null) {
    return;
  }
  this.result=result;
  if (nodeFilter == null) {
    filter=new ModelNodeFilter(result.getLattice().getTop().getTransformation(),model.getInitialNodesInViewer());
    filter.initialize(result);
    if (model != null) {
      model.setNodeFilter(filter);
      controller.update(new ModelEvent(this,ModelPart.FILTER,filter));
    }
  }
 else {
    filter=nodeFilter;
  }
  this.update();
}","/** 
 * Initializes the view.
 * @param result
 * @param nodeFilter
 */
private void initialize(final ARXResult result,final ModelNodeFilter nodeFilter){
  reset();
  if (result == null || result.getLattice() == null) {
    return;
  }
  this.result=result;
  if (nodeFilter == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  filter=nodeFilter;
  this.update();
}",0.5900990099009901
108259,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    eventNodeSelected();
  }
 else   if (event.part == ModelPart.RESULT) {
    if (model != null && model.getResult() != null && model.getResult().getGlobalOptimum() != null) {
      optimum=model.getResult().getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventResultChanged(model.getResult());
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    if (model != null && model.getResult() != null && model.getResult().getGlobalOptimum() != null) {
      optimum=model.getResult().getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventModelChanged();
    }
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null && !isTooLarge(model.getResult(),(ModelNodeFilter)event.data,model.getMaxNodesInViewer())) {
      eventFilterChanged(model.getResult(),(ModelNodeFilter)event.data);
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    eventNodeSelected();
  }
 else   if (event.part == ModelPart.RESULT) {
    ARXResult result=(ARXResult)event.data;
    if (model != null && result != null && result.getGlobalOptimum() != null) {
      optimum=result.getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(result,model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventResultChanged(result);
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    if (model != null && model.getResult() != null && model.getResult().getGlobalOptimum() != null) {
      optimum=model.getResult().getGlobalOptimum();
    }
 else {
      optimum=null;
    }
    if (model != null && !isTooLarge(model.getResult(),model.getNodeFilter(),model.getMaxNodesInViewer())) {
      eventModelChanged();
    }
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null && !isTooLarge(model.getResult(),(ModelNodeFilter)event.data,model.getMaxNodesInViewer())) {
      eventFilterChanged(model.getResult(),(ModelNodeFilter)event.data);
    }
  }
}",0.9351285189718482
108260,"/** 
 * Replaces the original value with the replacement in the given column. Only supported by handles for input data.
 * @param original
 * @param replacement
 * @return Whether the original value was found
 */
public boolean replace(int column,String original,String replacement){
  checkRegistry();
  checkColumn(column);
  if (!getDataType(getAttributeName(column)).isValid(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return registry.replace(column,original,replacement);
}","/** 
 * Replaces the original value with the replacement in the given column. Only supported by handles for input data.
 * @param original
 * @param replacement
 * @return Whether the original value was found
 */
public boolean replace(int column,String original,String replacement){
  checkRegistry();
  checkColumn(column);
  if (!getDataType(getAttributeName(column)).isValid(replacement)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  String s : getDistinctValues(column)) {
    if (s.equals(replacement)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return registry.replace(column,original,replacement);
}",0.8763666947014298
108261,"/** 
 * Check whether the filtered part of the solution space is too large
 * @param result
 * @param filter
 * @return
 */
private boolean isTooLarge(ARXResult result,ModelNodeFilter filter,int max){
  int count=0;
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        count++;
      }
    }
  }
  if (count > max) {
    showSecondaryComposite(count,max);
    return true;
  }
 else {
    showPrimaryComposite();
    return false;
  }
}","/** 
 * Check whether the filtered part of the solution space is too large
 * @param result
 * @param filter
 * @return
 */
private boolean isTooLarge(ARXResult result,ModelNodeFilter filter,int max){
  if (result == null)   return false;
  int count=0;
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        count++;
      }
    }
  }
  if (count > max) {
    showSecondaryComposite(count,max);
    return true;
  }
 else {
    showPrimaryComposite();
    return false;
  }
}",0.9683860232945092
108262,"/** 
 * Check whether the filtered part of the solution space is too large
 * @param result
 * @param filter
 * @return
 */
private boolean isTooLarge(ARXResult result,ModelNodeFilter filter,int max){
  if (result == null)   return false;
  int count=0;
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        count++;
      }
    }
  }
  if (count > max) {
    showSecondaryComposite(count,max);
    return true;
  }
 else {
    showPrimaryComposite();
    return false;
  }
}","/** 
 * Check whether the filtered part of the solution space is too large
 * @param result
 * @param filter
 * @return
 */
private boolean isTooLarge(ARXResult result,ModelNodeFilter filter,int max){
  if (result == null) {
    showPrimaryComposite();
    return false;
  }
  int count=0;
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        count++;
      }
    }
  }
  if (count > max) {
    showSecondaryComposite(count,max);
    return true;
  }
 else {
    showPrimaryComposite();
    return false;
  }
}",0.9482758620689656
108263,"/** 
 * Replace a value in the given column
 * @param column
 * @param original
 * @param replacement
 * @return
 */
public boolean replace(int column,String original,String replacement){
  boolean replaced=false;
  replaced|=input.replace(column,original,replacement);
  if (!output.isEmpty()) {
    replaced|=output.values().iterator().next().replace(column,original,replacement);
  }
  return replaced;
}","/** 
 * Replace a value in the given column
 * @param column
 * @param original
 * @param replacement
 * @return
 */
public boolean replace(int column,String original,String replacement){
  boolean replaced=false;
  replaced|=input.internalReplace(column,original,replacement);
  if (!output.isEmpty()) {
    replaced|=output.values().iterator().next().internalReplace(column,original,replacement);
  }
  return replaced;
}",0.9759036144578314
108264,"/** 
 * Contructor
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  super(parent,controller);
  table=new DynamicTable(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ARXNode node=list.get(table.getSelectionIndex());
      ViewList.this.actionSelectNode(node);
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=table.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewList.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  final DynamicTableColumn column0=new DynamicTableColumn(table,SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setWidth(""String_Node_Str"");
  final DynamicTableColumn column1=new DynamicTableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column4=new DynamicTableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column2=new DynamicTableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column3=new DynamicTableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  table.setItemCount(0);
  column0.pack();
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
  Listener tableListener=new Listener(){
    private TableItem previousHighlighted=null;
    public void handleEvent(    Event event){
      if (previousHighlighted != null) {
        if (!previousHighlighted.isDisposed()) {
          previousHighlighted.setBackground(background);
        }
      }
      TableItem item=table.getItem(new Point(event.x,event.y));
      if (item != null) {
        item.setBackground(GUIHelper.COLOR_GRAY);
        previousHighlighted=item;
        ARXNode node=(ARXNode)item.getData();
        table.redraw();
        table.setToolTipText(getTooltipDecorator().decorate(node));
      }
    }
  }
;
  table.addListener(SWT.MouseMove,tableListener);
  table.addListener(SWT.MouseExit,tableListener);
}","/** 
 * Contructor
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  super(parent,controller);
  table=new DynamicTable(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ARXNode node=list.get(table.getSelectionIndex());
      ViewList.this.actionSelectNode(node);
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=table.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewList.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  final DynamicTableColumn column0=new DynamicTableColumn(table,SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setWidth(""String_Node_Str"");
  final DynamicTableColumn column1=new DynamicTableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column4=new DynamicTableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column2=new DynamicTableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column3=new DynamicTableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  table.setItemCount(0);
  column0.pack();
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
  Listener tableListener=new Listener(){
    private TableItem previousHighlighted=null;
    public void handleEvent(    Event event){
      if (previousHighlighted != null) {
        if (!previousHighlighted.isDisposed()) {
          previousHighlighted.setBackground(background);
        }
      }
      TableItem item=table.getItem(new Point(event.x,event.y));
      if (item != null) {
        item.setBackground(GUIHelper.COLOR_GRAY);
        previousHighlighted=item;
        ARXNode node=(ARXNode)item.getData();
        if (node != null) {
          table.redraw();
          table.setToolTipText(getTooltipDecorator().decorate(node));
        }
      }
    }
  }
;
  table.addListener(SWT.MouseMove,tableListener);
  table.addListener(SWT.MouseExit,tableListener);
}",0.9925952045133992
108265,"public void run(){
synchronized (fireEvent) {
    if (fireEvent) {
      fireEvent=false;
      actionInfoLossChanged();
    }
  }
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
}","public void run(){
synchronized (fireEvent) {
    if (fireEvent) {
      fireEvent=false;
      actionInfoLossChanged();
    }
  }
  if (!parent.isDisposed() && !parent.getDisplay().isDisposed()) {
    parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
  }
}",0.8366013071895425
108266,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewFilter(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.RESULT,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.FILTER,this);
  IMG_RESET=controller.getResources().getImage(""String_Node_Str"");
  IMG_OPTIMUM=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(""String_Node_Str"",IMG_OPTIMUM,new Runnable(){
    public void run(){
      actionShowOptimum();
    }
  }
);
  bar.add(""String_Node_Str"",IMG_RESET,new Runnable(){
    public void run(){
      actionReset();
    }
  }
);
  ComponentTitledFolder border=new ComponentTitledFolder(parent,controller,bar,null);
  border.setLayoutData(SWTUtil.createFillGridData());
  root=border.createItem(Resources.getMessage(""String_Node_Str""),null);
  GridLayout groupLayout=new GridLayout();
  groupLayout.numColumns=2;
  root.setLayout(groupLayout);
  create(root);
  border.setSelection(0);
  border.setEnabled(true);
  reset();
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,new Runnable(){
    public void run(){
synchronized (fireEvent) {
        if (fireEvent) {
          fireEvent=false;
          actionInfoLossChanged();
        }
      }
      parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
    }
  }
);
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewFilter(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.RESULT,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.FILTER,this);
  IMG_RESET=controller.getResources().getImage(""String_Node_Str"");
  IMG_OPTIMUM=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(""String_Node_Str"",IMG_OPTIMUM,new Runnable(){
    public void run(){
      actionShowOptimum();
    }
  }
);
  bar.add(""String_Node_Str"",IMG_RESET,new Runnable(){
    public void run(){
      actionReset();
    }
  }
);
  ComponentTitledFolder border=new ComponentTitledFolder(parent,controller,bar,null);
  border.setLayoutData(SWTUtil.createFillGridData());
  root=border.createItem(Resources.getMessage(""String_Node_Str""),null);
  GridLayout groupLayout=new GridLayout();
  groupLayout.numColumns=2;
  root.setLayout(groupLayout);
  create(root);
  border.setSelection(0);
  border.setEnabled(true);
  reset();
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,new Runnable(){
    public void run(){
synchronized (fireEvent) {
        if (fireEvent) {
          fireEvent=false;
          actionInfoLossChanged();
        }
      }
      if (!parent.isDisposed() && !parent.getDisplay().isDisposed()) {
        parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
      }
    }
  }
);
}",0.9724596391263058
108267,"/** 
 * Contructor
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  super(parent,controller);
  table=new DynamicTable(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ARXNode node=list.get(table.getSelectionIndex());
      ViewList.this.actionSelectNode(node);
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=table.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewList.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  final DynamicTableColumn column0=new DynamicTableColumn(table,SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setWidth(""String_Node_Str"");
  final DynamicTableColumn column1=new DynamicTableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column4=new DynamicTableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column2=new DynamicTableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column3=new DynamicTableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  table.setItemCount(0);
  column0.pack();
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
  Listener tableListener=new Listener(){
    private TableItem previousHighlighted=null;
    public void handleEvent(    Event event){
      if (previousHighlighted != null) {
        if (!previousHighlighted.isDisposed()) {
          previousHighlighted.setBackground(background);
        }
      }
      TableItem item=table.getItem(new Point(event.x,event.y));
      if (item != null) {
        item.setBackground(GUIHelper.COLOR_GRAY);
        previousHighlighted=item;
        ARXNode node=(ARXNode)item.getData();
        if (node != null) {
          table.redraw();
          table.setToolTipText(getTooltipDecorator().decorate(node));
        }
      }
    }
  }
;
  table.addListener(SWT.MouseMove,tableListener);
  table.addListener(SWT.MouseExit,tableListener);
}","/** 
 * Contructor
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  super(parent,controller);
  table=new DynamicTable(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL| SWT.FULL_SELECTION);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      ARXNode node=list.get(table.getSelectionIndex());
      ViewList.this.actionSelectNode(node);
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (arg0.button == 3) {
        if (getSelectedNode() != null) {
          Point display=table.toDisplay(arg0.x,arg0.y);
          getModel().setSelectedNode(getSelectedNode());
          controller.update(new ModelEvent(ViewList.this,ModelPart.SELECTED_NODE,getSelectedNode()));
          actionShowMenu(display.x,display.y);
        }
      }
    }
  }
);
  final DynamicTableColumn column0=new DynamicTableColumn(table,SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setWidth(""String_Node_Str"");
  final DynamicTableColumn column1=new DynamicTableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  column1.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column4=new DynamicTableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  column4.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column2=new DynamicTableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column2.setWidth(""String_Node_Str"",""String_Node_Str"");
  final DynamicTableColumn column3=new DynamicTableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column3.setWidth(""String_Node_Str"",""String_Node_Str"");
  table.setItemCount(0);
  column0.pack();
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
  Listener tableListener=new Listener(){
    private TableItem previousHighlighted=null;
    public void handleEvent(    Event event){
      if (previousHighlighted != null) {
        if (!previousHighlighted.isDisposed()) {
          previousHighlighted.setBackground(background);
        }
      }
      TableItem item=table.getItem(new Point(event.x,event.y));
      if (item != null) {
        item.setBackground(GUIHelper.COLOR_GRAY);
        previousHighlighted=item;
        ARXNode node=(ARXNode)item.getData();
        if (node != null) {
          table.redraw();
          table.setToolTipText(getTooltipDecorator().decorate(node));
        }
      }
    }
  }
;
  table.addListener(SWT.MouseMove,tableListener);
  table.addListener(SWT.MouseExit,tableListener);
  table.addListener(SWT.EraseItem,new Listener(){
    @Override public void handleEvent(    Event event){
      event.gc.setBackground(((TableItem)event.item).getBackground(event.index));
      event.gc.fillRectangle(event.getBounds());
    }
  }
);
}",0.9580818242790072
108268,"public void run(){
synchronized (fireEvent) {
    if (fireEvent) {
      fireEvent=false;
      actionInfoLossChanged();
    }
  }
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
}","public void run(){
synchronized (fireEvent) {
    if (fireEvent) {
      fireEvent=false;
      actionInfoLossChanged();
    }
  }
  if (!parent.isDisposed() && !parent.getDisplay().isDisposed()) {
    parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
  }
}",0.8366013071895425
108269,"/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewFilter(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.RESULT,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.FILTER,this);
  IMG_RESET=controller.getResources().getImage(""String_Node_Str"");
  IMG_OPTIMUM=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(""String_Node_Str"",IMG_OPTIMUM,new Runnable(){
    public void run(){
      actionShowOptimum();
    }
  }
);
  bar.add(""String_Node_Str"",IMG_RESET,new Runnable(){
    public void run(){
      actionReset();
    }
  }
);
  ComponentTitledFolder border=new ComponentTitledFolder(parent,controller,bar,null);
  border.setLayoutData(SWTUtil.createFillGridData());
  root=border.createItem(Resources.getMessage(""String_Node_Str""),null);
  GridLayout groupLayout=new GridLayout();
  groupLayout.numColumns=2;
  root.setLayout(groupLayout);
  create(root);
  border.setSelection(0);
  border.setEnabled(true);
  reset();
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,new Runnable(){
    public void run(){
synchronized (fireEvent) {
        if (fireEvent) {
          fireEvent=false;
          actionInfoLossChanged();
        }
      }
      parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
    }
  }
);
}","/** 
 * Creates a new instance.
 * @param parent
 * @param controller
 */
public ViewFilter(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(ModelPart.RESULT,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.FILTER,this);
  IMG_RESET=controller.getResources().getImage(""String_Node_Str"");
  IMG_OPTIMUM=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(""String_Node_Str"",IMG_OPTIMUM,new Runnable(){
    public void run(){
      actionShowOptimum();
    }
  }
);
  bar.add(""String_Node_Str"",IMG_RESET,new Runnable(){
    public void run(){
      actionReset();
    }
  }
);
  ComponentTitledFolder border=new ComponentTitledFolder(parent,controller,bar,null);
  border.setLayoutData(SWTUtil.createFillGridData());
  root=border.createItem(Resources.getMessage(""String_Node_Str""),null);
  GridLayout groupLayout=new GridLayout();
  groupLayout.numColumns=2;
  root.setLayout(groupLayout);
  create(root);
  border.setSelection(0);
  border.setEnabled(true);
  reset();
  parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,new Runnable(){
    public void run(){
synchronized (fireEvent) {
        if (fireEvent) {
          fireEvent=false;
          actionInfoLossChanged();
        }
      }
      if (!parent.isDisposed() && !parent.getDisplay().isDisposed()) {
        parent.getDisplay().timerExec(SCALE_UPDATE_INTERVAL,this);
      }
    }
  }
);
}",0.9724596391263058
108270,"/** 
 * Dynamically creates an image with the given color
 * @param color
 * @return
 */
private Image getSymbol(Color color){
  if (symbols.containsKey(color)) {
    return symbols.get(color);
  }
  final int WIDTH=16;
  final int HEIGHT=16;
  Image image=getTransparentImage(table.getDisplay(),WIDTH,HEIGHT);
  GC gc=new GC(image);
  gc.setBackground(color);
  if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
    gc.fillRectangle(0,0,WIDTH,HEIGHT);
  }
 else {
    gc.setAntialias(SWT.ON);
    gc.fillOval(0,0,WIDTH,HEIGHT);
    gc.setAntialias(SWT.OFF);
  }
  gc.dispose();
  symbols.put(color,image);
  return image;
}","/** 
 * Dynamically creates an image with the given color
 * @param color
 * @return
 */
private Image getSymbol(Color color){
  if (symbols.containsKey(color)) {
    return symbols.get(color);
  }
  final int WIDTH=16;
  final int HEIGHT=16;
  Image image=null;
  GC gc=null;
  String os=System.getProperty(""String_Node_Str"").toLowerCase();
  if (os.indexOf(""String_Node_Str"") >= 0 || os.indexOf(""String_Node_Str"") >= 0) {
    image=new Image(table.getDisplay(),WIDTH,HEIGHT);
    gc=new GC(image);
    gc.setBackground(color);
    gc.fillRectangle(0,0,WIDTH,HEIGHT);
  }
 else {
    image=getTransparentImage(table.getDisplay(),WIDTH,HEIGHT);
    gc=new GC(image);
    gc.setBackground(color);
    gc.setAntialias(SWT.ON);
    gc.fillOval(0,0,WIDTH,HEIGHT);
    gc.setAntialias(SWT.OFF);
  }
  gc.dispose();
  symbols.put(color,image);
  return image;
}",0.7460526315789474
108271,"@Override public void characters(final char[] ch,final int start,final int length) throws SAXException {
  payload=new String(ch,start,length);
}","@Override public void characters(final char[] ch,final int start,final int length) throws SAXException {
  sb.add(ch,start,length);
}",0.9280575539568344
108272,"@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  if (!end(uri,localName,qName)) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + localName);
  }
}","@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  payload=new String(sb.buffer,0,sb.size());
  if (!end(uri,localName,qName)) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + localName);
  }
}",0.9129593810444874
108273,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  if (!start(uri,localName,qName,attributes)) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + localName);
  }
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  sb.clear();
  if (!start(uri,localName,qName,attributes)) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + localName);
  }
}",0.9755244755244756
108274,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] + 1d) * weights[i],1.0d / (double)values.length) - 1d;
  }
  return result;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] + 1d) * weights[i],1.0d / (double)values.length);
  }
  return result - 1d;
}",0.925
108275,"/** 
 * Returns the registered value if present, null otherwise.
 * @param dimension
 * @param string
 * @return
 */
public Integer probe(final int dimension,final String string){
  return maps[dimension].get(string);
}","/** 
 * Returns the registered value if present, null otherwise.
 * @param dimension
 * @param string
 * @return
 */
public Integer probe(final int dimension,final String string){
  if (maps[dimension].containsKey(string)) {
    return maps[dimension].lget();
  }
 else {
    return null;
  }
}",0.7875243664717348
108276,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] > 0d ? values[i] : Double.MIN_VALUE) * weights[i],1.0d / (double)values.length);
  }
  return result;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] + 1d) * weights[i],1.0d / (double)values.length) - 1d;
  }
  return result;
}",0.8668941979522184
108277,"/** 
 * Returns the matching interval.
 * @param index
 * @param type
 * @param tValue
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private Interval<T> getIntervalUpperSnap(IndexNode index,DataTypeWithRatioScale<T> type,T tValue){
  int shift=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),shift);
  T value=type.subtract(tValue,offset);
  Interval<T> interval=null;
  for (int j=0; j < intervals.size(); j++) {
    Interval<T> i=intervals.get(j);
    if (type.compare(i.min,value) <= 0 && type.compare(i.max,value) > 0) {
      if (type.compare(value,i.min) == 0) {
        if (j > 0) {
          interval=intervals.get(j - 1);
          break;
        }
 else {
          interval=intervals.get(intervals.size() - 1);
          offset=type.multiply(type.subtract(index.max,index.min),shift - 1);
          break;
        }
      }
 else {
        interval=i;
        break;
      }
    }
  }
  if (interval == null && intervals.size() == 1) {
    interval=intervals.get(0);
  }
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  return new Interval<T>(this,(DataType<T>)type,lower,upper,interval.function);
}","/** 
 * Returns the matching interval.
 * @param index
 * @param type
 * @param tValue
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private Interval<T> getIntervalUpperSnap(IndexNode index,DataTypeWithRatioScale<T> type,T tValue){
  double shift=Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),shift);
  T value=type.subtract(tValue,offset);
  Interval<T> interval=null;
  for (int j=0; j < intervals.size(); j++) {
    Interval<T> i=intervals.get(j);
    if (type.compare(i.min,value) <= 0 && type.compare(i.max,value) > 0) {
      if (type.compare(value,i.min) == 0) {
        if (j > 0) {
          interval=intervals.get(j - 1);
          break;
        }
 else {
          interval=intervals.get(intervals.size() - 1);
          offset=type.multiply(type.subtract(index.max,index.min),shift - 1);
          break;
        }
      }
 else {
        interval=i;
        break;
      }
    }
  }
  if (interval == null && intervals.size() == 1) {
    interval=intervals.get(0);
  }
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  return new Interval<T>(this,(DataType<T>)type,lower,upper,interval.function);
}",0.9947955390334572
108278,"/** 
 * Returns the geometric mean.
 * @return
 */
private double getMean(){
  double[] values=getValues();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow(values[i],1.0d / (double)values.length);
  }
  return result;
}","/** 
 * Returns the geometric mean. Handles zero values by adding 1 to each component and subtracting 1 from the result.
 * @return
 */
private double getMean(){
  double[] values=getValues();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow(values[i] + 1.0d,1.0d / (double)values.length);
  }
  return result - 1d;
}",0.8407224958949097
108279,"/** 
 * Main entry point.
 * @param args
 */
public static void main(final String[] args){
  try {
    Display display=new Display();
    Monitor monitor=getMonitor(display);
    splash=new MainSplash(display,monitor);
    splash.show();
    main=new MainWindow(display,monitor);
    main.show();
    if (args.length > 0 && args[0].endsWith(""String_Node_Str"")) {
      main.onShow(new Runnable(){
        public void run(){
          load(main,args[0]);
        }
      }
);
    }
    while (!main.isDisposed()) {
      try {
        if (!display.readAndDispatch()) {
          display.sleep();
        }
      }
 catch (      final Exception e) {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str""),e);
        StringWriter sw=new StringWriter();
        PrintWriter pw=new PrintWriter(sw);
        e.printStackTrace(pw);
        main.getController().getResources().getLogger().info(sw.toString());
      }
    }
    if (!display.isDisposed()) {
      display.dispose();
    }
  }
 catch (  Throwable e) {
    if (splash != null)     splash.hide();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","/** 
 * Main entry point.
 * @param args
 */
public static void main(final String[] args){
  try {
    Display display=new Display();
    Monitor monitor=getMonitor(display);
    splash=new MainSplash(display,monitor);
    splash.show();
    main=new MainWindow(display,monitor);
    if (args.length > 0 && args[0].endsWith(""String_Node_Str"")) {
      main.onShow(new Runnable(){
        public void run(){
          load(main,args[0]);
        }
      }
);
    }
    main.show();
    while (!main.isDisposed()) {
      try {
        if (!display.readAndDispatch()) {
          display.sleep();
        }
      }
 catch (      final Exception e) {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str""),e);
        StringWriter sw=new StringWriter();
        PrintWriter pw=new PrintWriter(sw);
        e.printStackTrace(pw);
        main.getController().getResources().getLogger().info(sw.toString());
      }
    }
    if (!display.isDisposed()) {
      display.dispose();
    }
  }
 catch (  Throwable e) {
    if (splash != null)     splash.hide();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.9875912408759124
108280,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow(values[i] * weights[i],1.0d / (double)values.length);
  }
  return result;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] > 0d ? values[i] : 1d) * weights[i],1.0d / (double)values.length);
  }
  return result;
}",0.925
108281,"/** 
 * Resets the view.
 */
@Override public void reset(){
  tiles.setRedraw(false);
  tiles.setItems(new ArrayList<ARXNode>());
  tiles.setRedraw(true);
  SWTUtil.disable(tiles);
}","/** 
 * Resets the view.
 */
@Override public void reset(){
  tiles.setRedraw(false);
  tiles.setItems(new ArrayList<ARXNode>());
  tiles.setRedraw(true);
  tiles.setFilter(new Filter<ARXNode>(){
    public boolean accepts(    ARXNode arg0){
      return true;
    }
  }
);
  tiles.update();
  SWTUtil.disable(tiles);
}",0.7265469061876247
108282,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] > 0d ? values[i] : 1d) * weights[i],1.0d / (double)values.length);
  }
  return result;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=1.0d;
  for (int i=0; i < values.length; i++) {
    result*=Math.pow((values[i] > 0d ? values[i] : Double.MIN_VALUE) * weights[i],1.0d / (double)values.length);
  }
  return result;
}",0.9698996655518396
108283,"/** 
 * Creates a new instance.
 * @param maxLevels
 * @param maxNumNodesInitial
 */
@SuppressWarnings(""String_Node_Str"") public ModelNodeFilter(final int[] maxLevels,final int maxNumNodesInitial){
  this.maxNumNodesInitial=maxNumNodesInitial;
  this.generalizations=new Set[maxLevels.length];
  for (int i=0; i < generalizations.length; i++) {
    generalizations[i]=new HashSet<Integer>();
  }
}","/** 
 * Creates a new instance used for cloning.
 * @param anonymity
 * @param generalizations
 * @param maxNumNodesInitial
 * @param minInformationLoss
 * @param maxInformationLoss
 */
@SuppressWarnings(""String_Node_Str"") private ModelNodeFilter(Set<Anonymity> anonymity,Set<Integer>[] generalizations,int maxNumNodesInitial,double minInformationLoss,double maxInformationLoss){
  for (  Anonymity element : anonymity) {
    this.anonymity.add(element);
  }
  this.generalizations=new Set[generalizations.length];
  for (int i=0; i < generalizations.length; i++) {
    Set<Integer> current=generalizations[i];
    this.generalizations[i]=new HashSet<Integer>();
    for (    Integer integer : current) {
      this.generalizations[i].add(integer);
    }
  }
  this.maxNumNodesInitial=maxNumNodesInitial;
  this.minInformationLoss=minInformationLoss;
  this.maxInformationLoss=maxInformationLoss;
}",0.4293436293436293
108284,"public boolean accepts(ARXNode node){
  return filter.isAllowed(lattice,node);
}","public boolean accepts(ARXNode node){
  return filterClone.isAllowed(lattice,node);
}",0.9696969696969696
108285,"/** 
 * Updates the filter
 * @param lattice
 * @param filter
 */
private void updateFilter(final ARXLattice lattice,final ModelNodeFilter filter){
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    public void run(){
      tiles.setFilter(new Filter<ARXNode>(){
        public boolean accepts(        ARXNode node){
          return filter.isAllowed(lattice,node);
        }
      }
);
      tiles.update();
    }
  }
);
}","/** 
 * Updates the filter
 * @param lattice
 * @param filter
 */
private void updateFilter(final ARXLattice lattice,final ModelNodeFilter filter){
  if (filter == null)   return;
  final ModelNodeFilter filterClone=filter.clone();
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    public void run(){
      tiles.setFilter(new Filter<ARXNode>(){
        public boolean accepts(        ARXNode node){
          return filterClone.isAllowed(lattice,node);
        }
      }
);
      tiles.update();
    }
  }
);
}",0.9433962264150944
108286,"@Override public Color decorate(ARXNode element){
switch (element.getAnonymity()) {
case NOT_ANONYMOUS:
case UNKNOWN:
case PROBABLY_NOT_ANONYMOUS:
    return new Color(tiles.getDisplay(),160,160,160);
default :
  return gradient.getColor(asRelativeValue(element.getMinimumInformationLoss()) / 100d);
}
}","@Override public Color decorate(ARXNode element){
switch (element.getAnonymity()) {
case NOT_ANONYMOUS:
case UNKNOWN:
case PROBABLY_NOT_ANONYMOUS:
    return gray;
default :
  return gradient.getColor(asRelativeValue(element.getMinimumInformationLoss()) / 100d);
}
}",0.9279437609841829
108287,"/** 
 * Creates a background decorator
 * @return
 */
private DecoratorColor<ARXNode> createDecoratorBackgroundColor(){
  final Gradient gradient=new GradientHeatscale(tiles);
  DecoratorColor<ARXNode> decorator=new DecoratorColor<ARXNode>(){
    @Override public Color decorate(    ARXNode element){
switch (element.getAnonymity()) {
case NOT_ANONYMOUS:
case UNKNOWN:
case PROBABLY_NOT_ANONYMOUS:
        return new Color(tiles.getDisplay(),160,160,160);
default :
      return gradient.getColor(asRelativeValue(element.getMinimumInformationLoss()) / 100d);
  }
}
}
;
decorator.addDecoratorListener(new DecoratorListener(){
@Override public void disposed(){
  gradient.dispose();
}
}
);
return decorator;
}","/** 
 * Creates a background decorator
 * @return
 */
private DecoratorColor<ARXNode> createDecoratorBackgroundColor(){
  final Gradient gradient=new GradientHeatscale(tiles);
  final Color gray=new Color(tiles.getDisplay(),160,160,160);
  DecoratorColor<ARXNode> decorator=new DecoratorColor<ARXNode>(){
    @Override public Color decorate(    ARXNode element){
switch (element.getAnonymity()) {
case NOT_ANONYMOUS:
case UNKNOWN:
case PROBABLY_NOT_ANONYMOUS:
        return gray;
default :
      return gradient.getColor(asRelativeValue(element.getMinimumInformationLoss()) / 100d);
  }
}
}
;
decorator.addDecoratorListener(new DecoratorListener(){
@Override public void disposed(){
  gradient.dispose();
  gray.dispose();
}
}
);
return decorator;
}",0.6492793411118737
108288,"/** 
 * Resets the view.
 */
@Override public void reset(){
  tiles.setRedraw(false);
  tiles.setItems(new ArrayList<ARXNode>());
  tiles.setRedraw(true);
  tiles.setFilter(new Filter<ARXNode>(){
    public boolean accepts(    ARXNode arg0){
      return true;
    }
  }
);
  tiles.update();
  SWTUtil.disable(tiles);
}","/** 
 * Resets the view.
 */
@Override public void reset(){
  tiles.setRedraw(false);
  tiles.setItems(new ArrayList<ARXNode>());
  tiles.setRedraw(true);
  tiles.setFilter(new Filter<ARXNode>(){
    public boolean accepts(    ARXNode arg0){
      return true;
    }
  }
);
  tiles.update();
  final int index=(levels[level].length - 1 - levelsize[level]);
  SWTUtil.disable(tiles);
}",0.907539118065434
108289,"@Override public void disposed(){
  gradient.dispose();
}","@Override public void disposed(){
  gradient.dispose();
  gray.dispose();
}",0.8636363636363636
108290,"/** 
 * De-serialization.
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.metric=Metric.createMetric(this.metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}","/** 
 * De-serialization.
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.maximumInformationLoss=InformationLoss.createInformationLoss(this.maximumInformationLoss,metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
  this.minimumInformationLoss=InformationLoss.createInformationLoss(this.minimumInformationLoss,metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
  this.metric=Metric.createMetric(this.metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}",0.6739526411657559
108291,"@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  RowSet subset=null;
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criterion=config.getCriteria(DPresence.class);
    if (criterion.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    subset=criterion.iterator().next().getSubset().getSet();
  }
  this.cardinalities=new Cardinalities(input,subset,hierarchies);
  cache=new double[hierarchies.length][];
  for (int i=0; i < cache.length; i++) {
    cache[i]=new double[hierarchies[i].getArray()[0].length];
    Arrays.fill(cache[i],NOT_AVAILABLE);
  }
  final int[][] data=input.getArray();
  this.hierarchies=new int[data[0].length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.hierarchies[i]=hierarchies[i].getArray();
  }
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  for (int i=0; i < max.length; i++) {
    max[i]=input.getDataLength() * log2(hierarchies[i].getArray().length);
  }
  super.setMax(max);
  super.setMin(min);
}","@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  RowSet subset=null;
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criterion=config.getCriteria(DPresence.class);
    if (criterion.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    subset=criterion.iterator().next().getSubset().getSet();
  }
  this.cardinalities=new Cardinalities(input,subset,hierarchies);
  cache=new double[hierarchies.length][];
  for (int i=0; i < cache.length; i++) {
    cache[i]=new double[hierarchies[i].getArray()[0].length];
    Arrays.fill(cache[i],NOT_AVAILABLE);
  }
  final int[][] data=input.getArray();
  this.hierarchies=new int[data[0].length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.hierarchies[i]=hierarchies[i].getArray();
  }
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  for (int i=0; i < max.length; i++) {
    max[i]=input.getDataLength() * log2(input.getDataLength());
  }
  super.setMax(max);
  super.setMin(min);
}",0.9784640390085332
108292,"@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  for (int i=0; i < max.length; i++) {
    max[i]=2d * input.getDataLength() * log2(hierarchies[i].getArray().length);
  }
  super.setMax(max);
  super.setMin(min);
}","@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  for (int i=0; i < max.length; i++) {
    max[i]=2d * input.getDataLength() * log2(input.getDataLength());
  }
  super.setMax(max);
  super.setMin(min);
}",0.9456410256410256
108293,"/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=a;
}","/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=InformationLoss.createInformationLoss(a,metric);
}",0.8402777777777778
108294,"/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=a;
}","/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=InformationLoss.createInformationLoss(a,metric);
}",0.864406779661017
108295,"/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=a;
}","/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=InformationLoss.createInformationLoss(a,metric);
}",0.864406779661017
108296,"/** 
 * Converter method
 * @param other
 * @return
 */
private InformationLossDefault convert(InformationLoss<?> other){
  if (other == null)   return null;
  if (!(other instanceof InformationLossDefault)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    return (InformationLossDefault)other;
  }
}","/** 
 * Converter method
 * @param other
 * @return
 */
private InformationLossDefault convert(InformationLoss<?> other){
  if (other == null)   return null;
  if (!(other instanceof InformationLossDefault)) {
    throw new IllegalStateException(""String_Node_Str"" + this.getClass().getSimpleName() + ""String_Node_Str""+ other.getClass().getSimpleName());
  }
 else {
    return (InformationLossDefault)other;
  }
}",0.8807588075880759
108297,"@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  double _min=convert(min).mean;
  double _max=convert(max).mean;
  if (_max - _min == 0d)   return 0d;
 else   return (this.mean - _min) / (_max - _min);
}","@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  double _min=convert(min).mean;
  double _max=convert(max).mean;
  if (_max - _min == 0d)   return 0d;
  double result=(this.mean - _min) / (_max - _min);
  return result < 0d ? 0d : (result > 1d ? 1d : result);
}",0.8395522388059702
108298,"@Override public void setVisible(boolean value){
  if (value) {
    this.composite.setRedraw(false);
    list.removeAll();
    this.view.setHierarchy(Hierarchy.create());
    if (groups != null) {
      for (      int count : groups) {
        list.add(String.valueOf(count));
      }
    }
    if (hierarchy != null) {
      view.setHierarchy(hierarchy);
    }
    this.composite.setRedraw(true);
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
    Button save=this.wizard.getSaveButton();
    if (save != null)     save.setEnabled(false);
  }
  super.setVisible(value);
}","@Override public void setVisible(boolean value){
  if (value) {
    this.composite.setRedraw(false);
    list.removeAll();
    this.view.setHierarchy(Hierarchy.create());
    if (groups != null) {
      for (      int count : groups) {
        list.add(String.valueOf(count));
      }
    }
    if (hierarchy != null) {
      view.setHierarchy(hierarchy);
    }
    this.composite.layout(true);
    this.composite.setRedraw(true);
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
    Button save=this.wizard.getSaveButton();
    if (save != null)     save.setEnabled(false);
  }
  super.setVisible(value);
}",0.974076983503535
108299,"public void widgetSelected(SelectionEvent arg0){
  double value=knob.getValue();
  label.setText(format.format(value));
  label.setToolTipText(String.valueOf(value));
  if (Double.parseDouble(format.format(value)) == 0d && value > 0d) {
    label.setText(""String_Node_Str"");
  }
  if (Double.parseDouble(format.format(value)) == 1d && value < 1d) {
    label.setText(""String_Node_Str"");
  }
  if (model != null && model.getInputConfig() != null) {
    model.getInputConfig().setAttributeWeight(attribute,value);
  }
}","public void widgetSelected(SelectionEvent arg0){
  double value=knob.getValue();
  label.setText(format.format(value));
  label.setToolTipText(String.valueOf(value));
  try {
    double parsedValue=format.parse(format.format(value)).doubleValue();
    if (parsedValue == 0d && value > 0d) {
      label.setText(""String_Node_Str"");
    }
    if (parsedValue == 1d && value < 1d) {
      label.setText(""String_Node_Str"");
    }
  }
 catch (  ParseException e) {
  }
  if (model != null && model.getInputConfig() != null) {
    model.getInputConfig().setAttributeWeight(attribute,value);
  }
}",0.7750677506775068
108300,"@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.MODEL || event.part == ModelPart.INPUT) {
    this.attributes.clear();
  }
  if (event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      DataDefinition definition=model.getInputDefinition();
      List<String> qis=new ArrayList<String>();
      if (definition != null) {
        Set<String> _qis=definition.getQuasiIdentifyingAttributes();
        if (this.attributes.equals(_qis)) {
          return;
        }
        DataHandle handle=model.getInputConfig().getInput().getHandle();
        for (int i=0; i < handle.getNumColumns(); i++) {
          String attr=handle.getAttributeName(i);
          if (_qis.contains(attr)) {
            qis.add(attr);
          }
        }
        attributes.clear();
        attributes.addAll(qis);
      }
      if (root.isDisposed())       return;
      root.setRedraw(false);
      if (panel != null) {
        panel.dispose();
      }
      panel=new Composite(root,SWT.NONE);
      panel.setLayoutData(GridDataFactory.swtDefaults().grab(true,true).align(SWT.FILL,SWT.CENTER).create());
      panel.setLayout(GridLayoutFactory.swtDefaults().numColumns(qis.size()).margins(0,0).equalWidth(true).create());
      List<Composite> composites=new ArrayList<Composite>();
      for (int i=0; i < qis.size(); i++) {
        Composite c=new Composite(panel,SWT.NONE);
        c.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        c.setLayout(GridLayoutFactory.swtDefaults().numColumns(1).margins(2,0).create());
        composites.add(c);
      }
      for (int i=0; i < qis.size(); i++) {
        Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(qis.get(i));
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
      }
      List<Knob<Double>> knobs=new ArrayList<Knob<Double>>();
      for (int i=0; i < qis.size(); i++) {
        Knob<Double> knob=new Knob<Double>(composites.get(i),SWT.NULL,new KnobRange.Double(0d,1d));
        knob.setLayoutData(GridDataFactory.swtDefaults().grab(false,false).align(SWT.CENTER,SWT.CENTER).hint(30,30).create());
        knob.setDefaultColorProfile(KnobColorProfile.createDefaultSystemProfile(root.getDisplay()));
        knob.setFocusedColorProfile(KnobColorProfile.createFocusedBlueRedProfile(root.getDisplay()));
        knobs.add(knob);
      }
      for (int i=0; i < qis.size(); i++) {
        final Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(""String_Node_Str"");
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        final String attribute=qis.get(i);
        final Knob<Double> knob=knobs.get(i);
        knob.addSelectionListener(new SelectionAdapter(){
          public void widgetSelected(          SelectionEvent arg0){
            double value=knob.getValue();
            label.setText(format.format(value));
            label.setToolTipText(String.valueOf(value));
            if (Double.parseDouble(format.format(value)) == 0d && value > 0d) {
              label.setText(""String_Node_Str"");
            }
            if (Double.parseDouble(format.format(value)) == 1d && value < 1d) {
              label.setText(""String_Node_Str"");
            }
            if (model != null && model.getInputConfig() != null) {
              model.getInputConfig().setAttributeWeight(attribute,value);
            }
          }
        }
);
      }
      for (int i=0; i < qis.size(); i++) {
        if (model != null && model.getInputConfig() != null) {
          knobs.get(i).setValue(model.getInputConfig().getAttributeWeight(qis.get(i)));
        }
      }
      root.setVisible(!qis.isEmpty());
      root.layout(true,true);
      root.setRedraw(true);
    }
  }
}","@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.MODEL || event.part == ModelPart.INPUT) {
    this.attributes.clear();
  }
  if (event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      DataDefinition definition=model.getInputDefinition();
      List<String> qis=new ArrayList<String>();
      if (definition != null) {
        Set<String> _qis=definition.getQuasiIdentifyingAttributes();
        if (this.attributes.equals(_qis)) {
          return;
        }
        DataHandle handle=model.getInputConfig().getInput().getHandle();
        for (int i=0; i < handle.getNumColumns(); i++) {
          String attr=handle.getAttributeName(i);
          if (_qis.contains(attr)) {
            qis.add(attr);
          }
        }
        attributes.clear();
        attributes.addAll(qis);
      }
      if (root.isDisposed())       return;
      root.setRedraw(false);
      if (panel != null) {
        panel.dispose();
      }
      panel=new Composite(root,SWT.NONE);
      panel.setLayoutData(GridDataFactory.swtDefaults().grab(true,true).align(SWT.FILL,SWT.CENTER).create());
      panel.setLayout(GridLayoutFactory.swtDefaults().numColumns(qis.size()).margins(0,0).equalWidth(true).create());
      List<Composite> composites=new ArrayList<Composite>();
      for (int i=0; i < qis.size(); i++) {
        Composite c=new Composite(panel,SWT.NONE);
        c.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        c.setLayout(GridLayoutFactory.swtDefaults().numColumns(1).margins(2,0).create());
        composites.add(c);
      }
      for (int i=0; i < qis.size(); i++) {
        Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(qis.get(i));
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
      }
      List<Knob<Double>> knobs=new ArrayList<Knob<Double>>();
      for (int i=0; i < qis.size(); i++) {
        Knob<Double> knob=new Knob<Double>(composites.get(i),SWT.NULL,new KnobRange.Double(0d,1d));
        knob.setLayoutData(GridDataFactory.swtDefaults().grab(false,false).align(SWT.CENTER,SWT.CENTER).hint(30,30).create());
        knob.setDefaultColorProfile(KnobColorProfile.createDefaultSystemProfile(root.getDisplay()));
        knob.setFocusedColorProfile(KnobColorProfile.createFocusedBlueRedProfile(root.getDisplay()));
        knobs.add(knob);
      }
      for (int i=0; i < qis.size(); i++) {
        final Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(""String_Node_Str"");
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        final String attribute=qis.get(i);
        final Knob<Double> knob=knobs.get(i);
        knob.addSelectionListener(new SelectionAdapter(){
          public void widgetSelected(          SelectionEvent arg0){
            double value=knob.getValue();
            label.setText(format.format(value));
            label.setToolTipText(String.valueOf(value));
            try {
              double parsedValue=format.parse(format.format(value)).doubleValue();
              if (parsedValue == 0d && value > 0d) {
                label.setText(""String_Node_Str"");
              }
              if (parsedValue == 1d && value < 1d) {
                label.setText(""String_Node_Str"");
              }
            }
 catch (            ParseException e) {
            }
            if (model != null && model.getInputConfig() != null) {
              model.getInputConfig().setAttributeWeight(attribute,value);
            }
          }
        }
);
      }
      for (int i=0; i < qis.size(); i++) {
        if (model != null && model.getInputConfig() != null) {
          knobs.get(i).setValue(model.getInputConfig().getAttributeWeight(qis.get(i)));
        }
      }
      root.setVisible(!qis.isEmpty());
      root.layout(true,true);
      root.setRedraw(true);
    }
  }
}",0.9674229940423374
108301,"private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(2));
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  folder=new ComponentTitledFolder(group,controller,bar,null);
  folder.setLayoutData(gd1);
  Composite item1=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionKAnonymity(item1,controller,model);
  Composite item2=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionDPresence(item2,controller,model);
  Composite item3=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionLDiversity(item3,controller,model);
  Composite item4=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionTCloseness(item4,controller,model);
  folder.setSelection(0);
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  enable=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  push=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  pull=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  push.setEnabled(false);
  pull.setEnabled(false);
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  folder2=new ComponentTitledFolder(parent,controller,null,""String_Node_Str"");
  folder2.setLayoutData(gd1);
  group=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(4,false));
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  Composite outliersBase=new Composite(group,SWT.NONE);
  GridData baseData=SWTUtil.createFillHorizontallyGridData();
  baseData.horizontalSpan=3;
  outliersBase.setLayoutData(baseData);
  outliersBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
  labelOutliers=new Label(outliersBase,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(outliersBase,SWT.HORIZONTAL);
  sliderOutliers.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  sliderOutliers.setMaximum(SWTUtil.SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(SWTUtil.sliderToDouble(0d,1d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=3;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label sLabel2=new Label(group,SWT.PUSH);
  sLabel2.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant=new Button(group,SWT.CHECK);
  precomputedVariant.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant.setSelection(false);
  precomputedVariant.setEnabled(false);
  precomputedVariant.setLayoutData(GridDataFactory.swtDefaults().span(1,1).create());
  precomputedVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputed(precomputedVariant.getSelection());
      if (precomputedVariant.getSelection()) {
        precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
        precomputationThreshold.setEnabled(true);
        labelThreshold.setText(String.valueOf((model.getMetricConfiguration().getPrecomputationThreshold())));
      }
 else {
        precomputationThreshold.setEnabled(false);
      }
    }
  }
);
  labelThreshold=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d24=new GridData();
  d24.minimumWidth=LABEL_WIDTH;
  d24.widthHint=LABEL_WIDTH;
  d24.heightHint=LABEL_HEIGHT;
  labelThreshold.setLayoutData(d24);
  labelThreshold.setText(""String_Node_Str"");
  precomputationThreshold=new Scale(group,SWT.HORIZONTAL);
  precomputationThreshold.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  precomputationThreshold.setMaximum(SWTUtil.SLIDER_MAX);
  precomputationThreshold.setMinimum(0);
  precomputationThreshold.setSelection(0);
  precomputationThreshold.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputationThreshold(SWTUtil.sliderToDouble(0d,1d,precomputationThreshold.getSelection()));
      labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
    }
  }
);
  Composite composite1=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  composite1.setLayout(new FillLayout());
  new ViewMetric(composite1,controller,folder2);
  Composite c=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  c.setLayout(new FillLayout());
  clv=new ViewCriteriaList(c,controller);
  folder2.setSelection(0);
  return group;
}","private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(2));
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  folder=new ComponentTitledFolder(group,controller,bar,null);
  folder.setLayoutData(gd1);
  Composite item1=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionKAnonymity(item1,controller,model);
  Composite item2=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionDPresence(item2,controller,model);
  Composite item3=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionLDiversity(item3,controller,model);
  Composite item4=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionTCloseness(item4,controller,model);
  folder.setSelection(0);
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  enable=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  push=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  pull=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  push.setEnabled(false);
  pull.setEnabled(false);
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  folder2=new ComponentTitledFolder(parent,controller,null,""String_Node_Str"");
  folder2.setLayoutData(gd1);
  group=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(4,false));
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  Composite outliersBase=new Composite(group,SWT.NONE);
  GridData baseData=SWTUtil.createFillHorizontallyGridData();
  baseData.horizontalSpan=3;
  outliersBase.setLayoutData(baseData);
  outliersBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
  labelOutliers=new Label(outliersBase,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(outliersBase,SWT.HORIZONTAL);
  sliderOutliers.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  sliderOutliers.setMaximum(SWTUtil.SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(SWTUtil.sliderToDouble(0d,1d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=3;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label sLabel2=new Label(group,SWT.PUSH);
  sLabel2.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant=new Button(group,SWT.CHECK);
  precomputedVariant.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant.setSelection(false);
  precomputedVariant.setEnabled(false);
  precomputedVariant.setLayoutData(GridDataFactory.swtDefaults().span(1,1).create());
  precomputedVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputed(precomputedVariant.getSelection());
      if (precomputedVariant.getSelection()) {
        precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
        precomputationThreshold.setEnabled(true);
        labelThreshold.setText(String.valueOf((model.getMetricConfiguration().getPrecomputationThreshold())));
      }
 else {
        precomputationThreshold.setEnabled(false);
      }
    }
  }
);
  labelThreshold=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d24=new GridData();
  d24.minimumWidth=LABEL_WIDTH;
  d24.widthHint=LABEL_WIDTH;
  d24.heightHint=LABEL_HEIGHT;
  labelThreshold.setLayoutData(d24);
  labelThreshold.setText(""String_Node_Str"");
  precomputationThreshold=new Scale(group,SWT.HORIZONTAL);
  precomputationThreshold.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  precomputationThreshold.setMaximum(SWTUtil.SLIDER_MAX);
  precomputationThreshold.setMinimum(0);
  precomputationThreshold.setSelection(0);
  precomputationThreshold.setEnabled(false);
  precomputationThreshold.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputationThreshold(SWTUtil.sliderToDouble(0d,1d,precomputationThreshold.getSelection()));
      labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
    }
  }
);
  Composite composite1=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  composite1.setLayout(new FillLayout());
  new ViewMetric(composite1,controller,folder2);
  Composite c=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  c.setLayout(new FillLayout());
  clv=new ViewCriteriaList(c,controller);
  folder2.setSelection(0);
  return group;
}",0.9970520799213888
108302,"/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setEnabled(true);
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
}","/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
}",0.990590248075278
108303,"private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  d2.grabExcessVerticalSpace=true;
  d2.verticalAlignment=GridData.CENTER;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.horizontalSpan=3;
  d30.verticalAlignment=GridData.CENTER;
  d30.grabExcessVerticalSpace=true;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  d22.grabExcessVerticalSpace=true;
  d22.verticalAlignment=GridData.CENTER;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  d23.grabExcessVerticalSpace=true;
  d23.verticalAlignment=GridData.CENTER;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.READ_ONLY);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.horizontalSpan=3;
  d31.grabExcessVerticalSpace=true;
  d31.verticalAlignment=GridData.CENTER;
  comboAggregate.setLayoutData(d31);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}","private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  d2.grabExcessVerticalSpace=true;
  d2.verticalAlignment=GridData.CENTER;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.horizontalSpan=3;
  d30.verticalAlignment=GridData.CENTER;
  d30.grabExcessVerticalSpace=true;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  d22.grabExcessVerticalSpace=true;
  d22.verticalAlignment=GridData.CENTER;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).grab(false,true).align(GridData.BEGINNING,GridData.CENTER).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  d23.grabExcessVerticalSpace=true;
  d23.verticalAlignment=GridData.CENTER;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.READ_ONLY);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.horizontalSpan=3;
  d31.grabExcessVerticalSpace=true;
  d31.verticalAlignment=GridData.CENTER;
  comboAggregate.setLayoutData(d31);
  comboAggregate.setEnabled(false);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}",0.9940298507462688
108304,"/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  MetricConfiguration config=model.getMetricConfiguration();
  MetricDescription description=model.getMetricDescription();
  if (config != null && description != null) {
    if (!description.isMonotonicVariantSupported()) {
      this.monotonicVariant.setSelection(false);
      this.monotonicVariant.setEnabled(false);
    }
 else {
      this.monotonicVariant.setEnabled(true);
      this.monotonicVariant.setSelection(config.isMonotonic());
    }
    if (model == null || model.getInputDefinition() == null || model.getInputConfig() == null || model.getInputDefinition().getQuasiIdentifyingAttributes().isEmpty() || !description.isAttributeWeightsSupported()) {
      hideSettingsAttributeWeights();
      hideSettingsCodingModel();
    }
 else {
      showSettingsAttributeWeights();
      if (description.isConfigurableCodingModelSupported()) {
        showSettingsCodingModel();
      }
 else {
        hideSettingsCodingModel();
      }
    }
    comboAggregate.removeAll();
    int index=0;
    int selected=-1;
    for (    AggregateFunction function : description.getSupportedAggregateFunctions()) {
      comboAggregate.add(function.toString());
      if (function.toString().equals(config.getAggregateFunction().toString())) {
        selected=index;
      }
      index++;
    }
    if (selected != -1) {
      comboAggregate.select(selected);
    }
    comboAggregate.setEnabled(!description.getSupportedAggregateFunctions().isEmpty());
  }
 else {
    reset();
  }
  root.setRedraw(true);
}","/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  MetricConfiguration config=model.getMetricConfiguration();
  MetricDescription description=model.getMetricDescription();
  if (config != null && description != null) {
    if (!description.isMonotonicVariantSupported()) {
      this.monotonicVariant.setSelection(false);
      this.monotonicVariant.setEnabled(false);
    }
 else {
      this.monotonicVariant.setEnabled(true);
      this.monotonicVariant.setSelection(config.isMonotonic());
    }
    if (model == null || model.getInputDefinition() == null || model.getInputConfig() == null || model.getInputDefinition().getQuasiIdentifyingAttributes().isEmpty() || !description.isAttributeWeightsSupported()) {
      hideSettingsAttributeWeights();
      hideSettingsCodingModel();
    }
 else {
      showSettingsAttributeWeights();
      if (description.isConfigurableCodingModelSupported()) {
        showSettingsCodingModel();
      }
 else {
        hideSettingsCodingModel();
      }
    }
    comboAggregate.removeAll();
    int index=0;
    int selected=-1;
    for (    AggregateFunction function : description.getSupportedAggregateFunctions()) {
      comboAggregate.add(function.toString());
      if (function.toString().equals(config.getAggregateFunction().toString())) {
        selected=index;
      }
      index++;
    }
    if (selected != -1) {
      comboAggregate.select(selected);
    }
    if (comboAggregate.getItemCount() == 0) {
      comboAggregate.add(""String_Node_Str"");
      comboAggregate.select(0);
    }
  }
 else {
    reset();
  }
  root.setRedraw(true);
}",0.95402635431918
108305,"private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(2));
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  folder=new ComponentTitledFolder(group,controller,bar,null);
  folder.setLayoutData(gd1);
  Composite item1=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionKAnonymity(item1,controller,model);
  Composite item2=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionDPresence(item2,controller,model);
  Composite item3=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionLDiversity(item3,controller,model);
  Composite item4=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionTCloseness(item4,controller,model);
  folder.setSelection(0);
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  enable=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  push=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  pull=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  push.setEnabled(false);
  pull.setEnabled(false);
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  folder2=new ComponentTitledFolder(parent,controller,null,""String_Node_Str"");
  folder2.setLayoutData(gd1);
  group=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(4,false));
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  labelOutliers=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(group,SWT.HORIZONTAL);
  GridData d3=SWTUtil.createFillHorizontallyGridData();
  d3.horizontalSpan=2;
  sliderOutliers.setLayoutData(d3);
  sliderOutliers.setMaximum(SWTUtil.SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(SWTUtil.sliderToDouble(0d,1d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=3;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label sLabel2=new Label(group,SWT.PUSH);
  sLabel2.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant=new Button(group,SWT.CHECK);
  precomputedVariant.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant.setSelection(false);
  precomputedVariant.setEnabled(false);
  precomputedVariant.setLayoutData(GridDataFactory.swtDefaults().span(1,1).create());
  precomputedVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputed(precomputedVariant.getSelection());
      if (precomputedVariant.getSelection()) {
        precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
        precomputationThreshold.setEnabled(true);
        labelThreshold.setText(String.valueOf((model.getMetricConfiguration().getPrecomputationThreshold())));
      }
 else {
        precomputationThreshold.setEnabled(false);
      }
    }
  }
);
  labelThreshold=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d24=new GridData();
  d24.minimumWidth=LABEL_WIDTH;
  d24.widthHint=LABEL_WIDTH;
  d24.heightHint=LABEL_HEIGHT;
  labelThreshold.setLayoutData(d24);
  labelThreshold.setText(""String_Node_Str"");
  precomputationThreshold=new Scale(group,SWT.HORIZONTAL);
  precomputationThreshold.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  precomputationThreshold.setMaximum(SWTUtil.SLIDER_MAX);
  precomputationThreshold.setMinimum(0);
  precomputationThreshold.setSelection(0);
  precomputationThreshold.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputationThreshold(SWTUtil.sliderToDouble(0d,1d,precomputationThreshold.getSelection()));
      labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
    }
  }
);
  Composite composite1=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  composite1.setLayout(new FillLayout());
  new ViewMetric(composite1,controller,folder2);
  Composite c=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  c.setLayout(new FillLayout());
  clv=new ViewCriteriaList(c,controller);
  folder2.setSelection(0);
  return group;
}","private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(2));
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  ComponentTitledFolderButton bar=new ComponentTitledFolderButton(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  folder=new ComponentTitledFolder(group,controller,bar,null);
  folder.setLayoutData(gd1);
  Composite item1=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionKAnonymity(item1,controller,model);
  Composite item2=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionDPresence(item2,controller,model);
  Composite item3=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionLDiversity(item3,controller,model);
  Composite item4=folder.createItem(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""));
  new ViewCriterionTCloseness(item4,controller,model);
  folder.setSelection(0);
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  enable=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  push=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  pull=folder.getButtonItem(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  push.setEnabled(false);
  pull.setEnabled(false);
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  folder2=new ComponentTitledFolder(parent,controller,null,""String_Node_Str"");
  folder2.setLayoutData(gd1);
  group=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  group.setLayoutData(SWTUtil.createFillGridData());
  group.setLayout(SWTUtil.createGridLayout(4,false));
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  Composite outliersBase=new Composite(group,SWT.NONE);
  GridData baseData=SWTUtil.createFillHorizontallyGridData();
  baseData.horizontalSpan=3;
  outliersBase.setLayoutData(baseData);
  outliersBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
  labelOutliers=new Label(outliersBase,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(outliersBase,SWT.HORIZONTAL);
  sliderOutliers.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  sliderOutliers.setMaximum(SWTUtil.SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(SWTUtil.sliderToDouble(0d,1d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=3;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label sLabel2=new Label(group,SWT.PUSH);
  sLabel2.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant=new Button(group,SWT.CHECK);
  precomputedVariant.setText(Resources.getMessage(""String_Node_Str""));
  precomputedVariant.setSelection(false);
  precomputedVariant.setEnabled(false);
  precomputedVariant.setLayoutData(GridDataFactory.swtDefaults().span(1,1).create());
  precomputedVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputed(precomputedVariant.getSelection());
      if (precomputedVariant.getSelection()) {
        precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
        precomputationThreshold.setEnabled(true);
        labelThreshold.setText(String.valueOf((model.getMetricConfiguration().getPrecomputationThreshold())));
      }
 else {
        precomputationThreshold.setEnabled(false);
      }
    }
  }
);
  labelThreshold=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d24=new GridData();
  d24.minimumWidth=LABEL_WIDTH;
  d24.widthHint=LABEL_WIDTH;
  d24.heightHint=LABEL_HEIGHT;
  labelThreshold.setLayoutData(d24);
  labelThreshold.setText(""String_Node_Str"");
  precomputationThreshold=new Scale(group,SWT.HORIZONTAL);
  precomputationThreshold.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  precomputationThreshold.setMaximum(SWTUtil.SLIDER_MAX);
  precomputationThreshold.setMinimum(0);
  precomputationThreshold.setSelection(0);
  precomputationThreshold.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setPrecomputationThreshold(SWTUtil.sliderToDouble(0d,1d,precomputationThreshold.getSelection()));
      labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
    }
  }
);
  Composite composite1=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  composite1.setLayout(new FillLayout());
  new ViewMetric(composite1,controller,folder2);
  Composite c=folder2.createItem(Resources.getMessage(""String_Node_Str""),null);
  c.setLayout(new FillLayout());
  clv=new ViewCriteriaList(c,controller);
  folder2.setSelection(0);
  return group;
}",0.9734276939511284
108306,"/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    root.setRedraw(true);
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setEnabled(true);
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
  root.setRedraw(true);
}","/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setEnabled(true);
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
}",0.9843587069864442
108307,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    updateControlls();
    root.setRedraw(true);
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    updateControlls();
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}",0.9673846153846154
108308,"/** 
 * @return the heights
 */
protected int[] getHeights(){
  return height;
}","/** 
 * @return the heights
 */
protected int[] getHeights(){
  return maxLevels;
}",0.9202453987730062
108309,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  height=new int[hierarchies.length];
  for (int j=0; j < height.length; j++) {
    height[j]=hierarchies[j].getArray()[0].length - 1;
  }
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  maxLevels=new int[hierarchies.length];
  for (int j=0; j < maxLevels.length; j++) {
    maxLevels[j]=hierarchies[j].getArray()[0].length - 1;
  }
}",0.940554821664465
108310,"@Override protected InformationLossWithBound<InformationLossDefault> getInformationLossInternal(final Node node,final IHashGroupify g){
  double result=0;
  final int[] transformation=node.getTransformation();
  for (int i=0; i < transformation.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double level=(double)transformation[i];
    result+=height[i] == 0 ? 0 : (level / (double)height[i]) * weight;
  }
  result/=(double)transformation.length;
  return new InformationLossDefaultWithBound(result,result);
}","@Override protected InformationLossWithBound<InformationLossDefault> getInformationLossInternal(final Node node,final IHashGroupify g){
  double result=0;
  final int[] transformation=node.getTransformation();
  for (int i=0; i < transformation.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double level=(double)transformation[i];
    result+=maxLevels[i] == 0 ? 0 : (level / (double)maxLevels[i]) * weight;
  }
  result/=(double)transformation.length;
  return new InformationLossDefaultWithBound(result,result);
}",0.9721189591078068
108311,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    root.setRedraw(true);
    updateControlls();
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    updateControlls();
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}",0.9673846153846154
108312,"/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    root.setRedraw(true);
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setEnabled(true);
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
  root.setRedraw(true);
}","/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  ModelCriterion mc=null;
  if (folder.getSelectionIndex() == 0) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getKAnonymityModel();
  }
 else   if (folder.getSelectionIndex() == 1) {
    push.setEnabled(false);
    pull.setEnabled(false);
    mc=model.getDPresenceModel();
  }
 else   if (folder.getSelectionIndex() == 2) {
    mc=model.getLDiversityModel().get(model.getSelectedAttribute());
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
 else   if (folder.getSelectionIndex() == 3) {
    mc=model.getTClosenessModel().get(model.getSelectedAttribute());
    push.setEnabled(true);
    pull.setEnabled(true);
    if (mc != null && mc.isActive() && mc.isEnabled()) {
      push.setEnabled(true);
      pull.setEnabled(true);
    }
 else {
      push.setEnabled(false);
      pull.setEnabled(false);
    }
  }
  if (mc == null) {
    return;
  }
  if (mc.isActive()) {
    enable.setEnabled(true);
    if (mc.isEnabled()) {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
 else {
      enable.setImage(controller.getResources().getImage(""String_Node_Str""));
    }
  }
 else {
    enable.setEnabled(false);
    enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  }
  this.precomputedVariant.setEnabled(true);
  this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
  if (model.getMetricConfiguration().isPrecomputed()) {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(true);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
 else {
    this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
    this.precomputationThreshold.setEnabled(false);
    this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
  }
}",0.9843587069864442
108313,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    updateControlls();
    root.setRedraw(true);
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(SWTUtil.doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    root.setRedraw(true);
    updateControlls();
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.METRIC) {
    if (model != null) {
      updateControlls();
    }
  }
}",0.9690107270560192
108314,"/** 
 * Creates a new instance
 * @param display
 * @throws IOException
 */
public MainSplash(Display display,Monitor monitor){
  this.version=Resources.getVersion();
  this.splash=Resources.getSplash(display);
  this.shell=new Shell(SWT.ON_TOP | SWT.NO_TRIM);
  this.shell.setImages(Resources.getIconSet(display));
  this.shell.setSize(splash.getBounds().width,splash.getBounds().height);
  SWTUtil.center(shell,monitor);
  shell.addPaintListener(new PaintListener(){
    public void paintControl(    PaintEvent arg0){
      paint(arg0.gc);
    }
  }
);
}","/** 
 * Creates a new instance
 * @param display
 * @throws IOException
 */
public MainSplash(Display display,Monitor monitor){
  this.version=Resources.getVersion();
  this.splash=Resources.getSplash(display);
  this.shell=new Shell(SWT.ON_TOP | (isMac() ? 0 : SWT.NO_TRIM));
  this.shell.setImages(Resources.getIconSet(display));
  this.shell.setSize(splash.getBounds().width,splash.getBounds().height);
  SWTUtil.center(shell,monitor);
  shell.addPaintListener(new PaintListener(){
    public void paintControl(    PaintEvent arg0){
      paint(arg0.gc);
    }
  }
);
}",0.9858156028368794
108315,"@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=0d;
  for (int i=0; i < values.length; i++) {
    result+=values[i] * weights[i];
  }
  return result;
}","@Override protected double getAggregate(){
  double[] values=getValues();
  double[] weights=getWeights();
  double result=0d;
  for (int i=0; i < values.length; i++) {
    result+=values[i] * weights[i];
  }
  if (Double.isInfinite(result) || Double.isNaN(result)) {
    result=Double.MAX_VALUE;
  }
  return result;
}",0.7765567765567766
108316,"/** 
 * Internal method for loading a project
 * @param path
 */
public void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError().getMessage());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final List<ARXNode> tempClipboard=model.getClipboard().getClipboardEntries();
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clearClipboard();
    model.getClipboard().addAllToClipboard(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard().getClipboardEntries()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}","/** 
 * Internal method for loading a project
 * @param path
 */
public void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    String message=worker.getError().getMessage();
    if (message == null || message.equals(""String_Node_Str"")) {
      message=""String_Node_Str"" + worker.getError().getClass().getSimpleName();
    }
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final List<ARXNode> tempClipboard=model.getClipboard().getClipboardEntries();
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clearClipboard();
    model.getClipboard().addAllToClipboard(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard().getClipboardEntries()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}",0.9670724958494744
108317,"/** 
 * Converts the slider value to an integer
 * @param min
 * @param max
 * @param value
 * @return
 */
public static int sliderToInt(final int min,final int max,final int value){
  int val=(int)Math.round(((double)value / (double)SLIDER_MAX) * max);
  if (val < min) {
    val=min;
  }
  if (val > max) {
    val=max;
  }
  return val;
}","/** 
 * Converts the slider value to an integer
 * @param min
 * @param max
 * @param value
 * @return
 */
public static int sliderToInt(final int min,final int max,final int value){
  return (int)Math.round(sliderToDouble(min,max,value));
}",0.7319587628865979
108318,"/** 
 * Converts the double value to a slider selection
 */
public static int doubleToSlider(final double min,final double max,final double value){
  double val=((value - min) / max) * SLIDER_MAX;
  val=Math.round(val * SLIDER_MAX) / (double)SLIDER_MAX;
  if (val < 0) {
    val=0;
  }
  if (val > SLIDER_MAX) {
    val=SLIDER_MAX;
  }
  return (int)val;
}","/** 
 * Converts the double value to a slider selection
 */
public static int doubleToSlider(final double min,final double max,final double value){
  int val=(int)Math.round((value - min) / (max - min) * SLIDER_MAX);
  if (val < 0) {
    val=0;
  }
  if (val > SLIDER_MAX) {
    val=SLIDER_MAX;
  }
  return val;
}",0.8597014925373134
108319,"/** 
 * Converts the slider value to a double
 * @param min
 * @param max
 * @param value
 * @return
 */
public static double sliderToDouble(final double min,final double max,final int value){
  double val=((double)value / (double)SLIDER_MAX) * max;
  val=Math.round(val * SLIDER_MAX) / (double)SLIDER_MAX;
  if (val < min) {
    val=min;
  }
  if (val > max) {
    val=max;
  }
  return val;
}","/** 
 * Converts the slider value to a double
 * @param min
 * @param max
 * @param value
 * @return
 */
public static double sliderToDouble(final double min,final double max,final int value){
  double val=((double)value / (double)SLIDER_MAX) * (max - min) + min;
  if (val < min) {
    val=min;
  }
  if (val > max) {
    val=max;
  }
  return val;
}",0.7543624161073825
108320,"/** 
 * Converts the integer value to a slider selection
 * @param min
 * @param max
 * @param value
 * @return
 */
public static int intToSlider(final int min,final int max,final int value){
  int val=(int)Math.round(((double)(value - min) / (double)max) * SLIDER_MAX);
  if (val < 0) {
    val=0;
  }
  if (val > SLIDER_MAX) {
    val=SLIDER_MAX;
  }
  return val;
}","/** 
 * Converts the integer value to a slider selection
 * @param min
 * @param max
 * @param value
 * @return
 */
public static int intToSlider(final int min,final int max,final int value){
  return doubleToSlider(min,max,value);
}",0.6722129783693843
108321,"@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),8);
  try {
    final ZipFile zip=zipfile;
    readMetadata(zip);
    arg0.worked(1);
    readModel(zip);
    arg0.worked(1);
    final Map<String,ARXNode> map=readLattice(zip);
    arg0.worked(1);
    readClipboard(map,zip);
    arg0.worked(1);
    readFilter(zip);
    arg0.worked(1);
    readConfiguration(map,zip);
    arg0.worked(1);
    zip.close();
    arg0.worked(1);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    error=e;
    arg0.done();
    return;
  }
  result=model;
  arg0.worked(1);
  arg0.done();
}","@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),8);
  try {
    final ZipFile zip=zipfile;
    readMetadata(zip);
    arg0.worked(1);
    readModel(zip);
    arg0.worked(1);
    final Map<String,ARXNode> map=readLattice(zip);
    arg0.worked(1);
    readClipboard(map,zip);
    arg0.worked(1);
    readFilter(zip);
    arg0.worked(1);
    readConfiguration(map,zip);
    arg0.worked(1);
    setMonotonicity();
    zip.close();
    arg0.worked(1);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    error=e;
    arg0.done();
    return;
  }
  result=model;
  arg0.worked(1);
  arg0.done();
}",0.983859649122807
108322,"/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  config.setMetric(Metric.createMetric(config.getMetric(),ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL,ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL));
  config.getConfig().setMetric(Metric.createMetric(config.getConfig().getMetric(),ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL,ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL));
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
    readDefinition(config,model.getInputDefinition(),prefix,zip);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
    DataDefinition definition=new DataDefinition();
    readDefinition(config,definition,prefix,zip);
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),definition,lattice,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}","/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  config.setMetric(Metric.createMetric(config.getMetric(),ARXLattice.getDeserializationContext().minLevel,ARXLattice.getDeserializationContext().maxLevel));
  config.getConfig().setMetric(Metric.createMetric(config.getConfig().getMetric(),ARXLattice.getDeserializationContext().minLevel,ARXLattice.getDeserializationContext().maxLevel));
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
    readDefinition(config,model.getInputDefinition(),prefix,zip);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
    DataDefinition definition=new DataDefinition();
    readDefinition(config,definition,prefix,zip);
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),definition,lattice,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}",0.9465680230168516
108323,"/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss<?>> max;
  final Map<Integer,InformationLoss<?>> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss<?>>)oos.readObject();
  max=(Map<Integer,InformationLoss<?>>)oos.readObject();
  oos.close();
  final int[] minMax=readMinMax(zip);
  ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL=minMax[0];
  ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL=minMax[1];
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  int bottomLevel=Integer.MAX_VALUE;
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
    if (!e.getValue().isEmpty()) {
      bottomLevel=Math.min(e.getKey(),bottomLevel);
    }
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[bottomLevel][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}","/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss<?>> max;
  final Map<Integer,InformationLoss<?>> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss<?>>)oos.readObject();
  max=(Map<Integer,InformationLoss<?>>)oos.readObject();
  oos.close();
  final int[] minMax=readMinMax(zip);
  ARXLattice.getDeserializationContext().minLevel=minMax[0];
  ARXLattice.getDeserializationContext().maxLevel=minMax[1];
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  int bottomLevel=Integer.MAX_VALUE;
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
    if (!e.getValue().isEmpty()) {
      bottomLevel=Math.min(e.getKey(),bottomLevel);
    }
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[bottomLevel][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}",0.9920440636474908
108324,"/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}","/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=InformationLoss.createInformationLoss(a,metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}",0.726890756302521
108325,"/** 
 * De-serialization
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.metric=Metric.createMetric(this.metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}","/** 
 * De-serialization
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.metric=Metric.createMetric(this.metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}",0.819672131147541
108326,"/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}","/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=InformationLoss.createInformationLoss(a,metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}",0.7601476014760148
108327,"/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}","/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=InformationLoss.createInformationLoss(a,metric,getDeserializationContext().minLevel,getDeserializationContext().maxLevel);
}",0.7601476014760148
108328,"@Override protected boolean start(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  if (vocabulary.isMetadata(localName) || vocabulary.isVersion(localName) || vocabulary.isVocabulary(localName)) {
    return true;
  }
 else {
    return false;
  }
}","@Override protected boolean start(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  if (vocabulary.isLevel(localName)) {
    int level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
    result[0]=Math.min(result[0],level);
    result[1]=Math.max(result[1],level);
  }
  return true;
}",0.5216095380029806
108329,"/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  config.setMetric(Metric.createMetric(config.getMetric()));
  config.getConfig().setMetric(Metric.createMetric(config.getConfig().getMetric()));
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
    readDefinition(config,model.getInputDefinition(),prefix,zip);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
    DataDefinition definition=new DataDefinition();
    readDefinition(config,definition,prefix,zip);
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),definition,lattice,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}","/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  config.setMetric(Metric.createMetric(config.getMetric(),ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL,ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL));
  config.getConfig().setMetric(Metric.createMetric(config.getConfig().getMetric(),ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL,ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL));
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
    readDefinition(config,model.getInputDefinition(),prefix,zip);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
    DataDefinition definition=new DataDefinition();
    readDefinition(config,definition,prefix,zip);
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),definition,lattice,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}",0.9422336328626444
108330,"/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss<?>> max;
  final Map<Integer,InformationLoss<?>> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss<?>>)oos.readObject();
  max=(Map<Integer,InformationLoss<?>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  int bottomLevel=Integer.MAX_VALUE;
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
    if (!e.getValue().isEmpty()) {
      bottomLevel=Math.min(e.getKey(),bottomLevel);
    }
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[bottomLevel][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}","/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss<?>> max;
  final Map<Integer,InformationLoss<?>> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss<?>>)oos.readObject();
  max=(Map<Integer,InformationLoss<?>>)oos.readObject();
  oos.close();
  final int[] minMax=readMinMax(zip);
  ARXLattice.DESERIALIZATION_CONTEXT_MIN_LEVEL=minMax[0];
  ARXLattice.DESERIALIZATION_CONTEXT_MAX_LEVEL=minMax[1];
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  int bottomLevel=Integer.MAX_VALUE;
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
    if (!e.getValue().isEmpty()) {
      bottomLevel=Math.min(e.getKey(),bottomLevel);
    }
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[bottomLevel][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}",0.9904820766378244
108331,"@Override protected boolean end(final String uri,final String localName,final String qName) throws SAXException {
  if (vocabulary.isMetadata(localName)) {
    if (vocabularyVersion == null) {
      vocabularyVersion=""String_Node_Str"";
    }
    WorkerLoad.this.vocabulary=Vocabulary.forVersion(vocabularyVersion);
    WorkerLoad.this.vocabulary.checkVersion(version);
  }
 else   if (vocabulary.isVersion(localName)) {
    version=payload;
  }
 else   if (vocabulary.isVocabulary(localName)) {
    vocabularyVersion=payload;
  }
 else {
    return false;
  }
  return true;
}","@Override protected boolean end(final String uri,final String localName,final String qName) throws SAXException {
  return true;
}",0.3682719546742209
108332,"/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=InformationLoss.createInformationLoss(a,metric);
}","/** 
 * Sets the lower bound
 * @return
 */
public void setLowerBound(final InformationLoss<?> a){
  node.lowerBound=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}",0.8308457711442786
108333,"/** 
 * De-serialization
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.metric=Metric.createMetric(this.metric);
}","/** 
 * De-serialization
 * @param aInputStream
 * @throws ClassNotFoundException
 * @throws IOException
 */
private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {
  aInputStream.defaultReadObject();
  this.metric=Metric.createMetric(this.metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}",0.8966565349544073
108334,"/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=InformationLoss.createInformationLoss(a,metric);
}","/** 
 * Sets the minimal information loss
 * @return
 */
public void setMinimumInformationLoss(final InformationLoss<?> a){
  node.minInformationLoss=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}",0.8547008547008547
108335,"/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=InformationLoss.createInformationLoss(a,metric);
}","/** 
 * Sets the maximal information loss
 * @return
 */
public void setMaximumInformationLoss(final InformationLoss<?> a){
  node.maxInformationLoss=InformationLoss.createInformationLoss(a,metric,DESERIALIZATION_CONTEXT_MIN_LEVEL,DESERIALIZATION_CONTEXT_MAX_LEVEL);
}",0.8547008547008547
108336,"/** 
 * Converter method, converting information loss from version 1 to information loss from version 2, if necessary
 * @param loss
 * @param metric
 * @return
 */
public static InformationLoss<?> createInformationLoss(InformationLoss<?> loss,Metric<?> metric){
  Metric<?> _metric=Metric.createMetric(metric);
  if (loss instanceof InformationLossDefault) {
    if (_metric instanceof AbstractMetricSingleDimensional) {
      return __MetricV2.createILSingleDimensional(((InformationLossDefault)loss).getValue());
    }
 else     if (_metric instanceof AbstractMetricMultiDimensional) {
      if (_metric instanceof MetricMDNUEntropyPrecomputed) {
        return __MetricV2.createILMultiDimensionalSum(((InformationLossDefault)loss).getValue());
      }
 else       if (_metric instanceof MetricMDHeight) {
        return __MetricV2.createILMultiDimensionalSum(((InformationLossDefault)loss).getValue());
      }
 else       if (_metric instanceof MetricMDNMPrecision) {
        return __MetricV2.createILMultiDimensionalArithmeticMean(((InformationLossDefault)loss).getValue());
      }
    }
  }
  return loss;
}","/** 
 * Converter method, converting information loss from version 1 to information loss from version 2, if necessary
 * @param loss
 * @param metric
 * @param minLevel
 * @param maxLevel
 * @return
 */
public static InformationLoss<?> createInformationLoss(InformationLoss<?> loss,Metric<?> metric,int minLevel,int maxLevel){
  Metric<?> _metric=Metric.createMetric(metric,minLevel,maxLevel);
  if (loss instanceof InformationLossDefault) {
    if (_metric instanceof AbstractMetricSingleDimensional) {
      return __MetricV2.createILSingleDimensional(((InformationLossDefault)loss).getValue());
    }
 else     if (_metric instanceof AbstractMetricMultiDimensional) {
      if (_metric instanceof MetricMDNUEntropyPrecomputed) {
        return __MetricV2.createILMultiDimensionalSum(((InformationLossDefault)loss).getValue());
      }
 else       if (_metric instanceof MetricMDHeight) {
        return __MetricV2.createILMultiDimensionalSum(((InformationLossDefault)loss).getValue());
      }
 else       if (_metric instanceof MetricMDNMPrecision) {
        return __MetricV2.createILMultiDimensionalArithmeticMean(((InformationLossDefault)loss).getValue());
      }
    }
  }
  return loss;
}",0.9645635263612792
108337,"/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  if (result == null || result.getLattice() == null)   return;
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      SWTUtil.enable(table);
      for (      final TableItem i : table.getItems()) {
        i.dispose();
      }
      list.clear();
      final ARXLattice l=result.getLattice();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(result.getLattice(),node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      table.setRedraw(true);
    }
  }
);
}","/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  if (result == null || result.getLattice() == null)   return;
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      SWTUtil.enable(table);
      for (      final TableItem i : table.getItems()) {
        i.dispose();
      }
      list.clear();
      final ARXLattice l=result.getLattice();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(result.getLattice(),node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      TableColumn[] colums=table.getColumns();
      for (      TableColumn tableColumn : colums) {
        tableColumn.setWidth(120);
      }
      table.setRedraw(true);
    }
  }
);
}",0.957069948964275
108338,"@Override public void run(){
  table.setRedraw(false);
  SWTUtil.enable(table);
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  list.clear();
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        list.add(node);
      }
    }
  }
  Collections.sort(list,new Comparator<ARXNode>(){
    @Override public int compare(    final ARXNode arg0,    final ARXNode arg1){
      return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
    }
  }
);
  if (list.size() > model.getMaxNodesInViewer()) {
    list.clear();
  }
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
  listener=new Listener(){
    @Override public void handleEvent(    final Event event){
      final TableItem item=(TableItem)event.item;
      final int index=table.indexOf(item);
      createItem(item,index);
    }
  }
;
  table.addListener(SWT.SetData,listener);
  table.setItemCount(list.size());
  table.setRedraw(true);
}","@Override public void run(){
  table.setRedraw(false);
  SWTUtil.enable(table);
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  list.clear();
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(result.getLattice(),node)) {
        list.add(node);
      }
    }
  }
  Collections.sort(list,new Comparator<ARXNode>(){
    @Override public int compare(    final ARXNode arg0,    final ARXNode arg1){
      return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
    }
  }
);
  if (list.size() > model.getMaxNodesInViewer()) {
    list.clear();
  }
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
  listener=new Listener(){
    @Override public void handleEvent(    final Event event){
      final TableItem item=(TableItem)event.item;
      final int index=table.indexOf(item);
      createItem(item,index);
    }
  }
;
  table.addListener(SWT.SetData,listener);
  table.setItemCount(list.size());
  TableColumn[] colums=table.getColumns();
  for (  TableColumn tableColumn : colums) {
    tableColumn.setWidth(120);
  }
  table.setRedraw(true);
}",0.9476818375159508
108339,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  weights=new double[hierarchies.length];
  double total=0d;
  for (int i=0; i < hierarchies.length; i++) {
    String attribute=hierarchies[i].getName();
    double weight=config.getAttributeWeight(attribute);
    weights[i]=weight;
    total+=weight;
  }
  if (total == 0d) {
    Arrays.fill(weights,1d);
  }
 else {
    for (int i=0; i < weights.length; i++) {
      weights[i]/=total;
    }
  }
  dimensions=hierarchies.length;
  this.min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  this.max=new double[min.length];
  Arrays.fill(max,Double.MAX_VALUE);
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  weights=new double[hierarchies.length];
  double maximum=0d;
  for (int i=0; i < hierarchies.length; i++) {
    String attribute=hierarchies[i].getName();
    double weight=config.getAttributeWeight(attribute);
    weights[i]=weight;
    maximum=Math.max(maximum,weight);
  }
  if (maximum == 0d) {
    Arrays.fill(weights,1d);
  }
 else {
    for (int i=0; i < weights.length; i++) {
      weights[i]/=maximum;
    }
  }
  dimensions=hierarchies.length;
  this.min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  this.max=new double[min.length];
  Arrays.fill(max,Double.MAX_VALUE);
}",0.9461794019933556
108340,"@SuppressWarnings(""String_Node_Str"") @Test public void testNMEntropy() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(5));
  config.addCriterion(new Inclusion(subset));
  config.setMaxOutliers(0.02d);
  config.setMetric(Metric.createEntropyMetric(false));
  ARXAnonymizer anonymizer=new ARXAnonymizer();
  ARXResult result=anonymizer.anonymize(data,config);
  result.getOutput(false).sort(true,new int[]{0,1,2,3,4});
  ARXLattice lattice=result.getLattice();
  for (  ARXNode[] level : lattice.getLevels()) {
    for (    ARXNode node : level) {
      if (Double.compare(((InformationLoss<Double>)node.getMinimumInformationLoss()).getValue(),Double.NaN) == 0 || Double.compare(((InformationLoss<Double>)node.getMaximumInformationLoss()).getValue(),Double.NaN) == 0) {
        fail();
      }
    }
  }
}","@Test public void testNMEntropy() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(5));
  config.addCriterion(new Inclusion(subset));
  config.setMaxOutliers(0.02d);
  config.setMetric(Metric.createEntropyMetric(false));
  ARXAnonymizer anonymizer=new ARXAnonymizer();
  ARXResult result=anonymizer.anonymize(data,config);
  result.getOutput(false).sort(true,new int[]{0,1,2,3,4});
  ARXLattice lattice=result.getLattice();
  for (  ARXNode[] level : lattice.getLevels()) {
    for (    ARXNode node : level) {
      if (Double.compare((Double.valueOf(node.getMinimumInformationLoss().toString())),Double.NaN) == 0 || Double.compare((Double.valueOf(node.getMaximumInformationLoss().toString())),Double.NaN) == 0) {
        fail();
      }
    }
  }
}",0.9557183816502072
108341,"private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.verticalAlignment=SWT.CENTER;
  d30.horizontalSpan=3;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.NULL);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.verticalAlignment=SWT.CENTER;
  d31.horizontalSpan=3;
  comboAggregate.setLayoutData(d31);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}","private Composite build(final Composite parent){
  final Composite mBase=new Composite(parent,SWT.NONE);
  mBase.setLayout(GridLayoutFactory.swtDefaults().numColumns(4).create());
  final Label mLabel=new Label(mBase,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  GridData d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  mLabel.setLayoutData(d2);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.verticalAlignment=SWT.CENTER;
  d30.horizontalSpan=3;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(METRICS.get(comboMetric.getSelectionIndex()));
      }
    }
  }
);
  final Label mLabel2=new Label(mBase,SWT.PUSH);
  mLabel2.setText(Resources.getMessage(""String_Node_Str""));
  GridData d22=new GridData();
  d22.heightHint=LABEL_HEIGHT;
  d22.minimumHeight=LABEL_HEIGHT;
  mLabel2.setLayoutData(d22);
  monotonicVariant=new Button(mBase,SWT.CHECK);
  monotonicVariant.setText(Resources.getMessage(""String_Node_Str""));
  monotonicVariant.setSelection(false);
  monotonicVariant.setEnabled(false);
  monotonicVariant.setLayoutData(GridDataFactory.swtDefaults().span(3,1).create());
  monotonicVariant.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getMetricConfiguration().setMonotonic(monotonicVariant.getSelection());
    }
  }
);
  final Label mLabel3=new Label(mBase,SWT.PUSH);
  mLabel3.setText(Resources.getMessage(""String_Node_Str""));
  GridData d23=new GridData();
  d23.heightHint=LABEL_HEIGHT;
  d23.minimumHeight=LABEL_HEIGHT;
  mLabel3.setLayoutData(d23);
  comboAggregate=new Combo(mBase,SWT.READ_ONLY);
  GridData d31=SWTUtil.createFillHorizontallyGridData();
  d31.verticalAlignment=SWT.CENTER;
  d31.horizontalSpan=3;
  comboAggregate.setLayoutData(d31);
  comboAggregate.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      String selected=comboAggregate.getItem(comboAggregate.getSelectionIndex());
      for (      AggregateFunction function : model.getMetricDescription().getSupportedAggregateFunctions()) {
        if (function.toString().equals(selected)) {
          model.getMetricConfiguration().setAggregateFunction(function);
        }
      }
    }
  }
);
  return mBase;
}",0.9979043627357592
108342,"@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  double[] result=super.getInformationLossInternalRaw(node,g);
  double suppressed=0;
  final IntIntOpenHashMap[] original=new IntIntOpenHashMap[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new IntIntOpenHashMap();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressed+=m.count;
      for (int i=0; i < original.length; i++) {
        original[i].putOrAdd(m.key[i],m.count,m.count);
      }
    }
    m=m.nextOrdered;
  }
  if (suppressed != 0) {
    for (int i=0; i < original.length; i++) {
      IntIntOpenHashMap map=original[i];
      for (int j=0; j < map.allocated.length; j++) {
        if (map.allocated[j]) {
          double count=map.values[j];
          result[i]+=count * log2(count / suppressed);
        }
      }
    }
  }
  for (int column=0; column < result.length; column++) {
    result[column]=round(result[column] == 0.0d ? result[column] : -result[column]);
  }
  return new ILMultiDimensionalWithBound(createInformationLoss(result),createInformationLoss(result));
}","@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  double[] result=super.getInformationLossInternalRaw(node,g);
  double[] bound=new double[result.length];
  System.arraycopy(result,0,bound,0,result.length);
  double suppressed=0;
  final IntIntOpenHashMap[] original=new IntIntOpenHashMap[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new IntIntOpenHashMap();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressed+=m.count;
      for (int i=0; i < original.length; i++) {
        original[i].putOrAdd(m.key[i],m.count,m.count);
      }
    }
    m=m.nextOrdered;
  }
  if (suppressed != 0) {
    for (int i=0; i < original.length; i++) {
      IntIntOpenHashMap map=original[i];
      for (int j=0; j < map.allocated.length; j++) {
        if (map.allocated[j]) {
          double count=map.values[j];
          result[i]+=count * log2(count / suppressed);
        }
      }
    }
  }
  for (int column=0; column < result.length; column++) {
    result[column]=round(result[column] == 0.0d ? result[column] : -result[column]);
  }
  return new ILMultiDimensionalWithBound(createInformationLoss(result),createInformationLoss(bound));
}",0.9579897919120534
108343,"/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  if (model.getMetricConfiguration() != null && model.getMetricDescription() != null) {
    if (!model.getMetricDescription().isMonotonicVariantSupported()) {
      this.monotonicVariant.setSelection(false);
      this.monotonicVariant.setEnabled(false);
    }
 else {
      this.monotonicVariant.setEnabled(true);
      this.monotonicVariant.setSelection(model.getMetricConfiguration().isMonotonic());
    }
    if (!model.getMetricDescription().isPrecomputationSupported()) {
      this.precomputedVariant.setSelection(false);
      this.precomputedVariant.setEnabled(false);
      this.precomputationThreshold.setSelection(0);
      this.precomputationThreshold.setEnabled(false);
      this.labelThreshold.setText(String.valueOf(0d));
    }
 else {
      this.precomputedVariant.setEnabled(true);
      this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
      if (model.getMetricConfiguration().isPrecomputed()) {
        this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getGsFactor()));
        this.precomputationThreshold.setEnabled(true);
        this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getGsFactor()));
      }
 else {
        this.precomputationThreshold.setSelection(0);
        this.precomputationThreshold.setEnabled(false);
        this.labelThreshold.setText(String.valueOf(0d));
      }
    }
    if (model == null || model.getInputDefinition() == null || model.getInputConfig() == null || model.getInputDefinition().getQuasiIdentifyingAttributes().isEmpty() || model.getMetricDescription() == null || !(model.getMetricDescription().isAttributeWeightsSupported())) {
      hideSettingsAttributeWeights();
      hideSettingsCodingModel();
    }
 else {
      showSettingsAttributeWeights();
      if (model.getMetricDescription().isConfigurableCodingModelSupported()) {
        showSettingsCodingModel();
      }
 else {
        hideSettingsCodingModel();
      }
    }
  }
 else {
    reset();
  }
  root.setRedraw(true);
}","/** 
 * This method adjusts the toolbar attached to the folder with criteria according to the current state of the model
 */
private void updateControlls(){
  root.setRedraw(false);
  if (model.getMetricConfiguration() != null && model.getMetricDescription() != null) {
    if (!model.getMetricDescription().isMonotonicVariantSupported()) {
      this.monotonicVariant.setSelection(false);
      this.monotonicVariant.setEnabled(false);
    }
 else {
      this.monotonicVariant.setEnabled(true);
      this.monotonicVariant.setSelection(model.getMetricConfiguration().isMonotonic());
    }
    if (!model.getMetricDescription().isPrecomputationSupported()) {
      this.precomputedVariant.setSelection(false);
      this.precomputedVariant.setEnabled(false);
      this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,0.5d));
      this.precomputationThreshold.setEnabled(false);
      this.labelThreshold.setText(String.valueOf(0.5d));
    }
 else {
      this.precomputedVariant.setEnabled(true);
      this.precomputedVariant.setSelection(model.getMetricConfiguration().isPrecomputed());
      if (model.getMetricConfiguration().isPrecomputed()) {
        this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,model.getMetricConfiguration().getPrecomputationThreshold()));
        this.precomputationThreshold.setEnabled(true);
        this.labelThreshold.setText(String.valueOf(model.getMetricConfiguration().getPrecomputationThreshold()));
      }
 else {
        this.precomputationThreshold.setSelection(SWTUtil.doubleToSlider(0d,1d,0.5d));
        this.precomputationThreshold.setEnabled(false);
        this.labelThreshold.setText(String.valueOf(0.5d));
      }
    }
    if (model == null || model.getInputDefinition() == null || model.getInputConfig() == null || model.getInputDefinition().getQuasiIdentifyingAttributes().isEmpty() || model.getMetricDescription() == null || !(model.getMetricDescription().isAttributeWeightsSupported())) {
      hideSettingsAttributeWeights();
      hideSettingsCodingModel();
    }
 else {
      showSettingsAttributeWeights();
      if (model.getMetricDescription().isConfigurableCodingModelSupported()) {
        showSettingsCodingModel();
      }
 else {
        hideSettingsCodingModel();
      }
    }
  }
 else {
    reset();
  }
  root.setRedraw(true);
}",0.8033144352376799
108344,"/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(GeneralizationHierarchy hierarchy,String[] dictvalues){
  int[][] array=hierarchy.getArray();
  this.size=array.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[dictvalues.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  IntIntOpenHashMap[] maps=new IntIntOpenHashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new IntIntOpenHashMap(hierarchy.getDistinctValues()[level]);
  }
  for (int value=0; value < array.length; value++) {
    int[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      maps[level].putOrAdd(transformation[level],1,1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    IntIntOpenHashMap map=maps[level];
    boolean[] allocated=map.allocated;
    int[] keys=map.keys;
    int[] values=map.values;
    for (int index=0; index < allocated.length; index++) {
      if (allocated[index]) {
        int key=keys[index];
        double share=(double)values[index] / size;
        double stored=shares[key];
        if (stored != NOT_AVAILABLE) {
          if (stored == share) {
            continue;
          }
          if (stored >= 0d) {
            shares[key]=-shares[key];
          }
          long dkey=(((long)key) << 32) | (level & 0xffffffffL);
          duplicates.put(dkey,share);
        }
 else {
          shares[key]=share;
        }
      }
    }
  }
}","/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(String[][] hierarchy,String[] distinctvalues){
  String[][] array=hierarchy;
  Map<String,Integer> internaldict=new HashMap<String,Integer>();
  for (int i=0; i < distinctvalues.length; i++) {
    internaldict.put(distinctvalues[i],i);
  }
  this.size=array.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[distinctvalues.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  @SuppressWarnings(""String_Node_Str"") Map<String,Integer>[] maps=new HashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new HashMap<String,Integer>();
  }
  for (int value=0; value < array.length; value++) {
    String[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      Map<String,Integer> map=maps[level];
      String key=transformation[level];
      if (!map.containsKey(key)) {
        map.put(key,0);
      }
      map.put(key,map.get(key) + 1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    Map<String,Integer> map=maps[level];
    for (    Entry<String,Integer> entry : map.entrySet()) {
      String keyString=entry.getKey();
      double share=(double)entry.getValue() / size;
      Integer key=internaldict.get(keyString);
      if (key == null) {
        continue;
      }
      double stored=shares[key];
      if (stored != NOT_AVAILABLE) {
        if (stored == share) {
          continue;
        }
        if (stored >= 0d) {
          shares[key]=-shares[key];
        }
        long dkey=(((long)key) << 32) | (level & 0xffffffffL);
        duplicates.put(dkey,share);
      }
 else {
        shares[key]=share;
      }
    }
  }
}",0.5361010830324909
108345,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  this.shares=new DomainShare[hierarchies.length];
  for (int i=0; i < shares.length; i++) {
    shares[i]=new DomainShare(hierarchies[i],input.getDictionary().getMapping()[i]);
  }
  this.tuples=input.getDataLength();
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criteria=config.getCriteria(DPresence.class);
    if (criteria.size() > 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    this.tuples=criteria.iterator().next().getSubset().getArray().length;
  }
  double[] min=new double[shares.length];
  Arrays.fill(min,0d);
  double[] max=new double[shares.length];
  Arrays.fill(max,1d);
  super.setMin(min);
  super.setMax(max);
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  this.shares=new DomainShare[hierarchies.length];
  for (int i=0; i < shares.length; i++) {
    shares[i]=new DomainShare(definition.getHierarchy(input.getHeader()[i]),input.getDictionary().getMapping()[i]);
  }
  this.tuples=input.getDataLength();
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criteria=config.getCriteria(DPresence.class);
    if (criteria.size() > 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    this.tuples=criteria.iterator().next().getSubset().getArray().length;
  }
  double[] min=new double[shares.length];
  Arrays.fill(min,0d);
  double[] max=new double[shares.length];
  Arrays.fill(max,1d);
  super.setMin(min);
  super.setMax(max);
}",0.9715206878022568
108346,"@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  ILMultiDimensionalWithBound loss=super.getInformationLossInternal(node,g);
  double[] result=loss.getInformationLoss().getValue();
  double suppressed=0;
  final IntIntOpenHashMap[] original=new IntIntOpenHashMap[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new IntIntOpenHashMap();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressed+=m.count;
      for (int i=0; i < original.length; i++) {
        original[i].putOrAdd(m.key[i],m.count,m.count);
      }
    }
    m=m.nextOrdered;
  }
  if (suppressed != 0) {
    for (int i=0; i < original.length; i++) {
      IntIntOpenHashMap map=original[i];
      for (int j=0; j < map.allocated.length; j++) {
        if (map.allocated[j]) {
          double count=map.values[j];
          result[i]-=count * log2(count / suppressed);
        }
      }
    }
  }
  return new ILMultiDimensionalWithBound(createInformationLoss(result),createInformationLoss(result));
}","@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  ILMultiDimensionalWithBound loss=super.getInformationLossInternal(node,g);
  double[] result=loss.getInformationLoss().getValue();
  double suppressed=0;
  final IntIntOpenHashMap[] original=new IntIntOpenHashMap[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new IntIntOpenHashMap();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressed+=m.count;
      for (int i=0; i < original.length; i++) {
        original[i].putOrAdd(m.key[i],m.count,m.count);
      }
    }
    m=m.nextOrdered;
  }
  if (suppressed != 0) {
    for (int i=0; i < original.length; i++) {
      IntIntOpenHashMap map=original[i];
      for (int j=0; j < map.allocated.length; j++) {
        if (map.allocated[j]) {
          double count=map.values[j];
          result[i]-=count * log2(count / suppressed);
        }
      }
    }
  }
  return new ILMultiDimensionalWithBound(createInformationLoss(result),loss.getLowerBound());
}",0.981230903535574
108347,"/** 
 * Compares double for ""equality"" with a tolerance of 1 ulp
 * @param d1
 * @param d2
 * @return
 */
private boolean closeEnough(double d1,double d2){
  return Math.abs(d2 - d1) <= Math.max(Math.ulp(d1),Math.ulp(d2));
}","/** 
 * Compares double for ""equality"" with a tolerance of 5 ulps
 * @param d1
 * @param d2
 * @return
 */
private boolean closeEnough(double d1,double d2){
  return Math.abs(d2 - d1) <= 5 * Math.max(Math.ulp(d1),Math.ulp(d2));
}",0.9668874172185432
108348,"/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
private double normalize(double aggregate,int dimension){
  double min=datasetSize / domainSizes[dimension];
  double max=datasetSize;
  double result=(aggregate - min) / (max - min);
  return result >= 0d ? result : 0d;
}","/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
private double normalize(double aggregate,int dimension){
  double min=gWeight * datasetSize / domainSizes[dimension];
  double max=datasetSize;
  double result=(aggregate - min) / (max - min);
  return result >= 0d ? result : 0d;
}",0.984126984126984
108349,"/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
protected double normalize(double aggregate,int dimension){
  double min=tuples / shares[dimension].getDomainSize();
  double max=tuples;
  double result=(aggregate - min) / (max - min);
  return result >= 0d ? result : 0d;
}","/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
protected double normalize(double aggregate,int dimension){
  double min=gFactor * tuples / shares[dimension].getDomainSize();
  double max=tuples;
  double result=(aggregate - min) / (max - min);
  return result >= 0d ? result : 0d;
}",0.9842767295597484
108350,"/** 
 * Utility method that helps with the conversion from metrics v1 to metrics v2
 * @param node
 * @return
 */
private String getInformationLoss(ARXNode node){
  InformationLoss<?> loss=node.getMaximumInformationLoss();
  if (loss instanceof ILMultiDimensionalRank) {
    @SuppressWarnings(""String_Node_Str"") double[] value=((InformationLoss<double[]>)loss).getValue().clone();
    sortDescending(value);
    int[] result=new int[value.length];
    for (int i=0; i < value.length; i++) {
      result[i]=(int)Math.round(value[i] * 100d);
    }
    return Arrays.toString(result);
  }
 else {
    return loss.toString();
  }
}","/** 
 * Utility method that helps with the conversion from metrics v1 to metrics v2
 * @param node
 * @return
 */
private String getInformationLoss(ARXNode node){
  InformationLoss<?> loss=node.getMaximumInformationLoss();
  if (loss instanceof ILMultiDimensionalRank) {
    @SuppressWarnings(""String_Node_Str"") double[] value=((InformationLoss<double[]>)loss).getValue().clone();
    sortDescending(value);
    int[] result=new int[value.length];
    for (int i=0; i < value.length; i++) {
      result[i]=(int)Math.round(value[i] * 100d);
    }
    return Arrays.toString(result).replace(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    return loss.toString();
  }
}",0.9654112221368178
108351,"@Override public Object getDataValue(int col,int row){
  try {
    return provider.getDataValue(col,row);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getClass().getSimpleName());
    return ""String_Node_Str"";
  }
}","@Override public Object getDataValue(int col,int row){
  if (col == -1 || row == -1)   return ""String_Node_Str"";
  try {
    return provider.getDataValue(col,row);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getClass().getSimpleName());
    return ""String_Node_Str"";
  }
}",0.8937728937728938
108352,"/** 
 * Estimate maximum information loss
 */
private void estimateMax(){
  initializeTopDown(lattice.getTop());
  setMaximum(lattice.getTop());
  this.globalMaximum=null;
  ARXNode[][] levels=lattice.getLevels();
  for (int i=levels.length - 2; i >= 0; i--) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      pullTopDown(node);
      setMaximum(node);
      this.globalMaximum=max(this.globalMaximum,node.getMaximumInformationLoss());
    }
  }
}","/** 
 * Estimate maximum information loss
 */
private void estimateMax(){
  initializeTopDown(lattice.getTop());
  setMaximum(lattice.getTop());
  this.globalMaximum=lattice.getTop().getMaximumInformationLoss();
  ARXNode[][] levels=lattice.getLevels();
  for (int i=levels.length - 2; i >= 0; i--) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      pullTopDown(node);
      setMaximum(node);
      this.globalMaximum=max(this.globalMaximum,node.getMaximumInformationLoss());
    }
  }
}",0.9523809523809524
108353,"/** 
 * Estimate minimum information loss
 */
private void estimateMin(){
  initializeBottomUp(lattice.getBottom());
  setMinimum(lattice.getBottom());
  this.globalMinimum=null;
  ARXNode[][] levels=lattice.getLevels();
  for (int i=1; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      pullBottomUp(node);
      setMinimum(node);
      this.globalMinimum=min(this.globalMinimum,node.getMinimumInformationLoss());
    }
  }
}","/** 
 * Estimate minimum information loss
 */
private void estimateMin(){
  initializeBottomUp(lattice.getBottom());
  setMinimum(lattice.getBottom());
  this.globalMinimum=lattice.getBottom().getMinimumInformationLoss();
  ARXNode[][] levels=lattice.getLevels();
  for (int i=1; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      pullBottomUp(node);
      setMinimum(node);
      this.globalMinimum=min(this.globalMinimum,node.getMinimumInformationLoss());
    }
  }
}",0.9498525073746312
108354,"@Override protected InformationLossWithBound<InformationLossRCE> getInformationLossInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension];
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * (1d - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossWithBound<InformationLossRCE>(new InformationLossRCE(scores,weights));
}","@Override protected InformationLossWithBound<InformationLossRCE> getInformationLossInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension];
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * ((double)m.count - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossWithBound<InformationLossRCE>(new InformationLossRCE(scores,weights));
}",0.9936732415333084
108355,"@Override protected ILMultiDimensionalWithBound getInformationLossInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] result=new double[dimensions];
  double[] bound=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int dimension=0; dimension < dimensions; dimension++) {
        int value=m.key[dimension];
        int level=transformation[dimension];
        double share=(double)m.count * shares[dimension].getShare(value,level);
        result[dimension]+=m.isNotOutlier ? share * gFactor : (sFactor == 1d ? m.count : share + sFactor * (1d - share));
        bound[dimension]+=share * gFactor;
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    result[dimension]=normalize(result[dimension],dimension);
    bound[dimension]=normalize(bound[dimension],dimension);
  }
  return new ILMultiDimensionalWithBound(super.createInformationLoss(result),super.createInformationLoss(bound));
}","@Override protected ILMultiDimensionalWithBound getInformationLossInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] result=new double[dimensions];
  double[] bound=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int dimension=0; dimension < dimensions; dimension++) {
        int value=m.key[dimension];
        int level=transformation[dimension];
        double share=(double)m.count * shares[dimension].getShare(value,level);
        result[dimension]+=m.isNotOutlier ? share * gFactor : (sFactor == 1d ? m.count : share + sFactor * ((double)m.count - share));
        bound[dimension]+=share * gFactor;
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    result[dimension]=normalize(result[dimension],dimension);
    bound[dimension]=normalize(bound[dimension],dimension);
  }
  return new ILMultiDimensionalWithBound(super.createInformationLoss(result),super.createInformationLoss(bound));
}",0.9922972360670592
108356,"/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(GeneralizationHierarchy hierarchy,String[] dictvalues){
  int[][] array=hierarchy.getArray();
  this.size=dictvalues.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[dictvalues.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  IntIntOpenHashMap[] maps=new IntIntOpenHashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new IntIntOpenHashMap(hierarchy.getDistinctValues()[level]);
  }
  for (int value=0; value < array.length; value++) {
    int[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      maps[level].putOrAdd(transformation[level],1,1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    IntIntOpenHashMap map=maps[level];
    boolean[] allocated=map.allocated;
    int[] keys=map.keys;
    int[] values=map.values;
    for (int index=0; index < allocated.length; index++) {
      if (allocated[index]) {
        int key=keys[index];
        double share=(double)values[index] / size;
        double stored=shares[key];
        if (stored != NOT_AVAILABLE) {
          if (stored == share) {
            continue;
          }
          if (stored >= 0d) {
            shares[key]=-shares[key];
          }
          long dkey=(((long)key) << 32) | (level & 0xffffffffL);
          duplicates.put(dkey,share);
        }
 else {
          shares[key]=share;
        }
      }
    }
  }
}","/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(GeneralizationHierarchy hierarchy,String[] dictvalues){
  int[][] array=hierarchy.getArray();
  this.size=array.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[dictvalues.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  IntIntOpenHashMap[] maps=new IntIntOpenHashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new IntIntOpenHashMap(hierarchy.getDistinctValues()[level]);
  }
  for (int value=0; value < array.length; value++) {
    int[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      maps[level].putOrAdd(transformation[level],1,1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    IntIntOpenHashMap map=maps[level];
    boolean[] allocated=map.allocated;
    int[] keys=map.keys;
    int[] values=map.values;
    for (int index=0; index < allocated.length; index++) {
      if (allocated[index]) {
        int key=keys[index];
        double share=(double)values[index] / size;
        double stored=shares[key];
        if (stored != NOT_AVAILABLE) {
          if (stored == share) {
            continue;
          }
          if (stored >= 0d) {
            shares[key]=-shares[key];
          }
          long dkey=(((long)key) << 32) | (level & 0xffffffffL);
          duplicates.put(dkey,share);
        }
 else {
          shares[key]=share;
        }
      }
    }
  }
}",0.9951440595662028
108357,"@Override public int compareTo(InformationLoss<?> other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    double[] otherValue=convert(other).aggregate;
    double[] thisValue=aggregate;
    for (int i=0; i < otherValue.length; i++) {
      if (thisValue[i] < otherValue[i])       return -1;
 else       if (thisValue[i] > otherValue[i])       return +1;
    }
    return 0;
  }
}","@Override public int compareTo(InformationLoss<?> other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    double[] otherValue=convert(other).aggregate;
    double[] thisValue=aggregate;
    for (int i=0; i < otherValue.length; i++) {
      int cmp=compareWithTolerance(thisValue[i],otherValue[i]);
      if (cmp != 0)       return cmp;
    }
    return 0;
  }
}",0.8452380952380952
108358,"/** 
 * This method triggers the estimation of the information loss of all nodes in the lattice regardless of whether they have been checked for anonymity or not
 */
protected void estimateInformationLoss(){
  if (metric.isMonotonic() || (maxAbsoluteOutliers == 0)) {
    estimateMonotonicMinLoss();
    estimateMonotonicMaxLoss();
  }
 else {
    estimateNonMonotonicLoss();
  }
}","/** 
 * This method triggers the estimation of the information loss of all nodes in the lattice regardless of whether they have been checked for anonymity or not
 */
protected void estimateInformationLoss(){
  estimateNonMonotonicLoss();
}",0.7354838709677419
108359,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  Set<String> qis=definition.getQuasiIdentifyingAttributes();
  for (  String qi : qis) {
    minHeight+=definition.getMinimumGeneralization(qi);
    maxHeight+=definition.getMaximumGeneralization(qi);
  }
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  minHeight=0;
  maxHeight=0;
  Set<String> qis=definition.getQuasiIdentifyingAttributes();
  for (  String qi : qis) {
    minHeight+=definition.getMinimumGeneralization(qi);
    maxHeight+=definition.getMaximumGeneralization(qi);
  }
}",0.9671052631578948
108360,"/** 
 * Creates a tooltip text
 * @param node
 */
private String getTooltipText(final ARXNode node){
  final StringBuffer b=new StringBuffer();
  b.append(Resources.getMessage(""String_Node_Str""));
  b.append(format.format(asRelativeValue(node.getMinimumInformationLoss())));
  b.append(""String_Node_Str"");
  b.append(format.format(asRelativeValue(node.getMaximumInformationLoss())));
  b.append(""String_Node_Str"");
  for (  final String qi : node.getQuasiIdentifyingAttributes()) {
    int height=model.getOutputDefinition().isHierarchyAvailable(qi) ? model.getOutputDefinition().getHierarchy(qi)[0].length : 0;
    b.append(""String_Node_Str"");
    b.append(qi);
    b.append(""String_Node_Str"");
    b.append(format.format(asRelativeValue(node.getGeneralization(qi),height - 1)));
    b.append(""String_Node_Str"");
  }
  b.setLength(b.length() - 1);
  return b.toString();
}","/** 
 * Creates a tooltip text
 * @param node
 */
private String getTooltipText(final ARXNode node){
  final StringBuffer b=new StringBuffer();
  b.append(Resources.getMessage(""String_Node_Str""));
  b.append(format.format(asRelativeValue(node.getMinimumInformationLoss())));
  b.append(""String_Node_Str"");
  b.append(format.format(asRelativeValue(node.getMaximumInformationLoss())));
  b.append(""String_Node_Str"");
  if (model.getOutputDefinition() != null) {
    for (    final String qi : node.getQuasiIdentifyingAttributes()) {
      int height=model.getOutputDefinition().isHierarchyAvailable(qi) ? model.getOutputDefinition().getHierarchy(qi)[0].length : 0;
      b.append(""String_Node_Str"");
      b.append(qi);
      b.append(""String_Node_Str"");
      b.append(format.format(asRelativeValue(node.getGeneralization(qi),height - 1)));
      b.append(""String_Node_Str"");
    }
  }
  b.setLength(b.length() - 1);
  return b.toString();
}",0.9575289575289576
108361,"@Override public void traverse(){
  FLASHPhaseConfiguration outerLoopConfiguration;
  if (config.isBinaryPhaseRequired()) {
    outerLoopConfiguration=config.getBinaryPhaseConfiguration();
  }
 else {
    outerLoopConfiguration=config.getLinearPhaseConfiguration();
  }
  lattice.setTagTrigger(config.getTriggerTagEvent());
  checker.getHistory().setStorageTrigger(config.getTriggerSnapshotStore());
  PriorityQueue<Node> queue=new PriorityQueue<Node>(lattice.getLevels().length,strategy);
  Node bottom=lattice.getBottom();
  INodeChecker.Result result=checker.check(bottom);
  lattice.setProperty(bottom,Node.PROPERTY_FORCE_SNAPSHOT);
  bottom.setData(result);
  int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    for (    Node node : getUnsetNodesAndSort(i,outerLoopConfiguration.getTriggerSkip())) {
      if (config.isBinaryPhaseRequired()) {
        binarySearch(node,queue);
      }
 else {
        linearSearch(node);
      }
    }
  }
  computeUtilityForMonotonicMetrics(lattice.getBottom());
  computeUtilityForMonotonicMetrics(lattice.getTop());
  lattice.getBottom().setData(null);
  potentiallyInsufficientUtility.clear();
}","@Override public void traverse(){
  FLASHPhaseConfiguration outerLoopConfiguration;
  if (config.isBinaryPhaseRequired()) {
    outerLoopConfiguration=config.getBinaryPhaseConfiguration();
  }
 else {
    outerLoopConfiguration=config.getLinearPhaseConfiguration();
  }
  lattice.setTagTrigger(config.getTriggerTagEvent());
  checker.getHistory().setStorageTrigger(config.getTriggerSnapshotStore());
  PriorityQueue<Node> queue=new PriorityQueue<Node>(lattice.getLevels().length,strategy);
  Node bottom=lattice.getBottom();
  INodeChecker.Result result=checker.check(bottom);
  lattice.setProperty(bottom,Node.PROPERTY_FORCE_SNAPSHOT);
  bottom.setData(result);
  int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    for (    Node node : getUnsetNodesAndSort(i,outerLoopConfiguration.getTriggerSkip())) {
      if (config.isBinaryPhaseRequired()) {
        binarySearch(node,queue);
      }
 else {
        linearSearch(node);
      }
    }
  }
  computeUtilityForMonotonicMetrics(lattice.getBottom());
  computeUtilityForMonotonicMetrics(lattice.getTop());
  lattice.getBottom().setData(null);
  if (potentiallyInsufficientUtility != null) {
    potentiallyInsufficientUtility.clear();
  }
}",0.9689336691855585
108362,"/** 
 * Creates a new instance for the given data set
 * @param hierarchy
 */
public Cardinalities(Data data,RowSet subset,GeneralizationHierarchy[] hierarchies){
  int[][] array=data.getArray();
  Dictionary dictionary=data.getDictionary();
  this.size=subset.size();
  cardinalities=new int[array[0].length][][];
  for (int i=0; i < cardinalities.length; i++) {
    cardinalities[i]=new int[dictionary.getMapping()[i].length][hierarchies[i].getArray()[0].length];
  }
  for (int i=0; i < array.length; i++) {
    if (subset == null || subset.contains(i)) {
      final int[] row=array[i];
      for (int column=0; column < row.length; column++) {
        cardinalities[column][row[column]][0]++;
      }
    }
  }
  for (int column=0; column < hierarchies.length; column++) {
    final int[][] hierarchy=hierarchies[column].getArray();
    for (int in=0; in < hierarchy.length; in++) {
      final int cardinality=cardinalities[column][in][0];
      for (int level=1; level < hierarchy[in].length; level++) {
        final int out=hierarchy[in][level];
        cardinalities[column][out][level]+=cardinality;
      }
    }
  }
}","/** 
 * Creates a new instance for the given data set
 * @param hierarchy
 */
public Cardinalities(Data data,RowSet subset,GeneralizationHierarchy[] hierarchies){
  int[][] array=data.getArray();
  Dictionary dictionary=data.getDictionary();
  this.size=subset == null ? data.getDataLength() : subset.size();
  cardinalities=new int[array[0].length][][];
  for (int i=0; i < cardinalities.length; i++) {
    cardinalities[i]=new int[dictionary.getMapping()[i].length][hierarchies[i].getArray()[0].length];
  }
  for (int i=0; i < array.length; i++) {
    if (subset == null || subset.contains(i)) {
      final int[] row=array[i];
      for (int column=0; column < row.length; column++) {
        cardinalities[column][row[column]][0]++;
      }
    }
  }
  for (int column=0; column < hierarchies.length; column++) {
    final int[][] hierarchy=hierarchies[column].getArray();
    for (int in=0; in < hierarchy.length; in++) {
      final int cardinality=cardinalities[column][in][0];
      for (int level=1; level < hierarchy[in].length; level++) {
        final int out=hierarchy[in][level];
        cardinalities[column][out][level]+=cardinality;
      }
    }
  }
}",0.982608695652174
108363,"/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(GeneralizationHierarchy hierarchy){
  int[][] array=hierarchy.getArray();
  this.size=array.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[array.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  IntIntOpenHashMap[] maps=new IntIntOpenHashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new IntIntOpenHashMap(hierarchy.getDistinctValues()[level]);
  }
  for (int value=0; value < array.length; value++) {
    int[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      maps[level].putOrAdd(transformation[level],1,1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    IntIntOpenHashMap map=maps[level];
    boolean[] allocated=map.allocated;
    int[] keys=map.keys;
    int[] values=map.values;
    for (int index=0; index < allocated.length; index++) {
      if (allocated[index]) {
        int key=keys[index];
        double share=(double)values[index] / size;
        double stored=shares[key];
        if (stored != NOT_AVAILABLE) {
          if (stored == share) {
            continue;
          }
          if (stored >= 0d) {
            shares[key]=-shares[key];
          }
          long dkey=(((long)key) << 32) | (level & 0xffffffffL);
          duplicates.put(dkey,share);
        }
 else {
          shares[key]=share;
        }
      }
    }
  }
}","/** 
 * Creates a new set of domain shares derived from the given attribute
 * @param hierarchy
 */
public DomainShare(GeneralizationHierarchy hierarchy,String[] dictvalues){
  int[][] array=hierarchy.getArray();
  this.size=dictvalues.length;
  this.duplicates=new LongDoubleOpenHashMap();
  this.shares=new double[dictvalues.length];
  Arrays.fill(shares,NOT_AVAILABLE);
  IntIntOpenHashMap[] maps=new IntIntOpenHashMap[array[0].length];
  for (int level=0; level < maps.length; level++) {
    maps[level]=new IntIntOpenHashMap(hierarchy.getDistinctValues()[level]);
  }
  for (int value=0; value < array.length; value++) {
    int[] transformation=array[value];
    for (int level=0; level < transformation.length; level++) {
      maps[level].putOrAdd(transformation[level],1,1);
    }
  }
  for (int level=0; level < maps.length; level++) {
    IntIntOpenHashMap map=maps[level];
    boolean[] allocated=map.allocated;
    int[] keys=map.keys;
    int[] values=map.values;
    for (int index=0; index < allocated.length; index++) {
      if (allocated[index]) {
        int key=keys[index];
        double share=(double)values[index] / size;
        double stored=shares[key];
        if (stored != NOT_AVAILABLE) {
          if (stored == share) {
            continue;
          }
          if (stored >= 0d) {
            shares[key]=-shares[key];
          }
          long dkey=(((long)key) << 32) | (level & 0xffffffffL);
          duplicates.put(dkey,share);
        }
 else {
          shares[key]=share;
        }
      }
    }
  }
}",0.9836814621409922
108364,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  this.shares=new DomainShare[hierarchies.length];
  for (int i=0; i < shares.length; i++) {
    shares[i]=new DomainShare(hierarchies[i]);
  }
  this.tuples=input.getDataLength();
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criteria=config.getCriteria(DPresence.class);
    if (criteria.size() > 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    this.tuples=criteria.iterator().next().getSubset().getArray().length;
  }
  double[] min=new double[shares.length];
  Arrays.fill(min,0d);
  double[] max=new double[shares.length];
  Arrays.fill(max,1d);
  super.setMin(min);
  super.setMax(max);
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  this.shares=new DomainShare[hierarchies.length];
  for (int i=0; i < shares.length; i++) {
    shares[i]=new DomainShare(hierarchies[i],input.getDictionary().getMapping()[i]);
  }
  this.tuples=input.getDataLength();
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criteria=config.getCriteria(DPresence.class);
    if (criteria.size() > 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    this.tuples=criteria.iterator().next().getSubset().getArray().length;
  }
  double[] min=new double[shares.length];
  Arrays.fill(min,0d);
  double[] max=new double[shares.length];
  Arrays.fill(max,1d);
  super.setMin(min);
  super.setMax(max);
}",0.9787946428571428
108365,"@Override protected AbstractILMultiDimensional getLowerBoundInternal(Node node,IHashGroupify groupify){
  return getLowerBoundInternal(node);
}","@Override protected AbstractILMultiDimensional getLowerBoundInternal(Node node,IHashGroupify groupify){
  return this.getLowerBoundInternal(node);
}",0.9828178694158076
108366,"@Override protected AbstractILMultiDimensional getLowerBoundInternal(Node node,IHashGroupify groupify){
  return super.getLowerBoundInternal(node);
}","@Override protected AbstractILMultiDimensional getLowerBoundInternal(Node node,IHashGroupify groupify){
  return super.getInformationLossInternal(node,null).getLowerBound();
}",0.8703703703703703
108367,"@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.MODEL || event.part == ModelPart.INPUT) {
    this.attributes.clear();
  }
  if (event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      DataDefinition definition=model.getInputDefinition();
      List<String> qis=new ArrayList<String>();
      if (definition != null) {
        Set<String> _qis=definition.getQuasiIdentifyingAttributes();
        if (this.attributes.equals(_qis)) {
          return;
        }
        DataHandle handle=model.getInputConfig().getInput().getHandle();
        for (int i=0; i < handle.getNumColumns(); i++) {
          String attr=handle.getAttributeName(i);
          if (_qis.contains(attr)) {
            qis.add(attr);
          }
        }
        attributes.clear();
        attributes.addAll(qis);
      }
      root.setRedraw(false);
      if (panel != null) {
        panel.dispose();
      }
      panel=new Composite(root,SWT.NONE);
      panel.setLayoutData(GridDataFactory.swtDefaults().grab(true,true).align(SWT.FILL,SWT.CENTER).create());
      panel.setLayout(GridLayoutFactory.swtDefaults().numColumns(qis.size()).margins(0,0).equalWidth(true).create());
      List<Composite> composites=new ArrayList<Composite>();
      for (int i=0; i < qis.size(); i++) {
        Composite c=new Composite(panel,SWT.NONE);
        c.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        c.setLayout(GridLayoutFactory.swtDefaults().numColumns(1).margins(2,0).create());
        composites.add(c);
      }
      for (int i=0; i < qis.size(); i++) {
        Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(qis.get(i));
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
      }
      List<Knob<Double>> knobs=new ArrayList<Knob<Double>>();
      for (int i=0; i < qis.size(); i++) {
        Knob<Double> knob=new Knob<Double>(composites.get(i),SWT.NULL,new KnobRange.Double(0d,1d));
        knob.setLayoutData(GridDataFactory.swtDefaults().grab(false,false).align(SWT.CENTER,SWT.CENTER).hint(30,30).create());
        knob.setDefaultColorProfile(KnobColorProfile.createDefaultSystemProfile(root.getDisplay()));
        knob.setFocusedColorProfile(KnobColorProfile.createFocusedBlueRedProfile(root.getDisplay()));
        knobs.add(knob);
      }
      for (int i=0; i < qis.size(); i++) {
        final Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(""String_Node_Str"");
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        final String attribute=qis.get(i);
        final Knob<Double> knob=knobs.get(i);
        knob.addSelectionListener(new SelectionAdapter(){
          public void widgetSelected(          SelectionEvent arg0){
            double value=knob.getValue();
            label.setText(format.format(value));
            if (model != null && model.getInputConfig() != null) {
              model.getInputConfig().setAttributeWeight(attribute,value);
            }
          }
        }
);
      }
      for (int i=0; i < qis.size(); i++) {
        if (model != null && model.getInputConfig() != null) {
          knobs.get(i).setValue(model.getInputConfig().getAttributeWeight(qis.get(i)));
        }
      }
      root.setVisible(!qis.isEmpty());
      root.layout(true,true);
      root.setRedraw(true);
    }
  }
}","@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.MODEL || event.part == ModelPart.INPUT) {
    this.attributes.clear();
  }
  if (event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.MODEL) {
    if (model != null) {
      DataDefinition definition=model.getInputDefinition();
      List<String> qis=new ArrayList<String>();
      if (definition != null) {
        Set<String> _qis=definition.getQuasiIdentifyingAttributes();
        if (this.attributes.equals(_qis)) {
          return;
        }
        DataHandle handle=model.getInputConfig().getInput().getHandle();
        for (int i=0; i < handle.getNumColumns(); i++) {
          String attr=handle.getAttributeName(i);
          if (_qis.contains(attr)) {
            qis.add(attr);
          }
        }
        attributes.clear();
        attributes.addAll(qis);
      }
      if (root.isDisposed())       return;
      root.setRedraw(false);
      if (panel != null) {
        panel.dispose();
      }
      panel=new Composite(root,SWT.NONE);
      panel.setLayoutData(GridDataFactory.swtDefaults().grab(true,true).align(SWT.FILL,SWT.CENTER).create());
      panel.setLayout(GridLayoutFactory.swtDefaults().numColumns(qis.size()).margins(0,0).equalWidth(true).create());
      List<Composite> composites=new ArrayList<Composite>();
      for (int i=0; i < qis.size(); i++) {
        Composite c=new Composite(panel,SWT.NONE);
        c.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        c.setLayout(GridLayoutFactory.swtDefaults().numColumns(1).margins(2,0).create());
        composites.add(c);
      }
      for (int i=0; i < qis.size(); i++) {
        Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(qis.get(i));
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
      }
      List<Knob<Double>> knobs=new ArrayList<Knob<Double>>();
      for (int i=0; i < qis.size(); i++) {
        Knob<Double> knob=new Knob<Double>(composites.get(i),SWT.NULL,new KnobRange.Double(0d,1d));
        knob.setLayoutData(GridDataFactory.swtDefaults().grab(false,false).align(SWT.CENTER,SWT.CENTER).hint(30,30).create());
        knob.setDefaultColorProfile(KnobColorProfile.createDefaultSystemProfile(root.getDisplay()));
        knob.setFocusedColorProfile(KnobColorProfile.createFocusedBlueRedProfile(root.getDisplay()));
        knobs.add(knob);
      }
      for (int i=0; i < qis.size(); i++) {
        final Label label=new Label(composites.get(i),SWT.CENTER);
        label.setText(""String_Node_Str"");
        label.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
        final String attribute=qis.get(i);
        final Knob<Double> knob=knobs.get(i);
        knob.addSelectionListener(new SelectionAdapter(){
          public void widgetSelected(          SelectionEvent arg0){
            double value=knob.getValue();
            label.setText(format.format(value));
            if (model != null && model.getInputConfig() != null) {
              model.getInputConfig().setAttributeWeight(attribute,value);
            }
          }
        }
);
      }
      for (int i=0; i < qis.size(); i++) {
        if (model != null && model.getInputConfig() != null) {
          knobs.get(i).setValue(model.getInputConfig().getAttributeWeight(qis.get(i)));
        }
      }
      root.setVisible(!qis.isEmpty());
      root.layout(true,true);
      root.setRedraw(true);
    }
  }
}",0.993892912938503
108368,"protected ARXNode getOptimum(){
  return optimum;
}","/** 
 * Returns the optimum, if any
 * @return
 */
protected ARXNode getOptimum(){
  return optimum;
}",0.6666666666666666
108369,"/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=null;
  InformationLoss<?> max=null;
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      InformationLoss<?> nodeMin=node.getMinimumInformationLoss();
      InformationLoss<?> nodeMax=node.getMaximumInformationLoss();
      if (nodeMin != null && nodeMin.equals(nodeMax)) {
        if (min == null || min.compareTo(nodeMin) > 0) {
          min=nodeMin.clone();
        }
        if (max == null || max.compareTo(nodeMax) < 0) {
          max=nodeMax.clone();
        }
      }
    }
  }
  if (min == null)   min=metric.createMinInformationLoss();
  if (max == null)   max=metric.createMaxInformationLoss();
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (node.minInformationLoss == null) {
        node.minInformationLoss=min.clone();
      }
      if (node.maxInformationLoss == null) {
        node.maxInformationLoss=max.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}","/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=metric.createMinInformationLoss();
  InformationLoss<?> max=metric.createMaxInformationLoss();
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (node.minInformationLoss == null) {
        node.minInformationLoss=min.clone();
      }
      if (node.maxInformationLoss == null) {
        node.maxInformationLoss=max.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}",0.3249727371864776
108370,"@Override protected InformationLossWithBound<InformationLossDefault> getInformationLossInternal(final Node node,final IHashGroupify g){
  if (node.getLowerBound() != null) {
    return new InformationLossWithBound<InformationLossDefault>((InformationLossDefault)node.getLowerBound(),(InformationLossDefault)node.getLowerBound());
  }
  double result=0;
  for (int column=0; column < hierarchies.length; column++) {
    final int state=node.getTransformation()[column];
    double value=cache[column][state];
    if (value == NA) {
      value=0d;
      final int[][] cardinality=cardinalities[column];
      final int[][] hierarchy=hierarchies[column];
      for (int in=0; in < hierarchy.length; in++) {
        final int out=hierarchy[in][state];
        final double a=cardinality[in][0];
        final double b=cardinality[out][state];
        if (a != 0d) {
          value+=a * log2(a / b);
        }
      }
      cache[column][state]=value;
    }
    result+=value;
  }
  return new InformationLossDefaultWithBound(-result,-result);
}","@Override protected InformationLossWithBound<InformationLossDefault> getInformationLossInternal(final Node node,final IHashGroupify g){
  if (node.getLowerBound() != null) {
    return new InformationLossWithBound<InformationLossDefault>((InformationLossDefault)node.getLowerBound(),(InformationLossDefault)node.getLowerBound());
  }
  double result=0;
  for (int column=0; column < hierarchies.length; column++) {
    final int state=node.getTransformation()[column];
    double value=cache[column][state];
    if (value == NA) {
      value=0d;
      final int[][] cardinality=cardinalities[column];
      final int[][] hierarchy=hierarchies[column];
      for (int in=0; in < hierarchy.length; in++) {
        final int out=hierarchy[in][state];
        final double a=cardinality[in][0];
        final double b=cardinality[out][state];
        if (a != 0d) {
          value+=a * log2(a / b);
        }
      }
      cache[column][state]=value;
    }
    result+=value;
  }
  result=result == 0.0d ? result : -result;
  return new InformationLossDefaultWithBound(result,result);
}",0.9783631232361242
108371,"@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  int[][][] cardinalities=this.cardinalities.getCardinalities();
  double[] result=new double[hierarchies.length];
  for (int column=0; column < hierarchies.length; column++) {
    final int transformation=node.getTransformation()[column];
    double value=cache[column][transformation];
    if (value == NOT_AVAILABLE) {
      value=0d;
      final int[][] cardinality=cardinalities[column];
      final int[][] hierarchy=hierarchies[column];
      for (int in=0; in < hierarchy.length; in++) {
        final int out=hierarchy[in][transformation];
        final double a=cardinality[in][0];
        final double b=cardinality[out][transformation];
        if (a != 0d) {
          value+=a * log2(a / b);
        }
      }
      cache[column][transformation]=value;
    }
    result[column]=value;
  }
  return new ILMultiDimensionalWithBound(super.createInformationLoss(result),super.createInformationLoss(result));
}","@Override protected ILMultiDimensionalWithBound getInformationLossInternal(final Node node,final IHashGroupify g){
  int[][][] cardinalities=this.cardinalities.getCardinalities();
  double[] result=new double[hierarchies.length];
  for (int column=0; column < hierarchies.length; column++) {
    final int transformation=node.getTransformation()[column];
    double value=cache[column][transformation];
    if (value == NOT_AVAILABLE) {
      value=0d;
      final int[][] cardinality=cardinalities[column];
      final int[][] hierarchy=hierarchies[column];
      for (int in=0; in < hierarchy.length; in++) {
        final int out=hierarchy[in][transformation];
        final double a=cardinality[in][0];
        final double b=cardinality[out][transformation];
        if (a != 0d) {
          value+=a * log2(a / b);
        }
      }
      cache[column][transformation]=value;
    }
    result[column]=value;
  }
  for (int column=0; column < hierarchies.length; column++) {
    result[column]=result[column] == 0.0d ? result[column] : -result[column];
  }
  return new ILMultiDimensionalWithBound(super.createInformationLoss(result),super.createInformationLoss(result));
}",0.9349005424954792
108372,"/** 
 * Creates a new instance. The precomputed variant will be used if  #distinctValues / #rows <= threshold for all quasi-identifiers.
 * @param threshold
 * @param function
 */
protected MetricMDNUNMEntropyPotentiallyPrecomputed(double threshold,AggregateFunction function){
  super(new MetricMDNUNMEntropy(function),new MetricMDNUNMEntropyPrecomputed(function),threshold);
}","/** 
 * Creates a new instance. The pre-computed variant will be used if  #distinctValues / #rows <= threshold for all quasi-identifiers.
 * @param threshold
 * @param function
 */
protected MetricMDNUNMEntropyPotentiallyPrecomputed(double threshold,AggregateFunction function){
  super(new MetricMDNUNMEntropy(function),new MetricMDNUNMEntropyPrecomputed(function),threshold);
}",0.998678996036988
108373,"/** 
 * Applies and checks a transformation
 * @param testcase 
 * @param result
 * @param node
 */
private void checkTransformation(ARXUtilityMetricsTestCase testcase,ARXResult result,ARXNode node){
  InformationLoss<?> min=node.getMinimumInformationLoss();
  InformationLoss<?> max=node.getMaximumInformationLoss();
  result.getOutput(node,false);
  assertTrue(""String_Node_Str"",node.getMinimumInformationLoss().compareTo(node.getMaximumInformationLoss()) == 0);
  if (min.compareTo(node.getMaximumInformationLoss()) > 0) {
    System.out.println(min + ""String_Node_Str"" + node.getMaximumInformationLoss()+ ""String_Node_Str""+ max);
    System.out.println(""String_Node_Str"" + node.getAnonymity() + ""String_Node_Str""+ testcase.config.isSuppressionAlwaysEnabled());
    System.out.println(testcase.getDescription());
  }
  assertTrue(""String_Node_Str"",min.compareTo(node.getMaximumInformationLoss()) <= 0);
  assertTrue(""String_Node_Str"",max.compareTo(node.getMaximumInformationLoss()) >= 0);
}","/** 
 * Applies and checks a transformation
 * @param testcase 
 * @param result
 * @param node
 */
private void checkTransformation(ARXUtilityMetricsTestCase testcase,ARXResult result,ARXNode node){
  InformationLoss<?> min=node.getMinimumInformationLoss();
  InformationLoss<?> max=node.getMaximumInformationLoss();
  result.getOutput(node,false);
  assertTrue(""String_Node_Str"",compareWithTolerance(node.getMinimumInformationLoss(),node.getMaximumInformationLoss()) == 0);
  if (min.compareTo(node.getMaximumInformationLoss()) > 0) {
    System.out.println(min + ""String_Node_Str"" + node.getMaximumInformationLoss()+ ""String_Node_Str""+ max);
    System.out.println(""String_Node_Str"" + node.getAnonymity() + ""String_Node_Str""+ testcase.config.isSuppressionAlwaysEnabled());
    System.out.println(testcase.getDescription());
  }
  assertTrue(""String_Node_Str"",compareWithTolerance(min,node.getMaximumInformationLoss()) <= 0);
  assertTrue(""String_Node_Str"",compareWithTolerance(max,node.getMaximumInformationLoss()) >= 0);
}",0.9499752352649826
108374,"/** 
 * Tests all estimates within a lattice
 * @param lattice
 */
private void checkLattice(ARXLattice lattice){
  for (  ARXNode[] level : lattice.getLevels()) {
    for (    ARXNode node : level) {
      assertTrue(""String_Node_Str"",node.getMinimumInformationLoss().compareTo(node.getMaximumInformationLoss()) <= 0);
    }
  }
}","/** 
 * Tests all estimates within a lattice
 * @param lattice
 */
private void checkLattice(ARXLattice lattice){
  for (  ARXNode[] level : lattice.getLevels()) {
    for (    ARXNode node : level) {
      assertTrue(""String_Node_Str"",compareWithTolerance(node.getMinimumInformationLoss(),node.getMaximumInformationLoss()) <= 0);
    }
  }
}",0.950965824665676
108375,"/** 
 * Tests the result
 * @param testcase 
 * @param result
 */
private void checkResult(ARXUtilityMetricsTestCase testcase,ARXResult result){
  checkLattice(result.getLattice());
  for (  ARXNode[] level : result.getLattice().getLevels()) {
    for (    ARXNode node : level) {
      String label=Arrays.toString(node.getTransformation());
      if (testcase.informationLoss.containsKey(label)) {
        if (node.getMaximumInformationLoss().compareTo(node.getMinimumInformationLoss()) != 0) {
          checkTransformation(testcase,result,node);
          checkLattice(result.getLattice());
        }
      }
    }
  }
}","/** 
 * Tests the result
 * @param testcase 
 * @param result
 */
private void checkResult(ARXUtilityMetricsTestCase testcase,ARXResult result){
  checkLattice(result.getLattice());
  for (  ARXNode[] level : result.getLattice().getLevels()) {
    for (    ARXNode node : level) {
      String label=Arrays.toString(node.getTransformation());
      if (testcase.informationLoss.containsKey(label)) {
        if (compareWithTolerance(node.getMaximumInformationLoss(),node.getMinimumInformationLoss()) != 0) {
          checkTransformation(testcase,result,node);
          checkLattice(result.getLattice());
        }
      }
    }
  }
}",0.9737887212073074
108376,"@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  RowSet subset=null;
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criterion=config.getCriteria(DPresence.class);
    if (criterion.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    subset=criterion.iterator().next().getSubset().getSet();
  }
  this.cardinalities=new Cardinalities(input,subset,hierarchies);
  cache=new double[hierarchies.length][];
  for (int i=0; i < cache.length; i++) {
    cache[i]=new double[hierarchies[i].getArray()[0].length];
    Arrays.fill(cache[i],NOT_AVAILABLE);
  }
  final int[][] data=input.getArray();
  this.hierarchies=new int[data[0].length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.hierarchies[i]=hierarchies[i].getArray();
  }
}","@Override protected void initializeInternal(DataDefinition definition,Data input,GeneralizationHierarchy[] hierarchies,ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  RowSet subset=null;
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> criterion=config.getCriteria(DPresence.class);
    if (criterion.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    subset=criterion.iterator().next().getSubset().getSet();
  }
  this.cardinalities=new Cardinalities(input,subset,hierarchies);
  cache=new double[hierarchies.length][];
  for (int i=0; i < cache.length; i++) {
    cache[i]=new double[hierarchies[i].getArray()[0].length];
    Arrays.fill(cache[i],NOT_AVAILABLE);
  }
  final int[][] data=input.getArray();
  this.hierarchies=new int[data[0].length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.hierarchies[i]=hierarchies[i].getArray();
  }
  double[] min=new double[hierarchies.length];
  Arrays.fill(min,0d);
  double[] max=new double[hierarchies.length];
  Arrays.fill(max,Double.MAX_VALUE / hierarchies.length);
  super.setMax(max);
  super.setMin(min);
}",0.898360655737705
108377,"@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  if (node.getLowerBound() != null) {
    return (InformationLossDefault)node.getLowerBound();
  }
  double lowerBound=0d;
  HashGroupifyEntry m=groupify.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        lowerBound+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
    }
    m=m.nextOrdered;
  }
  lowerBound/=cells;
  return new InformationLossDefault(lowerBound);
}","@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  if (node.getLowerBound() != null) {
    return (InformationLossDefault)node.getLowerBound();
  }
  double lowerBound=0d;
  HashGroupifyEntry m=groupify.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        lowerBound+=m.count * (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]);
      }
    }
    m=m.nextOrdered;
  }
  lowerBound/=cells;
  return new InformationLossDefault(lowerBound);
}",0.989010989010989
108378,"@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  double total=0d;
  double lowerBound=0d;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        total+=m.isNotOutlier ? (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]) : 1d;
        lowerBound+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
    }
    m=m.nextOrdered;
  }
  total/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(total,lowerBound);
}","@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  double total=0d;
  double lowerBound=0d;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        total+=m.count * (m.isNotOutlier ? (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]) : 1d);
        lowerBound+=m.count * (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]);
      }
    }
    m=m.nextOrdered;
  }
  total/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(total,lowerBound);
}",0.9807383627608348
108379,"@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  int suppressedTuples=0;
  int unsuppressedTuples=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    unsuppressedTuples+=m.isNotOutlier ? m.count : 0;
    suppressedTuples+=m.isNotOutlier ? 0 : m.count;
    m=m.nextOrdered;
  }
  double precision=0;
  double lowerBound=0;
  for (int i=0; i < height.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double value=height[i] == 0 ? 0 : (double)node.getTransformation()[i] / (double)height[i];
    precision+=(double)unsuppressedTuples * value * weight;
    precision+=(double)suppressedTuples * 1d * weight;
    lowerBound+=(double)unsuppressedTuples * value * weight;
  }
  precision/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(precision,lowerBound);
}","@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  int suppressedTuples=0;
  int unsuppressedTuples=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    unsuppressedTuples+=m.isNotOutlier ? m.count : 0;
    suppressedTuples+=m.isNotOutlier ? 0 : m.count;
    m=m.nextOrdered;
  }
  double precision=0;
  for (int i=0; i < height.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double value=height[i] == 0 ? 0 : (double)node.getTransformation()[i] / (double)height[i];
    precision+=(double)unsuppressedTuples * value * weight;
    precision+=(double)suppressedTuples * 1d * weight;
  }
  precision/=cells;
  return new BoundInformationLossDefault(precision,getLowerBound(node).getValue());
}",0.8344136711844431
108380,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_K_ANONYMOUS;
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_K_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_K_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_K_ANONYMOUS);
      }
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        lattice.setProperty(node,Node.PROPERTY_SUCCESSORS_PRUNED);
      }
    }
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_ANONYMOUS);
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_VISITED) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return !node.hasProperty(Node.PROPERTY_VISITED) && !node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) && !node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY)&& !node.hasProperty(Node.PROPERTY_CHECKED);
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Node node){
      lattice.setProperty(node,Node.PROPERTY_VISITED);
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY);
      }
    }
    @Override public boolean appliesTo(    Node node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED);
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),History.STORAGE_TRIGGER_ALL,triggerFireEvent,true);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,config);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_K_ANONYMOUS;
  NodeAction binaryTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeAction binaryTriggerTag=new NodeAction(){
    @Override public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_K_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_K_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_K_ANONYMOUS);
      }
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        lattice.setProperty(node,Node.PROPERTY_SUCCESSORS_PRUNED);
      }
    }
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_ANONYMOUS);
    }
  }
;
  NodeAction binaryTriggerCheck=new NodeActionInverse(binaryTriggerSkip);
  NodeAction binaryTriggerEvaluate=new NodeActionConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeAction linearTriggerSkip=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_VISITED) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeAction linearTriggerEvaluate=new NodeActionConstant(false);
  NodeAction linearTriggerCheck=new NodeAction(){
    @Override public boolean appliesTo(    Node node){
      return !node.hasProperty(Node.PROPERTY_VISITED) && !node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) && !node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY)&& !node.hasProperty(Node.PROPERTY_CHECKED);
    }
  }
;
  NodeAction linearTriggerTag=new NodeAction(){
    @Override public void action(    Node node){
      lattice.setProperty(node,Node.PROPERTY_VISITED);
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        lattice.setProperty(node,Node.PROPERTY_SUCCESSORS_PRUNED);
      }
    }
    @Override public boolean appliesTo(    Node node){
      return true;
    }
  }
;
  NodeAction triggerFireEvent=new NodeActionOR(linearTriggerSkip){
    @Override protected boolean additionalConditionAppliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED);
    }
  }
;
  FLASHConfiguration config=FLASHConfiguration.createTwoPhaseConfiguration(new FLASHPhaseConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip),new FLASHPhaseConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip),History.STORAGE_TRIGGER_ALL,triggerFireEvent,true);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,config);
}",0.9851623328926106
108381,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  height=new int[hierarchies.length];
  for (int j=0; j < height.length; j++) {
    height[j]=hierarchies[j].getArray()[0].length - 1;
  }
  this.cells=(double)input.getDataLength() * (double)input.getHeader().length;
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  height=new int[hierarchies.length];
  for (int j=0; j < height.length; j++) {
    height[j]=hierarchies[j].getArray()[0].length - 1;
  }
  int rowCount=0;
  if (config.containsCriterion(DPresence.class)) {
    Set<DPresence> crits=config.getCriteria(DPresence.class);
    if (crits.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    for (    DPresence dPresence : crits) {
      rowCount=dPresence.getSubset().getArray().length;
    }
  }
 else {
    rowCount=input.getDataLength();
  }
  this.cells=(double)rowCount * (double)input.getHeader().length;
}",0.6844166014095536
108382,"@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  if (node.getLowerBound() != null) {
    return (InformationLossDefault)node.getLowerBound();
  }
  double lowerBound=0d;
  HashGroupifyEntry m=groupify.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      double factor=0;
      for (int i=0; i < height.length; i++) {
        factor+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
      lowerBound+=m.count * factor;
    }
    m=m.nextOrdered;
  }
  lowerBound/=cells;
  return new InformationLossDefault(lowerBound);
}","@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  return getLowerBound(node);
}",0.3188811188811188
108383,"@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  double total=0d;
  double lowerBound=0d;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      double factor=0d;
      double factorLowerBound=0d;
      for (int i=0; i < height.length; i++) {
        factor+=m.isNotOutlier ? (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]) : 1d;
        factorLowerBound+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
      lowerBound+=m.count * factorLowerBound;
      total+=m.count * factor;
    }
    m=m.nextOrdered;
  }
  total/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(total,lowerBound);
}","@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  int suppressedTuples=0;
  int unsuppressedTuples=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    unsuppressedTuples+=m.isNotOutlier ? m.count : 0;
    suppressedTuples+=m.isNotOutlier ? 0 : m.count;
    m=m.nextOrdered;
  }
  double precision=0;
  double lowerBound=0;
  for (int i=0; i < height.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double value=height[i] == 0 ? 0 : (double)node.getTransformation()[i] / (double)height[i];
    precision+=(double)unsuppressedTuples * value * weight;
    precision+=(double)suppressedTuples * 1d * weight;
    lowerBound+=(double)unsuppressedTuples * value * weight;
  }
  precision/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(precision,lowerBound);
}",0.364963503649635
108384,"@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  if (node.getLowerBound() != null) {
    return (InformationLossDefault)node.getLowerBound();
  }
  double lowerBound=0d;
  HashGroupifyEntry m=groupify.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        lowerBound+=m.count * (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]);
      }
    }
    m=m.nextOrdered;
  }
  lowerBound/=cells;
  return new InformationLossDefault(lowerBound);
}","@Override public InformationLossDefault getLowerBound(Node node,IHashGroupify groupify){
  if (node.getLowerBound() != null) {
    return (InformationLossDefault)node.getLowerBound();
  }
  double lowerBound=0d;
  HashGroupifyEntry m=groupify.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      double factor=0;
      for (int i=0; i < height.length; i++) {
        factor+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
      lowerBound+=m.count * factor;
    }
    m=m.nextOrdered;
  }
  lowerBound/=cells;
  return new InformationLossDefault(lowerBound);
}",0.6503923278116827
108385,"@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  double total=0d;
  double lowerBound=0d;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      for (int i=0; i < height.length; i++) {
        total+=m.count * (m.isNotOutlier ? (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]) : 1d);
        lowerBound+=m.count * (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]);
      }
    }
    m=m.nextOrdered;
  }
  total/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(total,lowerBound);
}","@Override protected BoundInformationLoss<InformationLossDefault> evaluateInternal(final Node node,final IHashGroupify g){
  double total=0d;
  double lowerBound=0d;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      double factor=0d;
      double factorLowerBound=0d;
      for (int i=0; i < height.length; i++) {
        factor+=m.isNotOutlier ? (height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i]) : 1d;
        factorLowerBound+=height[i] == 0 ? 0 : (double)m.key[i] / (double)height[i];
      }
      lowerBound+=m.count * factorLowerBound;
      total+=m.count * factor;
    }
    m=m.nextOrdered;
  }
  total/=cells;
  lowerBound/=cells;
  return new BoundInformationLossDefault(total,lowerBound);
}",0.8573487031700289
108386,"private void checkScrollBars(){
  if (context.getTable().isDisposed()) {
    return;
  }
  Listener[] listeners=context.getTable().getListeners(SWT.Resize);
  for (  Listener listener : listeners) {
    context.getTable().removeListener(SWT.Resize,listener);
  }
  if (context.isColumnExpanded()) {
    context.getTable().getHorizontalBar().setVisible(true);
    context.getTable().getHorizontalBar().setValues(0,0,1,1,1,1);
    context.getTable().getHorizontalBar().setEnabled(false);
  }
  if (context.isRowExpanded()) {
    context.getTable().getVerticalBar().setVisible(true);
    context.getTable().getVerticalBar().setValues(0,0,1,1,1,1);
    context.getTable().getVerticalBar().setEnabled(false);
  }
  for (  Listener listener : listeners) {
    context.getTable().addListener(SWT.Resize,listener);
  }
}","private void checkScrollBars(){
  if (context.getTable().isDisposed()) {
    return;
  }
  Listener[] listeners=null;
  if (context.getTable() != null && !context.getTable().isDisposed()) {
    listeners=context.getTable().getListeners(SWT.Resize);
    for (    Listener listener : listeners) {
      context.getTable().removeListener(SWT.Resize,listener);
    }
  }
  if (context.isColumnExpanded()) {
    context.getTable().getHorizontalBar().setVisible(true);
    context.getTable().getHorizontalBar().setValues(0,0,1,1,1,1);
    context.getTable().getHorizontalBar().setEnabled(false);
  }
  if (context.isRowExpanded()) {
    context.getTable().getVerticalBar().setVisible(true);
    context.getTable().getVerticalBar().setValues(0,0,1,1,1,1);
    context.getTable().getVerticalBar().setEnabled(false);
  }
  if (context.getTable() != null && !context.getTable().isDisposed()) {
    for (    Listener listener : listeners) {
      context.getTable().addListener(SWT.Resize,listener);
    }
  }
}",0.891832229580574
108387,"@Override public boolean doCommand(ILayerCommand command){
  context.getTable().getHorizontalBar().getParent().setRedraw(false);
  context.getTable().getVerticalBar().getParent().setRedraw(false);
  boolean result=super.doCommand(command);
  if (command instanceof ClientAreaResizeCommand) {
    checkScrollBars();
  }
 else   if (command instanceof RecalculateScrollBarsCommand) {
    checkScrollBars();
  }
 else   if (command instanceof StructuralRefreshCommand) {
    checkScrollBars();
  }
  context.getTable().getHorizontalBar().getParent().setRedraw(true);
  context.getTable().getVerticalBar().getParent().setRedraw(true);
  return result;
}","@Override public boolean doCommand(ILayerCommand command){
  if (context.getTable() != null && !context.getTable().isDisposed()) {
    context.getTable().getHorizontalBar().getParent().setRedraw(false);
    context.getTable().getVerticalBar().getParent().setRedraw(false);
  }
  boolean result=super.doCommand(command);
  if (command instanceof ClientAreaResizeCommand) {
    checkScrollBars();
  }
 else   if (command instanceof RecalculateScrollBarsCommand) {
    checkScrollBars();
  }
 else   if (command instanceof StructuralRefreshCommand) {
    checkScrollBars();
  }
  if (context.getTable() != null && !context.getTable().isDisposed()) {
    context.getTable().getHorizontalBar().getParent().setRedraw(true);
    context.getTable().getVerticalBar().getParent().setRedraw(true);
  }
  return result;
}",0.8902606310013718
108388,"/** 
 * We may be able to prune some transformations based on weak lower bounds on the monotonic share of a node's information loss
 * @param node
 */
private void prune(Node node){
  if (node.getInformationLoss() == null || node.getLowerBound() == null) {
    return;
  }
  if (node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
    return;
  }
  if (super.getGlobalOptimum() == null) {
    pruningCandidates.add(node);
    return;
  }
  Node optimalTransformation=getGlobalOptimum();
  InformationLoss<?> optimalInfoLoss=optimalTransformation.getInformationLoss();
  if (node != optimalTransformation) {
    if (optimalInfoLoss.compareTo(node.getLowerBound()) <= 0) {
      lattice.setPropertyUpwards(node,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
    }
 else {
      pruningCandidates.add(node);
    }
  }
 else {
    Iterator<Node> iterator=pruningCandidates.iterator();
    while (iterator.hasNext()) {
      Node current=iterator.next();
      if (current.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
        iterator.remove();
      }
 else       if (optimalInfoLoss.compareTo(current.getLowerBound()) <= 0) {
        lattice.setPropertyUpwards(current,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        iterator.remove();
      }
    }
    pruningCandidates.add(node);
  }
}","/** 
 * We may be able to prune some transformations based on weak lower bounds on the monotonic share of a node's information loss
 * @param node
 */
private void prune(Node node){
  if (node.getLowerBound() == null) {
    return;
  }
  if (node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
    return;
  }
  if (super.getGlobalOptimum() == null) {
    pruningCandidates.add(node);
    return;
  }
  Node optimalTransformation=getGlobalOptimum();
  InformationLoss<?> optimalInfoLoss=optimalTransformation.getInformationLoss();
  if (node != optimalTransformation) {
    if (optimalInfoLoss.compareTo(node.getLowerBound()) <= 0) {
      lattice.setPropertyUpwards(node,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
    }
 else {
      pruningCandidates.add(node);
    }
  }
 else {
    Iterator<Node> iterator=pruningCandidates.iterator();
    while (iterator.hasNext()) {
      Node current=iterator.next();
      if (current.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
        iterator.remove();
      }
 else       if (optimalInfoLoss.compareTo(current.getLowerBound()) <= 0) {
        lattice.setPropertyUpwards(current,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        iterator.remove();
      }
    }
    pruningCandidates.add(node);
  }
}",0.9861475102957694
108389,"/** 
 * Analyze
 */
private void analyzeAll(){
  boolean dpresent=true;
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    int anonymous=isAnonymous(entry);
    if (anonymous != -1) {
      if (dpresence && entry.count == 0 && anonymous == 1) {
        dpresent=false;
      }
      currentOutliers+=entry.count;
    }
    entry.isNotOutlier=entry.count != 0 ? (anonymous == -1) : true;
    entry=entry.nextOrdered;
  }
  this.anonymous=(currentOutliers <= absoluteMaxOutliers) && dpresent;
}","/** 
 * Analyze
 */
private void analyzeAll(){
  kAnonymous=(currentOutliers <= absoluteMaxOutliers);
  boolean dpresent=true;
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    int anonymous=isAnonymous(entry);
    if (anonymous != -1) {
      if (dpresence && entry.count == 0 && anonymous == 1) {
        dpresent=false;
      }
      currentOutliers+=entry.count;
    }
    entry.isNotOutlier=entry.count != 0 ? (anonymous == -1) : true;
    entry=entry.nextOrdered;
  }
  this.anonymous=(currentOutliers <= absoluteMaxOutliers) && dpresent;
}",0.9506726457399104
108390,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  maxLevels=new int[hierarchies.length];
  for (int j=0; j < maxLevels.length; j++) {
    maxLevels[j]=hierarchies[j].getArray()[0].length;
  }
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] hierarchies,final ARXConfiguration config){
  super.initializeInternal(definition,input,hierarchies,config);
  height=new int[hierarchies.length];
  for (int j=0; j < height.length; j++) {
    height[j]=hierarchies[j].getArray()[0].length - 1;
  }
}",0.9349269588313412
108391,"protected MetricPrecision(){
  super(true,true);
}","/** 
 * Creates a new instance
 */
protected MetricPrecision(){
  super(true,true);
}",0.7407407407407407
108392,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  double value=0;
  double divisor=0;
  final int[] state=node.getTransformation();
  for (int i=0; i < state.length; i++) {
    divisor++;
    double weight=weights != null ? weights[i] : 1d;
    value+=((double)state[i] / (double)maxLevels[i]) * weight;
  }
  return new InformationLossDefault(value / divisor,value / divisor);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  double result=0;
  final int[] transformation=node.getTransformation();
  for (int i=0; i < transformation.length; i++) {
    double weight=weights != null ? weights[i] : 1d;
    double level=(double)transformation[i];
    result+=height[i] == 0 ? 0 : (level / (double)height[i]) * weight;
  }
  result/=(double)transformation.length;
  return new InformationLossDefault(result,result);
}",0.4495114006514658
108393,"/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=null;
  InformationLoss<?> max=null;
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      InformationLoss<?> nodeMin=node.getMinimumInformationLoss();
      InformationLoss<?> nodeMax=node.getMaximumInformationLoss();
      if (nodeMin != null && nodeMin.equals(nodeMax)) {
        if (min == null || min.compareTo(nodeMin) > 0) {
          min=nodeMin.clone();
        }
        if (max == null || max.compareTo(nodeMax) < 0) {
          max=nodeMax.clone();
        }
      }
    }
  }
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (node.minInformationLoss == null) {
        node.minInformationLoss=min.clone();
      }
      if (node.maxInformationLoss == null) {
        node.maxInformationLoss=max.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}","/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=null;
  InformationLoss<?> max=null;
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      InformationLoss<?> nodeMin=node.getMinimumInformationLoss();
      InformationLoss<?> nodeMax=node.getMaximumInformationLoss();
      if (nodeMin != null && nodeMin.equals(nodeMax)) {
        if (min == null || min.compareTo(nodeMin) > 0) {
          min=nodeMin.clone();
        }
        if (max == null || max.compareTo(nodeMax) < 0) {
          max=nodeMax.clone();
        }
      }
    }
  }
  if (min == null)   min=metric.createMinInformationLoss();
  if (max == null)   max=metric.createMaxInformationLoss();
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (node.minInformationLoss == null) {
        node.minInformationLoss=min.clone();
      }
      if (node.maxInformationLoss == null) {
        node.maxInformationLoss=max.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}",0.947871416159861
108394,"/** 
 * We may be able to prune some transformations based on weak lower bounds on the monotonic share of a node's information loss
 * @param node
 */
private void prune(Node node){
  if (node.getInformationLoss().getLowerBound() == null) {
    return;
  }
  if (node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
    return;
  }
  if (super.getGlobalOptimum() == null) {
    pruningCandidates.add(node);
    return;
  }
  Node optimalTransformation=getGlobalOptimum();
  InformationLoss<?> optimalInfoLoss=optimalTransformation.getInformationLoss();
  if (node != optimalTransformation) {
    if (optimalInfoLoss.compareTo(node.getInformationLoss().getLowerBound()) <= 0) {
      lattice.setPropertyUpwards(node,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
    }
 else {
      pruningCandidates.add(node);
    }
  }
 else {
    Iterator<Node> iterator=pruningCandidates.iterator();
    while (iterator.hasNext()) {
      Node current=iterator.next();
      if (current.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
        iterator.remove();
      }
 else       if (optimalInfoLoss.compareTo(current.getInformationLoss().getLowerBound()) <= 0) {
        lattice.setPropertyUpwards(current,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        iterator.remove();
      }
    }
    pruningCandidates.add(node);
  }
}","/** 
 * We may be able to prune some transformations based on weak lower bounds on the monotonic share of a node's information loss
 * @param node
 */
private void prune(Node node){
  if (node.getInformationLoss() == null || node.getInformationLoss().getLowerBound() == null) {
    return;
  }
  if (node.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
    return;
  }
  if (super.getGlobalOptimum() == null) {
    pruningCandidates.add(node);
    return;
  }
  Node optimalTransformation=getGlobalOptimum();
  InformationLoss<?> optimalInfoLoss=optimalTransformation.getInformationLoss();
  if (node != optimalTransformation) {
    if (optimalInfoLoss.compareTo(node.getInformationLoss().getLowerBound()) <= 0) {
      lattice.setPropertyUpwards(node,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
    }
 else {
      pruningCandidates.add(node);
    }
  }
 else {
    Iterator<Node> iterator=pruningCandidates.iterator();
    while (iterator.hasNext()) {
      Node current=iterator.next();
      if (current.hasProperty(Node.PROPERTY_SUCCESSORS_PRUNED)) {
        iterator.remove();
      }
 else       if (optimalInfoLoss.compareTo(current.getInformationLoss().getLowerBound()) <= 0) {
        lattice.setPropertyUpwards(current,true,Node.PROPERTY_INSUFFICIENT_UTILITY | Node.PROPERTY_SUCCESSORS_PRUNED);
        iterator.remove();
      }
    }
    pruningCandidates.add(node);
  }
}",0.986771540936718
108395,"/** 
 * Creates a new instance
 * @param lowerBound
 * @param informationLoss
 */
public BoundInformationLossDefault(double lowerBound,double informationLoss){
  super(new InformationLossDefault(lowerBound),new InformationLossDefault(informationLoss));
}","/** 
 * Creates a new instance
 * @param informationLoss
 * @param lowerBound
 */
public BoundInformationLossDefault(double informationLoss,double lowerBound){
  super(new InformationLossDefault(lowerBound),new InformationLossDefault(informationLoss));
}",0.8031496062992126
108396,"/** 
 * Checks a path binary.
 * @param path The path
 * @param queue 
 */
private Node checkPath(List<Node> path,NodeAction triggerSkip,PriorityQueue<Node> queue){
  int anonymityProperty=config.getBinaryPhaseConfiguration().getAnonymityProperty();
  int low=0;
  int high=path.size() - 1;
  Node lastAnonymousNode=null;
  while (low <= high) {
    final int mid=(low + high) >>> 1;
    final Node node=path.get(mid);
    if (!skip(triggerSkip,node)) {
      checkAndTag(node,config.getBinaryPhaseConfiguration());
      if (!node.hasProperty(anonymityProperty)) {
        for (        final Node up : node.getSuccessors()) {
          if (!skip(triggerSkip,up)) {
            queue.add(up);
          }
        }
      }
      if (node.hasProperty(anonymityProperty)) {
        lastAnonymousNode=node;
        high=mid - 1;
      }
 else {
        low=mid + 1;
      }
    }
  }
  return lastAnonymousNode;
}","/** 
 * Checks a path binary.
 * @param path The path
 * @param queue 
 */
private Node checkPath(List<Node> path,NodeAction triggerSkip,PriorityQueue<Node> queue){
  int anonymityProperty=config.getBinaryPhaseConfiguration().getAnonymityProperty();
  int low=0;
  int high=path.size() - 1;
  Node lastAnonymousNode=null;
  while (low <= high) {
    final int mid=(low + high) / 2;
    final Node node=path.get(mid);
    if (!skip(triggerSkip,node)) {
      checkAndTag(node,config.getBinaryPhaseConfiguration());
      if (!node.hasProperty(anonymityProperty)) {
        for (        final Node up : node.getSuccessors()) {
          if (!skip(triggerSkip,up)) {
            queue.add(up);
          }
        }
      }
      if (node.hasProperty(anonymityProperty)) {
        lastAnonymousNode=node;
        high=mid - 1;
      }
 else {
        low=mid + 1;
      }
    }
 else {
      high=mid - 1;
    }
  }
  return lastAnonymousNode;
}",0.9773218142548596
108397,"/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(DPresence.class)) {
    this.subset=config.getCriterion(DPresence.class).getSubset().getSet();
  }
 else {
    this.subset=null;
  }
  this.criteria=config.getCriteriaAsArray();
  this.k=config.getMinimalGroupSize();
}","/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(DPresence.class)) {
    this.subset=config.getCriterion(DPresence.class).getSubset().getSet();
  }
 else {
    this.subset=null;
  }
  this.criteria=config.getCriteriaAsArray();
  this.k=config.getMinimalGroupSize();
  for (int i=1; i < criteria.length; i++) {
    if (criteria[i] instanceof DPresence) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  dpresence=(criteria.length > 0 && (criteria[0] instanceof DPresence) && !(criteria[0] instanceof Inclusion));
}",0.8446544595392794
108398,"/** 
 * Checks whether the given entry is anonymous
 * @param entry
 * @return
 */
private boolean isAnonymous(HashGroupifyEntry entry){
  if (k != Integer.MAX_VALUE && entry.count < k) {
    return false;
  }
  for (int i=0; i < criteria.length; i++) {
    if (!criteria[i].isAnonymous(entry)) {
      return false;
    }
  }
  return true;
}","/** 
 * Checks whether the given entry is anonymous
 * @param entry
 * @returns -1, if all criteria are fulfilled, 0, if minimal group size is not fulfilled, (index+1) if criteria[index] is not fulfilled
 */
private int isAnonymous(HashGroupifyEntry entry){
  if (k != Integer.MAX_VALUE && entry.count < k) {
    return 0;
  }
  for (int i=0; i < criteria.length; i++) {
    if (!criteria[i].isAnonymous(entry)) {
      return i + 1;
    }
  }
  return -1;
}",0.8039950062421972
108399,"@Override public void analyze(){
  kAnonymous=(currentOutliers <= absoluteMaxOutliers);
  if (criteria.length == 0) {
    anonymous=kAnonymous;
    return;
  }
  if (k != Integer.MAX_VALUE && !kAnonymous) {
    anonymous=false;
    return;
  }
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      currentOutliers+=entry.count;
      if (currentOutliers > absoluteMaxOutliers) {
        this.anonymous=false;
        return;
      }
    }
    entry.isNotOutlier=anonymous;
    entry=entry.nextOrdered;
  }
  this.anonymous=true;
}","@Override public void analyze(){
  kAnonymous=(currentOutliers <= absoluteMaxOutliers);
  if (criteria.length == 0) {
    anonymous=kAnonymous;
    return;
  }
  if (k != Integer.MAX_VALUE && !kAnonymous) {
    anonymous=false;
    return;
  }
  currentOutliers=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    int anonymous=isAnonymous(entry);
    if (anonymous != -1) {
      if (dpresence && entry.count == 0 && anonymous == 1) {
        this.anonymous=false;
        return;
      }
      currentOutliers+=entry.count;
      if (currentOutliers > absoluteMaxOutliers) {
        this.anonymous=false;
        return;
      }
    }
    entry.isNotOutlier=(anonymous == -1);
    entry=entry.nextOrdered;
  }
  this.anonymous=true;
}",0.5229885057471264
108400,"/** 
 * Updates the max generalization level
 * @return
 */
private boolean pushMax(){
  if (max.getSelectionIndex() >= 0 && max.getItemCount() > 1) {
    if (max.getSelectionIndex() < (min.getSelectionIndex() - 1)) {
      max.select(min.getSelectionIndex() - 1);
    }
    if (model != null) {
      String val=max.getItem(max.getSelectionIndex());
      if (val.equals(ITEM_ALL)) {
        model.getInputConfig().setMaximumGeneralization(attribute,null);
      }
 else {
        model.getInputConfig().setMaximumGeneralization(attribute,Integer.valueOf(val) - 1);
      }
      return true;
    }
  }
  return false;
}","/** 
 * Updates the max generalization level
 * @return
 */
private boolean pushMax(){
  if (max.getSelectionIndex() >= 0) {
    if (max.getSelectionIndex() < (min.getSelectionIndex() - 1)) {
      max.select(min.getSelectionIndex() - 1);
    }
    if (model != null) {
      String val=max.getItem(max.getSelectionIndex());
      model.getInputConfig().setMaximumGeneralization(attribute,val.equals(ITEM_ALL) ? null : Integer.valueOf(val));
      return true;
    }
  }
  return false;
}",0.6600541027953111
108401,"/** 
 * Updates the combos
 */
private void updateCombos(){
  if (model == null || min == null || min.isDisposed()) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  for (int i=1; i <= (hierarchy == null ? 0 : hierarchy[0].length); i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  String minSelected=ITEM_ALL;
  if (minModel != null)   minSelected=String.valueOf(minModel + 1);
  int minIndex=minIndexOf(minSelected);
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  String maxSelected=ITEM_ALL;
  if (maxModel != null)   maxSelected=String.valueOf(maxModel + 1);
  int maxIndex=maxIndexOf(maxSelected);
  if (minIndex > (maxIndex + 1)) {
    minIndex=maxIndex + 1;
  }
  min.setItems(minItems.toArray(new String[]{}));
  max.setItems(maxItems.toArray(new String[]{}));
  min.select(minIndex);
  max.select(maxIndex);
  pushMin();
  pushMax();
}","/** 
 * Updates the combos
 */
private void updateCombos(){
  if (model == null || min == null || min.isDisposed()) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  for (int i=0; i < (hierarchy == null ? 0 : hierarchy[0].length); i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  int minIndex=minModel != null ? minModel + 1 : 0;
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  int maxIndex=maxModel != null ? maxModel : maxItems.size() - 1;
  maxIndex=maxIndex > maxItems.size() - 1 ? maxItems.size() - 1 : maxIndex;
  maxIndex=maxIndex < 0 ? maxItems.size() - 1 : maxIndex;
  minIndex=minIndex > minItems.size() - 1 ? minItems.size() - 1 : minIndex;
  minIndex=minIndex < 0 ? 0 : minIndex;
  minIndex=minIndex > (maxIndex + 1) ? maxIndex + 1 : minIndex;
  min.setItems(minItems.toArray(new String[minItems.size()]));
  max.setItems(maxItems.toArray(new String[maxItems.size()]));
  min.select(minIndex);
  max.select(maxIndex);
  pushMin();
  pushMax();
}",0.5217758985200845
108402,"/** 
 * Updates the min generalization level
 * @return
 */
private boolean pushMin(){
  if (min.getSelectionIndex() >= 0 && min.getItemCount() > 1) {
    if (min.getSelectionIndex() > (max.getSelectionIndex() + 1)) {
      min.select(max.getSelectionIndex() + 1);
    }
    if (model != null) {
      String val=min.getItem(min.getSelectionIndex());
      if (val.equals(ITEM_ALL)) {
        model.getInputConfig().setMinimumGeneralization(attribute,null);
      }
 else {
        model.getInputConfig().setMinimumGeneralization(attribute,Integer.valueOf(val) - 1);
      }
      return true;
    }
  }
  return false;
}","/** 
 * Updates the min generalization level
 * @return
 */
private boolean pushMin(){
  if (min.getSelectionIndex() >= 0) {
    if (min.getSelectionIndex() > (max.getSelectionIndex() + 1)) {
      min.select(max.getSelectionIndex() + 1);
    }
    if (model != null) {
      String val=min.getItem(min.getSelectionIndex());
      model.getInputConfig().setMinimumGeneralization(attribute,val.equals(ITEM_ALL) ? null : Integer.valueOf(val));
      return true;
    }
  }
  return false;
}",0.6600541027953111
108403,"/** 
 * Clears the table
 */
public void clear(){
  this.dataProviderBody.clear();
  this.dataProviderColumnHeader.clear();
  this.dataProviderRowHeader.clear();
  this.table.refresh();
  this.selectedRow=null;
  this.selectedColumn=null;
}","/** 
 * Clears the table
 */
public void clear(){
  this.table.doCommand(new CTLayerCommandReset());
  this.dataProviderBody.clear();
  this.dataProviderColumnHeader.clear();
  this.dataProviderRowHeader.clear();
  this.table.refresh();
  this.selectedRow=null;
  this.selectedColumn=null;
}",0.903954802259887
108404,"/** 
 * Resets the output
 */
private void actionResetOutput(){
  model.getViewConfig().setMode(Mode.UNSORTED);
  model.getViewConfig().setSubset(false);
  model.setGroups(null);
  update(new ModelEvent(this,ModelPart.VIEW_CONFIG,null));
  model.setResult(null);
  model.setOutputConfig(null);
  update(new ModelEvent(this,ModelPart.RESULT,null));
  model.setOutput(null,null);
  update(new ModelEvent(this,ModelPart.OUTPUT,null));
  model.setSelectedNode(null);
  update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
}","/** 
 * Resets the output
 */
private void actionResetOutput(){
  model.getViewConfig().setMode(Mode.UNSORTED);
  model.getViewConfig().setSubset(false);
  model.setGroups(null);
  model.setResult(null);
  model.setOutputConfig(null);
  model.setOutput(null,null);
  model.setSelectedNode(null);
  update(new ModelEvent(this,ModelPart.VIEW_CONFIG,null));
  update(new ModelEvent(this,ModelPart.RESULT,null));
  update(new ModelEvent(this,ModelPart.OUTPUT,null));
  update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
}",0.7771428571428571
108405,"/** 
 * Stops this analysis
 */
public synchronized void stop(){
  this.stopped=true;
  this.analysis.stop();
}","/** 
 * Stops all running analysis threads
 */
public void stop(){
  if (worker != null && !worker.isStopped()) {
    worker.stop();
    try {
      try {
        worker.getThread().interrupt();
      }
 catch (      SecurityException e) {
      }
      if (worker.getThread().isAlive()) {
        worker.getThread().join();
      }
    }
 catch (    InterruptedException e) {
    }
    worker=null;
  }
}",0.1627906976744186
108406,"/** 
 * Start a new analysis. Analyses already executing will be canceled.
 * @param analysis
 */
public synchronized void start(Analysis analysis){
  if (worker != null && !worker.isStopped()) {
    worker.stop();
    try {
      try {
        worker.getThread().interrupt();
      }
 catch (      SecurityException e) {
      }
      if (worker.getThread().isAlive()) {
        worker.getThread().join();
      }
    }
 catch (    InterruptedException e) {
    }
    worker=null;
  }
  worker=new AnalysisWorker(analysis);
  worker.start();
}","/** 
 * Start a new analysis. Analyses already executing will be canceled.
 * @param analysis
 */
public synchronized void start(Analysis analysis){
  stop();
  worker=new AnalysisWorker(analysis);
  worker.start();
}",0.4441524310118265
108407,"@Override protected void doReset(){
  this.table.clear();
}","@Override protected void doReset(){
  if (this.manager != null) {
    this.manager.stop();
  }
  this.table.clear();
}",0.6666666666666666
108408,"@Override protected void doReset(){
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(root,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  chart.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      updateCategories();
    }
  }
);
  chart.getPlotArea().addListener(SWT.MouseMove,new Listener(){
    @Override public void handleEvent(    Event event){
      IAxisSet axisSet=chart.getAxisSet();
      if (axisSet != null) {
        IAxis xAxis=axisSet.getXAxis(0);
        if (xAxis != null) {
          String[] series=xAxis.getCategorySeries();
          ISeries[] data=chart.getSeriesSet().getSeries();
          if (data != null && data.length > 0 && series != null) {
            int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
            if (x >= 0 && x < series.length) {
              chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
              return;
            }
          }
        }
      }
      chart.getPlotArea().setToolTipText(null);
    }
  }
);
  FontData[] fd=chart.getFont().getFontData();
  fd[0].setHeight(8);
  chart.setFont(new Font(chart.getDisplay(),fd[0]));
  ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(chart.getFont());
  chart.setBackground(root.getBackground());
  chart.setForeground(root.getForeground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final Color c2=new Color(chart.getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  IAxisSet axisSet=chart.getAxisSet();
  IAxis yAxis=axisSet.getYAxis(0);
  IAxis xAxis=axisSet.getXAxis(0);
  ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(chart.getFont());
  yAxis.getTitle().setFont(chart.getFont());
  xAxis.getTick().setFont(chart.getFont());
  yAxis.getTick().setFont(chart.getFont());
  xAxis.getTick().setForeground(chart.getForeground());
  yAxis.getTick().setForeground(chart.getForeground());
  xAxis.getTitle().setForeground(chart.getForeground());
  yAxis.getTitle().setForeground(chart.getForeground());
  ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  chart.setEnabled(false);
  updateCategories();
}","@Override protected void doReset(){
  if (this.manager != null) {
    this.manager.stop();
  }
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(root,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  chart.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      updateCategories();
    }
  }
);
  chart.getPlotArea().addListener(SWT.MouseMove,new Listener(){
    @Override public void handleEvent(    Event event){
      IAxisSet axisSet=chart.getAxisSet();
      if (axisSet != null) {
        IAxis xAxis=axisSet.getXAxis(0);
        if (xAxis != null) {
          String[] series=xAxis.getCategorySeries();
          ISeries[] data=chart.getSeriesSet().getSeries();
          if (data != null && data.length > 0 && series != null) {
            int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
            if (x >= 0 && x < series.length) {
              chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
              return;
            }
          }
        }
      }
      chart.getPlotArea().setToolTipText(null);
    }
  }
);
  FontData[] fd=chart.getFont().getFontData();
  fd[0].setHeight(8);
  chart.setFont(new Font(chart.getDisplay(),fd[0]));
  ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(chart.getFont());
  chart.setBackground(root.getBackground());
  chart.setForeground(root.getForeground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final Color c2=new Color(chart.getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  IAxisSet axisSet=chart.getAxisSet();
  IAxis yAxis=axisSet.getYAxis(0);
  IAxis xAxis=axisSet.getXAxis(0);
  ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(chart.getFont());
  yAxis.getTitle().setFont(chart.getFont());
  xAxis.getTick().setFont(chart.getFont());
  yAxis.getTick().setFont(chart.getFont());
  xAxis.getTick().setForeground(chart.getForeground());
  yAxis.getTick().setForeground(chart.getForeground());
  xAxis.getTitle().setForeground(chart.getForeground());
  yAxis.getTitle().setForeground(chart.getForeground());
  ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  chart.setEnabled(false);
  updateCategories();
}",0.9892941389947378
108409,"@Override protected void doReset(){
  this.table.clear();
}","@Override protected void doReset(){
  if (this.manager != null) {
    this.manager.stop();
  }
  this.table.clear();
}",0.6666666666666666
108410,"@Override public boolean isAnonymous(HashGroupifyEntry entry){
  if (entry.count > 0) {
    double dCurrent=(double)entry.count / (double)entry.pcount;
    return (dCurrent >= dMin) && (dCurrent <= dMax);
  }
 else {
    return true;
  }
}","@Override public boolean isAnonymous(HashGroupifyEntry entry){
  double delta=entry.count == 0 ? 0d : (double)entry.count / (double)entry.pcount;
  return (delta >= dMin) && (delta <= dMax);
}",0.7888631090487239
108411,"@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  if (_max.perc - _min.perc == 0)   return 0d;
  return (perc - _min.perc) / (_max.perc - _min.perc);
}","@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  if (_max.perc - _min.perc == 0)   return 0d;
  double result=(perc - _min.perc) / (_max.perc - _min.perc);
  return result >= 0d ? (result <= 1d ? result : 1d) : 0d;
}",0.9154334038054968
108412,"/** 
 * Triggers a tagged event at the listener
 */
private void triggerTagged(Node node){
  if (this.listener != null) {
    if (tagTrigger == null || tagTrigger.appliesTo(node)) {
      this.listener.nodeTagged(size);
    }
  }
}","/** 
 * Triggers a tagged event at the listener
 */
private void triggerTagged(Node node){
  if (this.listener != null && !node.hasProperty(Node.PROPERTY_EVENT_FIRED)) {
    if (tagTrigger == null || tagTrigger.appliesTo(node)) {
      node.setProperty(Node.PROPERTY_EVENT_FIRED);
      this.listener.nodeTagged(size);
    }
  }
}",0.8235294117647058
108413,"@Override public void moveCellPositionIntoViewport(int scrollableColumnPosition,int scrollableRowPosition){
}","@Override public void moveCellPositionIntoViewport(int scrollableColumnPosition,int scrollableRowPosition){
  if (!(context.isRowExpanded() && context.isColumnExpanded())) {
    super.moveCellPositionIntoViewport(scrollableColumnPosition,scrollableRowPosition);
  }
}",0.5797872340425532
108414,"@Override public void moveColumnPositionIntoViewport(int scrollableColumnPosition){
}","@Override public void moveColumnPositionIntoViewport(int scrollableColumnPosition){
  if (!context.isColumnExpanded()) {
    super.moveColumnPositionIntoViewport(scrollableColumnPosition);
  }
}",0.6093189964157706
108415,"@Override public void moveRowPositionIntoViewport(int scrollableRowPosition){
}","@Override public void moveRowPositionIntoViewport(int scrollableRowPosition){
  if (!context.isRowExpanded()) {
    super.moveRowPositionIntoViewport(scrollableRowPosition);
  }
}",0.6124031007751938
108416,"@Override public boolean doCommand(ILayerCommand command){
  if (!registered && context.getTable() != null) {
    registered=true;
    context.getTable().addControlListener(new ControlAdapter(){
      public void controlResized(      ControlEvent arg0){
        checkScrollBars();
      }
    }
);
  }
  if (context.isColumnExpanded() && context.isRowExpanded()) {
    return underlyingLayer.doCommand(command);
  }
 else {
    return super.doCommand(command);
  }
}","@Override public boolean doCommand(ILayerCommand command){
  if (!registered && context.getTable() != null) {
    registered=true;
    context.getTable().addControlListener(new ControlAdapter(){
      public void controlResized(      ControlEvent arg0){
        checkScrollBars();
      }
    }
);
  }
  return super.doCommand(command);
}",0.8109452736318408
108417,"@Override public boolean doCommand(ILayerCommand command){
  if (command instanceof FillLayerResetCommand) {
    this.modified=false;
    if (isEqualWidthActive()) {
      this.ignore=true;
      for (int i=0; i < getColumnCount(); i++) {
        ColumnResizeCommand resize=new ColumnResizeCommand(this,i,DataLayer.DEFAULT_COLUMN_WIDTH);
        underlyingLayer.doCommand(resize);
      }
      this.ignore=false;
    }
  }
  return super.doCommand(command);
}","@Override public boolean doCommand(ILayerCommand command){
  if (command instanceof FillLayerResetCommand) {
    this.modified=false;
    this.ignore=true;
    for (int i=0; i < getColumnCount(); i++) {
      ColumnResizeCommand resize=new ColumnResizeCommand(this,i,DataLayer.DEFAULT_COLUMN_WIDTH);
      underlyingLayer.doCommand(resize);
    }
    this.ignore=false;
  }
  return super.doCommand(command);
}",0.8666666666666667
108418,"private int getGapWidth(){
  NatTable table=getContext().getTable();
  return table != null ? table.getSize().x - super.getWidth() : 0;
}","private int getGapWidth(){
  NatTable table=getContext().getTable();
  if (table.isDisposed())   return 0;
  return table != null ? table.getSize().x - super.getWidth() : 0;
}",0.8782051282051282
108419,"private int getEqualWidth(){
  int offset=underlyingLayer.getClientAreaProvider().getClientArea().x;
  int width=getContext().getTable().getSize().x - offset;
  if (underlyingLayer.getColumnCount() == 0) {
    return width;
  }
  return width / underlyingLayer.getColumnCount();
}","private int getEqualWidth(){
  NatTable table=getContext().getTable();
  if (table.isDisposed())   return 0;
  int offset=underlyingLayer.getClientAreaProvider().getClientArea().x;
  int width=table.getSize().x - offset;
  if (underlyingLayer.getColumnCount() == 0) {
    return width;
  }
  return width / underlyingLayer.getColumnCount();
}",0.7909967845659164
108420,"private int getGapHeight(){
  NatTable table=getContext().getTable();
  return table != null ? table.getSize().y - DataLayer.DEFAULT_ROW_HEIGHT - super.getHeight() : 0;
}","private int getGapHeight(){
  NatTable table=getContext().getTable();
  if (table.isDisposed())   return 0;
  return table != null ? table.getSize().y - DataLayer.DEFAULT_ROW_HEIGHT - super.getHeight() : 0;
}",0.8994708994708994
108421,"private void checkScrollBars(){
  Listener[] listeners=context.getTable().getListeners(SWT.Resize);
  for (  Listener listener : listeners) {
    context.getTable().removeListener(SWT.Resize,listener);
  }
  if (context.isColumnExpanded()) {
    context.getTable().getHorizontalBar().setVisible(false);
  }
  if (context.isRowExpanded()) {
    context.getTable().getVerticalBar().setVisible(false);
  }
  for (  Listener listener : listeners) {
    context.getTable().addListener(SWT.Resize,listener);
  }
}","private void checkScrollBars(){
  if (context.getTable().isDisposed()) {
    return;
  }
  Listener[] listeners=context.getTable().getListeners(SWT.Resize);
  for (  Listener listener : listeners) {
    context.getTable().removeListener(SWT.Resize,listener);
  }
  if (context.isColumnExpanded()) {
    context.getTable().getHorizontalBar().setVisible(false);
  }
  if (context.isRowExpanded()) {
    context.getTable().getVerticalBar().setVisible(false);
  }
  for (  Listener listener : listeners) {
    context.getTable().addListener(SWT.Resize,listener);
  }
}",0.9467787114845938
108422,"/** 
 * Action
 * @param arg0
 */
private void actionColumnSelected(ColumnSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int column=arg0.getColumnPositionRanges().iterator().next().start;
  if (column >= 0) {
    this.selectedColumn=column;
    fireSelectionEvent();
  }
}","/** 
 * Action
 * @param arg0
 */
private boolean actionColumnSelected(ColumnSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int column=arg0.getColumnPositionRanges().iterator().next().start;
  if (column >= 0 && column < dataProviderBody.getColumnCount()) {
    this.selectedColumn=column;
    fireSelectionEvent();
    return true;
  }
 else {
    return false;
  }
}",0.8514285714285714
108423,"@Override public void handleLayerEvent(ILayerEvent arg0){
  if (arg0 instanceof CellSelectionEvent) {
    actionCellSelected((CellSelectionEvent)arg0);
  }
 else   if (arg0 instanceof ColumnSelectionEvent) {
    actionColumnSelected((ColumnSelectionEvent)arg0);
  }
 else   if (arg0 instanceof RowSelectionEvent) {
    actionRowSelected((RowSelectionEvent)arg0);
  }
}","@Override public void handleLayerEvent(ILayerEvent arg0){
  if (arg0 instanceof CellSelectionEvent) {
    if (!actionCellSelected((CellSelectionEvent)arg0)) {
      layer.clear(true);
    }
  }
 else   if (arg0 instanceof ColumnSelectionEvent) {
    if (!actionColumnSelected((ColumnSelectionEvent)arg0)) {
      layer.clear(true);
    }
  }
 else   if (arg0 instanceof RowSelectionEvent) {
    if (!actionRowSelected((RowSelectionEvent)arg0)) {
      layer.clear(true);
    }
  }
}",0.7576470588235295
108424,"/** 
 * Action
 * @param arg0
 */
private void actionCellSelected(CellSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int column=arg0.getColumnPosition();
  int row=arg0.getRowPosition();
  if (column >= 0 && row >= 0) {
    this.selectedColumn=column;
    this.selectedRow=row;
    fireSelectionEvent();
  }
}","/** 
 * Action
 * @param arg0
 */
private boolean actionCellSelected(CellSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int column=arg0.getColumnPosition();
  int row=arg0.getRowPosition();
  if (column >= 0 && row >= 0 && row < dataProviderBody.getRowCount() && column < dataProviderBody.getColumnCount()) {
    this.selectedColumn=column;
    this.selectedRow=row;
    fireSelectionEvent();
    return true;
  }
 else {
    return false;
  }
}",0.8230958230958231
108425,"/** 
 * Adds a selection listener
 * @param layer
 */
private void addSelectionListener(SelectionLayer layer){
  layer.addLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        actionCellSelected((CellSelectionEvent)arg0);
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        actionColumnSelected((ColumnSelectionEvent)arg0);
      }
 else       if (arg0 instanceof RowSelectionEvent) {
        actionRowSelected((RowSelectionEvent)arg0);
      }
    }
  }
);
}","/** 
 * Adds a selection listener
 * @param layer
 */
private void addSelectionListener(final SelectionLayer layer){
  layer.addLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        if (!actionCellSelected((CellSelectionEvent)arg0)) {
          layer.clear(true);
        }
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        if (!actionColumnSelected((ColumnSelectionEvent)arg0)) {
          layer.clear(true);
        }
      }
 else       if (arg0 instanceof RowSelectionEvent) {
        if (!actionRowSelected((RowSelectionEvent)arg0)) {
          layer.clear(true);
        }
      }
    }
  }
);
}",0.8900763358778626
108426,"/** 
 * Action
 * @param arg0
 */
private void actionRowSelected(RowSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int row=arg0.getRowPositionRanges().iterator().next().start;
  if (row >= 0) {
    this.selectedRow=row;
    fireSelectionEvent();
  }
}","/** 
 * Action
 * @param arg0
 */
private boolean actionRowSelected(RowSelectionEvent arg0){
  this.selectedColumn=null;
  this.selectedRow=null;
  int row=arg0.getRowPositionRanges().iterator().next().start;
  if (row >= 0 && row < dataProviderBody.getRowCount()) {
    this.selectedRow=row;
    fireSelectionEvent();
    return true;
  }
 else {
    return false;
  }
}",0.8496932515337423
108427,"/** 
 * This method is called when the metric may clear its cache.
 */
public void freeCache(){
  cache.clear();
}","/** 
 * This method is called when the metric may clear its cache.
 */
public void freeCache(){
  if (cache != null)   cache.clear();
}",0.9156626506024096
108428,"/** 
 * Returns a cache that may be used for arbitrary things
 * @param node
 * @return
 */
protected Map<Node,T> getCache(){
  return this.cache;
}","/** 
 * Returns a cache that may be used for arbitrary things
 * @param node
 * @return
 */
protected Map<Node,T> getCache(){
  if (cache == null) {
    cache=new HashMap<Node,T>();
  }
  return this.cache;
}",0.8314606741573034
108429,"/** 
 * Removes all items
 */
private void removeAllItems(){
  table.setRedraw(false);
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  table.removeAll();
  table.setRedraw(true);
  table.redraw();
}","/** 
 * Removes all items
 */
private void removeAllItems(){
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  table.removeAll();
}",0.816
108430,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param properties
 */
public ComponentFilterTable(Composite parent,Controller controller,List<String> properties){
  IMAGE_ENABLED=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DISABLED=controller.getResources().getImage(""String_Node_Str"");
  this.listeners=new ArrayList<SelectionListener>();
  this.selected=new HashMap<String,Map<String,Boolean>>();
  this.properties=new ArrayList<String>(properties);
  this.entries=new ArrayList<String>();
  this.items=new HashMap<String,TableItem>();
  this.itemProperties=new HashMap<String,List<String>>();
  this.table=new Table(parent,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  this.table.setHeaderVisible(true);
  this.setProperties(properties);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      int row=getItemRowAt(arg0.x,arg0.y);
      int column=getItemColumnAt(arg0.x,arg0.y);
      if (row != -1 && column > 0 && column < ComponentFilterTable.this.properties.size()) {
        String property=ComponentFilterTable.this.properties.get(column - 1);
        String entry=ComponentFilterTable.this.entries.get(row);
        if (itemProperties.get(entry).contains(property)) {
          selectedProperty=property;
          selectedEntry=entry;
        }
 else {
          selectedProperty=null;
          selectedEntry=null;
        }
      }
 else {
        selectedProperty=null;
        selectedEntry=null;
      }
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      if (selectedProperty != null && selectedEntry != null) {
        boolean selected=isSelected(selectedEntry,selectedProperty);
        setSelected(selectedEntry,selectedProperty,!selected);
        fireSelectionEvent();
      }
    }
  }
);
  table.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent arg0){
      IMAGE_ENABLED.dispose();
      IMAGE_DISABLED.dispose();
    }
  }
);
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param properties
 */
public ComponentFilterTable(Composite parent,Controller controller,List<String> properties){
  IMAGE_ENABLED=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DISABLED=controller.getResources().getImage(""String_Node_Str"");
  this.listeners=new ArrayList<SelectionListener>();
  this.selected=new HashMap<String,Map<String,Boolean>>();
  this.properties=new ArrayList<String>(properties);
  this.entries=new ArrayList<String>();
  this.items=new HashMap<String,TableItem>();
  this.itemProperties=new HashMap<String,List<String>>();
  this.table=new Table(parent,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  this.table.setHeaderVisible(true);
  this.setProperties(properties);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      int row=getItemRowAt(arg0.x,arg0.y);
      int column=getItemColumnAt(arg0.x,arg0.y);
      if (row != -1 && column > 0 && column <= ComponentFilterTable.this.properties.size()) {
        String property=ComponentFilterTable.this.properties.get(column - 1);
        String entry=ComponentFilterTable.this.entries.get(row);
        if (itemProperties.get(entry).contains(property)) {
          selectedProperty=property;
          selectedEntry=entry;
        }
 else {
          selectedProperty=null;
          selectedEntry=null;
        }
      }
 else {
        selectedProperty=null;
        selectedEntry=null;
      }
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      if (selectedProperty != null && selectedEntry != null) {
        boolean selected=isSelected(selectedEntry,selectedProperty);
        setSelected(selectedEntry,selectedProperty,!selected);
        fireSelectionEvent();
      }
    }
  }
);
  table.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent arg0){
      IMAGE_ENABLED.dispose();
      IMAGE_DISABLED.dispose();
    }
  }
);
}",0.999754962019113
108431,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  model.createConfig();
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),""String_Node_Str"",t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  model.createConfig();
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    if (t instanceof NullPointerException) {
      main.showErrorDialog(main.getShell(),""String_Node_Str"",t);
    }
 else {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.clearClipboard();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.997563204386232
108432,"/** 
 * Internal method for loading a project
 * @param path
 */
public void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError().getMessage());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}","/** 
 * Internal method for loading a project
 * @param path
 */
public void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError().getMessage());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final List<ARXNode> tempClipboard=new ArrayList<ARXNode>();
  tempClipboard.addAll(model.getClipboardEntries());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.clearClipboard();
    model.addAllToClipboard(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboardEntries()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}",0.9659043075627894
108433,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.SELECTED_NODE) {
    final ARXNode selected=(ARXNode)event.data;
    if (selected == null) {
      reset();
    }
 else {
      final String trans=Arrays.toString(selected.getTransformation());
      for (      final TableItem i : table.getItems()) {
        if (i.getText(0).equals(trans)) {
          table.setSelection(i);
        }
      }
      SWTUtil.enable(root);
    }
  }
 else   if (event.part == ModelPart.CLIPBOARD) {
    table.setRedraw(false);
    table.removeAll();
    for (    final TableItem i : items) {
      i.dispose();
    }
    items.clear();
    final List<ARXNode> nodes=new ArrayList<ARXNode>();
    nodes.addAll(model.getClipboard());
    Collections.sort(nodes,new Comparator<ARXNode>(){
      @Override public int compare(      final ARXNode arg0,      final ARXNode arg1){
        for (int i=0; i < arg0.getTransformation().length; i++) {
          if (arg0.getTransformation()[i] < arg1.getTransformation()[i]) {
            return -1;
          }
 else           if (arg0.getTransformation()[i] > arg1.getTransformation()[i]) {
            return +1;
          }
        }
        return 0;
      }
    }
);
    for (    final ARXNode node : nodes) {
      final TableItem i=new TableItem(table,SWT.NONE);
      i.setText(0,Arrays.toString(node.getTransformation()));
      if (node.getAttributes().get(NODE_COMMENT) != null) {
        i.setText(1,(String)node.getAttributes().get(NODE_COMMENT));
      }
 else {
        i.setText(1,""String_Node_Str"");
      }
      i.setData(node);
      items.add(i);
    }
    for (    final TableColumn c : columns) {
      c.pack();
    }
    table.setRedraw(true);
    table.redraw();
    SWTUtil.enable(root);
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.SELECTED_NODE) {
    final ARXNode selected=(ARXNode)event.data;
    if (selected == null) {
      reset();
    }
 else {
      final String trans=Arrays.toString(selected.getTransformation());
      for (      final TableItem i : table.getItems()) {
        if (i.getText(0).equals(trans)) {
          table.setSelection(i);
        }
      }
      SWTUtil.enable(root);
    }
  }
 else   if (event.part == ModelPart.CLIPBOARD) {
    table.setRedraw(false);
    table.removeAll();
    for (    final TableItem i : items) {
      i.dispose();
    }
    items.clear();
    List<ARXNode> nodes=model.getClipboardEntries();
    Collections.sort(nodes,new Comparator<ARXNode>(){
      @Override public int compare(      final ARXNode arg0,      final ARXNode arg1){
        for (int i=0; i < arg0.getTransformation().length; i++) {
          if (arg0.getTransformation()[i] < arg1.getTransformation()[i]) {
            return -1;
          }
 else           if (arg0.getTransformation()[i] > arg1.getTransformation()[i]) {
            return +1;
          }
        }
        return 0;
      }
    }
);
    for (    final ARXNode node : nodes) {
      final TableItem i=new TableItem(table,SWT.NONE);
      i.setText(0,Arrays.toString(node.getTransformation()));
      if (node.getAttributes().get(NODE_COMMENT) != null) {
        i.setText(1,(String)node.getAttributes().get(NODE_COMMENT));
      }
 else {
        i.setText(1,""String_Node_Str"");
      }
      i.setData(node);
      items.add(i);
    }
    for (    final TableColumn c : columns) {
      c.pack();
    }
    table.setRedraw(true);
    table.redraw();
    SWTUtil.enable(root);
  }
}",0.983884184649003
108434,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(controller.getResources().getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.getClipboard().remove(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      controller.update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          Rectangle bounds=i.getBounds();
          bounds.x=table.toDisplay(bounds.x,bounds.y).x;
          bounds.y=table.toDisplay(bounds.x,bounds.y).y;
          menu.setLocation(point);
          menu.setVisible(true);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(controller.getResources().getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.removeFromClipboard(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      controller.update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          Rectangle bounds=i.getBounds();
          bounds.x=table.toDisplay(bounds.x,bounds.y).x;
          bounds.y=table.toDisplay(bounds.x,bounds.y).y;
          menu.setLocation(point);
          menu.setVisible(true);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}",0.9972832798221783
108435,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param properties
 */
public ComponentFilterTable(Composite parent,Controller controller,List<String> properties){
  IMAGE_ENABLED=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DISABLED=controller.getResources().getImage(""String_Node_Str"");
  this.listeners=new ArrayList<SelectionListener>();
  this.selected=new HashMap<String,Map<String,Boolean>>();
  this.properties=new ArrayList<String>(properties);
  this.entries=new ArrayList<String>();
  this.items=new HashMap<String,TableItem>();
  this.itemProperties=new HashMap<String,List<String>>();
  this.table=new Table(parent,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  this.table.setHeaderVisible(true);
  this.setProperties(properties);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      int row=getItemRowAt(arg0.x,arg0.y);
      int column=getItemColumnAt(arg0.x,arg0.y);
      if (row != -1 && column > 0) {
        String property=ComponentFilterTable.this.properties.get(column - 1);
        String entry=ComponentFilterTable.this.entries.get(row);
        if (itemProperties.get(entry).contains(property)) {
          selectedProperty=property;
          selectedEntry=entry;
        }
 else {
          selectedProperty=null;
          selectedEntry=null;
        }
      }
 else {
        selectedProperty=null;
        selectedEntry=null;
      }
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      if (selectedProperty != null && selectedEntry != null) {
        boolean selected=isSelected(selectedEntry,selectedProperty);
        setSelected(selectedEntry,selectedProperty,!selected);
        fireSelectionEvent();
      }
    }
  }
);
  table.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent arg0){
      IMAGE_ENABLED.dispose();
      IMAGE_DISABLED.dispose();
    }
  }
);
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param properties
 */
public ComponentFilterTable(Composite parent,Controller controller,List<String> properties){
  IMAGE_ENABLED=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DISABLED=controller.getResources().getImage(""String_Node_Str"");
  this.listeners=new ArrayList<SelectionListener>();
  this.selected=new HashMap<String,Map<String,Boolean>>();
  this.properties=new ArrayList<String>(properties);
  this.entries=new ArrayList<String>();
  this.items=new HashMap<String,TableItem>();
  this.itemProperties=new HashMap<String,List<String>>();
  this.table=new Table(parent,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  this.table.setHeaderVisible(true);
  this.setProperties(properties);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      int row=getItemRowAt(arg0.x,arg0.y);
      int column=getItemColumnAt(arg0.x,arg0.y);
      if (row != -1 && column > 0 && column < ComponentFilterTable.this.properties.size()) {
        String property=ComponentFilterTable.this.properties.get(column - 1);
        String entry=ComponentFilterTable.this.entries.get(row);
        if (itemProperties.get(entry).contains(property)) {
          selectedProperty=property;
          selectedEntry=entry;
        }
 else {
          selectedProperty=null;
          selectedEntry=null;
        }
      }
 else {
        selectedProperty=null;
        selectedEntry=null;
      }
    }
  }
);
  table.addMouseListener(new MouseAdapter(){
    public void mouseDown(    MouseEvent arg0){
      if (selectedProperty != null && selectedEntry != null) {
        boolean selected=isSelected(selectedEntry,selectedProperty);
        setSelected(selectedEntry,selectedProperty,!selected);
        fireSelectionEvent();
      }
    }
  }
);
  table.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent arg0){
      IMAGE_ENABLED.dispose();
      IMAGE_DISABLED.dispose();
    }
  }
);
}",0.9860834990059644
108436,"/** 
 * Updates the combos
 */
private void updateCombos(){
  if (model == null || min == null) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  for (int i=1; i <= (hierarchy == null ? 0 : hierarchy[0].length); i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  String minSelected=ITEM_ALL;
  if (minModel != null)   minSelected=String.valueOf(minModel + 1);
  int minIndex=minIndexOf(minSelected);
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  String maxSelected=ITEM_ALL;
  if (maxModel != null)   maxSelected=String.valueOf(maxModel + 1);
  int maxIndex=maxIndexOf(maxSelected);
  if (minIndex > (maxIndex + 1)) {
    minIndex=maxIndex + 1;
  }
  min.setItems(minItems.toArray(new String[]{}));
  max.setItems(maxItems.toArray(new String[]{}));
  min.select(minIndex);
  max.select(maxIndex);
  pushMin();
  pushMax();
}","/** 
 * Updates the combos
 */
private void updateCombos(){
  if (model == null || min == null || min.isDisposed()) {
    return;
  }
  final List<String> minItems=new ArrayList<String>();
  final List<String> maxItems=new ArrayList<String>();
  minItems.add(ITEM_ALL);
  for (int i=1; i <= (hierarchy == null ? 0 : hierarchy[0].length); i++) {
    minItems.add(String.valueOf(i));
    maxItems.add(String.valueOf(i));
  }
  maxItems.add(ITEM_ALL);
  Integer minModel=model.getInputConfig().getMinimumGeneralization(attribute);
  String minSelected=ITEM_ALL;
  if (minModel != null)   minSelected=String.valueOf(minModel + 1);
  int minIndex=minIndexOf(minSelected);
  Integer maxModel=model.getInputConfig().getMaximumGeneralization(attribute);
  String maxSelected=ITEM_ALL;
  if (maxModel != null)   maxSelected=String.valueOf(maxModel + 1);
  int maxIndex=maxIndexOf(maxSelected);
  if (minIndex > (maxIndex + 1)) {
    minIndex=maxIndex + 1;
  }
  min.setItems(minItems.toArray(new String[]{}));
  max.setItems(maxItems.toArray(new String[]{}));
  min.select(minIndex);
  max.select(maxIndex);
  pushMin();
  pushMax();
}",0.9910394265232976
108437,"/** 
 * Resets the view
 */
@Override public void reset(){
  this.numNodes=0;
  this.optimum=null;
  this.selectedNode=null;
  for (  ARXNode node : lattice) {
    Path path=(Path)node.getAttributes().get(ATTRIBUTE_PATH);
    if (path != null)     path.dispose();
  }
  this.lattice.clear();
  this.latticeWidth=0;
  this.latticeHeight=0;
  this.screen=null;
  this.canvas.redraw();
}","/** 
 * Resets the view
 */
@Override public void reset(){
  this.numNodes=0;
  this.optimum=null;
  this.selectedNode=null;
  for (  ARXNode node : lattice) {
    Path path=(Path)node.getAttributes().get(ATTRIBUTE_PATH);
    if (path != null) {
      node.getAttributes().put(ATTRIBUTE_PATH,null);
      path.dispose();
    }
  }
  this.lattice.clear();
  this.latticeWidth=0;
  this.latticeHeight=0;
  this.screen=null;
  this.canvas.redraw();
}",0.8760529482551144
108438,"/** 
 * Initializes the data structures for displaying a new lattice
 * @param lattice
 */
private void initialize(final ARXResult r,final ModelNodeFilter filter){
  if ((r == null) || (r.getLattice() == null) || (filter == null)) {
    reset();
    return;
  }
  final ARXLattice l=r.getLattice();
  latticeWidth=0;
  numNodes=0;
  optimum=r.getGlobalOptimum();
  final List<List<ARXNode>> lattice=new ArrayList<List<ARXNode>>();
  for (  final ARXNode[] level : l.getLevels()) {
    final List<ARXNode> lvl=new ArrayList<ARXNode>();
    for (    final ARXNode node : level) {
      if (filter.isAllowed(r.getLattice(),node)) {
        lvl.add(node);
        numNodes++;
        node.getAttributes().put(ATTRIBUTE_VISIBLE,true);
      }
 else {
        node.getAttributes().put(ATTRIBUTE_VISIBLE,false);
      }
    }
    if (!lvl.isEmpty()) {
      lattice.add(lvl);
    }
    latticeWidth=Math.max(latticeWidth,lvl.size());
  }
  latticeHeight=lattice.size();
  if (numNodes > model.getMaxNodesInViewer()) {
    return;
  }
  for (  ARXNode node : this.lattice) {
    Path path=(Path)node.getAttributes().get(ATTRIBUTE_PATH);
    if (path != null)     path.dispose();
  }
  this.lattice.clear();
  int y=latticeHeight - 1;
  for (  final List<ARXNode> level : lattice) {
    for (int i=0; i < level.size(); i++) {
      final ARXNode node=level.get(i);
      this.lattice.add(node);
      node.getAttributes().put(ATTRIBUTE_POSITION,i);
      node.getAttributes().put(ATTRIBUTE_LEVEL,y);
      node.getAttributes().put(ATTRIBUTE_LEVELSIZE,level.size());
      String text=Arrays.toString(node.getTransformation());
      text=text.substring(1,text.length() - 1);
      node.getAttributes().put(ATTRIBUTE_LABEL,text);
    }
    y--;
  }
  initializeCanvas();
}","/** 
 * Initializes the data structures for displaying a new lattice
 * @param lattice
 */
private void initialize(final ARXResult r,final ModelNodeFilter filter){
  if ((r == null) || (r.getLattice() == null) || (filter == null)) {
    reset();
    return;
  }
  final ARXLattice l=r.getLattice();
  latticeWidth=0;
  numNodes=0;
  optimum=r.getGlobalOptimum();
  final List<List<ARXNode>> lattice=new ArrayList<List<ARXNode>>();
  for (  final ARXNode[] level : l.getLevels()) {
    final List<ARXNode> lvl=new ArrayList<ARXNode>();
    for (    final ARXNode node : level) {
      if (filter.isAllowed(r.getLattice(),node)) {
        lvl.add(node);
        numNodes++;
        node.getAttributes().put(ATTRIBUTE_VISIBLE,true);
      }
 else {
        node.getAttributes().put(ATTRIBUTE_VISIBLE,false);
      }
    }
    if (!lvl.isEmpty()) {
      lattice.add(lvl);
    }
    latticeWidth=Math.max(latticeWidth,lvl.size());
  }
  latticeHeight=lattice.size();
  if (numNodes > model.getMaxNodesInViewer()) {
    return;
  }
  for (  ARXNode node : this.lattice) {
    Path path=(Path)node.getAttributes().get(ATTRIBUTE_PATH);
    if (path != null) {
      path.dispose();
      node.getAttributes().put(ATTRIBUTE_PATH,null);
    }
  }
  this.lattice.clear();
  int y=latticeHeight - 1;
  for (  final List<ARXNode> level : lattice) {
    for (int i=0; i < level.size(); i++) {
      final ARXNode node=level.get(i);
      this.lattice.add(node);
      node.getAttributes().put(ATTRIBUTE_POSITION,i);
      node.getAttributes().put(ATTRIBUTE_LEVEL,y);
      node.getAttributes().put(ATTRIBUTE_LEVELSIZE,level.size());
      String text=Arrays.toString(node.getTransformation());
      text=text.substring(1,text.length() - 1);
      node.getAttributes().put(ATTRIBUTE_LABEL,text);
    }
    y--;
  }
  initializeCanvas();
}",0.9824365765263452
108439,"/** 
 * Moves an element up
 */
private void actionMoveUp(){
  if (null == targetRow) {
    return;
  }
  final int index=table.indexOf(targetRow);
  if (index <= 0) {
    return;
  }
  table.setRedraw(false);
  final TableItem o1=table.getItems()[index - 1];
  final TableItem o2=table.getItems()[index];
  final TableItem n1=new TableItem(table,SWT.NONE,index);
  n1.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n1.setText(i,o1.getText(i));
  }
  final TableItem n2=new TableItem(table,SWT.NONE,index);
  n2.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n2.setText(i,o2.getText(i));
  }
  o1.dispose();
  o2.dispose();
  base.setRedraw(true);
  base.redraw();
  targetRow=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}","/** 
 * Moves an element up
 */
private void actionMoveUp(){
  if (null == targetRow) {
    return;
  }
  final int index=table.indexOf(targetRow);
  if (index <= 0) {
    return;
  }
  base.setRedraw(false);
  final TableItem o1=table.getItems()[index - 1];
  final TableItem o2=table.getItems()[index];
  final TableItem n1=new TableItem(table,SWT.NONE,index);
  n1.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n1.setText(i,o1.getText(i));
  }
  final TableItem n2=new TableItem(table,SWT.NONE,index);
  n2.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n2.setText(i,o2.getText(i));
  }
  o1.dispose();
  o2.dispose();
  base.setRedraw(true);
  base.redraw();
  targetRow=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}",0.9957498482088646
108440,"/** 
 * Moves an element down
 */
private void actionMoveDown(){
  if (null == targetRow) {
    return;
  }
  int index=table.indexOf(targetRow);
  if (index >= (table.getItemCount() - 1)) {
    return;
  }
  table.setRedraw(false);
  TableItem o1=table.getItems()[index];
  TableItem o2=table.getItems()[index + 1];
  TableItem n1=new TableItem(table,SWT.NONE,index);
  n1.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n1.setText(i,o1.getText(i));
  }
  TableItem n2=new TableItem(table,SWT.NONE,index);
  n2.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n2.setText(i,o2.getText(i));
  }
  o1.dispose();
  o2.dispose();
  base.setRedraw(true);
  base.redraw();
  targetRow=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}","/** 
 * Moves an element down
 */
private void actionMoveDown(){
  if (null == targetRow) {
    return;
  }
  int index=table.indexOf(targetRow);
  if (index >= (table.getItemCount() - 1)) {
    return;
  }
  base.setRedraw(false);
  TableItem o1=table.getItems()[index];
  TableItem o2=table.getItems()[index + 1];
  TableItem n1=new TableItem(table,SWT.NONE,index);
  n1.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n1.setText(i,o1.getText(i));
  }
  TableItem n2=new TableItem(table,SWT.NONE,index);
  n2.setBackground(COLOR);
  for (int i=0; i < table.getColumnCount(); i++) {
    n2.setText(i,o2.getText(i));
  }
  o1.dispose();
  o2.dispose();
  base.setRedraw(true);
  base.redraw();
  targetRow=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}",0.9957446808510638
108441,"/** 
 * Called when button 3 is clicked on a node
 * @param node
 * @param x
 * @param y
 */
private void actionButtonClicked3(ARXNode node,final int x,final int y){
  selectedNode=node;
  model.setSelectedNode(selectedNode);
  controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
  canvas.redraw();
  menu.setLocation(x,y);
  menu.setVisible(true);
}","/** 
 * Called when button 3 is clicked on a node
 * @param node
 * @param x
 * @param y
 */
private void actionButtonClicked3(ARXNode node,final int x,final int y){
  selectedNode=node;
  model.setSelectedNode(selectedNode);
  controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
  canvas.redraw();
  menu.setLocation(x,y);
  menu.setVisible(true);
  dragType=DragType.NONE;
}",0.9675810473815462
108442,"/** 
 * Creates all required listeners
 */
private void initializeListeners(){
  canvas.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent arg0){
      if (arg0.button == 1) {
        final ARXNode node=getNode(arg0.x,arg0.y);
        if (node != null) {
          actionButtonClicked1(node);
        }
      }
 else       if (arg0.button == 3) {
        final ARXNode node=getNode(arg0.x,arg0.y);
        if (node != null) {
          Point display=canvas.toDisplay(arg0.x,arg0.y);
          actionButtonClicked3(node,display.x,display.y);
        }
      }
    }
  }
);
  canvas.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent arg0){
      dragX=arg0.x;
      dragY=arg0.y;
      dragStartX=arg0.x;
      dragStartY=arg0.y;
      if (dragType == DragType.NONE) {
        if (arg0.button == 1) {
          dragType=DragType.MOVE;
        }
 else         if (arg0.button == 3) {
          dragType=DragType.ZOOM;
        }
      }
    }
    @Override public void mouseUp(    MouseEvent arg0){
      dragType=DragType.NONE;
    }
  }
);
  canvas.addMouseMoveListener(new MouseMoveListener(){
    @Override public void mouseMove(    MouseEvent arg0){
      if (arg0.button != 1 && arg0.button != 2) {
        dragType=DragType.NONE;
      }
      if (dragType != DragType.NONE) {
        final int deltaX=arg0.x - dragX;
        final int deltaY=arg0.y - dragY;
        if (dragType == DragType.MOVE) {
          for (          final ARXNode node : lattice) {
            final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
            dbounds.centerX+=deltaX;
            dbounds.centerY+=deltaY;
            dbounds.x+=deltaX;
            dbounds.y+=deltaY;
          }
        }
 else         if (dragType == DragType.ZOOM) {
          double zoom=-((double)deltaY / (double)screen.y) * ZOOM_SPEED;
          final double newWidth=nodeWidth + (zoom * nodeWidth);
          if (newWidth > screen.x) {
            zoom=(screen.x - nodeWidth) / nodeWidth;
          }
          if (newWidth < MIN_WIDTH) {
            zoom=(MIN_WIDTH - nodeWidth) / nodeWidth;
          }
          final double newHeight=nodeHeight + (zoom * nodeHeight);
          if (newHeight > screen.y) {
            zoom=(screen.y - nodeHeight) / nodeHeight;
          }
          if (newHeight < MIN_HEIGHT) {
            zoom=(MIN_HEIGHT - nodeHeight) / nodeHeight;
          }
          nodeWidth+=zoom * nodeWidth;
          nodeHeight+=zoom * nodeHeight;
          for (          final ARXNode node : lattice) {
            final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
            dbounds.centerX-=dragStartX;
            dbounds.centerX+=zoom * dbounds.centerX;
            dbounds.centerX+=dragStartX;
            dbounds.centerY-=dragStartY;
            dbounds.centerY+=zoom * dbounds.centerY;
            dbounds.centerY+=dragStartY;
            dbounds.x-=dragStartX;
            dbounds.x+=zoom * dbounds.x;
            dbounds.x+=dragStartX;
            dbounds.y-=dragStartY;
            dbounds.y+=zoom * dbounds.y;
            dbounds.y+=dragStartY;
          }
        }
        dragX+=deltaX;
        dragY+=deltaY;
        canvas.redraw();
      }
    }
  }
);
  canvas.addMouseMoveListener(new MouseMoveListener(){
    public void mouseMove(    MouseEvent arg0){
      tooltipX=arg0.x;
      tooltipY=arg0.y;
    }
  }
);
  canvas.addListener(SWT.MouseExit,new Listener(){
    public void handleEvent(    Event e){
      tooltipX=-1;
      tooltipY=-1;
    }
  }
);
  canvas.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      screen=canvas.getSize();
      initializeCanvas();
      canvas.redraw();
    }
  }
);
}","/** 
 * Creates all required listeners
 */
private void initializeListeners(){
  canvas.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent arg0){
      dragX=arg0.x;
      dragY=arg0.y;
      dragStartX=arg0.x;
      dragStartY=arg0.y;
      if (dragType == DragType.NONE) {
        if (arg0.button == 1) {
          dragType=DragType.MOVE;
        }
 else         if (arg0.button == 3) {
          dragType=DragType.ZOOM;
        }
      }
    }
    @Override public void mouseUp(    MouseEvent arg0){
      dragType=DragType.NONE;
    }
  }
);
  canvas.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent arg0){
      if (arg0.button == 1) {
        final ARXNode node=getNode(arg0.x,arg0.y);
        if (node != null) {
          actionButtonClicked1(node);
        }
      }
 else       if (arg0.button == 3) {
        final ARXNode node=getNode(arg0.x,arg0.y);
        if (node != null) {
          Point display=canvas.toDisplay(arg0.x,arg0.y);
          actionButtonClicked3(node,display.x,display.y);
        }
      }
    }
  }
);
  canvas.addMouseMoveListener(new MouseMoveListener(){
    @Override public void mouseMove(    MouseEvent arg0){
      if (dragType != DragType.NONE) {
        final int deltaX=arg0.x - dragX;
        final int deltaY=arg0.y - dragY;
        if (dragType == DragType.MOVE) {
          for (          final ARXNode node : lattice) {
            final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
            dbounds.centerX+=deltaX;
            dbounds.centerY+=deltaY;
            dbounds.x+=deltaX;
            dbounds.y+=deltaY;
          }
        }
 else         if (dragType == DragType.ZOOM) {
          double zoom=-((double)deltaY / (double)screen.y) * ZOOM_SPEED;
          final double newWidth=nodeWidth + (zoom * nodeWidth);
          if (newWidth > screen.x) {
            zoom=(screen.x - nodeWidth) / nodeWidth;
          }
          if (newWidth < MIN_WIDTH) {
            zoom=(MIN_WIDTH - nodeWidth) / nodeWidth;
          }
          final double newHeight=nodeHeight + (zoom * nodeHeight);
          if (newHeight > screen.y) {
            zoom=(screen.y - nodeHeight) / nodeHeight;
          }
          if (newHeight < MIN_HEIGHT) {
            zoom=(MIN_HEIGHT - nodeHeight) / nodeHeight;
          }
          nodeWidth+=zoom * nodeWidth;
          nodeHeight+=zoom * nodeHeight;
          for (          final ARXNode node : lattice) {
            final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
            dbounds.centerX-=dragStartX;
            dbounds.centerX+=zoom * dbounds.centerX;
            dbounds.centerX+=dragStartX;
            dbounds.centerY-=dragStartY;
            dbounds.centerY+=zoom * dbounds.centerY;
            dbounds.centerY+=dragStartY;
            dbounds.x-=dragStartX;
            dbounds.x+=zoom * dbounds.x;
            dbounds.x+=dragStartX;
            dbounds.y-=dragStartY;
            dbounds.y+=zoom * dbounds.y;
            dbounds.y+=dragStartY;
          }
        }
        dragX+=deltaX;
        dragY+=deltaY;
        canvas.redraw();
      }
    }
  }
);
  canvas.addMouseMoveListener(new MouseMoveListener(){
    public void mouseMove(    MouseEvent arg0){
      tooltipX=arg0.x;
      tooltipY=arg0.y;
    }
  }
);
  canvas.addListener(SWT.MouseExit,new Listener(){
    public void handleEvent(    Event e){
      tooltipX=-1;
      tooltipY=-1;
    }
  }
);
  canvas.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      screen=canvas.getSize();
      initializeCanvas();
      canvas.redraw();
    }
  }
);
}",0.847344542300507
108443,"@Override public void mouseDown(MouseEvent arg0){
  dragX=arg0.x;
  dragY=arg0.y;
  dragStartX=arg0.x;
  dragStartY=arg0.y;
  if (dragType == DragType.NONE) {
    if (arg0.button == 1) {
      dragType=DragType.MOVE;
    }
 else     if (arg0.button == 3) {
      dragType=DragType.ZOOM;
    }
  }
}","@Override public void mouseDown(MouseEvent arg0){
  if (arg0.button == 1) {
    final ARXNode node=getNode(arg0.x,arg0.y);
    if (node != null) {
      actionButtonClicked1(node);
    }
  }
 else   if (arg0.button == 3) {
    final ARXNode node=getNode(arg0.x,arg0.y);
    if (node != null) {
      Point display=canvas.toDisplay(arg0.x,arg0.y);
      actionButtonClicked3(node,display.x,display.y);
    }
  }
}",0.2732394366197183
108444,"@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  currentGroupify.analyze();
  if (currentGroupify.isAnonymous() && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  InformationLoss<?> loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics());
}","@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  currentGroupify.analyze();
  InformationLoss<?> loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  if (currentGroupify.isAnonymous() && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics());
}",0.7917888563049853
108445,"@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  boolean anonymous=g.isAnonymous();
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier || !anonymous) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension] & Data.REMOVE_OUTLIER_MASK;
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * (1d - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores,weights);
}","@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  boolean anonymous=g.isAnonymous();
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier || !anonymous) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension];
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * (1d - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores,weights);
}",0.9897377423033068
108446,"@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  currentGroupify.analyze();
  if (transformation.hasProperty(Node.PROPERTY_ANONYMOUS) && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  InformationLoss<?> loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics());
}","@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  currentGroupify.analyze();
  if (currentGroupify.isAnonymous() && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  InformationLoss<?> loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics());
}",0.9451659451659452
108447,"@Override public void traverse(){
  FLASHConfiguration outerLoopConfiguration;
  if (binaryPhaseConfiguration.active) {
    outerLoopConfiguration=binaryPhaseConfiguration;
  }
 else {
    outerLoopConfiguration=linearPhaseConfiguration;
  }
  PriorityQueue<Node> queue=new PriorityQueue<Node>(11,strategy);
  INodeChecker.Result result=checker.check(lattice.getBottom(),true);
  lattice.getBottom().setInformationLoss(result.informationLoss);
  lattice.getBottom().setProperty(Node.PROPERTY_FORCE_SNAPSHOT);
  lattice.getBottom().setData(result);
  int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    for (    Node node : this.getUnsetNodesAndSort(i,outerLoopConfiguration.triggerSkip)) {
      if (binaryPhaseConfiguration.active) {
        checker.getHistory().setEvictionTrigger(binaryPhaseConfiguration.triggerSnapshotEvict);
        checker.getHistory().setStorageTrigger(binaryPhaseConfiguration.triggerSnapshotStore);
        binarySearch(node,queue);
      }
 else {
        checker.getHistory().setEvictionTrigger(linearPhaseConfiguration.triggerSnapshotEvict);
        checker.getHistory().setStorageTrigger(linearPhaseConfiguration.triggerSnapshotStore);
        linearSearch(node);
      }
    }
  }
  computeUtilityForMonotonicMetrics(lattice.getBottom());
  computeUtilityForMonotonicMetrics(lattice.getTop());
}","@Override public void traverse(){
  FLASHConfiguration outerLoopConfiguration;
  if (binaryPhaseConfiguration.active) {
    outerLoopConfiguration=binaryPhaseConfiguration;
  }
 else {
    outerLoopConfiguration=linearPhaseConfiguration;
  }
  PriorityQueue<Node> queue=new PriorityQueue<Node>(11,strategy);
  INodeChecker.Result result=checker.check(lattice.getBottom(),true);
  lattice.getBottom().setInformationLoss(result.informationLoss);
  lattice.getBottom().setProperty(Node.PROPERTY_FORCE_SNAPSHOT);
  lattice.getBottom().setData(result);
  int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    for (    Node node : this.getUnsetNodesAndSort(i,outerLoopConfiguration.triggerSkip)) {
      if (binaryPhaseConfiguration.active) {
        checker.getHistory().setEvictionTrigger(binaryPhaseConfiguration.triggerSnapshotEvict);
        checker.getHistory().setStorageTrigger(binaryPhaseConfiguration.triggerSnapshotStore);
        binarySearch(node,queue);
      }
 else {
        checker.getHistory().setEvictionTrigger(linearPhaseConfiguration.triggerSnapshotEvict);
        checker.getHistory().setStorageTrigger(linearPhaseConfiguration.triggerSnapshotStore);
        linearSearch(node);
      }
    }
  }
  computeUtilityForMonotonicMetrics(lattice.getBottom());
  computeUtilityForMonotonicMetrics(lattice.getTop());
  lattice.getBottom().setData(null);
}",0.986511119212541
108448,"/** 
 * Disposes the control
 */
public void dispose(){
  table.dispose();
}","/** 
 * Disposes the control
 */
public void dispose(){
  if (!table.isDisposed())   table.dispose();
}",0.8491620111731844
108449,"/** 
 * Sets the current suppression weight
 * @param d
 */
private void setSuppressionWeight(double d){
  int value=(int)(MINIMUM + d * (double)(MAXIMUM - MINIMUM));
  this.slider.setSelection(value);
  this.canvas.redraw();
}","/** 
 * Sets the current suppression weight
 * @param d
 */
private void setSuppressionWeight(double d){
  int value=(int)(MINIMUM + d * (double)(MAXIMUM - MINIMUM));
  if (!this.slider.isDisposed())   this.slider.setSelection(value);
  if (!this.canvas.isDisposed())   this.canvas.redraw();
}",0.8730769230769231
108450,"@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  boolean anonymous=g.isAnonymous();
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier || !anonymous) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension];
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * (1d - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores,weights);
}","@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  boolean anonymous=g.isAnonymous();
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier || !anonymous) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
          scores[dimension]+=share * gWeight;
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          if (sWeight == 1d) {
            double share=(double)m.count;
            scores[dimension]+=share;
          }
 else {
            int value=m.key[dimension] & Data.REMOVE_OUTLIER_MASK;
            double share=(double)m.count * frequencies[dimension][transformation[dimension]][value];
            scores[dimension]+=share + sWeight * (1d - share);
          }
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores,weights);
}",0.9897377423033068
108451,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      groups+=m.isNotOutlier ? 1 : 0;
      suppressed|=!m.isNotOutlier;
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  boolean anonymous=g.isAnonymous();
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      groups+=!anonymous || m.isNotOutlier ? 1 : 0;
      suppressed|=!m.isNotOutlier && anonymous;
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}",0.9367588932806324
108452,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final boolean anonymous=node.hasProperty(Node.PROPERTY_ANONYMOUS);
  double value=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!anonymous || m.isNotOutlier) {
      value+=((double)m.count * (double)m.count);
    }
 else {
      value+=((double)rowCount * (double)m.count);
    }
    m=m.nextOrdered;
  }
  return new InformationLossDefault(value);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final boolean anonymous=g.isAnonymous();
  double value=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!anonymous || m.isNotOutlier) {
      value+=((double)m.count * (double)m.count);
    }
 else {
      value+=((double)rowCount * (double)m.count);
    }
    m=m.nextOrdered;
  }
  return new InformationLossDefault(value);
}",0.9444444444444444
108453,"@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final InformationLossDefault originalInfoLossDefault=super.evaluateInternal(node,g);
  if (!node.hasProperty(Node.PROPERTY_ANONYMOUS))   return originalInfoLossDefault;
  final double originalInfoLoss=originalInfoLossDefault.getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}","@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final InformationLossDefault originalInfoLossDefault=super.evaluateInternal(node,g);
  if (!g.isAnonymous())   return originalInfoLossDefault;
  final double originalInfoLoss=originalInfoLossDefault.getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}",0.9809523809523808
108454,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullNone(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger binaryTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger binaryTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
    public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_ANONYMOUS);
      }
    }
  }
;
  NodeTrigger binaryTriggerSnapshotStore=History.STORAGE_TRIGGER_NON_ANONYMOUS;
  NodeTrigger binaryTriggerSnapshotEvict=History.EVICTION_TRIGGER_ANONYMOUS;
  NodeTrigger binaryTriggerCheck=new NodeTriggerInverse(binaryTriggerSkip);
  NodeTrigger binaryTriggerEvaluate=new NodeTriggerConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger linearTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_CHECKED) || node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger linearTriggerSnapshotStore=History.STORAGE_TRIGGER_ALL;
  NodeTrigger linearTriggerSnapshotEvict=History.EVICTION_TRIGGER_CHECKED;
  NodeTrigger linearTriggerEvaluate=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return checker.getMetric().isIndependent() && !node.hasProperty(Node.PROPERTY_CHECKED) && !node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger linearTriggerCheck=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return !checker.getMetric().isIndependent() && !node.hasProperty(Node.PROPERTY_CHECKED) && !node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger linearTriggerTag=new NodeTriggerConstant(false);
  FLASHConfiguration binaryConfiguration=new FLASHConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip,binaryTriggerSnapshotStore,binaryTriggerSnapshotEvict);
  FLASHConfiguration linearConfiguration=new FLASHConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip,linearTriggerSnapshotStore,linearTriggerSnapshotEvict);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,binaryConfiguration,linearConfiguration);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createFullNone(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger binaryTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger binaryTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
    public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_ANONYMOUS);
      }
    }
  }
;
  NodeTrigger binaryTriggerSnapshotStore=History.STORAGE_TRIGGER_NON_ANONYMOUS;
  NodeTrigger binaryTriggerSnapshotEvict=History.EVICTION_TRIGGER_ANONYMOUS;
  NodeTrigger binaryTriggerCheck=new NodeTriggerInverse(binaryTriggerSkip);
  NodeTrigger binaryTriggerEvaluate=new NodeTriggerConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger linearTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS) || node.hasProperty(Node.PROPERTY_VISITED);
    }
  }
;
  NodeTrigger linearTriggerSnapshotStore=History.STORAGE_TRIGGER_ALL;
  NodeTrigger linearTriggerSnapshotEvict=History.EVICTION_TRIGGER_CHECKED;
  NodeTrigger linearTriggerEvaluate=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return checker.getMetric().isIndependent() && !node.hasProperty(Node.PROPERTY_CHECKED) && !node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger linearTriggerCheck=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return !checker.getMetric().isIndependent() && !node.hasProperty(Node.PROPERTY_CHECKED) && !node.hasProperty(Node.PROPERTY_NOT_ANONYMOUS);
    }
  }
;
  NodeTrigger linearTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return true;
    }
    public void action(    Node node){
      node.setProperty(Node.PROPERTY_VISITED);
    }
  }
;
  FLASHConfiguration binaryConfiguration=new FLASHConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip,binaryTriggerSnapshotStore,binaryTriggerSnapshotEvict);
  FLASHConfiguration linearConfiguration=new FLASHConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip,linearTriggerSnapshotStore,linearTriggerSnapshotEvict);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,binaryConfiguration,linearConfiguration);
}",0.9617151607963248
108455,"/** 
 * Greedily finds a path to the top node
 * @param start The node to start the path with. Will be included
 * @param triggerSkip All nodes to which this trigger applies will be skipped
 * @return The path as a list
 */
private List<Node> findPath(Node start,NodeTrigger triggerSkip){
  List<Node> path=new ArrayList<Node>();
  path.add(start);
  boolean found=true;
  while (found) {
    found=false;
    this.sortSuccessors(start);
    for (    final Node candidate : start.getSuccessors()) {
      if (!triggerSkip.appliesTo(candidate)) {
        start=candidate;
        path.add(candidate);
        found=true;
        break;
      }
    }
  }
  return path;
}","/** 
 * Greedily finds a path to the top node
 * @param current The node to start the path with. Will be included
 * @param triggerSkip All nodes to which this trigger applies will be skipped
 * @return The path as a list
 */
private List<Node> findPath(Node current,NodeTrigger triggerSkip){
  List<Node> path=new ArrayList<Node>();
  path.add(current);
  boolean found=true;
  while (found) {
    found=false;
    this.sortSuccessors(current);
    for (    final Node candidate : current.getSuccessors()) {
      if (!triggerSkip.appliesTo(candidate)) {
        current=candidate;
        path.add(candidate);
        found=true;
        break;
      }
    }
  }
  return path;
}",0.9555555555555556
108456,"/** 
 * Creates a new instance of the FLASH algorithm
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
public static AbstractAlgorithm create(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  if ((checker.getConfiguration().getAbsoluteMaxOutliers() == 0) || (checker.getConfiguration().isCriterionMonotonic() && checker.getMetric().isMonotonic()) || (checker.getConfiguration().isPracticalMonotonicity())) {
    return new FLASHAlgorithmBinary(lattice,checker,strategy);
  }
 else {
    if (checker.getConfiguration().getMinimalGroupSize() != Integer.MAX_VALUE) {
      return new FLASHAlgorithmTwoPhases(lattice,checker,strategy);
    }
 else {
      return new FLASHAlgorithmLinear(lattice,checker,strategy);
    }
  }
}","/** 
 * Creates a new instance of the FLASH algorithm
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
public static AbstractAlgorithm create(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  ARXConfiguration config=checker.getConfiguration();
  Metric<?> metric=checker.getMetric();
  Monotonicity monotonicityMetric;
  if (metric.isMonotonic() || config.getMaxOutliers() == 0d || config.isPracticalMonotonicity()) {
    monotonicityMetric=Monotonicity.FULL;
  }
 else {
    monotonicityMetric=Monotonicity.NONE;
  }
  Monotonicity monotonicityCriteria;
  if (config.getMaxOutliers() == 0d || config.isPracticalMonotonicity()) {
    monotonicityCriteria=Monotonicity.FULL;
  }
 else {
    if (config.getMinimalGroupSize() != Integer.MAX_VALUE) {
      if (config.getCriteria().size() == 1 && config.containsCriterion(KAnonymity.class)) {
        monotonicityCriteria=Monotonicity.FULL;
      }
 else {
        monotonicityCriteria=Monotonicity.PARTIAL;
      }
    }
 else {
      monotonicityCriteria=Monotonicity.NONE;
    }
  }
  if (monotonicityCriteria == Monotonicity.FULL && monotonicityMetric == Monotonicity.FULL) {
    return createFullFull(lattice,checker,strategy);
  }
  if (monotonicityCriteria == Monotonicity.FULL && monotonicityMetric == Monotonicity.NONE) {
    return createFullNone(lattice,checker,strategy);
  }
  if (monotonicityCriteria == Monotonicity.PARTIAL && monotonicityMetric == Monotonicity.FULL) {
    return createPartialFull(lattice,checker,strategy);
  }
  if (monotonicityCriteria == Monotonicity.PARTIAL && monotonicityMetric == Monotonicity.NONE) {
    return createPartialNone(lattice,checker,strategy);
  }
  if (monotonicityCriteria == Monotonicity.NONE && monotonicityMetric == Monotonicity.FULL) {
    return createNoneFull(lattice,checker,strategy);
  }
  if (monotonicityCriteria == Monotonicity.NONE && monotonicityMetric == Monotonicity.NONE) {
    return createNoneNone(lattice,checker,strategy);
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.2640310624779385
108457,"/** 
 * Checks and tags the given transformation
 * @param node
 */
private void checkAndTag(Node node,FLASHConfiguration configuration){
  if (configuration.triggerEvaluate.appliesTo(node)) {
    node.setInformationLoss(checker.getMetric().evaluate(node,null));
  }
 else   if (configuration.triggerCheck.appliesTo(node)) {
    node.setChecked(checker.check(node));
  }
  configuration.triggerTag.apply(node);
}","/** 
 * Checks and tags the given transformation
 * @param node
 */
private void checkAndTag(Node node,FLASHConfiguration configuration){
  if (configuration.triggerEvaluate.appliesTo(node)) {
    node.setInformationLoss(checker.getMetric().evaluate(node,null));
  }
 else   if (configuration.triggerCheck.appliesTo(node)) {
    node.setChecked(checker.check(node));
  }
  trackOptimum(node);
  configuration.triggerTag.apply(node);
}",0.9739952718676124
108458,"/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_K_ANONYMOUS;
  NodeTrigger binaryTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeTrigger binaryTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_ANONYMOUS);
    }
    public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_K_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_K_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_K_ANONYMOUS);
      }
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY);
      }
    }
  }
;
  NodeTrigger binaryTriggerSnapshotStore=History.STORAGE_TRIGGER_NON_ANONYMOUS;
  NodeTrigger binaryTriggerSnapshotEvict=History.EVICTION_TRIGGER_K_ANONYMOUS;
  NodeTrigger binaryTriggerCheck=new NodeTriggerInverse(binaryTriggerSkip);
  NodeTrigger binaryTriggerEvaluate=new NodeTriggerConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger linearTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_VISITED) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeTrigger linearTriggerSnapshotStore=History.STORAGE_TRIGGER_ALL;
  NodeTrigger linearTriggerSnapshotEvict=History.EVICTION_TRIGGER_CHECKED;
  NodeTrigger linearTriggerEvaluate=new NodeTriggerConstant(false);
  NodeTrigger linearTriggerCheck=new NodeTriggerInverse(linearTriggerSkip);
  NodeTrigger linearTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return true;
    }
    public void action(    Node node){
      node.setProperty(Node.PROPERTY_VISITED);
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY);
      }
    }
  }
;
  FLASHConfiguration binaryConfiguration=new FLASHConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip,binaryTriggerSnapshotStore,binaryTriggerSnapshotEvict);
  FLASHConfiguration linearConfiguration=new FLASHConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip,linearTriggerSnapshotStore,linearTriggerSnapshotEvict);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,binaryConfiguration,linearConfiguration);
}","/** 
 * Semantics of method name: monotonicity of criteria + monotonicity of metric
 * @param lattice
 * @param checker
 * @param strategy
 * @return
 */
private static AbstractAlgorithm createPartialFull(final Lattice lattice,final INodeChecker checker,final FLASHStrategy strategy){
  int binaryAnonymityProperty=Node.PROPERTY_K_ANONYMOUS;
  NodeTrigger binaryTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeTrigger binaryTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_ANONYMOUS);
    }
    public void action(    Node node){
      if (node.hasProperty(Node.PROPERTY_K_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_K_ANONYMOUS);
      }
 else {
        lattice.setPropertyDownwards(node,false,Node.PROPERTY_NOT_K_ANONYMOUS);
      }
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY);
      }
    }
  }
;
  NodeTrigger binaryTriggerSnapshotStore=History.STORAGE_TRIGGER_NON_ANONYMOUS;
  NodeTrigger binaryTriggerSnapshotEvict=History.EVICTION_TRIGGER_K_ANONYMOUS;
  NodeTrigger binaryTriggerCheck=new NodeTriggerInverse(binaryTriggerSkip);
  NodeTrigger binaryTriggerEvaluate=new NodeTriggerConstant(false);
  int linearAnonymityProperty=Node.PROPERTY_ANONYMOUS;
  NodeTrigger linearTriggerSkip=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return node.hasProperty(Node.PROPERTY_VISITED) || node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) || node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY);
    }
  }
;
  NodeTrigger linearTriggerSnapshotStore=History.STORAGE_TRIGGER_ALL;
  NodeTrigger linearTriggerSnapshotEvict=History.EVICTION_TRIGGER_CHECKED;
  NodeTrigger linearTriggerEvaluate=new NodeTriggerConstant(false);
  NodeTrigger linearTriggerCheck=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return !node.hasProperty(Node.PROPERTY_VISITED) && !node.hasProperty(Node.PROPERTY_NOT_K_ANONYMOUS) && !node.hasProperty(Node.PROPERTY_INSUFFICIENT_UTILITY)&& !node.hasProperty(Node.PROPERTY_CHECKED);
    }
  }
;
  NodeTrigger linearTriggerTag=new NodeTrigger(){
    public boolean appliesTo(    Node node){
      return true;
    }
    public void action(    Node node){
      node.setProperty(Node.PROPERTY_VISITED);
      if (node.hasProperty(Node.PROPERTY_ANONYMOUS)) {
        lattice.setPropertyUpwards(node,false,Node.PROPERTY_INSUFFICIENT_UTILITY);
      }
    }
  }
;
  FLASHConfiguration binaryConfiguration=new FLASHConfiguration(binaryAnonymityProperty,binaryTriggerTag,binaryTriggerCheck,binaryTriggerEvaluate,binaryTriggerSkip,binaryTriggerSnapshotStore,binaryTriggerSnapshotEvict);
  FLASHConfiguration linearConfiguration=new FLASHConfiguration(linearAnonymityProperty,linearTriggerTag,linearTriggerCheck,linearTriggerEvaluate,linearTriggerSkip,linearTriggerSnapshotStore,linearTriggerSnapshotEvict);
  return new FLASHAlgorithmImpl(lattice,checker,strategy,binaryConfiguration,linearConfiguration);
}",0.891733497840839
108459,"@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify.clear();
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  if (transformation.hasProperty(Node.PROPERTY_ANONYMOUS) && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  InformationLoss loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics(transformation.hasProperty(Node.PROPERTY_ANONYMOUS)));
}","@Override public TransformedData applyAndSetProperties(final Node transformation){
  currentGroupify.clear();
  currentGroupify=transformer.apply(0L,transformation.getTransformation(),currentGroupify);
  currentGroupify.analyze();
  if (transformation.hasProperty(Node.PROPERTY_ANONYMOUS) && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  InformationLoss loss=transformation.getInformationLoss();
  if (loss == null) {
    loss=metric.evaluate(transformation,currentGroupify);
  }
  transformation.setChecked(new Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),loss));
  return new TransformedData(getBuffer(),currentGroupify.getGroupStatistics());
}",0.945872801082544
108460,"@Override public INodeChecker.Result check(final Node node,final boolean forceMeasureInfoLoss){
  if (stateMachine.getLastNode() != null) {
    history.store(stateMachine.getLastNode(),currentGroupify,stateMachine.getLastTransition().snapshot);
  }
  final Transition transition=stateMachine.transition(node);
  final IHashGroupify temp=lastGroupify;
  lastGroupify=currentGroupify;
  currentGroupify=temp;
  currentGroupify.clear();
switch (transition.type) {
case UNOPTIMIZED:
    currentGroupify=transformer.apply(transition.projection,node.getTransformation(),currentGroupify);
  break;
case ROLLUP:
currentGroupify=transformer.applyRollup(transition.projection,node.getTransformation(),lastGroupify,currentGroupify);
break;
case SNAPSHOT:
currentGroupify=transformer.applySnapshot(transition.projection,node.getTransformation(),currentGroupify,transition.snapshot);
break;
}
InformationLoss infoLoss=(currentGroupify.isAnonymous() || forceMeasureInfoLoss) ? metric.evaluate(node,currentGroupify) : null;
return new INodeChecker.Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),infoLoss);
}","@Override public INodeChecker.Result check(final Node node,final boolean forceMeasureInfoLoss){
  if (stateMachine.getLastNode() != null) {
    history.store(stateMachine.getLastNode(),currentGroupify,stateMachine.getLastTransition().snapshot);
  }
  final Transition transition=stateMachine.transition(node);
  final IHashGroupify temp=lastGroupify;
  lastGroupify=currentGroupify;
  currentGroupify=temp;
  currentGroupify.clear();
switch (transition.type) {
case UNOPTIMIZED:
    currentGroupify=transformer.apply(transition.projection,node.getTransformation(),currentGroupify);
  break;
case ROLLUP:
currentGroupify=transformer.applyRollup(transition.projection,node.getTransformation(),lastGroupify,currentGroupify);
break;
case SNAPSHOT:
currentGroupify=transformer.applySnapshot(transition.projection,node.getTransformation(),currentGroupify,transition.snapshot);
break;
}
currentGroupify.analyze();
InformationLoss infoLoss=(currentGroupify.isAnonymous() || forceMeasureInfoLoss) ? metric.evaluate(node,currentGroupify) : null;
return new INodeChecker.Result(currentGroupify.isAnonymous(),currentGroupify.isKAnonymous(),infoLoss);
}",0.9880159786950732
108461,"@Override public void markOutliers(final int[][] data){
  for (int row=0; row < data.length; row++) {
    final int[] key=data[row];
    final int hash=HashTableUtil.hashcode(key);
    final int index=hash & (buckets.length - 1);
    HashGroupifyEntry m=buckets[index];
    while ((m != null) && ((m.hashcode != hash) || !equalsIgnoringOutliers(key,m.key))) {
      m=m.next;
    }
    if (m == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (!m.isNotOutlier) {
      key[0]|=Data.OUTLIER_MASK;
    }
  }
}","@Override public void markOutliers(final int[][] data){
  if (!anonymous)   return;
  for (int row=0; row < data.length; row++) {
    final int[] key=data[row];
    final int hash=HashTableUtil.hashcode(key);
    final int index=hash & (buckets.length - 1);
    HashGroupifyEntry m=buckets[index];
    while ((m != null) && ((m.hashcode != hash) || !equalsIgnoringOutliers(key,m.key))) {
      m=m.next;
    }
    if (m == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (!m.isNotOutlier) {
      key[0]|=Data.OUTLIER_MASK;
    }
  }
}",0.9744058500914076
108462,"/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriterion(DPresence.class).getSubset().getSet();
  }
 else {
    subset=null;
  }
  criteria=config.getCriteriaAsArray();
  k=config.getMinimalGroupSize();
}","/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(DPresence.class)) {
    this.subset=config.getCriterion(DPresence.class).getSubset().getSet();
  }
 else {
    this.subset=null;
  }
  this.criteria=config.getCriteriaAsArray();
  this.k=config.getMinimalGroupSize();
}",0.9858156028368794
108463,"@Override public GroupStatistics getGroupStatistics(boolean anonymous){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      numberOfEquivalenceClasses++;
      if (anonymous && !isAnonymous(entry)) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      numberOfEquivalenceClasses++;
      if (this.anonymous && !entry.isNotOutlier) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.9887005649717514
108464,"/** 
 * Is the current transformation k-anonymous? CAUTION: Call before isAnonymous()!
 * @return
 */
@Override public boolean isKAnonymous(){
  if (currentOutliers > absoluteMaxOutliers) {
    return false;
  }
 else {
    return true;
  }
}","@Override public boolean isKAnonymous(){
  return kAnonymous;
}",0.3540983606557377
108465,"/** 
 * Min groupsize greater equals.
 * @return true, if successful
 */
public abstract boolean isAnonymous();","/** 
 * Are all defined privacy criteria fulfilled by this transformation, given the specified limit on suppressed tuples
 * @return true, if successful
 */
public abstract boolean isAnonymous();",0.6339869281045751
108466,"/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics(boolean anonymous);","/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics();",0.9294605809128632
108467,"/** 
 * Is it k-anonymous?
 * @return
 */
public abstract boolean isKAnonymous();","/** 
 * Is the current transformation k-anonymous. Always returns true, if no k-anonymity (sub-)criterion was specified
 * @return
 */
public abstract boolean isKAnonymous();",0.6196078431372549
108468,"@Override public void handleEvent(Event event){
  IAxisSet axisSet=chart.getAxisSet();
  if (axisSet != null) {
    IAxis xAxis=axisSet.getXAxis(0);
    if (xAxis != null) {
      String[] series=xAxis.getCategorySeries();
      ISeries[] data=chart.getSeriesSet().getSeries();
      if (data != null && data.length > 0 && series != null) {
        int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
        if (x >= 0 && x <= series.length) {
          chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
          return;
        }
      }
    }
  }
  chart.getPlotArea().setToolTipText(null);
}","@Override public void handleEvent(Event event){
  IAxisSet axisSet=chart.getAxisSet();
  if (axisSet != null) {
    IAxis xAxis=axisSet.getXAxis(0);
    if (xAxis != null) {
      String[] series=xAxis.getCategorySeries();
      ISeries[] data=chart.getSeriesSet().getSeries();
      if (data != null && data.length > 0 && series != null) {
        int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
        if (x >= 0 && x < series.length) {
          chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
          return;
        }
      }
    }
  }
  chart.getPlotArea().setToolTipText(null);
}",0.9992663242846662
108469,"@Override public void reset(){
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(parent,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  chart.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      updateCategories();
    }
  }
);
  chart.getPlotArea().addListener(SWT.MouseMove,new Listener(){
    @Override public void handleEvent(    Event event){
      IAxisSet axisSet=chart.getAxisSet();
      if (axisSet != null) {
        IAxis xAxis=axisSet.getXAxis(0);
        if (xAxis != null) {
          String[] series=xAxis.getCategorySeries();
          ISeries[] data=chart.getSeriesSet().getSeries();
          if (data != null && data.length > 0 && series != null) {
            int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
            if (x >= 0 && x <= series.length) {
              chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
              return;
            }
          }
        }
      }
      chart.getPlotArea().setToolTipText(null);
    }
  }
);
  FontData[] fd=chart.getFont().getFontData();
  fd[0].setHeight(8);
  chart.setFont(new Font(chart.getDisplay(),fd[0]));
  ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(chart.getFont());
  chart.setBackground(parent.getBackground());
  chart.setForeground(parent.getForeground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final Color c2=new Color(controller.getResources().getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  IAxisSet axisSet=chart.getAxisSet();
  IAxis yAxis=axisSet.getYAxis(0);
  IAxis xAxis=axisSet.getXAxis(0);
  ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(chart.getFont());
  yAxis.getTitle().setFont(chart.getFont());
  xAxis.getTick().setFont(chart.getFont());
  yAxis.getTick().setFont(chart.getFont());
  xAxis.getTick().setForeground(chart.getForeground());
  yAxis.getTick().setForeground(chart.getForeground());
  xAxis.getTitle().setForeground(chart.getForeground());
  yAxis.getTitle().setForeground(chart.getForeground());
  ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  chart.setEnabled(false);
  updateCategories();
}","@Override public void reset(){
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(parent,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  chart.addControlListener(new ControlAdapter(){
    @Override public void controlResized(    ControlEvent arg0){
      updateCategories();
    }
  }
);
  chart.getPlotArea().addListener(SWT.MouseMove,new Listener(){
    @Override public void handleEvent(    Event event){
      IAxisSet axisSet=chart.getAxisSet();
      if (axisSet != null) {
        IAxis xAxis=axisSet.getXAxis(0);
        if (xAxis != null) {
          String[] series=xAxis.getCategorySeries();
          ISeries[] data=chart.getSeriesSet().getSeries();
          if (data != null && data.length > 0 && series != null) {
            int x=(int)Math.round(xAxis.getDataCoordinate(event.x));
            if (x >= 0 && x < series.length) {
              chart.getPlotArea().setToolTipText(""String_Node_Str"" + series[x] + ""String_Node_Str""+ data[0].getYSeries()[x]+ ""String_Node_Str"");
              return;
            }
          }
        }
      }
      chart.getPlotArea().setToolTipText(null);
    }
  }
);
  FontData[] fd=chart.getFont().getFontData();
  fd[0].setHeight(8);
  chart.setFont(new Font(chart.getDisplay(),fd[0]));
  ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(chart.getFont());
  chart.setBackground(parent.getBackground());
  chart.setForeground(parent.getForeground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final Color c2=new Color(controller.getResources().getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  IAxisSet axisSet=chart.getAxisSet();
  IAxis yAxis=axisSet.getYAxis(0);
  IAxis xAxis=axisSet.getXAxis(0);
  ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(chart.getFont());
  yAxis.getTitle().setFont(chart.getFont());
  xAxis.getTick().setFont(chart.getFont());
  yAxis.getTick().setFont(chart.getFont());
  xAxis.getTick().setForeground(chart.getForeground());
  yAxis.getTick().setForeground(chart.getForeground());
  xAxis.getTitle().setForeground(chart.getForeground());
  yAxis.getTitle().setForeground(chart.getForeground());
  ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  chart.setEnabled(false);
  updateCategories();
}",0.999818016378526
108470,"/** 
 * Scales the given string array
 * @param values
 * @param factor
 * @return
 */
private String[] getScaledValues(String[] values,double factor){
  AggregateFunction<String> function=AggregateFunction.forType(DataType.STRING).createSetFunction();
  String[] result=new String[(int)Math.round(factor * (double)values.length)];
  int previous=-1;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    if (index == previous) {
      toAggregate.add(values[i]);
    }
 else     if (previous != -1) {
      result[previous]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
      toAggregate.clear();
      previous=index;
    }
  }
  return result;
}","/** 
 * Scales the given string array
 * @param values
 * @param length The resulting length
 * @return
 */
private String[] getScaledValues(String[] values,int length){
  AggregateFunction<String> function=AggregateFunction.forType(DataType.STRING).createSetFunction();
  double factor=(double)length / (double)values.length;
  String[] result=new String[length];
  int previous=0;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    index=index < length ? index : length - 1;
    if (index != previous) {
      result[previous]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
      toAggregate.clear();
      previous=index;
    }
    toAggregate.add(values[i]);
  }
  return result;
}",0.7967067764407854
108471,"/** 
 * Returns a contingency table for the given columns. The order for string data items is derived from the provided hierarchies
 * @param column1     The first column
 * @param size1       The maximal size in this dimension
 * @param hierarchy1  The hierarchy for the first column, may be null
 * @param column2     The second column
 * @param size2       The maximal size in this dimension
 * @param hierarchy2  The hierarchy for the second column, may be null
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,int size1,Hierarchy hierarchy1,int column2,int size2,Hierarchy hierarchy2){
  if (size1 <= 0 || size2 <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  StatisticsContingencyTable table=getContingencyTable(column1,hierarchy1,column2,hierarchy2);
  if (table.values1.length <= size1 && table.values2.length <= size2) {
    return table;
  }
  String[] values1;
  String[] values2;
  double factor1;
  double factor2;
  if (table.values1.length > size1) {
    factor1=(double)size1 / (double)table.values1.length;
    values1=getScaledValues(table.values1,factor1);
  }
 else {
    factor1=1;
    values1=table.values1;
  }
  if (table.values2.length > size2) {
    factor2=(double)size2 / (double)table.values2.length;
    values2=getScaledValues(table.values2,factor2);
  }
 else {
    factor2=1;
    values2=table.values2;
  }
  final Map<Entry,Double> entries=new HashMap<Entry,Double>();
  Iterator<Entry> iter=table.iterator;
  double max=Double.MIN_VALUE;
  while (iter.hasNext()) {
    Entry old=iter.next();
    int index1=(int)Math.round((double)old.value1 * factor1);
    int index2=(int)Math.round((double)old.value2 * factor2);
    index1=index1 < size1 ? index1 : size1 - 1;
    index2=index2 < size2 ? index2 : size2 - 1;
    Entry entry=new Entry(index1,index2);
    Double previous=entries.get(entry);
    double value=previous != null ? previous + old.frequency : old.frequency;
    max=Math.max(value,max);
    entries.put(entry,value);
  }
  final Iterator<Entry> internal=entries.keySet().iterator();
  final Iterator<Entry> iterator=new Iterator<Entry>(){
    private Iterator<Entry> _internal=internal;
    private Map<Entry,Double> _entries=entries;
    @Override public boolean hasNext(){
      if (_internal == null)       return false;
      boolean result=_internal.hasNext();
      if (!result) {
        _internal=null;
        _entries=null;
      }
      return result;
    }
    @Override public Entry next(){
      if (_internal == null)       return null;
      Entry e=_internal.next();
      e.frequency=_entries.get(e);
      return e;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  return new StatisticsContingencyTable(values1,values2,table.count,max,iterator);
}","/** 
 * Returns a contingency table for the given columns. The order for string data items is derived from the provided hierarchies
 * @param column1     The first column
 * @param size1       The maximal size in this dimension
 * @param hierarchy1  The hierarchy for the first column, may be null
 * @param column2     The second column
 * @param size2       The maximal size in this dimension
 * @param hierarchy2  The hierarchy for the second column, may be null
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,int size1,Hierarchy hierarchy1,int column2,int size2,Hierarchy hierarchy2){
  if (size1 <= 0 || size2 <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  StatisticsContingencyTable table=getContingencyTable(column1,hierarchy1,column2,hierarchy2);
  if (table.values1.length <= size1 && table.values2.length <= size2) {
    return table;
  }
  String[] values1;
  String[] values2;
  double factor1;
  double factor2;
  if (table.values1.length > size1) {
    factor1=(double)size1 / (double)table.values1.length;
    values1=getScaledValues(table.values1,size1);
  }
 else {
    factor1=1;
    values1=table.values1;
  }
  if (table.values2.length > size2) {
    factor2=(double)size2 / (double)table.values2.length;
    values2=getScaledValues(table.values2,size2);
  }
 else {
    factor2=1;
    values2=table.values2;
  }
  final Map<Entry,Double> entries=new HashMap<Entry,Double>();
  Iterator<Entry> iter=table.iterator;
  double max=Double.MIN_VALUE;
  while (iter.hasNext()) {
    Entry old=iter.next();
    int index1=(int)Math.round((double)old.value1 * factor1);
    int index2=(int)Math.round((double)old.value2 * factor2);
    index1=index1 < size1 ? index1 : size1 - 1;
    index2=index2 < size2 ? index2 : size2 - 1;
    Entry entry=new Entry(index1,index2);
    Double previous=entries.get(entry);
    double value=previous != null ? previous + old.frequency : old.frequency;
    max=Math.max(value,max);
    entries.put(entry,value);
  }
  final Iterator<Entry> internal=entries.keySet().iterator();
  final Iterator<Entry> iterator=new Iterator<Entry>(){
    private Iterator<Entry> _internal=internal;
    private Map<Entry,Double> _entries=entries;
    @Override public boolean hasNext(){
      if (_internal == null)       return false;
      boolean result=_internal.hasNext();
      if (!result) {
        _internal=null;
        _entries=null;
      }
      return result;
    }
    @Override public Entry next(){
      if (_internal == null)       return null;
      Entry e=_internal.next();
      e.frequency=_entries.get(e);
      return e;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  return new StatisticsContingencyTable(values1,values2,table.count,max,iterator);
}",0.9435770049680624
108472,"/** 
 * Returns a contingency table for the given columns. The order for string data items is derived from the provided hierarchies
 * @param column1     The first column
 * @param size1       The maximal size in this dimension
 * @param hierarchy1  The hierarchy for the first column, may be null
 * @param column2     The second column
 * @param size2       The maximal size in this dimension
 * @param hierarchy2  The hierarchy for the second column, may be null
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,int size1,Hierarchy hierarchy1,int column2,int size2,Hierarchy hierarchy2){
  if (size1 <= 0 || size2 <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  StatisticsContingencyTable table=getContingencyTable(column1,hierarchy1,column2,hierarchy2);
  if (table.values1.length <= size1 && table.values2.length <= size2) {
    return table;
  }
  String[] values1;
  String[] values2;
  double factor1;
  double factor2;
  if (table.values1.length > size1) {
    factor1=(double)size1 / (double)table.values1.length;
    values1=getScaledValues(table.values1,factor1);
  }
 else {
    factor1=1;
    values1=table.values1;
  }
  if (table.values2.length > size2) {
    factor2=(double)size2 / (double)table.values2.length;
    values2=getScaledValues(table.values2,factor2);
  }
 else {
    factor2=1;
    values2=table.values2;
  }
  final Map<Entry,Double> entries=new HashMap<Entry,Double>();
  Iterator<Entry> iter=table.iterator;
  double max=Double.MIN_VALUE;
  while (iter.hasNext()) {
    Entry old=iter.next();
    int index1=(int)Math.round((double)old.value1 * factor1);
    int index2=(int)Math.round((double)old.value2 * factor2);
    Entry entry=new Entry(index1,index2);
    Double previous=entries.get(entry);
    double value=previous != null ? previous + old.frequency : old.frequency;
    max=Math.max(value,max);
    entries.put(entry,value);
  }
  final Iterator<Entry> internal=entries.keySet().iterator();
  final Iterator<Entry> iterator=new Iterator<Entry>(){
    private Iterator<Entry> _internal=internal;
    private Map<Entry,Double> _entries=entries;
    @Override public boolean hasNext(){
      if (_internal == null)       return false;
      boolean result=_internal.hasNext();
      if (!result) {
        _internal=null;
        _entries=null;
      }
      return result;
    }
    @Override public Entry next(){
      if (_internal == null)       return null;
      Entry e=_internal.next();
      e.frequency=_entries.get(e);
      return e;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  return new StatisticsContingencyTable(values1,values2,table.count,max,iterator);
}","/** 
 * Returns a contingency table for the given columns. The order for string data items is derived from the provided hierarchies
 * @param column1     The first column
 * @param size1       The maximal size in this dimension
 * @param hierarchy1  The hierarchy for the first column, may be null
 * @param column2     The second column
 * @param size2       The maximal size in this dimension
 * @param hierarchy2  The hierarchy for the second column, may be null
 * @return
 */
public StatisticsContingencyTable getContingencyTable(int column1,int size1,Hierarchy hierarchy1,int column2,int size2,Hierarchy hierarchy2){
  if (size1 <= 0 || size2 <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  StatisticsContingencyTable table=getContingencyTable(column1,hierarchy1,column2,hierarchy2);
  if (table.values1.length <= size1 && table.values2.length <= size2) {
    return table;
  }
  String[] values1;
  String[] values2;
  double factor1;
  double factor2;
  if (table.values1.length > size1) {
    factor1=(double)size1 / (double)table.values1.length;
    values1=getScaledValues(table.values1,factor1);
  }
 else {
    factor1=1;
    values1=table.values1;
  }
  if (table.values2.length > size2) {
    factor2=(double)size2 / (double)table.values2.length;
    values2=getScaledValues(table.values2,factor2);
  }
 else {
    factor2=1;
    values2=table.values2;
  }
  final Map<Entry,Double> entries=new HashMap<Entry,Double>();
  Iterator<Entry> iter=table.iterator;
  double max=Double.MIN_VALUE;
  while (iter.hasNext()) {
    Entry old=iter.next();
    int index1=(int)Math.round((double)old.value1 * factor1);
    int index2=(int)Math.round((double)old.value2 * factor2);
    index1=index1 < size1 ? index1 : size1 - 1;
    index2=index2 < size2 ? index2 : size2 - 1;
    Entry entry=new Entry(index1,index2);
    Double previous=entries.get(entry);
    double value=previous != null ? previous + old.frequency : old.frequency;
    max=Math.max(value,max);
    entries.put(entry,value);
  }
  final Iterator<Entry> internal=entries.keySet().iterator();
  final Iterator<Entry> iterator=new Iterator<Entry>(){
    private Iterator<Entry> _internal=internal;
    private Map<Entry,Double> _entries=entries;
    @Override public boolean hasNext(){
      if (_internal == null)       return false;
      boolean result=_internal.hasNext();
      if (!result) {
        _internal=null;
        _entries=null;
      }
      return result;
    }
    @Override public Entry next(){
      if (_internal == null)       return null;
      Entry e=_internal.next();
      e.frequency=_entries.get(e);
      return e;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  return new StatisticsContingencyTable(values1,values2,table.count,max,iterator);
}",0.9826839826839828
108473,"/** 
 * Scales the given string array
 * @param values
 * @param length The resulting length
 * @return
 */
private String[] getScaledValues(String[] values,int length){
  AggregateFunction<String> function=AggregateFunction.forType(DataType.STRING).createSetFunction();
  double factor=(double)length / (double)values.length;
  String[] result=new String[length];
  int previous=0;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    index=index < length ? index : length - 1;
    if (index != previous) {
      result[previous]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
      toAggregate.clear();
      previous=index;
    }
    toAggregate.add(values[i]);
  }
  return result;
}","/** 
 * Scales the given string array
 * @param values
 * @param length The resulting length
 * @return
 */
private String[] getScaledValues(String[] values,int length){
  AggregateFunction<String> function=AggregateFunction.forType(DataType.STRING).createSetFunction();
  double factor=(double)length / (double)values.length;
  String[] result=new String[length];
  int previous=0;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    index=index < length ? index : length - 1;
    if (index != previous) {
      result[previous]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
      toAggregate.clear();
      previous=index;
    }
    toAggregate.add(values[i]);
  }
  result[length - 1]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
  return result;
}",0.9450934579439252
108474,"/** 
 * Sets the transformation
 * @param transformation
 */
protected void setTransformation(final int[] transformation,final int level){
  this.transformation=transformation;
  this.level=level;
}","/** 
 * Sets the transformation
 * @param transformation
 */
public void setTransformation(final int[] transformation,final int level){
  this.transformation=transformation;
  this.level=level;
}",0.9720101781170484
108475,"@Test public void testStableSorting() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(false,2);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] resultArray=iteratorToArray(outHandle.iterator());
  final String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] expectedIn={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(resultArray,expected));
  assertTrue(Arrays.deepEquals(inArray,expectedIn));
}","@Test public void testStableSorting() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(true,2);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] resultArray=iteratorToArray(outHandle.iterator());
  final String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] expectedIn={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(resultArray,expected));
  assertTrue(Arrays.deepEquals(inArray,expectedIn));
}",0.9981447124304268
108476,"@Test public void testMultipleDataHandlesForkSync() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  ARXLattice lattice=result.getLattice();
  ARXNode topNode=lattice.getTop();
  ARXNode bottomNode=lattice.getBottom();
  DataHandle optimal=result.getOutput();
  DataHandle top=result.getOutput(topNode);
  DataHandle bottom=result.getOutput(bottomNode);
  optimal.sort(true,0);
  bottom.sort(false,2);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] optimalArray=iteratorToArray(optimal.iterator());
  final String[][] topArray=iteratorToArray(top.iterator());
  final String[][] bottomArray=iteratorToArray(bottom.iterator());
  final String[][] topExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] bottomExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] optimalExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(optimalArray,optimalExpected));
  assertTrue(Arrays.deepEquals(topArray,topExpected));
  assertTrue(Arrays.deepEquals(bottomArray,bottomExpected));
  assertTrue(Arrays.deepEquals(inArray,bottomExpected));
}","@Test public void testMultipleDataHandlesForkSync() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  ARXLattice lattice=result.getLattice();
  ARXNode topNode=lattice.getTop();
  ARXNode bottomNode=lattice.getBottom();
  DataHandle optimal=result.getOutput();
  DataHandle top=result.getOutput(topNode);
  DataHandle bottom=result.getOutput(bottomNode);
  optimal.sort(false,0);
  bottom.sort(true,2);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] optimalArray=iteratorToArray(optimal.iterator());
  final String[][] topArray=iteratorToArray(top.iterator());
  final String[][] bottomArray=iteratorToArray(bottom.iterator());
  final String[][] topExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] bottomExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] optimalExpected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(optimalArray,optimalExpected));
  assertTrue(Arrays.deepEquals(topArray,topExpected));
  assertTrue(Arrays.deepEquals(bottomArray,bottomExpected));
  assertTrue(Arrays.deepEquals(inArray,bottomExpected));
}",0.9974646867077146
108477,"@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(true,0,1,2);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getOutput(n,false);
  String[][] given=iteratorToArray(h.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}","@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(false,0,1,2);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getOutput(n,false);
  String[][] given=iteratorToArray(h.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}",0.9973831775700934
108478,"@Test public void testSubset3() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new Inclusion(subset));
  final ARXResult result=anonymizer.anonymize(data,config);
  final DataHandle outHandle=result.getOutput(false);
  data.getHandle().sort(true,0);
  String[][] given=iteratorToArray(outHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}","@Test public void testSubset3() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new Inclusion(subset));
  final ARXResult result=anonymizer.anonymize(data,config);
  final DataHandle outHandle=result.getOutput(false);
  data.getHandle().sort(false,0);
  String[][] given=iteratorToArray(outHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}",0.9974006683995544
108479,"@Test public void testSubset2() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  DataSelector selector=DataSelector.create(provider.getData()).field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(provider.getData(),selector);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(0,1,subset));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(false,2);
  outHandle.getView().sort(true,0);
  String[][] given=iteratorToArray(outHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}","@Test public void testSubset2() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  DataSelector selector=DataSelector.create(provider.getData()).field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(provider.getData(),selector);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(0,1,subset));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(true,2);
  outHandle.getView().sort(false,0);
  String[][] given=iteratorToArray(outHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}",0.9947800149142432
108480,"@Test public void testSubset1() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  DataSelector selector=DataSelector.create(provider.getData()).field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(provider.getData(),selector);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(0,1,subset));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(false,2);
  outHandle.getView().sort(true,0);
  String[][] given=iteratorToArray(inHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}","@Test public void testSubset1() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final DataHandle inHandle=provider.getData().getHandle();
  provider.getData().getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  DataSelector selector=DataSelector.create(provider.getData()).field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(provider.getData(),selector);
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(0,1,subset));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  outHandle.sort(true,2);
  outHandle.getView().sort(false,0);
  String[][] given=iteratorToArray(inHandle.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}",0.995
108481,"@Test public void testSorting() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  final DataHandle inHandle=provider.getData().getHandle();
  inHandle.sort(false,0);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] resultArray=iteratorToArray(outHandle.iterator());
  final String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] expectedIn={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(inArray,expectedIn));
  assertTrue(Arrays.deepEquals(resultArray,expected));
}","@Test public void testSorting() throws IllegalArgumentException, IOException {
  provider.createDataDefinition();
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  anonymizer.setSuppressionString(""String_Node_Str"");
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new KAnonymity(2));
  config.setMaxOutliers(0d);
  final ARXResult result=anonymizer.anonymize(provider.getData(),config);
  final DataHandle outHandle=result.getOutput(false);
  final DataHandle inHandle=provider.getData().getHandle();
  inHandle.sort(true,0);
  final String[][] inArray=iteratorToArray(inHandle.iterator());
  final String[][] resultArray=iteratorToArray(outHandle.iterator());
  final String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  final String[][] expectedIn={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(inArray,expectedIn));
  assertTrue(Arrays.deepEquals(resultArray,expected));
}",0.9980220401243288
108482,"public double getSuppressionWeight(){
  return suppressionWeight;
}","public double getSuppressionWeight(){
  if (this.suppressionWeight == null) {
    this.suppressionWeight=0.5d;
  }
  return suppressionWeight;
}",0.6350710900473934
108483,"protected MetricAECS(){
  super(true,false);
}","protected MetricAECS(){
  super(false,false);
}",0.9247311827956988
108484,"/** 
 * Converts an information loss into a relative value in percent  TODO: Code duplicate from NodePropertiesView
 * @param infoLoss
 * @return
 */
protected double asRelativeValue(final InformationLoss<?> infoLoss,final ARXResult result){
  return infoLoss.relativeTo(model.getResult().getLattice().getBottom().getMinimumInformationLoss(),model.getResult().getLattice().getTop().getMaximumInformationLoss()) * 100d;
}","/** 
 * Converts an information loss into a relative value in percent  TODO: Code duplicate from NodePropertiesView
 * @param infoLoss
 * @return
 */
protected double asRelativeValue(final InformationLoss<?> infoLoss,final ARXResult result){
  return infoLoss.relativeTo(model.getResult().getLattice().getMinimumInformationLoss(),model.getResult().getLattice().getMaximumInformationLoss()) * 100d;
}",0.9743589743589745
108485,"/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss<?> infoLoss){
  if (model != null && model.getResult() != null && model.getResult().getLattice() != null && model.getResult().getLattice().getBottom() != null && model.getResult().getLattice().getTop() != null) {
    return infoLoss.relativeTo(model.getResult().getLattice().getBottom().getMinimumInformationLoss(),model.getResult().getLattice().getTop().getMaximumInformationLoss()) * 100d;
  }
 else {
    return 0;
  }
}","/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss<?> infoLoss){
  if (model != null && model.getResult() != null && model.getResult().getLattice() != null && model.getResult().getLattice().getBottom() != null && model.getResult().getLattice().getTop() != null) {
    return infoLoss.relativeTo(model.getResult().getLattice().getMinimumInformationLoss(),model.getResult().getLattice().getMaximumInformationLoss()) * 100d;
  }
 else {
    return 0;
  }
}",0.9815627743634768
108486,"/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss<?> infoLoss){
  if (result == null)   return 0;
  return infoLoss.relativeTo(result.getLattice().getBottom().getMinimumInformationLoss(),result.getLattice().getTop().getMaximumInformationLoss()) * 100d;
}","/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss<?> infoLoss){
  if (result == null)   return 0;
  return infoLoss.relativeTo(result.getLattice().getMinimumInformationLoss(),result.getLattice().getMaximumInformationLoss()) * 100d;
}",0.8815977175463623
108487,"/** 
 * Estimates minimal information loss
 */
private void estimateMonotonicMinLoss(){
  if (bottom.getMinimumInformationLoss() == null) {
    bottom.access().setMinimumInformationLoss(metric.createMinInformationLoss());
  }
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      final InformationLoss<?> a=node.getMinimumInformationLoss();
      for (      final ARXNode n : node.getSuccessors()) {
        if (n.getMinimumInformationLoss() == null) {
          n.access().setMinimumInformationLoss(metric.createMinInformationLoss());
        }
        if (n.getMinimumInformationLoss() != n.getMaximumInformationLoss()) {
          n.getMinimumInformationLoss().max(a);
        }
      }
    }
  }
  this.minimumInformationLoss=this.getTop().getMinimumInformationLoss().clone();
}","/** 
 * Estimates minimal information loss
 */
private void estimateMonotonicMinLoss(){
  if (bottom.getMinimumInformationLoss() == null) {
    bottom.access().setMinimumInformationLoss(metric.createMinInformationLoss());
  }
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      final InformationLoss<?> a=node.getMinimumInformationLoss();
      for (      final ARXNode n : node.getSuccessors()) {
        if (n.getMinimumInformationLoss() == null) {
          n.access().setMinimumInformationLoss(metric.createMinInformationLoss());
        }
        if (n.getMinimumInformationLoss() != n.getMaximumInformationLoss()) {
          n.getMinimumInformationLoss().max(a);
        }
      }
    }
  }
  this.minimumInformationLoss=this.getBottom().getMinimumInformationLoss().clone();
}",0.9947521865889212
108488,"/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=null;
  InformationLoss<?> max=null;
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      InformationLoss<?> nodeMin=node.getMinimumInformationLoss();
      InformationLoss<?> nodeMax=node.getMaximumInformationLoss();
      if (node.isChecked()) {
        if (min == null || min.compareTo(nodeMin) > 0) {
          min=nodeMin;
        }
        if (max == null || max.compareTo(nodeMax) < 0) {
          max=nodeMax;
        }
      }
    }
  }
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (!node.isChecked()) {
        node.maxInformationLoss=max.clone();
        node.minInformationLoss=min.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}","/** 
 * Estimates minimal information loss
 */
private void estimateNonMonotonicLoss(){
  InformationLoss<?> min=null;
  InformationLoss<?> max=null;
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      InformationLoss<?> nodeMin=node.getMinimumInformationLoss();
      InformationLoss<?> nodeMax=node.getMaximumInformationLoss();
      if (node.isChecked()) {
        if (min == null || min.compareTo(nodeMin) > 0) {
          min=nodeMin.clone();
        }
        if (max == null || max.compareTo(nodeMax) < 0) {
          max=nodeMax.clone();
        }
      }
    }
  }
  for (int i=0; i < levels.length; i++) {
    final ARXNode[] level=levels[i];
    for (    final ARXNode node : level) {
      if (!node.isChecked()) {
        node.maxInformationLoss=max.clone();
        node.minInformationLoss=min.clone();
      }
    }
  }
  this.minimumInformationLoss=min.clone();
  this.maximumInformationLoss=max.clone();
}",0.991919191919192
108489,"@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossDefault _min=convert(min);
  InformationLossDefault _max=convert(max);
  return (this.value - _min.getValue()) / (_max.getValue() - _min.getValue());
}","@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossDefault _min=convert(min);
  InformationLossDefault _max=convert(max);
  if (_max.value - _min.value == 0d)   return 0d;
 else   return (this.value - _min.value) / (_max.value - _min.value);
}",0.8866442199775533
108490,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      groups+=m.isNotOutlier ? 1 : 0;
      suppressed|=!m.isNotOutlier;
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      if (m.isNotOutlier || !node.isAnonymous()) {
        groups++;
      }
 else {
        suppressed=true;
      }
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}",0.6042296072507553
108491,"@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          scores[dimension]+=(double)m.count * frequencies[dimension][transformation[dimension]][value];
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          scores[dimension]+=(double)m.count;
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores);
}","@Override protected InformationLossRCE evaluateInternal(Node node,IHashGroupify g){
  int[] transformation=node.getTransformation();
  int dimensions=transformation.length;
  double[] scores=new double[dimensions];
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      if (m.isNotOutlier || !node.isAnonymous()) {
        for (int dimension=0; dimension < dimensions; dimension++) {
          int value=m.key[dimension];
          scores[dimension]+=(double)m.count * frequencies[dimension][transformation[dimension]][value];
        }
      }
 else {
        for (int dimension=0; dimension < dimensions; dimension++) {
          scores[dimension]+=(double)m.count;
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int dimension=0; dimension < dimensions; dimension++) {
    scores[dimension]=normalize(scores[dimension],dimension);
  }
  return new InformationLossRCE(scores);
}",0.9874110563765736
108492,"@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final InformationLossDefault originalInfoLossDefault=super.evaluateInternal(node,g);
  if (!node.isAnonymous())   return originalInfoLossDefault;
  final double originalInfoLoss=originalInfoLossDefault.getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}","@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final InformationLossDefault originalInfoLossDefault=super.evaluateInternal(node,g);
  if (!node.isAnonymous())   return originalInfoLossDefault;
  final double originalInfoLoss=originalInfoLossDefault.getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  if (node.isAnonymous()) {
    HashGroupifyEntry m=g.getFirstEntry();
    while (m != null) {
      if (!m.isNotOutlier && m.count > 0) {
        suppressedTuples+=m.count;
        for (int i=0; i < original.length; i++) {
          key=m.key[i];
          val=original[i].get(key);
          if (val == null) {
            original[i].put(key,m.count);
          }
 else {
            original[i].put(key,m.count + val);
          }
        }
      }
      m=m.nextOrdered;
    }
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}",0.976928622927181
108493,"protected MetricAECS(){
  super(true,false);
}","protected MetricAECS(){
  super(false,false);
}",0.9247311827956988
108494,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int size=0;
  if (dPresence) {
    HashGroupifyEntry m=g.getFirstEntry();
    while (m != null) {
      if (m.count > 0) {
        size++;
      }
      m=m.nextOrdered;
    }
  }
 else {
    size=g.size();
  }
  final double value=total / size;
  return new InformationLossDefault(value);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      groups+=m.isNotOutlier ? 1 : 0;
      suppressed|=!m.isNotOutlier;
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}",0.5559400230680508
108495,"@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] ahierarchies,final ARXConfiguration config){
  if (config.containsCriterion(DPresence.class)) {
    dPresence=true;
    Set<DPresence> crits=config.getCriteria(DPresence.class);
    if (crits.size() > 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    for (    DPresence dPresence : crits) {
      total=dPresence.getSubset().getArray().length;
    }
  }
 else {
    total=input.getDataLength();
  }
}","@Override protected void initializeInternal(final DataDefinition definition,final Data input,final GeneralizationHierarchy[] ahierarchies,final ARXConfiguration config){
}",0.4736842105263157
108496,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int size=0;
  if (dPresence) {
    HashGroupifyEntry m=g.getFirstEntry();
    while (m != null) {
      if (m.count > 0) {
        size++;
      }
      m=m.nextOrdered;
    }
  }
 else {
    size=g.size();
  }
  final double value=total / size;
  return new InformationLossDefault(value);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  int groups=0;
  int tuples=0;
  boolean suppressed=false;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.count > 0) {
      tuples+=m.count;
      groups+=m.isNotOutlier ? 1 : 0;
      suppressed|=!m.isNotOutlier;
    }
    m=m.nextOrdered;
  }
  groups+=suppressed ? 1 : 0;
  return new InformationLossDefault((double)tuples / (double)groups);
}",0.5559400230680508
108497,"/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  StatisticsEquivalenceClasses statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMinimalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMaximalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getAverageEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  StatisticsEquivalenceClasses statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMinimalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMaximalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getAverageEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
  }
  if (node.getMaximumInformationLoss().getValue().equals(node.getMinimumInformationLoss().getValue())) {
    final String infoloss=node.getMinimumInformationLoss().toString() + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9962936676918224
108498,"@Override public void min(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) < 0) {
    value=o.value;
    ints=o.ints;
  }
}","@Override public void min(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) < 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
  }
}",0.9521640091116174
108499,"/** 
 * Creates a new instance
 * @param value
 */
InformationLossRCE(final double[] value){
  this.value=value;
  Arrays.sort(value);
  for (int i=0; i < value.length / 2; i++) {
    int other=value.length - (i + 1);
    double temp=value[i];
    value[i]=value[other];
    value[other]=temp;
  }
  StringBuilder digits=new StringBuilder();
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER);
    StringBuilder sval=new StringBuilder();
    sval.append(ival);
    while (sval.length() != PRECISION) {
      sval.insert(0,""String_Node_Str"");
    }
    digits.append(sval);
  }
  this.ints=new BigInteger(digits.toString());
}","/** 
 * Creates a new instance
 * @param value
 */
InformationLossRCE(final double[] value){
  this.value=value;
  Arrays.sort(value);
  for (int i=0; i < value.length / 2; i++) {
    int other=value.length - (i + 1);
    double temp=value[i];
    value[i]=value[other];
    value[other]=temp;
  }
  StringBuilder digits=new StringBuilder();
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER);
    StringBuilder sval=new StringBuilder();
    sval.append(ival);
    while (sval.length() < (PRECISION + 1)) {
      sval.insert(0,""String_Node_Str"");
    }
    digits.append(sval);
  }
  this.ints=new BigInteger(digits.toString());
  digits.setLength(0);
  digits.append(""String_Node_Str"");
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER_STRING);
    digits.append(ival);
    digits.append(""String_Node_Str"");
  }
  digits.setCharAt(digits.length() - 1,']');
  this.string=digits.toString();
}",0.8123038292529818
108500,"@Override public void max(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) > 0) {
    value=o.value;
    ints=o.ints;
  }
}","@Override public void max(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) > 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
  }
}",0.9521640091116174
108501,"@Override public InformationLoss<double[]> clone(){
  return new InformationLossRCE(value,ints);
}","@Override public InformationLoss<double[]> clone(){
  return new InformationLossRCE(value,ints,string);
}",0.9655172413793104
108502,"@Override public String toString(){
  return Arrays.toString(this.value);
}","@Override public String toString(){
  return string;
}",0.8372093023255814
108503,"@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  BigDecimal a=new BigDecimal(this.ints.subtract(_min.ints),PRECISION);
  BigDecimal b=new BigDecimal(_max.ints.subtract(_min.ints),PRECISION);
  return a.divide(b).doubleValue();
}","@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  BigDecimal a=new BigDecimal(this.ints.subtract(_min.ints));
  BigDecimal b=new BigDecimal(_max.ints.subtract(_min.ints));
  return a.divide(b,MathContext.DECIMAL64).doubleValue();
}",0.8053949903660886
108504,"public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy == null || hierarchy.getHierarchy() == null) {
      hierarchy=Hierarchy.create();
      config.setHierarchy(attr,hierarchy);
    }
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    definition.setAttributeType(attr,hierarchy);
    definition.setMinimumGeneralization(attr,min);
    definition.setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","public void createConfig(){
  ModelConfiguration config=getInputConfig();
  DataDefinition definition=getInputDefinition();
  config.removeAllCriteria();
  if (definition == null)   return;
  for (  String attr : definition.getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy == null || hierarchy.getHierarchy() == null) {
      hierarchy=Hierarchy.create();
      config.setHierarchy(attr,hierarchy);
    }
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    definition.setAttributeType(attr,hierarchy);
    definition.setMinimumGeneralization(attr,min);
    definition.setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(config.getInput(),config.getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9924843423799582
108505,"public DataDefinition getInputDefinition(){
  return inputConfig.getInput().getDefinition();
}","public DataDefinition getInputDefinition(){
  if (inputConfig == null)   return null;
 else   if (inputConfig.getInput() == null)   return null;
 else   return inputConfig.getInput().getDefinition();
}",0.5898305084745763
108506,"/** 
 * Reads the metadata from the file
 * @param map
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readMetadata(final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    Vocabulary_V2 vocabulary=new Vocabulary_V2();
    String version=null;
    String vocabularyVersion=null;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isMetadata(localName)) {
        if (vocabularyVersion == null) {
          vocabularyVersion=""String_Node_Str"";
        }
        WorkerLoad.this.vocabulary=Vocabulary.forVersion(vocabularyVersion);
        WorkerLoad.this.vocabulary.checkVersion(version,Resources.getVersion());
      }
 else       if (vocabulary.isVersion(localName)) {
        version=payload;
      }
 else       if (vocabulary.isVocabulary(localName)) {
        vocabularyVersion=payload;
      }
 else {
        return false;
      }
      return true;
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isMetadata(localName) || vocabulary.isVersion(localName) || vocabulary.isVocabulary(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the metadata from the file
 * @param map
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readMetadata(final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    Vocabulary_V2 vocabulary=new Vocabulary_V2();
    String version=null;
    String vocabularyVersion=null;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isMetadata(localName)) {
        if (vocabularyVersion == null) {
          vocabularyVersion=""String_Node_Str"";
        }
        WorkerLoad.this.vocabulary=Vocabulary.forVersion(vocabularyVersion);
        WorkerLoad.this.vocabulary.checkVersion(version);
      }
 else       if (vocabulary.isVersion(localName)) {
        version=payload;
      }
 else       if (vocabulary.isVocabulary(localName)) {
        vocabularyVersion=payload;
      }
 else {
        return false;
      }
      return true;
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isMetadata(localName) || vocabulary.isVersion(localName) || vocabulary.isVocabulary(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.9933042212518196
108507,"@Override protected boolean end(final String uri,final String localName,final String qName) throws SAXException {
  if (vocabulary.isMetadata(localName)) {
    if (vocabularyVersion == null) {
      vocabularyVersion=""String_Node_Str"";
    }
    WorkerLoad.this.vocabulary=Vocabulary.forVersion(vocabularyVersion);
    WorkerLoad.this.vocabulary.checkVersion(version,Resources.getVersion());
  }
 else   if (vocabulary.isVersion(localName)) {
    version=payload;
  }
 else   if (vocabulary.isVocabulary(localName)) {
    vocabularyVersion=payload;
  }
 else {
    return false;
  }
  return true;
}","@Override protected boolean end(final String uri,final String localName,final String qName) throws SAXException {
  if (vocabulary.isMetadata(localName)) {
    if (vocabularyVersion == null) {
      vocabularyVersion=""String_Node_Str"";
    }
    WorkerLoad.this.vocabulary=Vocabulary.forVersion(vocabularyVersion);
    WorkerLoad.this.vocabulary.checkVersion(version);
  }
 else   if (vocabulary.isVersion(localName)) {
    version=payload;
  }
 else   if (vocabulary.isVocabulary(localName)) {
    vocabularyVersion=payload;
  }
 else {
    return false;
  }
  return true;
}",0.9804255319148936
108508,"public abstract void checkVersion(String file,String current) throws SAXException ;",public abstract void checkVersion(String version) throws SAXException ;,0.8571428571428571
108509,"@Override public void checkVersion(String file,String current) throws SAXException {
  if (!file.equals(""String_Node_Str"")) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + file);
  }
}","@Override public void checkVersion(String version) throws SAXException {
  if (!version.equals(""String_Node_Str"")) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}",0.8823529411764706
108510,"@Override public void checkVersion(String file,String current) throws SAXException {
  if (!compareVersion(current,file)) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + file);
  }
}","@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.startsWith(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}",0.6993318485523385
108511,"/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
private double normalize(double aggregate,int dimension){
  double min=datasetSize / domainSizes[dimension];
  double max=datasetSize;
  return (aggregate - min) / (max - min);
}","/** 
 * Normalizes the aggregate
 * @param aggregate
 * @param dimension
 * @return
 */
private double normalize(double aggregate,int dimension){
  double min=datasetSize / domainSizes[dimension];
  double max=datasetSize;
  double result=(aggregate - min) / (max - min);
  return result >= 0d ? result : 0d;
}",0.8993055555555556
108512,"@Override public void min(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) < 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
  }
}","@Override public void min(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) < 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
    perc=o.perc;
  }
}",0.9643605870020964
108513,"/** 
 * Creates a new instance
 * @param value
 */
InformationLossRCE(final double[] value){
  this.value=value;
  Arrays.sort(value);
  for (int i=0; i < value.length / 2; i++) {
    int other=value.length - (i + 1);
    double temp=value[i];
    value[i]=value[other];
    value[other]=temp;
  }
  StringBuilder digits=new StringBuilder();
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER);
    StringBuilder sval=new StringBuilder();
    sval.append(ival);
    while (sval.length() < (PRECISION + 1)) {
      sval.insert(0,""String_Node_Str"");
    }
    digits.append(sval);
  }
  this.ints=new BigInteger(digits.toString());
  digits.setLength(0);
  digits.append(""String_Node_Str"");
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER_STRING);
    digits.append(ival);
    digits.append(""String_Node_Str"");
  }
  digits.setCharAt(digits.length() - 1,']');
  this.string=digits.toString();
}","/** 
 * Creates a new instance
 * @param value
 */
InformationLossRCE(final double[] value){
  this.value=value;
  Arrays.sort(value);
  for (int i=0; i < value.length / 2; i++) {
    int other=value.length - (i + 1);
    double temp=value[i];
    value[i]=value[other];
    value[other]=temp;
  }
  StringBuilder digits=new StringBuilder();
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER);
    StringBuilder sval=new StringBuilder();
    sval.append(ival);
    while (sval.length() < (PRECISION + 1)) {
      sval.insert(0,""String_Node_Str"");
    }
    digits.append(sval);
  }
  this.ints=new BigInteger(digits.toString());
  digits.setLength(0);
  digits.append(""String_Node_Str"");
  for (  double v : value) {
    long ival=(long)Math.round(v * MULTIPLIER_STRING);
    digits.append(ival);
    digits.append(""String_Node_Str"");
  }
  digits.setCharAt(digits.length() - 1,']');
  this.string=digits.toString();
  double mean=getMean(value);
  this.perc=mean + getStandardDeviation(mean,value);
}",0.957846622651092
108514,"@Override public void max(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) > 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
  }
}","@Override public void max(final InformationLoss<?> other){
  InformationLossRCE o=convert(other);
  if (other == null) {
    return;
  }
  if (o.compareTo(this) > 0) {
    value=o.value;
    ints=o.ints;
    string=o.string;
    perc=o.perc;
  }
}",0.9643605870020964
108515,"@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  BigDecimal a=new BigDecimal(this.ints.subtract(_min.ints));
  BigDecimal b=new BigDecimal(_max.ints.subtract(_min.ints));
  return a.divide(b,MathContext.DECIMAL64).doubleValue();
}","@Override public double relativeTo(InformationLoss<?> min,InformationLoss<?> max){
  if (min == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (max == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InformationLossRCE _min=convert(min);
  InformationLossRCE _max=convert(max);
  return (perc - _min.perc) / (_max.perc - _min.perc);
}",0.7667031763417306
108516,"@Override public InformationLoss<double[]> clone(){
  return new InformationLossRCE(value,ints,string);
}","@Override public InformationLoss<double[]> clone(){
  return new InformationLossRCE(value,ints,string,perc);
}",0.9767441860465116
108517,"/** 
 * Performs some sanity checks.
 * @param manager the manager
 */
private void checkAfterEncoding(final ARXConfiguration config,final DataManager manager){
  if (config.containsCriterion(KAnonymity.class)) {
    KAnonymity c=config.getCriterion(KAnonymity.class);
    if ((c.getK() > manager.getDataQI().getDataLength()) || (c.getK() < 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + c.getK() + ""String_Node_Str""+ manager.getDataQI().getDataLength()+ ""String_Node_Str"");
    }
  }
  if (config.containsCriterion(LDiversity.class)) {
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if ((c.getL() > manager.getDataQI().getDataLength()) || (c.getL() < 1)) {
        throw new IllegalArgumentException(""String_Node_Str"" + c.getL() + ""String_Node_Str""+ manager.getDataQI().getDataLength()+ ""String_Node_Str"");
      }
    }
  }
  for (  final GeneralizationHierarchy hierarchy : manager.getHierarchies()) {
    if (!hierarchy.isMonotonic()) {
      throw new IllegalArgumentException(""String_Node_Str"" + hierarchy.getName() + ""String_Node_Str"");
    }
  }
  final int[] hierarchyHeights=manager.getHierachyHeights();
  final int[] minLevels=manager.getMinLevels();
  final int[] maxLevels=manager.getMaxLevels();
  for (int i=0; i < hierarchyHeights.length; i++) {
    if (minLevels[i] > (hierarchyHeights[i] - 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str""+ minLevels[i]+ ""String_Node_Str""+ (hierarchyHeights[i] - 1));
    }
    if (minLevels[i] < 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str"");
    }
    if (maxLevels[i] > (hierarchyHeights[i] - 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str""+ maxLevels[i]+ ""String_Node_Str""+ (hierarchyHeights[i] - 1));
    }
    if (maxLevels[i] < minLevels[i]) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str"");
    }
  }
}","/** 
 * Performs some sanity checks.
 * @param manager the manager
 */
private void checkAfterEncoding(final ARXConfiguration config,final DataManager manager){
  if (config.containsCriterion(KAnonymity.class)) {
    KAnonymity c=config.getCriterion(KAnonymity.class);
    if ((c.getK() > manager.getDataQI().getDataLength()) || (c.getK() < 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + c.getK() + ""String_Node_Str""+ manager.getDataQI().getDataLength()+ ""String_Node_Str"");
    }
  }
  if (config.containsCriterion(LDiversity.class)) {
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if ((c.getL() > manager.getDataQI().getDataLength()) || (c.getL() < 1)) {
        throw new IllegalArgumentException(""String_Node_Str"" + c.getL() + ""String_Node_Str""+ manager.getDataQI().getDataLength()+ ""String_Node_Str"");
      }
    }
  }
  for (  final GeneralizationHierarchy hierarchy : manager.getHierarchies()) {
    hierarchy.checkMonotonicity(manager);
  }
  final int[] hierarchyHeights=manager.getHierachyHeights();
  final int[] minLevels=manager.getMinLevels();
  final int[] maxLevels=manager.getMaxLevels();
  for (int i=0; i < hierarchyHeights.length; i++) {
    if (minLevels[i] > (hierarchyHeights[i] - 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str""+ minLevels[i]+ ""String_Node_Str""+ (hierarchyHeights[i] - 1));
    }
    if (minLevels[i] < 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str"");
    }
    if (maxLevels[i] > (hierarchyHeights[i] - 1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str""+ maxLevels[i]+ ""String_Node_Str""+ (hierarchyHeights[i] - 1));
    }
    if (maxLevels[i] < minLevels[i]) {
      throw new IllegalArgumentException(""String_Node_Str"" + manager.getHierarchies()[i].getName() + ""String_Node_Str"");
    }
  }
}",0.9677575757575756
108518,"/** 
 * Returns the name
 * @return
 */
public String getName(){
  return name;
}","/** 
 * Returns the name
 * @return
 */
public String getName(){
  return attribute;
}",0.9461077844311376
108519,"/** 
 * Creates a new empty generalization hierarchy from the given dictionary
 * @param name
 * @param dimension
 * @param dictionary
 */
public GeneralizationHierarchy(final String name,final int dimension,final Dictionary dictionary){
  this.name=name;
  final int uniqueIn=dictionary.getNumUniqueUnfinalizedValues(dimension);
  map=new int[uniqueIn][1];
  for (int i=0; i < map.length; i++) {
    map[i][0]=i;
  }
  distinctValues=new int[1];
  distinctValues[0]=uniqueIn;
}","/** 
 * Creates a new empty generalization hierarchy from the given dictionary
 * @param name
 * @param dimension
 * @param dictionary
 */
public GeneralizationHierarchy(final String name,final int dimension,final Dictionary dictionary){
  this.attribute=name;
  final int uniqueIn=dictionary.getNumUniqueUnfinalizedValues(dimension);
  map=new int[uniqueIn][1];
  for (int i=0; i < map.length; i++) {
    map[i][0]=i;
  }
  distinctValues=new int[1];
  distinctValues[0]=uniqueIn;
}",0.988553590010406
108520,"@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.equals(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}","@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.startsWith(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}",0.9710743801652892
108521,"/** 
 * Shows an error dialog
 * @param header
 * @param message
 * @param t
 */
public void showErrorDialog(final Shell shell,final String message,final Throwable t){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  t.printStackTrace(pw);
  final String trace=sw.toString();
  final DialogError dialog=new DialogError(shell,controller,message,trace);
  dialog.create();
  dialog.open();
}","/** 
 * Shows an error dialog
 * @param header
 * @param message
 * @param t
 */
public void showErrorDialog(final Shell shell,final String message,final Throwable t){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  if (t != null)   t.printStackTrace(pw);
  final String trace=sw.toString();
  final DialogError dialog=new DialogError(shell,controller,message,trace);
  dialog.create();
  dialog.open();
}",0.9800703399765534
108522,"@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.equals(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}","@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.equals(""String_Node_Str"") || version.equals(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}",0.9284332688588008
108523,"public DataDefinition getInputDefinition(){
  return inputConfig.getInput().getDefinition();
}","public DataDefinition getInputDefinition(){
  Data data=inputConfig.getInput();
  if (data == null)   return null;
  return data.getDefinition();
}",0.7385892116182573
108524,"public double getAttributeWeight(String attribute){
  Double value=this.attributeWeights.get(attribute);
  if (value == null)   return 0d;
 else   return value;
}","public double getAttributeWeight(String attribute){
  if (this.attributeWeights == null) {
    this.attributeWeights=new HashMap<String,Double>();
  }
  Double value=this.attributeWeights.get(attribute);
  if (value == null)   return 0d;
 else   return value;
}",0.7659574468085106
108525,"public void setAttributeWeight(String attribute,Double weight){
  this.attributeWeights.put(attribute,weight);
}","public void setAttributeWeight(String attribute,Double weight){
  if (this.attributeWeights == null) {
    this.attributeWeights=new HashMap<String,Double>();
  }
  this.attributeWeights.put(attribute,weight);
}",0.6934984520123839
108526,"@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.equals(""String_Node_Str"") || version.equals(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}","@Override public void checkVersion(String version) throws SAXException {
  if (!(version.equals(""String_Node_Str"") || version.startsWith(""String_Node_Str""))) {
    throw new SAXException(Resources.getMessage(""String_Node_Str"") + version);
  }
}",0.9021113243761996
108527,"/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      for (int j=i + 3; j < snapshot.length - 1; j+=2) {
        dictionarySensValue.decrementRefCount(snapshot[j]);
        dictionarySensFreq.decrementRefCount(snapshot[j + 1]);
      }
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  for (int j=i + 2; j < snapshot.length - 1; j+=2) {
    dictionarySensValue.decrementRefCount(snapshot[j]);
    dictionarySensFreq.decrementRefCount(snapshot[j + 1]);
  }
}
}
}","/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      for (int j=i + 3; j < i + config.getSnapshotLength() - 1; j+=2) {
        dictionarySensValue.decrementRefCount(snapshot[j]);
        dictionarySensFreq.decrementRefCount(snapshot[j + 1]);
      }
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  for (int j=i + 2; j < i + config.getSnapshotLength() - 1; j+=2) {
    dictionarySensValue.decrementRefCount(snapshot[j]);
    dictionarySensFreq.decrementRefCount(snapshot[j + 1]);
  }
}
}
}",0.9542682926829268
108528,"public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
 else {
      try {
        Class.forName(JDK16_FRAME);
      }
 catch (      Exception e) {
        SWT_AWT.embeddedFrameClass=JDK17_FRAME;
      }
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.addListener(SWT.Show,new Listener(){
      @Override public void handleEvent(      Event arg0){
        hideSplash();
      }
    }
);
    String path=null;
    if (args.length > 0) {
      path=args[0];
    }
    main.show(path);
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
 else {
      try {
        Class.forName(JDK16_FRAME);
      }
 catch (      Exception e) {
        SWT_AWT.embeddedFrameClass=JDK17_FRAME;
      }
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.addListener(SWT.Show,new Listener(){
      @Override public void handleEvent(      Event arg0){
        hideSplash();
      }
    }
);
    String path=null;
    if (args.length > 0 && args[0].endsWith(""String_Node_Str"")) {
      path=args[0];
    }
    main.show(path);
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.9825190497534738
108529,"/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (((DataHandleInput)data.getHandle()).isLocked()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (config.isProtectSensitiveAssociations()) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  DataHandle handle=data.getHandle();
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(handle,config);
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
}","/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (((DataHandleInput)data.getHandle()).isLocked()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (data.getDefinition().getSensitiveAttributes().size() > 1 && config.isProtectSensitiveAssociations()) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  DataHandle handle=data.getHandle();
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(handle,config);
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
}",0.9620733249051832
108530,"/** 
 * Updates the resulting hierarchy and the view
 */
public void update(){
  build();
  if (view != null)   view.update();
}","/** 
 * Updates the resulting hierarchy and the view
 */
public void update(){
  if (visible)   build();
  if (view != null)   view.update();
}",0.9446494464944648
108531,"@Override public void setVisible(boolean value){
  if (value) {
    this.model.update();
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
  }
  super.setVisible(value);
}","@Override public void setVisible(boolean value){
  if (value) {
    this.model.update();
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
  }
  super.setVisible(value);
  model.setVisible(value);
}",0.9411764705882352
108532,"/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon whether or not names have been assigned explicitly either the appropriate values will be returned, or names from the JDBC metadata will be used.
 */
private String[] createHeader(){
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    if (column.getAliasName() != null && !column.getAliasName().equals(""String_Node_Str"")) {
      header[i]=column.getAliasName();
    }
 else {
      try {
        header[i]=resultSet.getMetaData().getColumnName(((ImportColumnJDBC)column).getIndex() + 1);
      }
 catch (      SQLException e) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    column.setAliasName(header[i]);
  }
  return header;
}","/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon whether or not names have been assigned explicitly either the appropriate values will be returned, or names from the JDBC metadata will be used.
 */
private String[] createHeader(){
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    if (column.getAliasName() != null && !column.getAliasName().equals(""String_Node_Str"")) {
      header[i]=column.getAliasName();
    }
 else {
      try {
        header[i]=resultSet.getMetaData().getColumnName(((ImportColumnJDBC)column).getIndex() + 1);
      }
 catch (      SQLException e) {
        throw new IllegalArgumentException(""String_Node_Str"" + ((ImportColumnJDBC)column).getIndex() + ""String_Node_Str"");
      }
    }
    column.setAliasName(header[i]);
  }
  return header;
}",0.9592850049652432
108533,"/** 
 * Sets the indexes based on the header
 * @param row
 */
public void prepare(String[] row){
  for (  ImportColumn c : super.getColumns()) {
    ImportColumnCSV column=(ImportColumnCSV)c;
    if (!column.isIndexSpecified()) {
      for (int i=0; i < row.length; i++) {
        if (row[i].equals(column.getName())) {
          column.setIndex(i);
        }
      }
    }
  }
}","/** 
 * Sets the indexes based on the header
 * @param row
 */
public void prepare(String[] row){
  for (  ImportColumn c : super.getColumns()) {
    ImportColumnCSV column=(ImportColumnCSV)c;
    if (!column.isIndexSpecified()) {
      boolean found=false;
      for (int i=0; i < row.length; i++) {
        if (row[i].equals(column.getName())) {
          found=true;
          column.setIndex(i);
        }
      }
      if (!found) {
        throw new IllegalArgumentException(""String_Node_Str"" + column.getName() + ""String_Node_Str"");
      }
    }
  }
}",0.8093716719914803
108534,"/** 
 * Sets the indexes based on the header
 * @param row
 */
public void prepare(Row row){
  for (  ImportColumn c : super.getColumns()) {
    ImportColumnExcel column=(ImportColumnExcel)c;
    if (!column.isIndexSpecified()) {
      for (int i=0; i < row.getPhysicalNumberOfCells(); i++) {
        row.getCell(i).setCellType(Cell.CELL_TYPE_STRING);
        if (row.getCell(i).getStringCellValue().equals(column.getName())) {
          column.setIndex(i);
        }
      }
    }
  }
}","/** 
 * Sets the indexes based on the header
 * @param row
 */
public void prepare(Row row){
  for (  ImportColumn c : super.getColumns()) {
    ImportColumnExcel column=(ImportColumnExcel)c;
    if (!column.isIndexSpecified()) {
      boolean found=false;
      for (int i=0; i < row.getPhysicalNumberOfCells(); i++) {
        row.getCell(i).setCellType(Cell.CELL_TYPE_STRING);
        if (row.getCell(i).getStringCellValue().equals(column.getName())) {
          found=true;
          column.setIndex(i);
        }
      }
      if (!found) {
        throw new IllegalArgumentException(""String_Node_Str"" + column.getName() + ""String_Node_Str"");
      }
    }
  }
}",0.8447528187337381
108535,"/** 
 * Converts the input String array to data of type T, performs the masking and writes the results into the input array.
 * @param dataStrings The array of strings that contains the input dictionary and isreplaced by the masked output.
 * @param parser The object used to parse the data - usually a {@link org.deidentifier.arx.DataType DataType}.
 */
public void maskStrings(String[] dataStrings,IDataParser<T> parser){
  List<String> stringList=Arrays.asList(dataStrings);
  Vector<T> dataVector=new Vector<T>();
  for (  String item : stringList)   dataVector.add(parser.fromString(item));
  maskList(dataVector);
  for (int i=0; i < dataVector.size(); ++i)   dataStrings[i]=parser.toString(dataVector.elementAt(i));
}","/** 
 * Converts the input String array to data of type T, performs the masking and writes the results into the input array.
 * @param dataStrings The array of strings that contains the input dictionary and isreplaced by the masked output.
 * @param type The object used to parse the data - usually a {@link org.deidentifier.arx.DataType DataType}.
 */
public void maskStrings(String[] dataStrings,DataType<T> type){
  List<String> stringList=Arrays.asList(dataStrings);
  Vector<T> dataVector=new Vector<T>();
  for (  String item : stringList)   dataVector.add(type.parse(item));
  maskList(dataVector);
  for (int i=0; i < dataVector.size(); ++i)   dataStrings[i]=type.format(dataVector.elementAt(i));
}",0.9412587412587412
108536,"/** 
 * Interprets the input string as a data instance of type T, performs data masking on it and returns the masked data, converted back to a string.
 * @param input The string representing a data instance.
 * @param parser The parser used to interpret the string as data - usually a {@link org.deidentifier.arx.DataType DataType}.
 * @return The string representing the masked data.
 */
public String maskString(String input,IDataParser<T> parser){
  return parser.toString(mask(parser.fromString(input)));
}","/** 
 * Interprets the input string as a data instance of type T, performs data masking on it and returns the masked data, converted back to a string.
 * @param input The string representing a data instance.
 * @param type The parser used to interpret the string as data - usually a {@link org.deidentifier.arx.DataType DataType}.
 * @return The string representing the masked data.
 */
public String maskString(String input,DataType<T> type){
  return type.format(mask(type.parse(input)));
}",0.9161676646706588
108537,"/** 
 * Interprets the input string as a data instance of type T, performs data masking on it and returns the masked data, converted back to a string.
 * @param input The string representing a data instance.
 * @param parser The parser used to interpret the string as data - usually a {@link org.deidentifier.arx.DataType DataType}.
 * @return The string representing the masked data.
 */
public String maskString(String input,IDataParser<T> parser){
  return parser.toString(mask(parser.fromString(input)));
}","/** 
 * Interprets the input string as a data instance of type T, performs data masking on it and returns the masked data, converted back to a string.
 * @param input The string representing a data instance.
 * @param type The parser used to interpret the string as data - usually a {@link org.deidentifier.arx.DataType DataType}.
 * @return The string representing the masked data.
 */
public String maskString(String input,DataType<T> type){
  return type.format(mask(type.parse(input)));
}",0.9161676646706588
108538,"@Override public void process(Lattice lattice,Node node){
  Node other=map.get(new IntArrayWrapper(node.getTransformation()));
  if (other.isAnonymous()) {
    node.setAnonymous(false);
    node.setNotTagged();
    node.setNotChecked();
  }
 else {
    node.setAnonymous(false);
    node.setTagged();
    node.setChecked();
    lattice.triggerTagged();
    lattice.decUntaggedCount(node.getLevel());
  }
}","@Override public void process(Lattice lattice,Node node){
  Node other=map.get(new IntArrayWrapper(node.getTransformation()));
  if (other.isAnonymous()) {
    node.setAnonymous(false);
    node.setNotTagged();
    node.setNotChecked();
  }
 else {
    node.setAnonymous(false);
    node.setTagged();
    node.setChecked();
    lattice.triggerTagged();
    lattice.decUntaggedCount(node.getLevel());
  }
  node.setInformationLoss(other.getInformationLoss());
}",0.9364161849710982
108539,"/** 
 * Creates the manipulator for the final lattice in the iterative process
 * @param lattice
 * @param config
 * @param header
 * @param definition
 * @return
 */
private LatticeManipulator createFinalManipulator(Lattice lattice,ARXConfiguration config,String[] header,DataDefinition previous,DataDefinition definition){
  final Map<IntArrayWrapper,Node> map=new HashMap<IntArrayWrapper,Node>();
  final Set<String> previousQI=previous.getQuasiIdentifyingAttributes();
  final Set<String> currentQI=definition.getQuasiIdentifyingAttributes();
  for (  Node[] level : lattice.getLevels()) {
    for (    Node node : level) {
      int[] key=new int[currentQI.size()];
      int previousIdx=-1;
      int currentIdx=-1;
      for (int i=0; i < header.length; i++) {
        if (previousQI.contains(header[i])) {
          previousIdx++;
        }
        if (currentQI.contains(header[i])) {
          currentIdx++;
          key[currentIdx]=node.getTransformation()[previousIdx];
        }
      }
      map.put(new IntArrayWrapper(key),node);
    }
  }
  return new LatticeManipulator(){
    @Override public void process(    Lattice lattice,    Node node){
      Node other=map.get(new IntArrayWrapper(node.getTransformation()));
      if (other.isAnonymous()) {
        node.setAnonymous(false);
        node.setNotTagged();
        node.setNotChecked();
      }
 else {
        node.setAnonymous(false);
        node.setTagged();
        node.setChecked();
        lattice.triggerTagged();
        lattice.decUntaggedCount(node.getLevel());
      }
    }
  }
;
}","/** 
 * Creates the manipulator for the final lattice in the iterative process
 * @param lattice
 * @param config
 * @param header
 * @param definition
 * @return
 */
private LatticeManipulator createFinalManipulator(Lattice lattice,ARXConfiguration config,String[] header,DataDefinition previous,DataDefinition definition){
  final Map<IntArrayWrapper,Node> map=new HashMap<IntArrayWrapper,Node>();
  final Set<String> previousQI=previous.getQuasiIdentifyingAttributes();
  final Set<String> currentQI=definition.getQuasiIdentifyingAttributes();
  for (  Node[] level : lattice.getLevels()) {
    for (    Node node : level) {
      int[] key=new int[currentQI.size()];
      int previousIdx=-1;
      int currentIdx=-1;
      for (int i=0; i < header.length; i++) {
        if (previousQI.contains(header[i])) {
          previousIdx++;
        }
        if (currentQI.contains(header[i])) {
          currentIdx++;
          key[currentIdx]=node.getTransformation()[previousIdx];
        }
      }
      map.put(new IntArrayWrapper(key),node);
    }
  }
  return new LatticeManipulator(){
    @Override public void process(    Lattice lattice,    Node node){
      Node other=map.get(new IntArrayWrapper(node.getTransformation()));
      if (other.isAnonymous()) {
        node.setAnonymous(false);
        node.setNotTagged();
        node.setNotChecked();
      }
 else {
        node.setAnonymous(false);
        node.setTagged();
        node.setChecked();
        lattice.triggerTagged();
        lattice.decUntaggedCount(node.getLevel());
      }
      node.setInformationLoss(other.getInformationLoss());
    }
  }
;
}",0.9815451986237096
108540,"@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            findPath(head);
            head=checkPathBinary(path);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    checker.check(lattice.getTop(),true);
  }
}","@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  if (!lattice.getBottom().isChecked())   checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            findPath(head);
            head=checkPathBinary(path);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    if (!lattice.getTop().isChecked())     checker.check(lattice.getTop(),true);
  }
}",0.9380917698470502
108541,"@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            final PruningStrategy pruning=history.getPruningStrategy();
            history.setPruningStrategy(PruningStrategy.CHECKED);
            stack.push(head);
            while (!stack.isEmpty()) {
              final Node start=stack.pop();
              if (!start.isTagged()) {
                findPath(start);
                checkPathLinear(path);
              }
            }
            history.setPruningStrategy(pruning);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    checker.check(lattice.getTop(),true);
  }
}","@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  if (!lattice.getBottom().isChecked())   checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            final PruningStrategy pruning=history.getPruningStrategy();
            history.setPruningStrategy(PruningStrategy.CHECKED);
            stack.push(head);
            while (!stack.isEmpty()) {
              final Node start=stack.pop();
              if (!start.isTagged()) {
                findPath(start);
                checkPathLinear(path);
              }
            }
            history.setPruningStrategy(pruning);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    if (!lattice.getTop().isChecked())     checker.check(lattice.getTop(),true);
  }
}",0.9598488427019368
108542,"@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            final PruningStrategy pruning=history.getPruningStrategy();
            history.setPruningStrategy(PruningStrategy.CHECKED);
            stack.push(head);
            while (!stack.isEmpty()) {
              final Node start=stack.pop();
              if (!start.isTagged()) {
                findPath(start);
                checkPathLinear(path);
              }
            }
            history.setPruningStrategy(pruning);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    checker.check(lattice.getTop(),true);
  }
}","@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  if (!lattice.getBottom().isChecked())   checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            final PruningStrategy pruning=history.getPruningStrategy();
            history.setPruningStrategy(PruningStrategy.CHECKED);
            stack.push(head);
            while (!stack.isEmpty()) {
              final Node start=stack.pop();
              if (!start.isTagged()) {
                findPath(start);
                checkPathLinear(path);
              }
            }
            history.setPruningStrategy(pruning);
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    if (!lattice.getTop().isChecked())     checker.check(lattice.getTop(),true);
  }
}",0.9598488427019368
108543,"@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            findPath(head);
            head=checkPathBinary(path);
            if (head != null) {
              final PruningStrategy pruning=history.getPruningStrategy();
              history.setPruningStrategy(PruningStrategy.CHECKED);
              lattice.doUnTagUpwards(head);
              stack.push(head);
              while (!stack.isEmpty()) {
                final Node start=stack.pop();
                if (!start.isTagged()) {
                  findPath(start);
                  checkPathLinear(path);
                }
              }
              history.setPruningStrategy(pruning);
            }
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    checker.check(lattice.getTop(),true);
  }
}","@Override public void traverse(){
  pqueue.clear();
  stack.clear();
  if (!lattice.getBottom().isChecked())   checker.check(lattice.getBottom(),true);
  final int length=lattice.getLevels().length;
  for (int i=0; i < length; i++) {
    Node[] level;
    level=this.sort(i);
    for (    final Node node : level) {
      if (!node.isTagged()) {
        pqueue.add(node);
        while (!pqueue.isEmpty()) {
          Node head=pqueue.poll();
          if (!head.isTagged()) {
            findPath(head);
            head=checkPathBinary(path);
            if (head != null) {
              final PruningStrategy pruning=history.getPruningStrategy();
              history.setPruningStrategy(PruningStrategy.CHECKED);
              lattice.doUnTagUpwards(head);
              stack.push(head);
              while (!stack.isEmpty()) {
                final Node start=stack.pop();
                if (!start.isTagged()) {
                  findPath(start);
                  checkPathLinear(path);
                }
              }
              history.setPruningStrategy(pruning);
            }
          }
        }
      }
    }
  }
  if (lattice.getTop().getInformationLoss() == null) {
    if (!lattice.getTop().isChecked())     checker.check(lattice.getTop(),true);
  }
}",0.9656842955187728
108544,"@Override public void update(){
  this.canvascomposite.redraw();
}","@Override public void update(){
  this.canvascomposite.redraw();
  this.editor.update();
}",0.8461538461538461
108545,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
    SWTUtil.enable(this.editorFunction.getControl1());
    SWTUtil.enable(this.editorFunction.getControl2());
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
    this.editorFunction.update();
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}",0.6869565217391305
108546,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
    SWTUtil.enable(this.editorFunction.getControl1());
    SWTUtil.enable(this.editorFunction.getControl2());
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
    this.editorFunction.update();
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}",0.7885375494071146
108547,"/** 
 * Gets executed once the wizard is about to finish This will build an appropriate   {@link ImportConfiguration} object, dependingupon the  {@link ImportWizardModel#getSourceType() source type} and thechoices the user made during the process of the wizard. {@link #configuration} will hold a reference of the object. This can beretrieved later on by  {@link #getResultingConfiguration()}.
 * @see {@link #getResultingConfiguration()}
 */
@Override public boolean performFinish(){
  if (data.getSourceType() == SourceType.CSV) {
    configuration=new ImportConfigurationCSV(data.getFileLocation(),data.getCsvSeparator(),data.getFirstRowContainsHeader());
  }
 else   if (data.getSourceType() == SourceType.EXCEL) {
    configuration=new ImportConfigurationExcel(data.getFileLocation(),data.getExcelSheetIndex(),data.getFirstRowContainsHeader());
  }
 else   if (data.getSourceType() == SourceType.JDBC) {
    configuration=new ImportConfigurationJDBC(data.getJdbcConnection(),data.getSelectedJdbcTable());
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  for (  ImportColumn c : data.getEnabledColumns()) {
    configuration.addColumn(c);
  }
  return true;
}","/** 
 * Gets executed once the wizard is about to finish This will build an appropriate   {@link ImportConfiguration} object, dependingupon the  {@link ImportWizardModel#getSourceType() source type} and thechoices the user made during the process of the wizard. {@link #configuration} will hold a reference of the object. This can beretrieved later on by  {@link #getResultingConfiguration()}.
 * @see {@link #getResultingConfiguration()}
 */
@Override public boolean performFinish(){
  if (data.getSourceType() == SourceType.CSV) {
    configuration=new ImportConfigurationCSV(data.getFileLocation(),data.getCsvSeparator(),data.getFirstRowContainsHeader());
  }
 else   if (data.getSourceType() == SourceType.EXCEL) {
    configuration=new ImportConfigurationExcel(data.getFileLocation(),data.getExcelSheetIndex(),data.getFirstRowContainsHeader());
  }
 else   if (data.getSourceType() == SourceType.JDBC) {
    configuration=new ImportConfigurationJDBC(data.getJdbcConnection(),data.getSelectedJdbcTable());
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  for (  ImportColumn c : data.getEnabledColumns()) {
    configuration.addColumn(c);
  }
  if (data.getSourceType() != SourceType.JDBC) {
    try {
      if (data.getJdbcConnection() != null && !data.getJdbcConnection().isClosed()) {
        data.getJdbcConnection().close();
      }
    }
 catch (    Exception e) {
    }
  }
  return true;
}",0.9001536098310292
108548,"/** 
 * Reads in the available sheets from file This reads in the available sheets from the file chosen at  {@link #comboLocation} and adds them as items to {@link #comboSheet}.
 */
private void readSheets() throws IOException {
  comboSheet.removeAll();
  try {
    workbook=WorkbookFactory.create(new FileInputStream(comboLocation.getText()));
  }
 catch (  InvalidFormatException e) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < workbook.getNumberOfSheets(); i++) {
    comboSheet.add(workbook.getSheetName(i));
  }
}","/** 
 * Reads in the available sheets from file This reads in the available sheets from the file chosen at  {@link #comboLocation} and adds them as items to {@link #comboSheet}.
 */
private void readSheets() throws IOException {
  comboSheet.removeAll();
  try {
    try {
      if (stream != null)       stream.close();
    }
 catch (    Exception e) {
    }
    stream=new FileInputStream(comboLocation.getText());
    workbook=WorkbookFactory.create(stream);
  }
 catch (  InvalidFormatException e) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < workbook.getNumberOfSheets(); i++) {
    comboSheet.add(workbook.getSheetName(i));
  }
}",0.8311258278145696
108549,"/** 
 * Connects to the database This tries to establish an JDBC connection. In case of an error appropriate error messages are set. Otherwise the connection is passed on to   {@link ImportWizardModel}. The return value indicates whether a connection has been established.
 * @return True if successfully connected, false otherwise
 * @see {@link ImportWizardModel#setJdbcConnection(Connection)}
 */
protected boolean connect(){
  try {
    Connection connection=null;
    if (comboType.getText().equals(SQLITE)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + comboLocation.getText());
    }
 else     if (comboType.getText().equals(MYSQL)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + txtServer.getText() + ""String_Node_Str""+ txtPort.getText()+ ""String_Node_Str""+ txtDatabase.getText(),txtUsername.getText(),txtPassword.getText());
    }
 else     if (comboType.getText().equals(POSTGRESQL)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + txtServer.getText() + ""String_Node_Str""+ txtPort.getText()+ ""String_Node_Str""+ txtDatabase.getText(),txtUsername.getText(),txtPassword.getText());
    }
    wizardImport.getData().setJdbcConnection(connection);
    return true;
  }
 catch (  ClassNotFoundException e) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
catch (  SQLException e) {
    setErrorMessage(e.getLocalizedMessage());
    return false;
  }
}","/** 
 * Connects to the database This tries to establish an JDBC connection. In case of an error appropriate error messages are set. Otherwise the connection is passed on to   {@link ImportWizardModel}. The return value indicates whether a connection has been established.
 * @return True if successfully connected, false otherwise
 * @see {@link ImportWizardModel#setJdbcConnection(Connection)}
 */
protected boolean connect(){
  try {
    Connection connection=null;
    if (comboType.getText().equals(SQLITE)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + comboLocation.getText());
    }
 else     if (comboType.getText().equals(MYSQL)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + txtServer.getText() + ""String_Node_Str""+ txtPort.getText()+ ""String_Node_Str""+ txtDatabase.getText(),txtUsername.getText(),txtPassword.getText());
    }
 else     if (comboType.getText().equals(POSTGRESQL)) {
      Class.forName(""String_Node_Str"");
      connection=DriverManager.getConnection(""String_Node_Str"" + txtServer.getText() + ""String_Node_Str""+ txtPort.getText()+ ""String_Node_Str""+ txtDatabase.getText(),txtUsername.getText(),txtPassword.getText());
    }
    try {
      if (!wizardImport.getData().getJdbcConnection().isClosed()) {
        wizardImport.getData().getJdbcConnection().close();
      }
    }
 catch (    Exception e) {
    }
    wizardImport.getData().setJdbcConnection(connection);
    return true;
  }
 catch (  ClassNotFoundException e) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
catch (  SQLException e) {
    setErrorMessage(e.getLocalizedMessage());
    return false;
  }
}",0.943683409436834
108550,"/** 
 * Returns the created builder
 * @return
 */
public HierarchyWizardResult<T> getResult(){
  try {
    return new HierarchyWizardResult<T>(model.getHierarchy(),model.getBuilder());
  }
 catch (  Exception e) {
    return null;
  }
}","/** 
 * Returns the created builder
 * @return
 */
public HierarchyWizardResult<T> getResult(){
  try {
    return new HierarchyWizardResult<T>(model.getHierarchy(),model.getBuilder(true));
  }
 catch (  Exception e) {
    return null;
  }
}",0.99163179916318
108551,"/** 
 * Saves the current specification
 */
private void save(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  String file=controller.actionShowSaveFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  try {
    HierarchyBuilder<T> builder=null;
    if (getDialog().getCurrentPage() instanceof HierarchyWizardPageOrder) {
      builder=model.getOrderModel().getBuilder();
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageIntervals) {
      builder=model.getIntervalModel().getBuilder();
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageRedaction) {
      builder=model.getRedactionModel().getBuilder();
    }
    builder.save(file);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
}","/** 
 * Saves the current specification
 */
private void save(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  String file=controller.actionShowSaveFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  try {
    HierarchyBuilder<T> builder=null;
    if (getDialog().getCurrentPage() instanceof HierarchyWizardPageOrder) {
      builder=model.getOrderModel().getBuilder(true);
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageIntervals) {
      builder=model.getIntervalModel().getBuilder(true);
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageRedaction) {
      builder=model.getRedactionModel().getBuilder(true);
    }
    builder.save(file);
  }
 catch (  Exception e) {
    e.printStackTrace();
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
}",0.979792463134899
108552,"/** 
 * Returns the current builder
 * @return
 */
public HierarchyBuilder<T> getBuilder() throws Exception {
  if (type == Type.INTERVAL_BASED) {
    return intervalModel.getBuilder();
  }
 else   if (type == Type.REDACTION_BASED) {
    return redactionModel.getBuilder();
  }
 else   if (type == Type.ORDER_BASED) {
    return orderModel.getBuilder();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Returns the current builder
 * @return
 */
public HierarchyBuilder<T> getBuilder(boolean serializable) throws Exception {
  if (type == Type.INTERVAL_BASED) {
    return intervalModel.getBuilder(serializable);
  }
 else   if (type == Type.REDACTION_BASED) {
    return redactionModel.getBuilder(serializable);
  }
 else   if (type == Type.ORDER_BASED) {
    return orderModel.getBuilder(serializable);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9388646288209608
108553,"/** 
 * Returns the builder currently configured
 * @return
 */
public abstract HierarchyBuilder<T> getBuilder() throws Exception ;","/** 
 * Returns the builder currently configured
 * @return
 */
public abstract HierarchyBuilder<T> getBuilder(boolean serializable) throws Exception ;",0.9290780141843972
108554,"@Override public HierarchyBuilderIntervalBased<T> getBuilder() throws Exception {
  HierarchyBuilderIntervalBased<T> builder=HierarchyBuilderIntervalBased.create(super.getDataType(),new Range<T>(super.getLowerRange().repeat,super.getLowerRange().snap,super.getLowerRange().label),new Range<T>(super.getUpperRange().repeat,super.getUpperRange().snap,super.getUpperRange().label));
  builder.setAggregateFunction(this.getDefaultFunction());
  for (  HierarchyWizardGroupingInterval<T> interval : super.getIntervals()) {
    builder.addInterval(interval.min,interval.max,interval.function);
  }
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}","@Override public HierarchyBuilderIntervalBased<T> getBuilder(boolean serializable) throws Exception {
  HierarchyBuilderIntervalBased<T> builder=HierarchyBuilderIntervalBased.create(super.getDataType(),new Range<T>(super.getLowerRange().repeat,super.getLowerRange().snap,super.getLowerRange().label),new Range<T>(super.getUpperRange().repeat,super.getUpperRange().snap,super.getUpperRange().label));
  builder.setAggregateFunction(this.getDefaultFunction());
  for (  HierarchyWizardGroupingInterval<T> interval : super.getIntervals()) {
    builder.addInterval(interval.min,interval.max,interval.function);
  }
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}",0.9884659746251442
108555,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderIntervalBased<T> builder=null;
  try {
    builder=getBuilder();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderIntervalBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.9959250203748982
108556,"@Override public HierarchyBuilderOrderBased<T> getBuilder() throws Exception {
  HierarchyBuilderOrderBased<T> builder=HierarchyBuilderOrderBased.create(super.getDataType(),false);
  builder.setAggregateFunction(this.getDefaultFunction());
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}","@Override public HierarchyBuilderOrderBased<T> getBuilder(boolean serializable) throws Exception {
  HierarchyBuilderOrderBased<T> builder;
  if (serializable) {
    builder=HierarchyBuilderOrderBased.create(super.getDataType(),data);
  }
 else {
    builder=HierarchyBuilderOrderBased.create(super.getDataType(),false);
  }
  builder.setAggregateFunction(this.getDefaultFunction());
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}",0.8752166377816292
108557,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderOrderBased<T> builder=null;
  try {
    builder=getBuilder();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderOrderBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.995904995904996
108558,"@Override public HierarchyBuilderRedactionBased<T> getBuilder(){
  return HierarchyBuilderRedactionBased.create(alignmentOrder,redactionOrder,paddingCharacter,redactionCharacter);
}","@Override public HierarchyBuilderRedactionBased<T> getBuilder(boolean serializable){
  return HierarchyBuilderRedactionBased.create(alignmentOrder,redactionOrder,paddingCharacter,redactionCharacter);
}",0.9476439790575916
108559,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderRedactionBased<T> builder=getBuilder();
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderRedactionBased<T> builder=getBuilder(false);
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
}",0.9940688018979834
108560,"@SuppressWarnings(""String_Node_Str"") @Override protected AbstractGroup[][] prepareGroups(){
  if (comparator != null) {
    Arrays.sort(super.getData(),comparator);
  }
  List<Group<T>> groups=super.getLevel(0).getGroups();
  List<String> items=new ArrayList<String>();
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  int index=0;
  int resultIndex=0;
  int groupCount=0;
  if (!super.getLevels().isEmpty() && !super.getLevel(0).getGroups().isEmpty()) {
    AbstractGroup[] first=new AbstractGroup[data.length];
    outer:     while (true) {
      for (      Group<T> group : groups) {
        for (int i=0; i < group.getSize(); i++) {
          items.add(data[index++]);
          if (index == data.length)           break;
        }
        CloseElements<T> element=new CloseElements<T>(items.toArray(new String[items.size()]),group.getFunction());
        for (int i=0; i < items.size(); i++) {
          first[resultIndex++]=element;
        }
        groupCount++;
        items.clear();
        if (index == data.length)         break outer;
      }
    }
    result.add(first);
    if (groupCount > 1) {
      for (int i=1; i < super.getLevels().size(); i++) {
        if (groupCount == 1)         break;
        groupCount=0;
        groups=super.getLevel(i).getGroups();
        Map<AbstractGroup,AbstractGroup> map=new HashMap<AbstractGroup,AbstractGroup>();
        List<AbstractGroup> list=new ArrayList<AbstractGroup>();
        AbstractGroup[] column=result.get(i - 1);
        for (int j=0; j < column.length; j++) {
          if (!map.containsKey(column[j])) {
            map.put(column[j],column[j]);
            list.add(column[j]);
          }
        }
        index=0;
        resultIndex=0;
        List<CloseElements<T>> gItems=new ArrayList<CloseElements<T>>();
        outer:         while (true) {
          for (          Group<T> group : groups) {
            for (int j=0; j < group.getSize(); j++) {
              gItems.add((CloseElements<T>)list.get(index++));
              if (index == list.size())               break;
            }
            CloseElements<T> element=gItems.get(0).merge(gItems,group.getFunction());
            groupCount++;
            for (int j=0; j < gItems.size(); j++) {
              map.put(gItems.get(j),element);
            }
            gItems.clear();
            if (index == list.size())             break outer;
          }
        }
        AbstractGroup[] ccolumn=new AbstractGroup[data.length];
        for (int j=0; j < column.length; j++) {
          ccolumn[j]=map.get(column[j]);
        }
        result.add(ccolumn);
      }
    }
  }
 else {
    groupCount=data.length;
  }
  if (groupCount > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    CloseElements<T> element=new CloseElements<T>(new String[]{},AggregateFunction.forType(getDataType()).createConstantFunction(""String_Node_Str""));
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@SuppressWarnings(""String_Node_Str"") @Override protected AbstractGroup[][] prepareGroups(){
  if (comparator != null) {
    try {
      Arrays.sort(super.getData(),comparator);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(e.getMessage());
    }
  }
  List<Group<T>> groups=super.getLevel(0).getGroups();
  List<String> items=new ArrayList<String>();
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  int index=0;
  int resultIndex=0;
  int groupCount=0;
  if (!super.getLevels().isEmpty() && !super.getLevel(0).getGroups().isEmpty()) {
    AbstractGroup[] first=new AbstractGroup[data.length];
    outer:     while (true) {
      for (      Group<T> group : groups) {
        for (int i=0; i < group.getSize(); i++) {
          items.add(data[index++]);
          if (index == data.length)           break;
        }
        CloseElements<T> element=new CloseElements<T>(items.toArray(new String[items.size()]),group.getFunction());
        for (int i=0; i < items.size(); i++) {
          first[resultIndex++]=element;
        }
        groupCount++;
        items.clear();
        if (index == data.length)         break outer;
      }
    }
    result.add(first);
    if (groupCount > 1) {
      for (int i=1; i < super.getLevels().size(); i++) {
        if (groupCount == 1)         break;
        groupCount=0;
        groups=super.getLevel(i).getGroups();
        Map<AbstractGroup,AbstractGroup> map=new HashMap<AbstractGroup,AbstractGroup>();
        List<AbstractGroup> list=new ArrayList<AbstractGroup>();
        AbstractGroup[] column=result.get(i - 1);
        for (int j=0; j < column.length; j++) {
          if (!map.containsKey(column[j])) {
            map.put(column[j],column[j]);
            list.add(column[j]);
          }
        }
        index=0;
        resultIndex=0;
        List<CloseElements<T>> gItems=new ArrayList<CloseElements<T>>();
        outer:         while (true) {
          for (          Group<T> group : groups) {
            for (int j=0; j < group.getSize(); j++) {
              gItems.add((CloseElements<T>)list.get(index++));
              if (index == list.size())               break;
            }
            CloseElements<T> element=gItems.get(0).merge(gItems,group.getFunction());
            groupCount++;
            for (int j=0; j < gItems.size(); j++) {
              map.put(gItems.get(j),element);
            }
            gItems.clear();
            if (index == list.size())             break outer;
          }
        }
        AbstractGroup[] ccolumn=new AbstractGroup[data.length];
        for (int j=0; j < column.length; j++) {
          ccolumn[j]=map.get(column[j]);
        }
        result.add(ccolumn);
      }
    }
  }
 else {
    groupCount=data.length;
  }
  if (groupCount > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    CloseElements<T> element=new CloseElements<T>(new String[]{},AggregateFunction.forType(getDataType()).createConstantFunction(""String_Node_Str""));
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.982662637187848
108561,"/** 
 * Creates a new instance
 * @param type The data type
 * @param comparator Use this comparator for ordering data items
 */
private HierarchyBuilderOrderBased(final DataType<T> type,final Comparator<T> comparator){
  super(Type.ORDER_BASED,type);
  this.comparator=new Comparator<String>(){
    @Override public int compare(    String o1,    String o2){
      try {
        return comparator.compare(type.parse(o1),type.parse(o2));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param type The data type
 * @param comparator Use this comparator for ordering data items
 */
private HierarchyBuilderOrderBased(final DataType<T> type,final Comparator<T> comparator){
  super(Type.ORDER_BASED,type);
  if (!(comparator instanceof Serializable)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.comparator=new SerializableComparator<String>(){
    private static final long serialVersionUID=-487411642974218418L;
    @Override public int compare(    String o1,    String o2){
      try {
        return comparator.compare(type.parse(o1),type.parse(o2));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
;
}",0.8501960784313726
108562,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  if (row.getPhysicalNumberOfCells() > numberOfColumns) {
    throw new IllegalArgumentException(""String_Node_Str"" + currentRow + ""String_Node_Str"");
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  if (row.getPhysicalNumberOfCells() > numberOfColumns) {
    throw new IllegalArgumentException(""String_Node_Str"" + currentRow + ""String_Node_Str"");
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
    try {
      input.close();
    }
 catch (    Exception e) {
    }
  }
  return result;
}",0.9550660792951542
108563,"/** 
 * Creates a new instance of this object with given configuration Depending upon the file type it either uses HSSF or XSSF to access the file. In both cases   {@link #iterator} will be assigned a reference toan iterator, which can then be used to access the actual data on a row by row basis.
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterExcel(ImportConfigurationExcel config) throws IOException {
  super(config);
  this.config=config;
  FileInputStream input=new FileInputStream(config.getFileLocation());
  Workbook workbook=null;
  if (config.getExcelFileType() == ExcelFileTypes.XLS) {
    workbook=new HSSFWorkbook(input);
  }
 else   if (config.getExcelFileType() == ExcelFileTypes.XLSX) {
    workbook=new XSSFWorkbook(input);
  }
 else {
    input.close();
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);
  Sheet sheet=workbook.getSheetAt(config.getSheetIndex());
  iterator=sheet.iterator();
  totalRows=sheet.getPhysicalNumberOfRows();
  if (iterator.hasNext()) {
    row=iterator.next();
    if (config.getContainsHeader()) {
      if (!iterator.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  header=createHeader();
}","/** 
 * Creates a new instance of this object with given configuration Depending upon the file type it either uses HSSF or XSSF to access the file. In both cases   {@link #iterator} will be assigned a reference toan iterator, which can then be used to access the actual data on a row by row basis.
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterExcel(ImportConfigurationExcel config) throws IOException {
  super(config);
  this.config=config;
  input=new FileInputStream(config.getFileLocation());
  Workbook workbook=null;
  if (config.getExcelFileType() == ExcelFileTypes.XLS) {
    workbook=new HSSFWorkbook(input);
  }
 else   if (config.getExcelFileType() == ExcelFileTypes.XLSX) {
    workbook=new XSSFWorkbook(input);
  }
 else {
    input.close();
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);
  Sheet sheet=workbook.getSheetAt(config.getSheetIndex());
  iterator=sheet.iterator();
  totalRows=sheet.getPhysicalNumberOfRows();
  if (iterator.hasNext()) {
    row=iterator.next();
    if (config.getContainsHeader()) {
      if (!iterator.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  header=createHeader();
}",0.9941733430444284
108564,"@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    hasNext=resultSet.next();
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    hasNext=resultSet.next();
    if (!hasNext) {
      try {
        if (!config.getConnection().isClosed()) {
          config.getConnection().close();
        }
      }
 catch (      Exception e) {
      }
    }
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.8482362592288761
108565,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) > 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) > 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,lowerSnap.max) < 0) {
        interval=lowerSnap;
      }
 else       if (type.compare(interval.max,upperSnap.min) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9941566645609602
108566,"/** 
 * Creates a new instance. Data points that are out of range are handled according to the given settings.
 * @param type
 * @param lowerRange
 * @param upperRange
 */
private HierarchyBuilderIntervalBased(DataType<T> type,Range<T> lowerRange,Range<T> upperRange){
  super(Type.INTERVAL_BASED,type);
  if (!(type instanceof DataTypeWithRatioScale)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.lowerRange=lowerRange;
  this.upperRange=upperRange;
}","/** 
 * Creates a new instance. Data points that are out of range are handled according to the given settings.
 * @param type
 * @param lowerRange
 * @param upperRange
 */
private HierarchyBuilderIntervalBased(DataType<T> type,Range<T> lowerRange,Range<T> upperRange){
  super(Type.INTERVAL_BASED,type);
  if (!(type instanceof DataTypeWithRatioScale)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.lowerRange=lowerRange;
  this.upperRange=upperRange;
  this.function=AggregateFunction.forType(type).createIntervalFunction();
}",0.9282945736434108
108567,"/** 
 * Creates a new instance
 * @param type The data type
 * @param comparator Use this comparator for ordering data items
 */
private HierarchyBuilderOrderBased(final DataType<T> type,final Comparator<T> comparator){
  super(Type.ORDER_BASED,type);
  if (!(comparator instanceof Serializable)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.comparator=new SerializableComparator<String>(){
    private static final long serialVersionUID=-487411642974218418L;
    @Override public int compare(    String o1,    String o2){
      try {
        return comparator.compare(type.parse(o1),type.parse(o2));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param type The data type
 * @param comparator Use this comparator for ordering data items
 */
private HierarchyBuilderOrderBased(final DataType<T> type,final Comparator<T> comparator){
  super(Type.ORDER_BASED,type);
  if (!(comparator instanceof Serializable)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.comparator=new SerializableComparator<String>(){
    private static final long serialVersionUID=-487411642974218418L;
    @Override public int compare(    String o1,    String o2){
      try {
        return comparator.compare(type.parse(o1),type.parse(o2));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
;
  this.function=AggregateFunction.forType(type).createSetFunction();
}",0.9550488599348534
108568,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getInterval(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9971863621317444
108569,"/** 
 * Creates a new instance
 * @param repeatBound
 * @param snapBound
 * @param labelBound
 */
public Range(U repeatBound,U snapBound,U labelBound){
  this.repeatBound=repeatBound;
  this.snapBound=snapBound;
  this.labelBound=labelBound;
}","/** 
 * Creates a new instance
 * @param repeatBound
 * @param snapBound
 * @param labelBound
 */
public Range(U repeatBound,U snapBound,U labelBound){
  if (!(repeatBound == null && snapBound == null && labelBound == null)) {
    if (repeatBound == null || snapBound == null || labelBound == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.repeatBound=repeatBound;
  this.snapBound=snapBound;
  this.labelBound=labelBound;
}",0.6883852691218131
108570,"@Override public String toString(){
  DataType<T> type=(DataType<T>)builder.getDataType();
  return ""String_Node_Str"" + type.format(min) + ""String_Node_Str""+ type.format(max)+ ""String_Node_Str""+ function.toString()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + repeatBound + ""String_Node_Str""+ snapBound+ ""String_Node_Str""+ labelBound+ ""String_Node_Str"";
}",0.702020202020202
108571,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) > 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,lowerSnap.max) < 0) {
        interval=lowerSnap;
      }
 else       if (type.compare(interval.max,upperSnap.min) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) > 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  System.out.println(""String_Node_Str"" + lowerSnap);
  System.out.println(""String_Node_Str"" + upperSnap);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,lowerSnap.max) < 0) {
        interval=lowerSnap;
      }
 else       if (type.compare(interval.max,upperSnap.min) > 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.991613762834078
108572,"/** 
 * Creates a new instance
 * @param controller
 * @param attribute
 * @param builder
 * @param datatype
 * @param items
 */
public HierarchyWizard(final Controller controller,final String attribute,HierarchyBuilder<?> builder,final DataType<T> datatype,final String[] items){
  super(new Point(800,400));
  this.model=new HierarchyWizardModel<T>(datatype,items,builder);
  this.controller=controller;
  this.setWindowTitle(Resources.getMessage(""String_Node_Str""));
  this.setDefaultPageImageDescriptor(ImageDescriptor.createFromImage(controller.getResources().getImage(""String_Node_Str"")));
  this.buttonLoad=new ARXWizardButton(""String_Node_Str"",new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      load();
    }
  }
);
  this.buttonSave=new ARXWizardButton(""String_Node_Str"",new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      save();
    }
  }
);
  this.setButtons(this.buttonLoad,this.buttonSave);
  pageFinal=new HierarchyWizardPageFinal<T>(this);
  if (model.getIntervalModel() != null) {
    pageIntervals=new HierarchyWizardPageIntervals<T>(this,model,pageFinal);
  }
 else {
    pageIntervals=null;
  }
  pageOrder=new HierarchyWizardPageOrder<T>(controller,this,model,pageFinal);
  pageRedaction=new HierarchyWizardPageRedaction<T>(controller,this,model,pageFinal);
  pageType=new HierarchyWizardPageType<T>(this,model,pageIntervals,pageOrder,pageRedaction);
}","/** 
 * Creates a new instance
 * @param controller
 * @param attribute
 * @param builder
 * @param datatype
 * @param items
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizard(final Controller controller,final String attribute,final HierarchyBuilder<?> builder,final DataType<T> datatype,final String[] items){
  super(new Point(800,400));
  this.model=new HierarchyWizardModel<T>(datatype,items);
  this.controller=controller;
  try {
    if (builder != null) {
      this.model.parse((HierarchyBuilder<T>)builder);
    }
  }
 catch (  Exception e) {
    this.model=new HierarchyWizardModel<T>(datatype,items);
  }
  this.setWindowTitle(Resources.getMessage(""String_Node_Str""));
  this.setDefaultPageImageDescriptor(ImageDescriptor.createFromImage(controller.getResources().getImage(""String_Node_Str"")));
  this.buttonLoad=new ARXWizardButton(""String_Node_Str"",new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      load();
    }
  }
);
  this.buttonSave=new ARXWizardButton(""String_Node_Str"",new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      save();
    }
  }
);
  this.setButtons(this.buttonLoad,this.buttonSave);
  pageFinal=new HierarchyWizardPageFinal<T>(this);
  if (model.getIntervalModel() != null) {
    pageIntervals=new HierarchyWizardPageIntervals<T>(this,model,pageFinal);
  }
 else {
    pageIntervals=null;
  }
  pageOrder=new HierarchyWizardPageOrder<T>(controller,this,model,pageFinal);
  pageRedaction=new HierarchyWizardPageRedaction<T>(controller,this,model,pageFinal);
  pageType=new HierarchyWizardPageType<T>(this,model,pageIntervals,pageOrder,pageRedaction);
}",0.9133608378292606
108573,"/** 
 * Loads a specification
 */
private void load(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  final String ERROR_RATIO_TEXT=""String_Node_Str"";
  final String ERROR_TYPE_TEXT=""String_Node_Str"";
  final String ERROR_APPLY_TEXT=""String_Node_Str"";
  String file=controller.actionShowOpenFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  HierarchyBuilder<T> builder=null;
  try {
    builder=HierarchyBuilder.create(file);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
  if (builder == null)   return;
 else   if (builder.getType() == Type.INTERVAL_BASED) {
    if (!(model.getDataType() instanceof DataTypeWithRatioScale)) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_RATIO_TEXT);
      return;
    }
 else     if (!((HierarchyBuilderIntervalBased<?>)builder).getDataType().equals(model.getDataType())) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TYPE_TEXT);
      return;
    }
  }
 else   if (builder.getType() == Type.ORDER_BASED) {
    if (!((HierarchyBuilderOrderBased<?>)builder).getDataType().equals(model.getDataType())) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TYPE_TEXT);
      return;
    }
  }
  try {
    model.setSpecification(builder);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_APPLY_TEXT + e.getMessage());
    return;
  }
switch (builder.getType()) {
case INTERVAL_BASED:
    this.pageIntervals.updatePage();
  this.model.setType(Type.INTERVAL_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageIntervals);
break;
case ORDER_BASED:
this.pageOrder.updatePage();
this.model.setType(Type.ORDER_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageOrder);
break;
case REDACTION_BASED:
this.pageRedaction.updatePage();
this.model.setType(Type.REDACTION_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageRedaction);
break;
}
}","/** 
 * Loads a specification
 */
private void load(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  final String ERROR_RATIO_TEXT=""String_Node_Str"";
  final String ERROR_TYPE_TEXT=""String_Node_Str"";
  final String ERROR_APPLY_TEXT=""String_Node_Str"";
  String file=controller.actionShowOpenFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  HierarchyBuilder<T> builder=null;
  try {
    builder=HierarchyBuilder.create(file);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
  if (builder == null)   return;
 else   if (builder.getType() == Type.INTERVAL_BASED) {
    if (!(model.getDataType() instanceof DataTypeWithRatioScale)) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_RATIO_TEXT);
      return;
    }
 else     if (!((HierarchyBuilderIntervalBased<?>)builder).getDataType().equals(model.getDataType())) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TYPE_TEXT);
      return;
    }
  }
 else   if (builder.getType() == Type.ORDER_BASED) {
    if (!((HierarchyBuilderOrderBased<?>)builder).getDataType().equals(model.getDataType())) {
      controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TYPE_TEXT);
      return;
    }
  }
  try {
    model.parse(builder);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_APPLY_TEXT + e.getMessage());
    return;
  }
switch (builder.getType()) {
case INTERVAL_BASED:
    this.pageIntervals.updatePage();
  this.model.setType(Type.INTERVAL_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageIntervals);
break;
case ORDER_BASED:
this.pageOrder.updatePage();
this.model.setType(Type.ORDER_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageOrder);
break;
case REDACTION_BASED:
this.pageRedaction.updatePage();
this.model.setType(Type.REDACTION_BASED);
this.pageType.updatePage();
this.getContainer().showPage(pageRedaction);
break;
}
}",0.9949555608935864
108574,"/** 
 * Creates a new instance for the given data type
 * @param dataType
 * @param data
 * @param builder 
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizardModel(DataType<T> dataType,String[] data,HierarchyBuilder<?> builder){
  this.data=data;
  this.dataType=dataType;
  orderModel=new HierarchyWizardModelOrder<T>(dataType,getOrderData());
  if (dataType instanceof DataTypeWithRatioScale) {
    intervalModel=new HierarchyWizardModelIntervals<T>(dataType,data);
  }
  redactionModel=new HierarchyWizardModelRedaction<T>(dataType,data);
  if (equals(dataType,DataType.DATE)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.DECIMAL)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.INTEGER)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.ORDERED_STRING)) {
    this.type=Type.ORDER_BASED;
  }
 else   if (equals(dataType,DataType.STRING)) {
    this.type=Type.REDACTION_BASED;
  }
  try {
    if (builder != null) {
      this.setSpecification((HierarchyBuilder<T>)builder);
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Creates a new instance for the given data type
 * @param dataType
 * @param data
 * @param builder 
 */
public HierarchyWizardModel(DataType<T> dataType,String[] data){
  this.data=data;
  this.dataType=dataType;
  orderModel=new HierarchyWizardModelOrder<T>(dataType,getOrderData());
  if (dataType instanceof DataTypeWithRatioScale) {
    intervalModel=new HierarchyWizardModelIntervals<T>(dataType,data);
  }
  redactionModel=new HierarchyWizardModelRedaction<T>(dataType,data);
  if (equals(dataType,DataType.DATE)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.DECIMAL)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.INTEGER)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.ORDERED_STRING)) {
    this.type=Type.ORDER_BASED;
  }
 else   if (equals(dataType,DataType.STRING)) {
    this.type=Type.REDACTION_BASED;
  }
}",0.9034146341463416
108575,"@Override public boolean isVisible(){
  if (isNativeImplementationSupported()) {
    if (this.menu == null)     return false;
 else     return this.menu.isVisible();
  }
 else   return super.isVisible();
}","@Override public boolean isVisible(){
  if (isNativeImplementationSupported()) {
    return false;
  }
 else   return super.isVisible();
}",0.8046647230320699
108576,"@Override public void actionPerformed(ActionEvent e){
  if (string != null && !isVisible() && !popup.isVisible()) {
    Point p=MouseInfo.getPointerInfo().getLocation();
    if (p.x != oldX || p.y != oldY) {
      oldX=p.x;
      oldY=p.y;
      oldTime=System.currentTimeMillis();
    }
 else     if (System.currentTimeMillis() - oldTime > TIME) {
      if (isNativeImplementationSupported()) {
        tooltip.setLocation(oldX,oldY);
        tooltip.setVisible(true);
      }
 else {
        show(oldX,oldY);
      }
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
synchronized (this) {
    if (string != null && !isVisible() && !popup.isVisible()) {
      Point p=MouseInfo.getPointerInfo().getLocation();
      if (p.x != oldX || p.y != oldY) {
        oldX=p.x;
        oldY=p.y;
        oldTime=System.currentTimeMillis();
      }
 else       if (System.currentTimeMillis() - oldTime > TIME) {
        if (isNativeImplementationSupported()) {
          Display.getDefault().asyncExec(new Runnable(){
            @Override public void run(){
              tooltip.setMessage(string);
              tooltip.setLocation(oldX,oldY);
              tooltip.setVisible(true);
            }
          }
);
        }
 else {
          show(oldX,oldY);
        }
      }
    }
  }
}",0.7722007722007722
108577,"/** 
 * Sets the options displayed by the popup
 * @param items
 * @param listener
 */
public void show(final String text){
  if (isNativeImplementationSupported()) {
    if (super.isVisible())     return;
    this.string=text;
  }
 else {
    if (super.isVisible())     return;
    this.string=text;
  }
}","/** 
 * Sets the options displayed by the popup
 * @param items
 * @param listener
 */
public void show(final String text){
synchronized (this) {
    if (isNativeImplementationSupported()) {
      this.string=text;
    }
 else {
      if (super.isVisible())       return;
      this.string=text;
    }
  }
}",0.8776508972267537
108578,"@Override public boolean isVisible(){
  if (isNativeImplementationSupported()) {
    return tooltip.isVisible();
  }
 else {
    return super.isVisible();
  }
}","@Override public boolean isVisible(){
  if (isNativeImplementationSupported()) {
    return false;
  }
 else {
    return super.isVisible();
  }
}",0.9411764705882352
108579,"/** 
 * Hides the tooltip
 */
public void unshow(){
  if (isNativeImplementationSupported()) {
    this.tooltip.setVisible(false);
    this.string=null;
  }
 else {
    if (super.isVisible())     return;
    this.string=null;
  }
}","/** 
 * Hides the tooltip
 */
public void unshow(){
synchronized (this) {
    if (isNativeImplementationSupported()) {
      this.string=null;
    }
 else {
      if (super.isVisible())       return;
      this.string=null;
    }
  }
}",0.7896995708154506
108580,"/** 
 * Creates a new instance
 * @param parent
 */
public MainToolTip(final Shell parent){
  super(parent);
  if (isNativeImplementationSupported()) {
    tooltip=new ToolTip(parent,SWT.ICON_INFORMATION);
    tooltip.setAutoHide(true);
  }
  new Timer(WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (string != null && !isVisible() && !popup.isVisible()) {
        Point p=MouseInfo.getPointerInfo().getLocation();
        if (p.x != oldX || p.y != oldY) {
          oldX=p.x;
          oldY=p.y;
          oldTime=System.currentTimeMillis();
        }
 else         if (System.currentTimeMillis() - oldTime > TIME) {
          if (isNativeImplementationSupported()) {
            tooltip.setLocation(oldX,oldY);
            tooltip.setVisible(true);
          }
 else {
            show(oldX,oldY);
          }
        }
      }
    }
  }
).start();
}","/** 
 * Creates a new instance
 * @param parent
 */
public MainToolTip(final Shell parent){
  super(parent);
  if (isNativeImplementationSupported()) {
    tooltip=new ToolTip(parent,SWT.ICON_INFORMATION);
    tooltip.setAutoHide(true);
  }
  new Timer(WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
synchronized (this) {
        if (string != null && !isVisible() && !popup.isVisible()) {
          Point p=MouseInfo.getPointerInfo().getLocation();
          if (p.x != oldX || p.y != oldY) {
            oldX=p.x;
            oldY=p.y;
            oldTime=System.currentTimeMillis();
          }
 else           if (System.currentTimeMillis() - oldTime > TIME) {
            if (isNativeImplementationSupported()) {
              Display.getDefault().asyncExec(new Runnable(){
                @Override public void run(){
                  tooltip.setMessage(string);
                  tooltip.setLocation(oldX,oldY);
                  tooltip.setVisible(true);
                }
              }
);
            }
 else {
              show(oldX,oldY);
            }
          }
        }
      }
    }
  }
).start();
}",0.8639225181598063
108581,"@Override public void handleEvent(final Event event){
  if (event.button == 3) {
    final TableItem i=getItemAt(event.x,event.y);
    if (i != null) {
      final ARXNode node=(ARXNode)i.getData();
      model.setSelectedNode(node);
      controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      selectedTableItem=i;
      Point point=table.toDisplay(event.x,event.y);
      Rectangle bounds=i.getBounds();
      bounds.x=table.toDisplay(bounds.x,bounds.y).x;
      bounds.y=table.toDisplay(bounds.x,bounds.y).y;
      controller.getPopup().show(menu,point.x,point.y);
    }
  }
}","@Override public void handleEvent(final Event event){
  if (event.button == 3) {
    final TableItem i=getItemAt(event.x,event.y);
    if (i != null) {
      final ARXNode node=(ARXNode)i.getData();
      model.setSelectedNode(node);
      controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      selectedTableItem=i;
      Point point=table.toDisplay(event.x,event.y);
      Rectangle bounds=i.getBounds();
      bounds.x=table.toDisplay(bounds.x,bounds.y).x;
      bounds.y=table.toDisplay(bounds.x,bounds.y).y;
      controller.getContextMenu().show(menu,point.x,point.y);
    }
  }
}",0.987034035656402
108582,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(controller.getResources().getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.getClipboard().remove(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      controller.update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          Rectangle bounds=i.getBounds();
          bounds.x=table.toDisplay(bounds.x,bounds.y).x;
          bounds.y=table.toDisplay(bounds.x,bounds.y).y;
          controller.getPopup().show(menu,point.x,point.y);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(controller.getResources().getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.getClipboard().remove(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      controller.update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          Rectangle bounds=i.getBounds();
          bounds.x=table.toDisplay(bounds.x,bounds.y).x;
          bounds.y=table.toDisplay(bounds.x,bounds.y).y;
          controller.getContextMenu().show(menu,point.x,point.y);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}",0.9980222496909764
108583,"/** 
 * Called when button 3 is clicked on a node
 * @param node
 * @param x
 * @param y
 */
private void actionButtonClicked3(ARXNode node,final int x,final int y){
  selectedNode=node;
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
      controller.getPopup().show(menu,x,y);
    }
  }
);
}","/** 
 * Called when button 3 is clicked on a node
 * @param node
 * @param x
 * @param y
 */
private void actionButtonClicked3(ARXNode node,final int x,final int y){
  selectedNode=node;
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
      controller.getContextMenu().show(menu,x,y);
    }
  }
);
}",0.9835390946502056
108584,"/** 
 * Returns a list of strings containing the data for the given column This will only return the   {@link #previewData} for the given columnrather than all of the preview data.
 * @param column Column the preview data should be returned for
 * @return Data for the given column
 * @see {@link #getPreviewData()}
 */
public List<String> getPreviewData(ImportWizardModelColumn column){
  List<String> result=new ArrayList<String>();
  int index=wizardColumns.indexOf(column);
  if (index != -1) {
    for (    String[] s : getPreviewData()) {
      result.add(s[((ImportColumnIndexed)column.getColumn()).getIndex()]);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return result;
}","/** 
 * Returns a list of strings containing the data for the given column This will only return the   {@link #previewData} for the given columnrather than all of the preview data.
 * @param column Column the preview data should be returned for
 * @return Data for the given column
 * @see {@link #getPreviewData()}
 */
public List<String> getPreviewData(ImportWizardModelColumn column){
  List<String> result=new ArrayList<String>();
  int index=wizardColumns.indexOf(column);
  if (index != -1) {
    for (    String[] s : getPreviewData()) {
      if (column.getColumn() instanceof ImportColumnIndexed) {
        result.add(s[((ImportColumnIndexed)column.getColumn()).getIndex()]);
      }
 else       if (column.getColumn() instanceof ImportColumnJDBC) {
        result.add(s[((ImportColumnJDBC)column.getColumn()).getIndex()]);
      }
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return result;
}",0.8595539481615431
108585,"/** 
 * Creates a new editor for the given   {@link TableViewer}.
 * @param viewer The TableViewer this editor is implemented for
 */
public DatatypeEditingSupport(TableViewer viewer){
  super(viewer);
  List<String> labels=new ArrayList<String>();
  for (  DataTypeDescription<?> description : DataType.list()) {
    if (description.newInstance().getClass() == DataType.ORDERED_STRING.getClass()) {
      continue;
    }
    labels.add(description.getLabel());
  }
  choices=labels.toArray(new String[labels.size()]);
  editor=new ComboBoxCellEditor(viewer.getTable(),choices,SWT.READ_ONLY);
}","/** 
 * Creates a new editor for the given   {@link TableViewer}.
 * @param viewer The TableViewer this editor is implemented for
 */
public DatatypeEditingSupport(TableViewer viewer){
  super(viewer);
  List<String> labels=new ArrayList<String>();
  for (  DataTypeDescription<?> description : DataType.list()) {
    if (description.newInstance().getClass() == DataType.ORDERED_STRING.getClass()) {
      continue;
    }
    labels.add(description.getLabel());
  }
  choices=labels.toArray(new String[labels.size()]);
  editor=new AutoDropComboBoxViewerCellEditor(viewer.getTable());
  editor.setContentProvider(new ArrayContentProvider());
  editor.setInput(choices);
}",0.915415019762846
108586,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=new Interval<T>(this,getDataType(),tempLower.repeatBound,interval.max,interval.function);
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=new Interval<T>(this,getDataType(),interval.min,tempUpper.repeatBound,interval.function);
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.8277021348125735
108587,"@SuppressWarnings(""String_Node_Str"") private Interval<T> getInterval(IndexNode index,DataTypeWithRatioScale<T> type,T tValue){
  int shift=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),shift);
  Interval<T> interval=query(index,type.subtract(tValue,offset));
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"" + type.format(tValue));
  }
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  return new Interval<T>(this,(DataType<T>)type,lower,upper,interval.function);
}","/** 
 * Performs the index lookup
 * @param value
 * @return
 */
private Interval<T> getInterval(IndexNode node,T value){
  @SuppressWarnings(""String_Node_Str"") DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  if (node.isLeaf) {
    for (    Interval<T> leaf : node.leafs) {
      if (type.compare(leaf.min,value) <= 0 && type.compare(leaf.max,value) > 0) {
        return leaf;
      }
    }
  }
 else {
    for (    IndexNode child : node.children) {
      if (type.compare(child.min,value) <= 0 && type.compare(child.max,value) > 0) {
        return getInterval(child,value);
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"" + type.format(value));
}",0.2164179104477611
108588,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderIntervalBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  if (data == null)   return;
  HierarchyBuilderIntervalBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.9762282091917592
108589,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderOrderBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  if (data == null)   return;
  HierarchyBuilderOrderBased<T> builder=null;
  try {
    builder=getBuilder(false);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.9761146496815286
108590,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderRedactionBased<T> builder=getBuilder(false);
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  if (data == null)   return;
  HierarchyBuilderRedactionBased<T> builder=getBuilder(false);
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=""String_Node_Str"";
    return;
  }
}",0.9658314350797268
108591,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getInterval(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9680170575692963
108592,"/** 
 * Returns the matching interval
 * @param index
 * @param type
 * @param tValue
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private Interval<T> getIntervalUpperSnap(IndexNode index,DataTypeWithRatioScale<T> type,T tValue){
  int shift=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),shift);
  T value=type.subtract(tValue,offset);
  Interval<T> interval=null;
  for (int j=0; j < intervals.size(); j++) {
    Interval<T> i=intervals.get(j);
    if (type.compare(i.min,value) <= 0 && type.compare(i.max,value) > 0) {
      if (type.compare(value,i.min) == 0) {
        if (j > 0) {
          interval=intervals.get(j - 1);
          break;
        }
 else {
          interval=intervals.get(intervals.size() - 1);
          offset=type.multiply(type.subtract(index.max,index.min),shift - 1);
          break;
        }
      }
 else {
        interval=i;
        break;
      }
    }
  }
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"" + type.format(tValue) + ""String_Node_Str""+ type.format(value));
  }
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  return new Interval<T>(this,(DataType<T>)type,lower,upper,interval.function);
}","/** 
 * Returns the matching interval
 * @param index
 * @param type
 * @param tValue
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private Interval<T> getIntervalUpperSnap(IndexNode index,DataTypeWithRatioScale<T> type,T tValue){
  int shift=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),shift);
  T value=type.subtract(tValue,offset);
  Interval<T> interval=null;
  for (int j=0; j < intervals.size(); j++) {
    Interval<T> i=intervals.get(j);
    if (type.compare(i.min,value) <= 0 && type.compare(i.max,value) > 0) {
      if (type.compare(value,i.min) == 0) {
        if (j > 0) {
          interval=intervals.get(j - 1);
          break;
        }
 else {
          interval=intervals.get(intervals.size() - 1);
          offset=type.multiply(type.subtract(index.max,index.min),shift - 1);
          break;
        }
      }
 else {
        interval=i;
        break;
      }
    }
  }
  if (interval == null && intervals.size() == 1) {
    interval=intervals.get(0);
  }
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  return new Interval<T>(this,(DataType<T>)type,lower,upper,interval.function);
}",0.9444861215303826
108593,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) >= 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) > 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9999211045364892
108594,"/** 
 * Sort
 * @param type
 * @return successful, or not
 */
private boolean internalSort(final DataType<?> type){
  try {
    Arrays.sort(data,new Comparator<String>(){
      @Override public int compare(      String o1,      String o2){
        try {
          return type.compare(o1,o2);
        }
 catch (        NumberFormatException|ParseException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    return true;
  }
 catch (  Exception e) {
    return false;
  }
}","/** 
 * Sort
 * @param type
 * @return successful, or not
 */
private <U>boolean internalSort(final DataType<U> type){
  try {
    ArrayList<U> list=new ArrayList<U>();
    for (    String s : data)     list.add(type.parse(s));
    Collections.sort(list,type);
    for (int i=0; i < list.size(); i++) {
      data[i]=type.format(list.get(i));
    }
    return true;
  }
 catch (  Exception e) {
    return false;
  }
}",0.3912568306010929
108595,"/** 
 * This class demonstrates how to use the API to import data from a JDBC source (SQLite in this case). It is loosely based upon previous examples as the API is quite similar.
 * @throws ClassNotFoundException 
 */
private static void exampleJDBC() throws IOException, SQLException, ClassNotFoundException {
  Class.forName(""String_Node_Str"");
  DataSource source=DataSource.createJDBCSource(""String_Node_Str"",""String_Node_Str"");
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(1,DataType.STRING);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
}","/** 
 * This class demonstrates how to use the API to import data from a JDBC source (SQLite in this case). It is loosely based upon previous examples as the API is quite similar.
 * @throws ClassNotFoundException 
 */
private static void exampleJDBC() throws IOException, SQLException, ClassNotFoundException {
  Class.forName(""String_Node_Str"");
  DataSource source=DataSource.createJDBCSource(""String_Node_Str"",""String_Node_Str"");
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(1,DataType.STRING);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
  System.out.println(""String_Node_Str"");
}",0.9695619896065332
108596,"/** 
 * This class implements an example on how to use the API to import data from a CSV file. It uses more advanced features than   {@link #Example2}. Columns are renamed and could be ignored altogether.
 */
private static void exampleCSV() throws IOException {
  DataSource source=DataSource.createCSVSource(""String_Node_Str"",';',true);
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(1,DataType.STRING);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
}","/** 
 * This class implements an example on how to use the API to import data from a CSV file. It uses more advanced features than   {@link #Example2}. Columns are renamed and could be ignored altogether.
 */
private static void exampleCSV() throws IOException {
  DataSource source=DataSource.createCSVSource(""String_Node_Str"",';',true);
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(1,DataType.STRING);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
  System.out.println(""String_Node_Str"");
}",0.9645635263612792
108597,"/** 
 * This class demonstrates how to use the API to import data from an Excel source It is loosely based upon previous examples as the API is quite similar.
 */
private static void exampleExcel() throws IOException {
  DataSource source=DataSource.createExcelSource(""String_Node_Str"",0,true);
  source.addColumn(1,DataType.STRING);
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
}","/** 
 * This class demonstrates how to use the API to import data from an Excel source It is loosely based upon previous examples as the API is quite similar.
 */
private static void exampleExcel() throws IOException {
  DataSource source=DataSource.createExcelSource(""String_Node_Str"",0,true);
  source.addColumn(1,DataType.STRING);
  source.addColumn(""String_Node_Str"",""String_Node_Str"",DataType.INTEGER);
  source.addColumn(2,DataType.STRING);
  final Data data=Data.create(source);
  print(data.getHandle());
  System.out.println(""String_Node_Str"");
}",0.961646398503274
108598,"/** 
 * Creates a new instance of this object with given configuration
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterCSV(ImportConfigurationCSV config) throws IOException {
  super(config);
  this.config=config;
  this.bytesTotal=new File(config.getFileLocation()).length();
  cin=new CountingInputStream(new FileInputStream(new File(config.getFileLocation())));
  in=new CSVDataInput(cin,config.getSeparator());
  it=in.iterator();
  if (it.hasNext()) {
    row=it.next();
    if (config.getContainsHeader()) {
      if (!it.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}","/** 
 * Creates a new instance of this object with given configuration
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterCSV(ImportConfigurationCSV config) throws IOException {
  super(config);
  this.config=config;
  this.bytesTotal=new File(config.getFileLocation()).length();
  cin=new CountingInputStream(new FileInputStream(new File(config.getFileLocation())));
  in=new CSVDataInput(cin,config.getSeparator());
  it=in.iterator();
  if (it.hasNext()) {
    row=it.next();
    if (config.getContainsHeader()) {
      if (!it.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  header=createHeader();
}",0.9834765366820886
108599,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return createHeader();
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=row[indexes[i]];
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (it.hasNext()) {
    row=it.next();
  }
 else {
    row=null;
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=row[indexes[i]];
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (it.hasNext()) {
    row=it.next();
  }
 else {
    row=null;
  }
  return result;
}",0.9879081015719468
108600,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return createHeader();
  }
  if (row.getPhysicalNumberOfCells() > numberOfColumns) {
    throw new IllegalArgumentException(""String_Node_Str"" + currentRow + ""String_Node_Str"");
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link ImportColumn#index}and contains as many elements as there are columns selected to import from   {@link #indexes}. The first row will always contain the names of the columns.   {@link #headerReturned} is used to keep track of that.
 * @throws IllegalArgumentException In case defined datatypes don't match
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  if (row.getPhysicalNumberOfCells() > numberOfColumns) {
    throw new IllegalArgumentException(""String_Node_Str"" + currentRow + ""String_Node_Str"");
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    row.getCell(indexes[i]).setCellType(Cell.CELL_TYPE_STRING);
    result[i]=row.getCell(indexes[i]).getStringCellValue();
    if (!dataTypes[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (iterator.hasNext()) {
    row=iterator.next();
    currentRow++;
  }
 else {
    row=null;
  }
  return result;
}",0.9909420289855072
108601,"/** 
 * Creates a new instance of this object with given configuration Depending upon the file type it either uses HSSF or XSSF to access the file. In both cases   {@link #iterator} will be assigned a reference toan iterator, which can then be used to access the actual data on a row by row basis.
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterExcel(ImportConfigurationExcel config) throws IOException {
  super(config);
  this.config=config;
  FileInputStream input=new FileInputStream(config.getFileLocation());
  Workbook workbook=null;
  if (config.getExcelFileType() == ExcelFileTypes.XLS) {
    workbook=new HSSFWorkbook(input);
  }
 else   if (config.getExcelFileType() == ExcelFileTypes.XLSX) {
    workbook=new XSSFWorkbook(input);
  }
 else {
    input.close();
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);
  Sheet sheet=workbook.getSheetAt(config.getSheetIndex());
  iterator=sheet.iterator();
  totalRows=sheet.getPhysicalNumberOfRows();
  if (iterator.hasNext()) {
    row=iterator.next();
    if (config.getContainsHeader()) {
      if (!iterator.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}","/** 
 * Creates a new instance of this object with given configuration Depending upon the file type it either uses HSSF or XSSF to access the file. In both cases   {@link #iterator} will be assigned a reference toan iterator, which can then be used to access the actual data on a row by row basis.
 * @param config {@link #config}
 * @throws IOException In case file doesn't contain actual data
 */
protected ImportAdapterExcel(ImportConfigurationExcel config) throws IOException {
  super(config);
  this.config=config;
  FileInputStream input=new FileInputStream(config.getFileLocation());
  Workbook workbook=null;
  if (config.getExcelFileType() == ExcelFileTypes.XLS) {
    workbook=new HSSFWorkbook(input);
  }
 else   if (config.getExcelFileType() == ExcelFileTypes.XLSX) {
    workbook=new XSSFWorkbook(input);
  }
 else {
    input.close();
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);
  Sheet sheet=workbook.getSheetAt(config.getSheetIndex());
  iterator=sheet.iterator();
  totalRows=sheet.getPhysicalNumberOfRows();
  if (iterator.hasNext()) {
    row=iterator.next();
    if (config.getContainsHeader()) {
      if (!iterator.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  header=createHeader();
}",0.990865911582024
108602,"/** 
 * Creates a new instance of this object with given configuration
 * @param config {@link #config}
 * @throws IOException In case of communication errors with JDBC
 * @todo Fix IOException
 */
protected ImportAdapterJDBC(ImportConfigurationJDBC config) throws IOException {
  super(config);
  this.config=config;
  this.indexes=getIndexesToImport();
  this.dataTypes=getColumnDatatypes();
  try {
    Statement statement;
    statement=config.getConnection().createStatement();
    statement.execute(""String_Node_Str"" + config.getTable());
    resultSet=statement.getResultSet();
    if (resultSet.next()) {
      totalRows=resultSet.getInt(1);
      if (totalRows == 0) {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
    statement=config.getConnection().createStatement();
    statement.execute(""String_Node_Str"" + config.getTable());
    resultSet=statement.getResultSet();
    hasNext=resultSet.next();
  }
 catch (  SQLException e) {
    throw new IOException(e.getMessage());
  }
}","/** 
 * Creates a new instance of this object with given configuration
 * @param config {@link #config}
 * @throws IOException In case of communication errors with JDBC
 * @todo Fix IOException
 */
protected ImportAdapterJDBC(ImportConfigurationJDBC config) throws IOException {
  super(config);
  this.config=config;
  this.indexes=getIndexesToImport();
  this.dataTypes=getColumnDatatypes();
  try {
    Statement statement;
    statement=config.getConnection().createStatement();
    statement.execute(""String_Node_Str"" + config.getTable());
    resultSet=statement.getResultSet();
    if (resultSet.next()) {
      totalRows=resultSet.getInt(1);
      if (totalRows == 0) {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
    statement=config.getConnection().createStatement();
    statement.execute(""String_Node_Str"" + config.getTable());
    resultSet=statement.getResultSet();
    hasNext=resultSet.next();
  }
 catch (  SQLException e) {
    throw new IOException(e.getMessage());
  }
  header=createHeader();
}",0.9884739511295528
108603,"@Override public String[] next(){
  if (!headerReturned) {
    return createHeader();
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    hasNext=resultSet.next();
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return header;
  }
  try {
    String[] result=new String[indexes.length];
    for (int i=0; i < indexes.length; i++) {
      result[i]=resultSet.getString(indexes[i]);
      if (!dataTypes[i].isValid(result[i])) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    hasNext=resultSet.next();
    return result;
  }
 catch (  SQLException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9419862340216324
108604,"/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon whether or not names have been assigned explicitly either the appropriate values will be returned, or names from the JDBC metadata will be used.
 */
private String[] createHeader(){
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    if (column.getAliasName() != null && !column.getAliasName().equals(""String_Node_Str"")) {
      header[i]=column.getAliasName();
    }
 else {
      try {
        header[i]=resultSet.getMetaData().getColumnName(((ImportColumnJDBC)column).getIndex() + 1);
      }
 catch (      SQLException e) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    column.setAliasName(header[i]);
  }
  headerReturned=true;
  return header;
}","/** 
 * Creates the header row This returns a string array with the names of the columns that will be returned later on by iterating over this object. Depending upon whether or not names have been assigned explicitly either the appropriate values will be returned, or names from the JDBC metadata will be used.
 */
private String[] createHeader(){
  String[] header=new String[config.getColumns().size()];
  List<ImportColumn> columns=config.getColumns();
  for (int i=0, len=columns.size(); i < len; i++) {
    ImportColumn column=columns.get(i);
    if (column.getAliasName() != null && !column.getAliasName().equals(""String_Node_Str"")) {
      header[i]=column.getAliasName();
    }
 else {
      try {
        header[i]=resultSet.getMetaData().getColumnName(((ImportColumnJDBC)column).getIndex() + 1);
      }
 catch (      SQLException e) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    column.setAliasName(header[i]);
  }
  return header;
}",0.9751142712036568
108605,"/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditorGroup(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  final Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  this.editorSize=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (group == null)       return false;
      try {
        int i=Integer.parseInt(s);
        return i > 0;
      }
 catch (      NumberFormatException e) {
        return false;
      }
    }
    @Override public String getValue(){
      if (group == null)       return ""String_Node_Str"";
 else       return String.valueOf(group.size);
    }
    @Override public void setValue(    final String s){
      if (group != null) {
        if (group.size != Integer.valueOf(s)) {
          group.size=Integer.valueOf(s);
          model.update(HierarchyWizardEditorGroup.this);
        }
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditorGroup(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  this.editorSize=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (group == null)       return false;
      try {
        int i=Integer.parseInt(s);
        return i > 0;
      }
 catch (      NumberFormatException e) {
        return false;
      }
    }
    @Override public String getValue(){
      if (group == null)       return ""String_Node_Str"";
 else       return String.valueOf(group.size);
    }
    @Override public void setValue(    final String s){
      if (group != null) {
        if (group.size != Integer.valueOf(s)) {
          group.size=Integer.valueOf(s);
          model.update(HierarchyWizardEditorGroup.this);
        }
      }
    }
  }
;
}",0.9935691318327974
108606,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
    SWTUtil.enable(composite);
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
    SWTUtil.disable(composite);
  }
}",0.7386046511627907
108607,"/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizardEditorInterval(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.type=(DataTypeWithRatioScale<T>)model.getDataType();
  final Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  editorMin=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.max) > 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.min);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.min != type.parse(s)) {
          interval.min=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
  createLabel(composite,""String_Node_Str"");
  editorMax=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.min) < 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.max);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.max != type.parse(s)) {
          interval.max=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizardEditorInterval(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.type=(DataTypeWithRatioScale<T>)model.getDataType();
  composite=new Composite(parent,SWT.NONE);
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  editorMin=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.max) > 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.min);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.min != type.parse(s)) {
          interval.min=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
  createLabel(composite,""String_Node_Str"");
  editorMax=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.min) < 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.max);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.max != type.parse(s)) {
          interval.max=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
}",0.996266915538964
108608,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
    SWTUtil.enable(composite);
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
    SWTUtil.disable(composite);
  }
}",0.8423502036067481
108609,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  Interval<T> lowerSnap=getInterval(index,type,tempLower.repeatBound);
  lowerSnap=new Interval<T>(this,getDataType(),tempLower.snapBound,lowerSnap.max,lowerSnap.function);
  Interval<T> upperSnap=getIntervalUpperSnap(index,type,tempUpper.repeatBound);
  upperSnap=new Interval<T>(this,getDataType(),upperSnap.min,tempUpper.snapBound,upperSnap.function);
  if (type.compare(lowerSnap.max,upperSnap.min) >= 0) {
    lowerSnap=new Interval<T>(this,getDataType(),lowerSnap.min,upperSnap.max,lowerSnap.function);
    upperSnap=lowerSnap;
  }
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=lowerSnap;
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=upperSnap;
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=new ArrayList<Group<T>>();
  if (!super.getLevels().isEmpty())   groups=super.getLevels().get(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),tempLower,tempUpper);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.getPreparedGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9853517970063236
108610,"/** 
 * Updates the model with a new specification
 * @param builder
 */
public void parse(HierarchyBuilder<T> builder) throws IllegalArgumentException {
  if (type == Type.INTERVAL_BASED) {
    if (intervalModel != null) {
      this.intervalModel.parse((HierarchyBuilderIntervalBased<T>)builder);
      this.type=Type.INTERVAL_BASED;
    }
  }
 else   if (type == Type.ORDER_BASED) {
    this.orderModel.parse((HierarchyBuilderOrderBased<T>)builder);
    this.type=Type.ORDER_BASED;
  }
 else   if (type == Type.REDACTION_BASED) {
    this.redactionModel.parse(builder);
    this.type=Type.REDACTION_BASED;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Updates the model with a new specification
 * @param builder
 */
public void parse(HierarchyBuilder<T> builder) throws IllegalArgumentException {
  if (builder.getType() == Type.INTERVAL_BASED) {
    if (intervalModel != null) {
      this.intervalModel.parse((HierarchyBuilderIntervalBased<T>)builder);
      this.type=Type.INTERVAL_BASED;
    }
  }
 else   if (builder.getType() == Type.ORDER_BASED) {
    this.orderModel.parse((HierarchyBuilderOrderBased<T>)builder);
    this.type=Type.ORDER_BASED;
  }
 else   if (builder.getType() == Type.REDACTION_BASED) {
    this.redactionModel.parse(builder);
    this.type=Type.REDACTION_BASED;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9552874378992192
108611,"/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditorGroup(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  this.editorSize=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (group == null)       return false;
      try {
        int i=Integer.parseInt(s);
        return i > 0;
      }
 catch (      NumberFormatException e) {
        return false;
      }
    }
    @Override public String getValue(){
      if (group == null)       return ""String_Node_Str"";
 else       return String.valueOf(group.size);
    }
    @Override public void setValue(    final String s){
      if (group != null) {
        if (group.size != Integer.valueOf(s)) {
          group.size=Integer.valueOf(s);
          model.update(HierarchyWizardEditorGroup.this);
        }
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditorGroup(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  this.editorSize=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (group == null)       return false;
      try {
        int i=Integer.parseInt(s);
        return i > 0;
      }
 catch (      NumberFormatException e) {
        return false;
      }
    }
    @Override public String getValue(){
      if (group == null)       return ""String_Node_Str"";
 else       return String.valueOf(group.size);
    }
    @Override public void setValue(    final String s){
      if (group != null) {
        if (group.size != Integer.valueOf(s)) {
          group.size=Integer.valueOf(s);
          model.update(HierarchyWizardEditorGroup.this);
        }
      }
    }
  }
;
}",0.9959709911361804
108612,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
    SWTUtil.enable(composite);
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
    SWTUtil.disable(composite);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    this.group=(HierarchyWizardGroupingGroup<T>)model.getSelectedElement();
    this.editorFunction.setFunction(group.function);
    this.editorSize.update();
    SWTUtil.enable(editorSize.getControl());
    SWTUtil.enable(this.editorFunction.getControl1());
    SWTUtil.enable(this.editorFunction.getControl2());
  }
 else {
    this.group=null;
    this.editorFunction.setFunction(null);
    this.editorSize.update();
    SWTUtil.disable(editorSize.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}",0.6939090208172706
108613,"/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizardEditorInterval(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.type=(DataTypeWithRatioScale<T>)model.getDataType();
  composite=new Composite(parent,SWT.NONE);
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  editorMin=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.max) > 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.min);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.min != type.parse(s)) {
          interval.min=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
  createLabel(composite,""String_Node_Str"");
  editorMax=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.min) < 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.max);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.max != type.parse(s)) {
          interval.max=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
}","/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
@SuppressWarnings(""String_Node_Str"") public HierarchyWizardEditorInterval(final Composite parent,final HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.type=(DataTypeWithRatioScale<T>)model.getDataType();
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  composite.setLayout(SWTUtil.createGridLayout(2,true));
  this.editorFunction=new HierarchyWizardEditorFunction<T>(this,model,composite,false);
  createLabel(composite,""String_Node_Str"");
  editorMin=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.max) > 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.min);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.min != type.parse(s)) {
          interval.min=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
  createLabel(composite,""String_Node_Str"");
  editorMax=new EditorString(composite){
    @Override public boolean accepts(    final String s){
      if (interval == null)       return false;
      if (!type.isValid(s))       return false;
      T value=type.parse(s);
      if (type.compare(value,interval.min) < 0)       return false;
 else       return true;
    }
    @Override public String getValue(){
      if (interval == null)       return ""String_Node_Str"";
 else       return type.format(interval.max);
    }
    @Override public void setValue(    final String s){
      if (interval != null) {
        if (interval.max != type.parse(s)) {
          interval.max=type.parse(s);
          model.update(HierarchyWizardEditorInterval.this);
        }
      }
    }
  }
;
}",0.9976635514018692
108614,"@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
    SWTUtil.enable(composite);
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
    SWTUtil.disable(composite);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void update(){
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    this.interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    this.editorFunction.setFunction(this.interval.function);
    this.editorMin.update();
    this.editorMax.update();
    if (model.isFirst(this.interval)) {
      SWTUtil.enable(editorMin.getControl());
    }
 else {
      SWTUtil.disable(editorMin.getControl());
    }
    if (model.isLast(this.interval)) {
      SWTUtil.enable(editorMax.getControl());
    }
 else {
      SWTUtil.disable(editorMax.getControl());
    }
    SWTUtil.enable(this.editorFunction.getControl1());
    SWTUtil.enable(this.editorFunction.getControl2());
  }
 else {
    this.interval=null;
    this.editorFunction.setFunction(null);
    SWTUtil.disable(editorMin.getControl());
    SWTUtil.disable(editorMax.getControl());
    SWTUtil.disable(this.editorFunction.getControl1());
    SWTUtil.disable(this.editorFunction.getControl2());
  }
}",0.8232869654817104
108615,"@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","@Override public GroupStatistics getGroupStatistics(boolean anonymous){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      numberOfEquivalenceClasses++;
      if (anonymous && !isAnonymous(entry)) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.9785097409118296
108616,"/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics();","/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics(boolean anonymous);",0.9294605809128632
108617,"/** 
 * Checks the interval
 * @param type
 * @param min
 * @param max
 */
private <U>void checkInterval(DataType<U> type,U min,U max){
  int cmp=0;
  try {
    cmp=type.compare(type.format(min),type.format(max));
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max);
  }
  if (cmp > 0)   throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"");
}","/** 
 * Checks the interval
 * @param type
 * @param min
 * @param max
 */
private <U>void checkInterval(DataType<U> type,U min,U max){
  int cmp=0;
  try {
    cmp=type.compare(type.format(min),type.format(max));
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max);
  }
  if (cmp >= 0)   throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"");
}",0.998914223669924
108618,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  IndexNode index=nodes.get(0);
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    first[i]=getGroup(cache,getInterval(index,data[i],tempLower,tempUpper));
  }
  result.add(first);
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (!groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      if (type.compare(max,tempUpper.getRepeatBound()) > 0) {
        max=tempUpper.getRepeatBound();
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else {
    if (cache.size() > 1) {
      AbstractGroup[] column=new AbstractGroup[data.length];
      @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
      }
;
      for (int i=0; i < column.length; i++) {
        column[i]=element;
      }
      result.add(column);
    }
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    first[i]=getGroup(cache,getInterval(index,data[i],tempLower,tempUpper));
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      if (type.compare(max,tempUpper.getRepeatBound()) > 0) {
        max=tempUpper.getRepeatBound();
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.978917494425299
108619,"private void actionDeleteColumn(){
  if (null == targetColumn) {
    return;
  }
  base.setRedraw(false);
  int index=table.indexOf(targetColumn);
  TableColumn toRemove=table.getColumn(index);
  toRemove.dispose();
  updateColumnTitles();
  base.setRedraw(true);
  base.redraw();
  targetColumn=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}","private void actionDeleteColumn(){
  if (null == targetColumn) {
    return;
  }
  base.setRedraw(false);
  int index=table.indexOf(targetColumn);
  TableColumn toRemove=table.getColumn(index);
  toRemove.dispose();
  updateColumnTitles();
  base.setRedraw(true);
  base.redraw();
  if (table.getColumnCount() == 0) {
    actionClear();
  }
  targetColumn=null;
  updateArray();
  updateCombos();
  pushHierarchy();
  pushMin();
  pushMax();
}",0.927360774818402
108620,"@SuppressWarnings(""String_Node_Str"") @Override protected AbstractGroup[][] prepareGroups(){
  if (comparator != null) {
    Arrays.sort(super.getData(),comparator);
  }
  List<Group<T>> groups=super.getLevel(0).getGroups();
  List<String> items=new ArrayList<String>();
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  int index=0;
  int resultIndex=0;
  int groupCount=0;
  if (!super.getLevels().isEmpty() && !super.getLevel(0).getGroups().isEmpty()) {
    AbstractGroup[] first=new AbstractGroup[data.length];
    outer:     while (true) {
      for (      Group<T> group : groups) {
        for (int i=0; i < group.getSize(); i++) {
          items.add(data[index++]);
          if (index == data.length)           break;
        }
        CloseElements<T> element=new CloseElements<T>(items.toArray(new String[items.size()]),group.getFunction());
        for (int i=0; i < items.size(); i++) {
          first[resultIndex++]=element;
        }
        items.clear();
        if (index == data.length)         break outer;
      }
    }
    result.add(first);
    for (int i=1; i < super.getLevels().size(); i++) {
      if (groupCount == 1)       break;
      groupCount=0;
      groups=super.getLevel(i).getGroups();
      Map<AbstractGroup,AbstractGroup> map=new HashMap<AbstractGroup,AbstractGroup>();
      List<AbstractGroup> list=new ArrayList<AbstractGroup>();
      AbstractGroup[] column=result.get(i - 1);
      for (int j=0; j < column.length; j++) {
        if (!map.containsKey(column[j])) {
          map.put(column[j],column[j]);
          list.add(column[j]);
        }
      }
      index=0;
      resultIndex=0;
      List<CloseElements<T>> gItems=new ArrayList<CloseElements<T>>();
      outer:       while (true) {
        for (        Group<T> group : groups) {
          for (int j=0; j < group.getSize(); j++) {
            gItems.add((CloseElements<T>)list.get(index++));
            if (index == list.size())             break;
          }
          CloseElements<T> element=gItems.get(0).merge(gItems,group.getFunction());
          groupCount++;
          for (int j=0; j < gItems.size(); j++) {
            map.put(gItems.get(j),element);
          }
          gItems.clear();
          if (index == list.size())           break outer;
        }
      }
      AbstractGroup[] ccolumn=new AbstractGroup[data.length];
      for (int j=0; j < column.length; j++) {
        ccolumn[j]=map.get(column[j]);
      }
      result.add(ccolumn);
    }
  }
 else {
    groupCount=data.length;
  }
  if (groupCount > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    CloseElements<T> element=new CloseElements<T>(new String[]{},AggregateFunction.forType(getDataType()).createConstantFunction(""String_Node_Str""));
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@SuppressWarnings(""String_Node_Str"") @Override protected AbstractGroup[][] prepareGroups(){
  if (comparator != null) {
    Arrays.sort(super.getData(),comparator);
  }
  List<Group<T>> groups=super.getLevel(0).getGroups();
  List<String> items=new ArrayList<String>();
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  int index=0;
  int resultIndex=0;
  int groupCount=0;
  if (!super.getLevels().isEmpty() && !super.getLevel(0).getGroups().isEmpty()) {
    AbstractGroup[] first=new AbstractGroup[data.length];
    outer:     while (true) {
      for (      Group<T> group : groups) {
        for (int i=0; i < group.getSize(); i++) {
          items.add(data[index++]);
          if (index == data.length)           break;
        }
        CloseElements<T> element=new CloseElements<T>(items.toArray(new String[items.size()]),group.getFunction());
        for (int i=0; i < items.size(); i++) {
          first[resultIndex++]=element;
        }
        groupCount++;
        items.clear();
        if (index == data.length)         break outer;
      }
    }
    result.add(first);
    if (groupCount > 1) {
      for (int i=1; i < super.getLevels().size(); i++) {
        if (groupCount == 1)         break;
        groupCount=0;
        groups=super.getLevel(i).getGroups();
        Map<AbstractGroup,AbstractGroup> map=new HashMap<AbstractGroup,AbstractGroup>();
        List<AbstractGroup> list=new ArrayList<AbstractGroup>();
        AbstractGroup[] column=result.get(i - 1);
        for (int j=0; j < column.length; j++) {
          if (!map.containsKey(column[j])) {
            map.put(column[j],column[j]);
            list.add(column[j]);
          }
        }
        index=0;
        resultIndex=0;
        List<CloseElements<T>> gItems=new ArrayList<CloseElements<T>>();
        outer:         while (true) {
          for (          Group<T> group : groups) {
            for (int j=0; j < group.getSize(); j++) {
              gItems.add((CloseElements<T>)list.get(index++));
              if (index == list.size())               break;
            }
            CloseElements<T> element=gItems.get(0).merge(gItems,group.getFunction());
            groupCount++;
            for (int j=0; j < gItems.size(); j++) {
              map.put(gItems.get(j),element);
            }
            gItems.clear();
            if (index == list.size())             break outer;
          }
        }
        AbstractGroup[] ccolumn=new AbstractGroup[data.length];
        for (int j=0; j < column.length; j++) {
          ccolumn[j]=map.get(column[j]);
        }
        result.add(ccolumn);
      }
    }
  }
 else {
    groupCount=data.length;
  }
  if (groupCount > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    CloseElements<T> element=new CloseElements<T>(new String[]{},AggregateFunction.forType(getDataType()).createConstantFunction(""String_Node_Str""));
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.918543046357616
108621,"public void setPath(final String path){
  this.path=path;
  setModified();
}","public void setPath(final String path){
  this.path=path;
}",0.8740740740740741
108622,"@SuppressWarnings(""String_Node_Str"") public void show(int x,int y){
  if (model.getSelectedElement() == null) {
    return;
  }
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    if (model.getIntervals().size() == 1) {
      this.remove.setEnabled(false);
    }
 else {
      this.remove.setEnabled(true);
    }
    if (model.isFirst((HierarchyWizardGroupingInterval<T>)model.getSelectedElement())) {
      this.addBefore.setEnabled(true);
      this.mergeDown.setEnabled(false);
    }
 else {
      this.addBefore.setEnabled(false);
      this.mergeDown.setEnabled(true);
    }
    if (model.isLast((HierarchyWizardGroupingInterval<T>)model.getSelectedElement())) {
      this.addAfter.setEnabled(true);
      this.mergeUp.setEnabled(false);
    }
 else {
      this.addAfter.setEnabled(false);
      this.mergeUp.setEnabled(true);
    }
    this.addRight.setEnabled(true);
  }
 else   if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    if (model.isShowIntervals() && model.getModelGroups().size() == 1 && model.getModelGroups().get(0).size() == 1) {
      this.remove.setEnabled(false);
    }
 else {
      this.remove.setEnabled(true);
    }
    this.addBefore.setEnabled(true);
    this.addAfter.setEnabled(true);
    this.addRight.setEnabled(true);
    this.mergeUp.setEnabled(false);
    this.mergeDown.setEnabled(false);
  }
  menu.setLocation(composite.toDisplay(x,y));
  menu.setVisible(true);
}","@SuppressWarnings(""String_Node_Str"") public void show(int x,int y){
  if (model.getSelectedElement() == null) {
    return;
  }
  if (model.getSelectedElement() instanceof HierarchyWizardGroupingInterval) {
    HierarchyWizardGroupingInterval<T> interval=(HierarchyWizardGroupingInterval<T>)model.getSelectedElement();
    if (model.getIntervals().size() == 1) {
      this.remove.setEnabled(false);
    }
 else     if (model.isFirst(interval) || model.isLast(interval)) {
      this.remove.setEnabled(true);
    }
 else {
      this.remove.setEnabled(false);
    }
    if (model.isFirst(interval)) {
      this.addBefore.setEnabled(true);
      this.mergeDown.setEnabled(false);
    }
 else {
      this.addBefore.setEnabled(false);
      this.mergeDown.setEnabled(true);
    }
    if (model.isLast(interval)) {
      this.addAfter.setEnabled(true);
      this.mergeUp.setEnabled(false);
    }
 else {
      this.addAfter.setEnabled(false);
      this.mergeUp.setEnabled(true);
    }
    this.addRight.setEnabled(true);
  }
 else   if (model.getSelectedElement() instanceof HierarchyWizardGroupingGroup) {
    if (model.isShowIntervals()) {
      this.remove.setEnabled(true);
    }
 else {
      if (model.getModelGroups().size() == 1 && model.getModelGroups().get(0).size() == 1) {
        this.remove.setEnabled(false);
      }
 else {
        this.remove.setEnabled(true);
      }
    }
    this.addBefore.setEnabled(true);
    this.addAfter.setEnabled(true);
    this.addRight.setEnabled(true);
    this.mergeUp.setEnabled(false);
    this.mergeDown.setEnabled(false);
  }
  menu.setLocation(composite.toDisplay(x,y));
  menu.setVisible(true);
}",0.6621708413615928
108623,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    first[i]=getGroup(cache,getInterval(index,type,type.parse(data[i])));
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    T value=type.parse(data[i]);
    Interval<T> interval=getInterval(index,type,value);
    if (type.compare(value,tempLower.labelBound) < 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempLower.snapBound) < 0) {
      interval=new Interval<T>(this,true,tempLower.snapBound);
    }
    if (type.compare(value,tempUpper.labelBound) >= 0) {
      throw new IllegalArgumentException(type.format(value) + ""String_Node_Str"");
    }
 else     if (type.compare(value,tempUpper.snapBound) >= 0) {
      interval=new Interval<T>(this,false,tempUpper.snapBound);
    }
    if (interval.min != null && interval.max != null) {
      if (type.compare(interval.min,tempLower.repeatBound) < 0) {
        interval=new Interval<T>(this,getDataType(),tempLower.repeatBound,interval.max,interval.function);
      }
      if (type.compare(interval.max,tempUpper.repeatBound) >= 0) {
        interval=new Interval<T>(this,getDataType(),interval.min,tempUpper.repeatBound,interval.function);
      }
    }
    first[i]=getGroup(cache,interval);
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.8973398276508056
108624,"/** 
 * Checks the interval
 * @param type
 * @param min
 * @param max
 */
private <U>void checkInterval(DataType<U> type,U min,U max){
  try {
    if (type.compare(type.format(min),type.format(max)) > 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max);
  }
}","/** 
 * Checks the interval
 * @param type
 * @param min
 * @param max
 */
private <U>void checkInterval(DataType<U> type,U min,U max){
  int cmp=0;
  try {
    cmp=type.compare(type.format(min),type.format(max));
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max);
  }
  if (cmp > 0)   throw new IllegalArgumentException(""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"");
}",0.6806167400881057
108625,"@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    first[i]=getGroup(cache,getInterval(index,type,type.parse(data[i])));
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      if (type.compare(max,tempUpper.getRepeatBound()) > 0) {
        max=tempUpper.getRepeatBound();
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}","@Override @SuppressWarnings(""String_Node_Str"") protected AbstractGroup[][] prepareGroups(){
  String valid=isValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  Range<T> tempLower=new Range<T>(null,null,null);
  Range<T> tempUpper=new Range<T>(null,null,null);
  if (lowerRange.getRepeatBound() != null) {
    tempLower.setRepeatBound(lowerRange.getRepeatBound());
  }
 else {
    tempLower.setRepeatBound(intervals.get(0).min);
  }
  if (lowerRange.getSnapBound() != null) {
    tempLower.setSnapBound(lowerRange.getSnapBound());
  }
 else {
    tempLower.setSnapBound(tempLower.getRepeatBound());
  }
  if (lowerRange.getLabelBound() != null) {
    tempLower.setLabelBound(lowerRange.getLabelBound());
  }
 else {
    tempLower.setLabelBound(tempLower.getSnapBound());
  }
  if (upperRange.getRepeatBound() != null) {
    tempUpper.setRepeatBound(upperRange.getRepeatBound());
  }
 else {
    tempUpper.setRepeatBound(intervals.get(intervals.size() - 1).max);
  }
  if (upperRange.getSnapBound() != null) {
    tempUpper.setSnapBound(upperRange.getSnapBound());
  }
 else {
    tempUpper.setSnapBound(tempUpper.getRepeatBound());
  }
  if (upperRange.getLabelBound() != null) {
    tempUpper.setLabelBound(upperRange.getLabelBound());
  }
 else {
    tempUpper.setLabelBound(tempUpper.getSnapBound());
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  String[] data=getData();
  List<AbstractGroup[]> result=new ArrayList<AbstractGroup[]>();
  IndexNode index=nodes.get(0);
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  Map<AbstractGroup,AbstractGroup> cache=new HashMap<AbstractGroup,AbstractGroup>();
  AbstractGroup[] first=new AbstractGroup[data.length];
  for (int i=0; i < data.length; i++) {
    first[i]=getGroup(cache,getInterval(index,type,type.parse(data[i])));
  }
  result.add(first);
  index=null;
  List<Group<T>> groups=super.getLevel(0).getGroups();
  if (cache.size() > 1 && !groups.isEmpty()) {
    List<Interval<T>> newIntervals=new ArrayList<Interval<T>>();
    int intervalIndex=0;
    int multiplier=0;
    T width=type.subtract(intervals.get(intervals.size() - 1).max,intervals.get(0).min);
    for (    Group<T> group : groups) {
      T min=null;
      T max=null;
      for (int i=0; i < group.getSize(); i++) {
        Interval<T> current=intervals.get(intervalIndex++);
        T offset=type.multiply(width,multiplier);
        T cMin=type.add(current.min,offset);
        T cMax=type.add(current.max,offset);
        if (min == null || type.compare(min,cMin) > 0) {
          min=cMin;
        }
        if (max == null || type.compare(max,cMax) < 0) {
          max=cMax;
        }
        if (intervalIndex == intervals.size()) {
          intervalIndex=0;
          multiplier++;
        }
      }
      newIntervals.add(new Interval<T>(this,getDataType(),min,max,group.getFunction()));
    }
    HierarchyBuilderIntervalBased<T> builder=new HierarchyBuilderIntervalBased<T>(getDataType(),lowerRange,upperRange);
    for (    Interval<T> interval : newIntervals) {
      builder.addInterval(interval.min,interval.max,interval.function);
    }
    for (int i=1; i < super.getLevels().size(); i++) {
      for (      Group<T> sgroup : super.getLevel(i).getGroups()) {
        builder.getLevel(i - 1).addGroup(sgroup.getSize(),sgroup.getFunction());
      }
    }
    builder.prepare(data);
    AbstractGroup[][] columns=builder.prepareGroups();
    for (    AbstractGroup[] column : columns) {
      result.add(column);
    }
  }
 else   if (cache.size() > 1) {
    AbstractGroup[] column=new AbstractGroup[data.length];
    @SuppressWarnings(""String_Node_Str"") AbstractGroup element=new AbstractGroup(""String_Node_Str""){
    }
;
    for (int i=0; i < column.length; i++) {
      column[i]=element;
    }
    result.add(column);
  }
  return result.toArray(new AbstractGroup[0][0]);
}",0.9887248872488724
108626,"/** 
 * Creates a final result from this temporary result
 * @param anonymizer
 * @param handle
 * @param time
 * @return
 */
public ARXResult asResult(ARXConfiguration config,DataHandle handle,long time){
  final ARXLattice flattice=new ARXLattice(lattice,manager.getDataQI().getHeader(),config);
  ((DataHandleInput)handle).setLocked(true);
  return new ARXResult(handle.getRegistry(),this.manager,this.checker,handle.getDefinition(),config,flattice,flattice.getOptimum(),System.currentTimeMillis() - time,suppressionString,removeOutliers);
}","/** 
 * Creates a final result from this temporary result
 * @param anonymizer
 * @param handle
 * @param time
 * @return
 */
public ARXResult asResult(ARXConfiguration config,DataHandle handle,long time){
  final ARXLattice flattice=new ARXLattice(lattice,manager.getDataQI().getHeader(),config);
  ((DataHandleInput)handle).setLocked(true);
  return new ARXResult(handle.getRegistry(),this.manager,this.checker,handle.getDefinition(),config,flattice,System.currentTimeMillis() - time,suppressionString,removeOutliers);
}",0.9793621013133208
108627,"/** 
 * Creates a new instance
 * @param registry
 * @param manager
 * @param checker
 * @param definition
 * @param config
 * @param lattice
 * @param optimalNode
 * @param duration
 * @param suppressionString
 * @param removeOutliers
 */
protected ARXResult(DataRegistry registry,DataManager manager,INodeChecker checker,DataDefinition definition,ARXConfiguration config,ARXLattice lattice,ARXNode optimalNode,long duration,String suppressionString,boolean removeOutliers){
  this.registry=registry;
  this.manager=manager;
  this.checker=checker;
  this.definition=definition;
  this.config=config;
  this.lattice=lattice;
  this.optimalNode=optimalNode;
  this.duration=duration;
  this.suppressionString=suppressionString;
  this.removeOutliers=removeOutliers;
}","/** 
 * Creates a new instance
 * @param registry
 * @param manager
 * @param checker
 * @param definition
 * @param config
 * @param lattice
 * @param optimalNode
 * @param duration
 * @param suppressionString
 * @param removeOutliers
 */
protected ARXResult(DataRegistry registry,DataManager manager,INodeChecker checker,DataDefinition definition,ARXConfiguration config,ARXLattice lattice,long duration,String suppressionString,boolean removeOutliers){
  this.registry=registry;
  this.manager=manager;
  this.checker=checker;
  this.definition=definition;
  this.config=config;
  this.lattice=lattice;
  this.optimalNode=lattice.getOptimum();
  this.duration=duration;
  this.suppressionString=suppressionString;
  this.removeOutliers=removeOutliers;
}",0.9665134602757716
108628,"@Override @Deprecated public Data transform(final Node node){
  throw new RuntimeException(""String_Node_Str"");
}","@Override @Deprecated public Data transform(final Node node){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9113924050632912
108629,"@Override @Deprecated public double getInformationLoss(final Node node){
  check(node);
  metric.evaluate(node,currentGroupify);
  return node.getInformationLoss().getValue();
}","@Override @Deprecated public double getInformationLoss(final Node node){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.6325878594249201
108630,"/** 
 * Evaluates the metric for the given node
 * @param node The node for which to compute the information loss
 * @param groupify The groupify operator of the previous check
 * @return the double
 */
public final void evaluate(final Node node,final IHashGroupify groupify){
  node.setInformationLoss(this.evaluateInternal(node,groupify));
  if ((globalOptimum == null) || (node.getInformationLoss().compareTo(optimalInformationLoss) < 0) || (node.getInformationLoss().compareTo(optimalInformationLoss) == 0 && node.getLevel() < globalOptimum.getLevel())) {
    this.globalOptimum=node;
    this.optimalInformationLoss=node.getInformationLoss();
  }
}","/** 
 * Evaluates the metric for the given node
 * @param node The node for which to compute the information loss
 * @param groupify The groupify operator of the previous check
 * @return the double
 */
public final void evaluate(final Node node,final IHashGroupify groupify){
  node.setInformationLoss(this.evaluateInternal(node,groupify));
  if (node.isAnonymous() && ((globalOptimum == null) || (node.getInformationLoss().compareTo(optimalInformationLoss) < 0) || (node.getInformationLoss().compareTo(optimalInformationLoss) == 0 && node.getLevel() < globalOptimum.getLevel()))) {
    this.globalOptimum=node;
    this.optimalInformationLoss=node.getInformationLoss();
  }
}",0.9819548872180452
108631,"@Override public void setVisible(boolean value){
  if (value) {
    this.model.update();
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
    Button save=this.wizard.getSaveButton();
    if (save != null)     save.setEnabled(true);
  }
  super.setVisible(value);
}","@Override public void setVisible(boolean value){
  if (value) {
    this.model.update();
    Button load=this.wizard.getLoadButton();
    if (load != null)     load.setEnabled(false);
  }
  super.setVisible(value);
}",0.8212927756653993
108632,"/** 
 * Returns the created builder
 * @return
 */
public HierarchyWizardResult<T> getResult(){
  return new HierarchyWizardResult<T>(model.getHierarchy(),model.getBuilder());
}","/** 
 * Returns the created builder
 * @return
 */
public HierarchyWizardResult<T> getResult(){
  try {
    return new HierarchyWizardResult<T>(model.getHierarchy(),model.getBuilder());
  }
 catch (  Exception e) {
    return null;
  }
}",0.855072463768116
108633,"/** 
 * Saves the current specification
 */
private void save(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  String file=controller.actionShowSaveFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  HierarchyBuilder<T> builder=null;
  if (getDialog().getCurrentPage() instanceof HierarchyWizardPageOrder) {
    builder=model.getOrderModel().getBuilder();
  }
 else   if (getDialog().getCurrentPage() instanceof HierarchyWizardPageIntervals) {
    builder=model.getIntervalModel().getBuilder();
  }
 else   if (getDialog().getCurrentPage() instanceof HierarchyWizardPageRedaction) {
    builder=model.getRedactionModel().getBuilder();
  }
  try {
    builder.save(file);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
}","/** 
 * Saves the current specification
 */
private void save(){
  final String ERROR_HEADER=""String_Node_Str"";
  final String ERROR_TEXT=""String_Node_Str"";
  String file=controller.actionShowSaveFileDialog(getShell(),""String_Node_Str"");
  if (file == null)   return;
  try {
    HierarchyBuilder<T> builder=null;
    if (getDialog().getCurrentPage() instanceof HierarchyWizardPageOrder) {
      builder=model.getOrderModel().getBuilder();
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageIntervals) {
      builder=model.getIntervalModel().getBuilder();
    }
 else     if (getDialog().getCurrentPage() instanceof HierarchyWizardPageRedaction) {
      builder=model.getRedactionModel().getBuilder();
    }
    builder.save(file);
  }
 catch (  Exception e) {
    controller.actionShowInfoDialog(getShell(),ERROR_HEADER,ERROR_TEXT + e.getMessage());
    return;
  }
}",0.979706877113867
108634,"/** 
 * Returns the current builder
 * @return
 */
public HierarchyBuilder<T> getBuilder(){
  if (type == Type.INTERVAL_BASED) {
    return intervalModel.getBuilder();
  }
 else   if (type == Type.REDACTION_BASED) {
    return redactionModel.getBuilder();
  }
 else   if (type == Type.ORDER_BASED) {
    return orderModel.getBuilder();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Returns the current builder
 * @return
 */
public HierarchyBuilder<T> getBuilder() throws Exception {
  if (type == Type.INTERVAL_BASED) {
    return intervalModel.getBuilder();
  }
 else   if (type == Type.REDACTION_BASED) {
    return redactionModel.getBuilder();
  }
 else   if (type == Type.ORDER_BASED) {
    return orderModel.getBuilder();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.978622327790974
108635,"/** 
 * Returns the builder currently configured
 * @return
 */
public abstract HierarchyBuilder<T> getBuilder();","/** 
 * Returns the builder currently configured
 * @return
 */
public abstract HierarchyBuilder<T> getBuilder() throws Exception ;",0.9262295081967212
108636,"@Override public HierarchyBuilderIntervalBased<T> getBuilder(){
  HierarchyBuilderIntervalBased<T> builder=HierarchyBuilderIntervalBased.create(super.getDataType(),new Range<T>(super.getLowerRange().repeat,super.getLowerRange().snap,super.getLowerRange().label),new Range<T>(super.getUpperRange().repeat,super.getUpperRange().snap,super.getUpperRange().label));
  builder.setAggregateFunction(this.getDefaultFunction());
  for (  HierarchyWizardGroupingInterval<T> interval : super.getIntervals()) {
    builder.addInterval(interval.min,interval.max,interval.function);
  }
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}","@Override public HierarchyBuilderIntervalBased<T> getBuilder() throws Exception {
  HierarchyBuilderIntervalBased<T> builder=HierarchyBuilderIntervalBased.create(super.getDataType(),new Range<T>(super.getLowerRange().repeat,super.getLowerRange().snap,super.getLowerRange().label),new Range<T>(super.getUpperRange().repeat,super.getUpperRange().snap,super.getUpperRange().label));
  builder.setAggregateFunction(this.getDefaultFunction());
  for (  HierarchyWizardGroupingInterval<T> interval : super.getIntervals()) {
    builder.addInterval(interval.min,interval.max,interval.function);
  }
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}",0.9893867924528302
108637,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderIntervalBased<T> builder=getBuilder();
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderIntervalBased<T> builder=null;
  try {
    builder=getBuilder();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.6148346738159071
108638,"@Override public HierarchyBuilderOrderBased<T> getBuilder(){
  HierarchyBuilderOrderBased<T> builder=HierarchyBuilderOrderBased.create(super.getDataType(),false);
  builder.setAggregateFunction(this.getDefaultFunction());
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}","@Override public HierarchyBuilderOrderBased<T> getBuilder() throws Exception {
  HierarchyBuilderOrderBased<T> builder=HierarchyBuilderOrderBased.create(super.getDataType(),false);
  builder.setAggregateFunction(this.getDefaultFunction());
  int level=0;
  for (  List<HierarchyWizardGroupingGroup<T>> list : super.getModelGroups()) {
    for (    HierarchyWizardGroupingGroup<T> group : list) {
      builder.getLevel(level).addGroup(group.size,group.function);
    }
    level++;
  }
  return builder;
}",0.9818548387096774
108639,"@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderOrderBased<T> builder=getBuilder();
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}","@Override protected void build(){
  super.hierarchy=null;
  super.error=null;
  super.groupsizes=null;
  HierarchyBuilderOrderBased<T> builder=null;
  try {
    builder=getBuilder();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  String error=builder.isValid();
  if (error != null) {
    super.error=error;
    return;
  }
  try {
    super.groupsizes=builder.prepare(data);
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
  try {
    super.hierarchy=builder.build();
  }
 catch (  Exception e) {
    super.error=e.getMessage();
    return;
  }
}",0.6127583108715184
108640,"@Override public void update(){
  if (model.getError() != null) {
    this.setErrorMessage(model.getError());
    finalPage.setGroups(null);
    finalPage.setHierarchy(null);
    this.setPageComplete(false);
  }
 else {
    this.setErrorMessage(null);
    finalPage.setGroups(model.getGroups());
    finalPage.setHierarchy(model.getHierarchy());
    this.setPageComplete(true);
  }
}","@Override public void update(){
  if (model.getError() != null) {
    this.setErrorMessage(model.getError());
    finalPage.setGroups(null);
    finalPage.setHierarchy(null);
    this.setPageComplete(false);
    Button save=this.wizard.getSaveButton();
    if (save != null)     save.setEnabled(false);
  }
 else {
    this.setErrorMessage(null);
    finalPage.setGroups(model.getGroups());
    finalPage.setHierarchy(model.getHierarchy());
    this.setPageComplete(true);
    Button save=this.wizard.getSaveButton();
    if (save != null)     save.setEnabled(true);
  }
}",0.8020942408376963
108641,"/** 
 * Create a tab
 * @param tabFolder
 */
private void createGeneralTab(CTabFolder tabFolder){
  CTabItem tabItem1=new CTabItem(tabFolder,SWT.NULL);
  tabItem1.setText(""String_Node_Str"");
  Composite parent=new Composite(tabFolder,SWT.NULL);
  parent.setLayout(SWTUtil.createGridLayout(2,false));
  parent.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  HierarchyWizardEditorFunction<T> editor=new HierarchyWizardEditorFunction<T>(this,model,parent,true);
  editor.setFunction(model.getDefaultFunction());
  tabItem1.setControl(parent);
}","/** 
 * Create a tab
 * @param tabFolder
 */
private void createGeneralTab(CTabFolder tabFolder){
  CTabItem tabItem1=new CTabItem(tabFolder,SWT.NULL);
  tabItem1.setText(""String_Node_Str"");
  Composite parent=new Composite(tabFolder,SWT.NULL);
  parent.setLayout(SWTUtil.createGridLayout(2,false));
  parent.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  editor=new HierarchyWizardEditorFunction<T>(this,model,parent,true);
  editor.setFunction(model.getDefaultFunction());
  tabItem1.setControl(parent);
}",0.9449112978524744
108642,"@Override public void setFunction(AggregateFunction<T> function){
  model.setDefaultFunction(function);
  model.update();
}","@Override public void setFunction(AggregateFunction<T> function){
  model.setDefaultFunction(function);
  editor.setFunction(function);
  model.update();
}",0.8848920863309353
108643,"@Override public void updatePage(){
  model.update();
}","@Override public void updatePage(){
  model.update();
  if (editor != null)   editor.setFunction(model.getDefaultFunction());
}",0.6043956043956044
108644,"@Override public void createControl(final Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(1,false));
  @SuppressWarnings(""String_Node_Str"") HierarchyWizardEditor<Long> component=new HierarchyWizardEditor<Long>(composite,(HierarchyWizardModelGrouping<Long>)model);
  component.setLayoutData(SWTUtil.createFillGridData());
  setControl(composite);
}","@Override public void createControl(final Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(SWTUtil.createGridLayout(1,false));
  editor=new HierarchyWizardEditor<T>(composite,(HierarchyWizardModelGrouping<T>)model);
  editor.setLayoutData(SWTUtil.createFillGridData());
  setControl(composite);
}",0.80946123521682
108645,"@Override public void updatePage(){
  list.setRedraw(false);
  list.removeAll();
  for (  String s : model.getData()) {
    list.add(s);
  }
  list.setRedraw(true);
  combo.select(getIndexOfDataType(model.getDataType()));
  model.update();
}","@Override public void updatePage(){
  list.setRedraw(false);
  list.removeAll();
  for (  String s : model.getData()) {
    list.add(s);
  }
  list.setRedraw(true);
  combo.select(getIndexOfDataType(model.getDataType()));
  if (editor != null)   editor.setFunction(model.getDefaultFunction());
  model.update();
}",0.8700361010830325
108646,"/** 
 * Create the grouping-part of the page
 * @param parent
 */
@SuppressWarnings(""String_Node_Str"") private void createGroups(Composite parent){
  Group composite=new Group(parent,SWT.NONE);
  composite.setText(""String_Node_Str"");
  composite.setLayout(SWTUtil.createGridLayout(1,false));
  composite.setLayoutData(SWTUtil.createFillGridData());
  editor=new HierarchyWizardEditor<Long>(composite,(HierarchyWizardModelGrouping<Long>)model);
  editor.setLayoutData(SWTUtil.createFillGridData());
}","/** 
 * Create the grouping-part of the page
 * @param parent
 */
private void createGroups(Composite parent){
  Group composite=new Group(parent,SWT.NONE);
  composite.setText(""String_Node_Str"");
  composite.setLayout(SWTUtil.createGridLayout(1,false));
  composite.setLayoutData(SWTUtil.createFillGridData());
  editor=new HierarchyWizardEditor<T>(composite,(HierarchyWizardModelGrouping<T>)model);
  editor.setLayoutData(SWTUtil.createFillGridData());
}",0.9047120418848168
108647,"/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditor(Composite parent,HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.composite=new Composite(parent,SWT.NONE);
  this.composite.setLayoutData(SWTUtil.createFillGridData());
  this.composite.setLayout(SWTUtil.createGridLayout(1));
  this.scrolledcomposite=new ScrolledComposite(composite,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
  this.scrolledcomposite.setMinSize(200,200);
  this.scrolledcomposite.setExpandHorizontal(true);
  this.scrolledcomposite.setExpandVertical(true);
  this.scrolledcomposite.setLayoutData(SWTUtil.createFillGridData());
  this.canvascomposite=new Composite(scrolledcomposite,SWT.NONE);
  this.scrolledcomposite.setContent(canvascomposite);
  this.canvascomposite.addPaintListener(new PaintListener(){
    @Override public void paintControl(    PaintEvent e){
      paint(e.gc);
    }
  }
);
  this.canvascomposite.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (HierarchyWizardEditor.this.model.getRenderer().select(arg0.x,arg0.y)) {
        HierarchyWizardEditor.this.model.update(HierarchyWizardEditor.this);
        canvascomposite.redraw();
        Object selected=HierarchyWizardEditor.this.model.getSelectedElement();
        if (selected instanceof HierarchyWizardGroupingInterval) {
          if (HierarchyWizardEditor.this.model.isShowIntervals())           folder.setSelection(2);
        }
 else         if (selected instanceof HierarchyWizardGroupingGroup) {
          if (HierarchyWizardEditor.this.model.isShowIntervals())           folder.setSelection(3);
 else           folder.setSelection(1);
        }
      }
      if ((arg0.stateMask & SWT.BUTTON3) != 0 && HierarchyWizardEditor.this.model.getSelectedElement() != null) {
        menu.show(arg0.x,arg0.y);
      }
    }
  }
);
  this.menu=new HierarchyWizardEditorMenu<T>(composite,model);
  this.folder=new CTabFolder(composite,SWT.BORDER);
  this.folder.setSimple(false);
  this.folder.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.createGeneralTab(folder);
  if (model.isShowIntervals())   this.createRangeTab(folder);
  if (model.isShowIntervals())   this.createIntervalTab(folder);
  this.createGroupTab(folder);
  this.folder.setSelection(0);
  this.model.update();
}","/** 
 * Creates a new instance
 * @param parent
 * @param model
 */
public HierarchyWizardEditor(Composite parent,HierarchyWizardModelGrouping<T> model){
  this.model=model;
  this.model.register(this);
  this.composite=new Composite(parent,SWT.NONE);
  this.composite.setLayoutData(SWTUtil.createFillGridData());
  this.composite.setLayout(SWTUtil.createGridLayout(1));
  this.scrolledcomposite=new ScrolledComposite(composite,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
  this.scrolledcomposite.setMinSize(200,200);
  this.scrolledcomposite.setExpandHorizontal(true);
  this.scrolledcomposite.setExpandVertical(true);
  this.scrolledcomposite.setLayoutData(SWTUtil.createFillGridData());
  this.canvascomposite=new Composite(scrolledcomposite,SWT.NONE);
  this.scrolledcomposite.setContent(canvascomposite);
  this.canvascomposite.addPaintListener(new PaintListener(){
    @Override public void paintControl(    PaintEvent e){
      paint(e.gc);
    }
  }
);
  this.canvascomposite.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent arg0){
      if (HierarchyWizardEditor.this.model.getRenderer().select(arg0.x,arg0.y)) {
        HierarchyWizardEditor.this.model.update(HierarchyWizardEditor.this);
        canvascomposite.redraw();
        Object selected=HierarchyWizardEditor.this.model.getSelectedElement();
        if (selected instanceof HierarchyWizardGroupingInterval) {
          if (HierarchyWizardEditor.this.model.isShowIntervals())           folder.setSelection(2);
        }
 else         if (selected instanceof HierarchyWizardGroupingGroup) {
          if (HierarchyWizardEditor.this.model.isShowIntervals())           folder.setSelection(3);
 else           folder.setSelection(1);
        }
      }
      if ((arg0.stateMask & SWT.BUTTON3) != 0 && HierarchyWizardEditor.this.model.getSelectedElement() != null) {
        menu.show(arg0.x,arg0.y);
      }
    }
  }
);
  this.menu=new HierarchyWizardEditorMenu<T>(canvascomposite,model);
  this.folder=new CTabFolder(composite,SWT.BORDER);
  this.folder.setSimple(false);
  this.folder.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  this.createGeneralTab(folder);
  if (model.isShowIntervals())   this.createRangeTab(folder);
  if (model.isShowIntervals())   this.createIntervalTab(folder);
  this.createGroupTab(folder);
  this.folder.setSelection(0);
  this.model.update();
}",0.9987442444537464
108648,"/** 
 * Returns a generalization hierarchy for the attribute, if available
 * @param context
 * @param attribute
 * @return
 */
public Hierarchy getHierarchy(Context context,String attribute){
  if (context.config == model.getInputConfig())   return null;
  AttributeType type=model.getOutputDefinition().getAttributeType(attribute);
  if (type instanceof Hierarchy) {
    return (Hierarchy)type;
  }
  for (  HierarchicalDistanceTCloseness t : context.config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    if (t.getAttribute().equals(attribute)) {
      return t.getHierarchy();
    }
  }
  return null;
}","/** 
 * Returns a generalization hierarchy for the attribute, if available
 * @param context
 * @param attribute
 * @return
 */
public Hierarchy getHierarchy(Context context,String attribute){
  if (context.config == null || context.config == model.getInputConfig() || model.getOutputDefinition() == null) {
    return null;
  }
  AttributeType type=model.getOutputDefinition().getAttributeType(attribute);
  if (type instanceof Hierarchy) {
    return (Hierarchy)type;
  }
  for (  HierarchicalDistanceTCloseness t : context.config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    if (t.getAttribute().equals(attribute)) {
      return t.getHierarchy();
    }
  }
  return null;
}",0.942528735632184
108649,"@Override public Data transformAndMarkOutliers(final Node node){
  currentGroupify.clear();
  currentGroupify=transformer.apply(0L,node.getTransformation(),currentGroupify);
  node.setAnonymous(currentGroupify.isAnonymous());
  if (!node.isChecked()) {
    node.setChecked();
    metric.evaluate(node,currentGroupify);
    node.setTagged();
  }
  if (config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  return getBuffer();
}","@Override public Data transformAndMarkOutliers(final Node node){
  currentGroupify.clear();
  currentGroupify=transformer.apply(0L,node.getTransformation(),currentGroupify);
  node.setAnonymous(currentGroupify.isAnonymous());
  node.setChecked();
  node.setTagged();
  if (node.getInformationLoss() == null) {
    metric.evaluate(node,currentGroupify);
  }
  if (node.isAnonymous() && config.getAbsoluteMaxOutliers() != 0) {
    currentGroupify.markOutliers(transformer.getBuffer());
  }
  return getBuffer();
}",0.8502024291497976
108650,"@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  double value=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (m.isNotOutlier) {
      value+=((double)m.count * (double)m.count);
    }
 else {
      value+=((double)rowCount * (double)m.count);
    }
    m=m.nextOrdered;
  }
  return new InformationLossDefault(value);
}","@Override protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final boolean anonymous=node.isAnonymous();
  double value=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!anonymous || m.isNotOutlier) {
      value+=((double)m.count * (double)m.count);
    }
 else {
      value+=((double)rowCount * (double)m.count);
    }
    m=m.nextOrdered;
  }
  return new InformationLossDefault(value);
}",0.9299065420560748
108651,"@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final double originalInfoLoss=super.evaluateInternal(node,g).getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}","@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final InformationLossDefault originalInfoLossDefault=super.evaluateInternal(node,g);
  if (!node.isAnonymous())   return originalInfoLossDefault;
  final double originalInfoLoss=originalInfoLossDefault.getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}",0.9217594394706112
108652,"/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    Hierarchy h=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
    if (h == null) {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else {
      out.write(h.getHierarchy());
    }
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e);
  }
}","/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  Hierarchy hierarchy=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
  if (hierarchy == null || hierarchy.getHierarchy() == null || hierarchy.getHierarchy().length == 0 || hierarchy.getHierarchy()[0].length == 0) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    out.write(hierarchy.getHierarchy());
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e);
  }
}",0.6938037087290818
108653,"/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  if (false) {
    DataType<?> type=model.getInputConfig().getInput().getDefinition().getDataType(attr);
    org.deidentifier.arx.gui.view.impl.menu.hierarchy.HierarchyWizard<?> wizard=new org.deidentifier.arx.gui.view.impl.menu.hierarchy.HierarchyWizard(this,attr,type,model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
    wizard.open(main.getShell());
    return;
  }
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    Hierarchy hierarchy=i.getModel().getHierarchy();
    if (hierarchy != null) {
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}","/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  if (true) {
    DataType<?> type=model.getInputConfig().getInput().getDefinition().getDataType(attr);
    org.deidentifier.arx.gui.view.impl.menu.hierarchy.HierarchyWizard<?> wizard=new org.deidentifier.arx.gui.view.impl.menu.hierarchy.HierarchyWizard(this,attr,type,model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
    wizard.open(main.getShell());
    return;
  }
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    Hierarchy hierarchy=i.getModel().getHierarchy();
    if (hierarchy != null) {
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.9977714103788602
108654,"/** 
 * Creates a new instance for the given data type
 * @param dataType
 * @param data
 */
public HierarchyWizardModel(DataType<T> dataType,String[] data){
  this.data=data;
  this.dataType=dataType;
  orderModel=new HierarchyWizardModelOrder<T>(dataType,getOrderData());
  if (dataType instanceof DataTypeWithRatioScale) {
    intervalModel=new HierarchyWizardModelInterval<T>(dataType,data);
  }
  redactionModel=new HierarchyWizardModelRedaction<T>(dataType,data);
  if (equals(dataType,DataType.DATE)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.DECIMAL)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.INTEGER)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.ORDERED_STRING)) {
    this.type=Type.ORDER_BASED;
  }
 else   if (equals(dataType,DataType.STRING)) {
    this.type=Type.REDACTION_BASED;
  }
  if (data != null && dataType instanceof DataTypeWithRatioScale) {
    @SuppressWarnings(""String_Node_Str"") DataTypeWithRatioScale<T> dataTypeWRS=(DataTypeWithRatioScale<T>)dataType;
    T min=null;
    T max=null;
    for (    String date : data) {
      T value=dataTypeWRS.parse(date);
      if (min == null || dataTypeWRS.compare(value,min) < 0)       min=value;
      if (max == null || dataTypeWRS.compare(value,max) > 0)       max=value;
    }
    this.intervalModel.getLowerRange().label=min;
    this.intervalModel.getLowerRange().repeat=min;
    this.intervalModel.getLowerRange().snap=min;
    this.intervalModel.getUpperRange().label=max;
    this.intervalModel.getUpperRange().repeat=max;
    this.intervalModel.getUpperRange().snap=max;
  }
}","/** 
 * Creates a new instance for the given data type
 * @param dataType
 * @param data
 */
public HierarchyWizardModel(DataType<T> dataType,String[] data){
  this.data=data;
  this.dataType=dataType;
  orderModel=new HierarchyWizardModelOrder<T>(dataType,getOrderData());
  if (dataType instanceof DataTypeWithRatioScale) {
    intervalModel=new HierarchyWizardModelInterval<T>(dataType,data);
  }
  redactionModel=new HierarchyWizardModelRedaction<T>(dataType,data);
  if (equals(dataType,DataType.DATE)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.DECIMAL)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.INTEGER)) {
    this.type=Type.INTERVAL_BASED;
  }
 else   if (equals(dataType,DataType.ORDERED_STRING)) {
    this.type=Type.ORDER_BASED;
  }
 else   if (equals(dataType,DataType.STRING)) {
    this.type=Type.REDACTION_BASED;
  }
}",0.705607476635514
108655,"/** 
 * Update all UI components, apart from the sender
 * @param sender
 */
public void update(HierarchyWizardView sender){
  renderer.update();
  for (  HierarchyWizardView c : components) {
    if (c != sender) {
      c.update();
    }
  }
}","/** 
 * Update all UI components, apart from the sender
 * @param sender
 */
public void update(HierarchyWizardView sender){
  super.update();
  renderer.update();
  for (  HierarchyWizardView c : components) {
    if (c != sender) {
      c.update();
    }
  }
}",0.9645669291338582
108656,"@Override public void update(){
  if (model.getError() != null) {
    this.setErrorMessage(model.getError());
    this.setPageComplete(false);
  }
 else {
    this.setErrorMessage(null);
    finalPage.setGroups(model.getGroups());
    finalPage.setHierarchy(model.getHierarchy());
    this.setPageComplete(true);
  }
}","@Override public void update(){
  if (model.getError() != null) {
    this.setErrorMessage(model.getError());
    finalPage.setGroups(null);
    finalPage.setHierarchy(null);
    this.setPageComplete(false);
  }
 else {
    this.setErrorMessage(null);
    finalPage.setGroups(model.getGroups());
    finalPage.setHierarchy(model.getHierarchy());
    this.setPageComplete(true);
  }
}",0.9072753209700428
108657,"/** 
 * File->export data
 */
public void actionMenuFileExportData(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getOutput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getOutputNode().isAnonymous() != Anonymity.ANONYMOUS) {
    if (!main.showQuestionDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""))) {
      return;
    }
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  final WorkerExport worker=new WorkerExport(file,model.getSeparator(),model.getOutput(),model.getOutputConfig().getConfig(),model.getInputBytes());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
}","/** 
 * File->export data
 */
public void actionMenuFileExportData(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getOutput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getOutputNode().isAnonymous() != Anonymity.ANONYMOUS) {
    if (!main.showQuestionDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""))) {
      return;
    }
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  final WorkerExport worker=new WorkerExport(file,model.getSeparator(),model.getOutput(),model.getOutputConfig().getConfig(),model.getInputBytes());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
}",0.9836867862969004
108658,"/** 
 * Shows an error dialog
 * @param header
 * @param text
 */
public void actionShowErrorDialog(final Shell shell,final String header,final String text,final Throwable t){
  main.showErrorDialog(shell,header,text,t);
}","/** 
 * Shows an error dialog
 * @param header
 * @param text
 */
public void actionShowErrorDialog(final Shell shell,final String text,final Throwable t){
  main.showErrorDialog(shell,text,t);
}",0.935251798561151
108659,"/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private Hierarchy actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  Throwable error) {
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
  }
  return null;
}","/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private Hierarchy actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  Throwable error) {
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),error);
    }
  }
  return null;
}",0.9721059972105998
108660,"/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showInfoDialog(main.getShell(),""String_Node_Str"",e.getMessage());
  }
}","/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showInfoDialog(main.getShell(),""String_Node_Str"",e.getMessage());
  }
}",0.9839098954143202
108661,"/** 
 * Internal method for saving a project
 */
private void actionSaveProject(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final WorkerSave worker=new WorkerSave(model.getPath(),this,model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
}","/** 
 * Internal method for saving a project
 */
private void actionSaveProject(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final WorkerSave worker=new WorkerSave(model.getPath(),this,model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError().getMessage());
    return;
  }
}",0.9439102564102564
108662,"/** 
 * Starts the ""edit settings"" dialog
 */
public void actionMenuEditSettings(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  try {
    final DialogProperties dialog=new DialogProperties(main.getShell(),model);
    dialog.create();
    dialog.open();
    ((IView)main).update(new ModelEvent(this,ModelPart.MODEL,model));
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    getResources().getLogger().info(e);
  }
}","/** 
 * Starts the ""edit settings"" dialog
 */
public void actionMenuEditSettings(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  try {
    final DialogProperties dialog=new DialogProperties(main.getShell(),model);
    dialog.create();
    dialog.open();
    ((IView)main).update(new ModelEvent(this,ModelPart.MODEL,model));
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e);
    getResources().getLogger().info(e);
  }
}",0.952076677316294
108663,"/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}","/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError().getMessage());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
      if (handle.getNumColumns() > 0) {
        String attribute=handle.getAttributeName(0);
        model.setSelectedAttribute(attribute);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attribute));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}",0.9357319417742378
108664,"/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable error=worker.getError();
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
    return;
  }
  reset();
  final Data data=worker.getResult();
  if (model.getOutput() != null) {
    this.actionResetOutput();
  }
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable error=worker.getError();
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),error);
    }
    return;
  }
  reset();
  final Data data=worker.getResult();
  if (model.getOutput() != null) {
    this.actionResetOutput();
  }
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.9914965986394558
108665,"/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(main.getShell(),""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy hierarchy=actionImportHierarchy(path,separator);
    if (hierarchy != null) {
      String attr=model.getSelectedAttribute();
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}","/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(main.getShell(),""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(main.getShell(),""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy hierarchy=actionImportHierarchy(path,separator);
    if (hierarchy != null) {
      String attr=model.getSelectedAttribute();
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.9882972498537156
108666,"/** 
 * Applies the selected transformation
 */
public void actionApplySelectedTransformation(){
  final WorkerTransform worker=new WorkerTransform(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(main.getShell(),""String_Node_Str"",Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  if (worker.getResult() != null) {
    this.model.setOutput(worker.getResult(),model.getSelectedNode());
    this.update(new ModelEvent(this,ModelPart.OUTPUT,worker.getResult()));
    if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
    }
 else {
      this.model.getViewConfig().setMode(Mode.UNSORTED);
    }
    this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
}","/** 
 * Applies the selected transformation
 */
public void actionApplySelectedTransformation(){
  final WorkerTransform worker=new WorkerTransform(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  if (worker.getResult() != null) {
    this.model.setOutput(worker.getResult(),model.getSelectedNode());
    this.update(new ModelEvent(this,ModelPart.OUTPUT,worker.getResult()));
    if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
    }
 else {
      this.model.getViewConfig().setMode(Mode.UNSORTED);
    }
    this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
}",0.9909274193548387
108667,"/** 
 * Pull settings into the criterion
 * @param criterion
 */
public void actionCriterionPull(ModelCriterion criterion){
  List<ModelExplicitCriterion> others=new ArrayList<ModelExplicitCriterion>();
  if (criterion instanceof ModelLDiversityCriterion) {
    for (    ModelLDiversityCriterion other : model.getLDiversityModel().values()) {
      if (!other.equals(criterion) && other.isActive() && other.isEnabled()) {
        others.add((ModelExplicitCriterion)other);
      }
    }
  }
 else   if (criterion instanceof ModelTClosenessCriterion) {
    for (    ModelTClosenessCriterion other : model.getTClosenessModel().values()) {
      if (!other.equals(criterion) && other.isActive() && other.isEnabled()) {
        others.add((ModelExplicitCriterion)other);
      }
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (others.isEmpty()) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  ModelExplicitCriterion element=main.showSelectCriterionDialog(others);
  if (element == null) {
    return;
  }
 else {
    ((ModelExplicitCriterion)criterion).pull(element);
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,criterion));
  }
}","/** 
 * Pull settings into the criterion
 * @param criterion
 */
public void actionCriterionPull(ModelCriterion criterion){
  List<ModelExplicitCriterion> others=new ArrayList<ModelExplicitCriterion>();
  if (criterion instanceof ModelLDiversityCriterion) {
    for (    ModelLDiversityCriterion other : model.getLDiversityModel().values()) {
      if (!other.equals(criterion) && other.isActive() && other.isEnabled()) {
        others.add((ModelExplicitCriterion)other);
      }
    }
  }
 else   if (criterion instanceof ModelTClosenessCriterion) {
    for (    ModelTClosenessCriterion other : model.getTClosenessModel().values()) {
      if (!other.equals(criterion) && other.isActive() && other.isEnabled()) {
        others.add((ModelExplicitCriterion)other);
      }
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (others.isEmpty()) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  ModelExplicitCriterion element=main.showSelectCriterionDialog(others);
  if (element == null) {
    return;
  }
 else {
    ((ModelExplicitCriterion)criterion).pull(element);
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,criterion));
  }
}",0.9964552973611658
108668,"/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    Hierarchy h=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
    if (h == null) {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else {
      out.write(h.getHierarchy());
    }
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
  }
}","/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(main.getShell(),""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    Hierarchy h=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
    if (h == null) {
      main.showInfoDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else {
      out.write(h.getHierarchy());
    }
  }
 catch (  final Exception e) {
    main.showErrorDialog(main.getShell(),Resources.getMessage(""String_Node_Str""),e);
  }
}",0.9829787234042552
108669,"public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    config.getInput().getDefinition().setAttributeType(attr,hierarchy);
    config.getInput().getDefinition().setMinimumGeneralization(attr,min);
    config.getInput().getDefinition().setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    if (hierarchy == null || hierarchy.getHierarchy() == null) {
      hierarchy=Hierarchy.create();
      config.setHierarchy(attr,hierarchy);
    }
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    config.getInput().getDefinition().setAttributeType(attr,hierarchy);
    config.getInput().getDefinition().setMinimumGeneralization(attr,min);
    config.getInput().getDefinition().setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      if (entry.getValue().getVariant() == 1) {
        if (config.getHierarchy(entry.getValue().getAttribute()) == null) {
          config.setHierarchy(entry.getValue().getAttribute(),Hierarchy.create());
        }
      }
      PrivacyCriterion criterion=entry.getValue().getCriterion(this);
      config.addCriterion(criterion);
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9008320215875872
108670,"/** 
 * Constructor for displaying two messages
 * @param parentShell
 * @param controller
 * @param title
 * @param message
 * @param error
 */
public DialogError(final Shell parentShell,final Controller controller,final String message,String error){
  super(parentShell);
  this.message=message;
  this.error=error;
  this.image=controller.getResources().getImage(""String_Node_Str"");
  setTitle(""String_Node_Str"");
  setMessage(message,IMessageProvider.ERROR);
}","/** 
 * Constructor for displaying two messages
 * @param parentShell
 * @param controller
 * @param title
 * @param message
 * @param error
 */
public DialogError(final Shell parentShell,final Controller controller,final String message,String error){
  super(parentShell);
  this.message=message;
  this.error=error;
  this.image=controller.getResources().getImage(""String_Node_Str"");
}",0.90951821386604
108671,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  if (message != null) {
    final Label label=new Label(parent,SWT.NONE);
    label.setText(message.replaceAll(""String_Node_Str"",""String_Node_Str""));
    label.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  }
  if (error != null) {
    final Text text=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.H_SCROLL| SWT.BORDER);
    text.setText(error);
    final GridData d=SWTUtil.createFillGridData();
    d.heightHint=100;
    text.setLayoutData(d);
  }
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final Text text=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.H_SCROLL| SWT.BORDER);
  text.setText(error);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=100;
  text.setLayoutData(d);
  return parent;
}",0.6546227417640808
108672,"@Override protected Control createContents(Composite parent){
  Control contents=super.createContents(parent);
  if (image != null)   setTitleImage(image);
  return contents;
}","@Override protected Control createContents(Composite parent){
  Control contents=super.createContents(parent);
  setTitle(""String_Node_Str"");
  setMessage(message.replaceAll(""String_Node_Str"",""String_Node_Str""),IMessageProvider.ERROR);
  if (image != null)   setTitleImage(image);
  return contents;
}",0.7379454926624738
108673,"@Override public void shellClosed(final ShellEvent event){
  event.doit=false;
}","@Override public void shellClosed(final ShellEvent event){
  setReturnCode(Window.CANCEL);
}",0.8023255813953488
108674,"@Override protected ShellListener getShellListener(){
  return new ShellAdapter(){
    @Override public void shellClosed(    final ShellEvent event){
      event.doit=false;
    }
  }
;
}","@Override protected ShellListener getShellListener(){
  return new ShellAdapter(){
    @Override public void shellClosed(    final ShellEvent event){
      setReturnCode(Window.CANCEL);
    }
  }
;
}",0.911917098445596
108675,"@Override public void shellClosed(final ShellEvent event){
  event.doit=ok.isEnabled();
}","@Override public void shellClosed(final ShellEvent event){
  setReturnCode(Window.CANCEL);
}",0.7955801104972375
108676,"@Override protected ShellListener getShellListener(){
  return new ShellAdapter(){
    @Override public void shellClosed(    final ShellEvent event){
      event.doit=ok.isEnabled();
    }
  }
;
}","@Override protected ShellListener getShellListener(){
  return new ShellAdapter(){
    @Override public void shellClosed(    final ShellEvent event){
      setReturnCode(Window.CANCEL);
    }
  }
;
}",0.9063291139240506
108677,"@Override public void widgetSelected(final SelectionEvent arg0){
  if (combo.getSelectionIndex() >= 0) {
    DataType<?> type=model.getDataType();
    if (combo.getSelectionIndex() > 0) {
      String label=combo.getItem(combo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      if (description.getLabel().equals(""String_Node_Str"")) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,model.getItems().toArray(new String[]{}));
        if (array == null) {
          type=DataType.STRING;
        }
 else {
          type=DataType.createOrderedString(array);
          if (!isValidDataType(type,model.getItems())) {
            type=DataType.STRING;
          }
        }
      }
 else       if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(getShell(),text1,text2,description,model.getItems());
        if (format == null) {
          type=DataType.STRING;
          combo.select(getIndexOfDataType(DataType.STRING) + 1);
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,model.getItems())) {
          type=DataType.STRING;
          combo.select(getIndexOfDataType(DataType.STRING) + 1);
        }
      }
    }
    try {
      sort(type);
    }
 catch (    Exception e) {
      sort(DataType.STRING);
    }
  }
}","@Override public void widgetSelected(final SelectionEvent arg0){
  if (combo.getSelectionIndex() >= 0) {
    DataType<?> type=model.getDataType();
    if (combo.getSelectionIndex() > 0) {
      String label=combo.getItem(combo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      if (description.getLabel().equals(""String_Node_Str"")) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,model.getItems().toArray(new String[]{}));
        if (array == null) {
          type=DataType.STRING;
        }
 else {
          try {
            type=DataType.createOrderedString(array);
            if (!isValidDataType(type,model.getItems())) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
          }
 catch (          Exception e) {
            controller.actionShowInfoDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
            type=DataType.STRING;
            combo.select(getIndexOfDataType(DataType.STRING) + 1);
          }
        }
      }
 else       if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(getShell(),text1,text2,description,model.getItems());
        if (format == null) {
          type=DataType.STRING;
          combo.select(getIndexOfDataType(DataType.STRING) + 1);
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,model.getItems())) {
          type=DataType.STRING;
          combo.select(getIndexOfDataType(DataType.STRING) + 1);
        }
      }
    }
    try {
      sort(type);
    }
 catch (    Exception e) {
      sort(DataType.STRING);
    }
  }
}",0.8371848739495799
108678,"@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  for (  String type : getDataTypes()) {
    combo.add(type);
  }
  combo.select(0);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() >= 0) {
        DataType<?> type=model.getDataType();
        if (combo.getSelectionIndex() > 0) {
          String label=combo.getItem(combo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          if (description.getLabel().equals(""String_Node_Str"")) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,model.getItems().toArray(new String[]{}));
            if (array == null) {
              type=DataType.STRING;
            }
 else {
              type=DataType.createOrderedString(array);
              if (!isValidDataType(type,model.getItems())) {
                type=DataType.STRING;
              }
            }
          }
 else           if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(getShell(),text1,text2,description,model.getItems());
            if (format == null) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,model.getItems())) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
          }
        }
        try {
          sort(type);
        }
 catch (        Exception e) {
          sort(DataType.STRING);
        }
      }
    }
  }
);
  sort(model.getDataType());
  setControl(composite);
}","@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  for (  String type : getDataTypes()) {
    combo.add(type);
  }
  combo.select(0);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() >= 0) {
        DataType<?> type=model.getDataType();
        if (combo.getSelectionIndex() > 0) {
          String label=combo.getItem(combo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          if (description.getLabel().equals(""String_Node_Str"")) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,model.getItems().toArray(new String[]{}));
            if (array == null) {
              type=DataType.STRING;
            }
 else {
              try {
                type=DataType.createOrderedString(array);
                if (!isValidDataType(type,model.getItems())) {
                  type=DataType.STRING;
                  combo.select(getIndexOfDataType(DataType.STRING) + 1);
                }
              }
 catch (              Exception e) {
                controller.actionShowInfoDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
                type=DataType.STRING;
                combo.select(getIndexOfDataType(DataType.STRING) + 1);
              }
            }
          }
 else           if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(getShell(),text1,text2,description,model.getItems());
            if (format == null) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,model.getItems())) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
          }
        }
        try {
          sort(type);
        }
 catch (        Exception e) {
          sort(DataType.STRING);
        }
      }
    }
  }
);
  sort(model.getDataType());
  setControl(composite);
}",0.8048498845265589
108679,"public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    config.getInput().getDefinition().setAttributeType(attr,hierarchy);
    config.setMinimumGeneralization(attr,min);
    config.setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    config.getInput().getDefinition().setAttributeType(attr,hierarchy);
    config.getInput().getDefinition().setMinimumGeneralization(attr,min);
    config.getInput().getDefinition().setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9864116758933064
108680,"/** 
 * Updates the max generalization level
 * @return
 */
private boolean pushMax(){
  if (max.getSelectionIndex() >= 0 && max.getItemCount() > 1) {
    if (max.getSelectionIndex() < (min.getSelectionIndex() - 1)) {
      max.select(min.getSelectionIndex() - 1);
    }
 else {
      if (model != null) {
        String val=max.getItem(max.getSelectionIndex());
        if (val.equals(ITEM_ALL)) {
          model.getInputConfig().setMaximumGeneralization(attribute,null);
        }
 else {
          model.getInputConfig().setMaximumGeneralization(attribute,Integer.valueOf(val) - 1);
        }
        return true;
      }
    }
  }
  return false;
}","/** 
 * Updates the max generalization level
 * @return
 */
private boolean pushMax(){
  if (max.getSelectionIndex() >= 0 && max.getItemCount() > 1) {
    if (max.getSelectionIndex() < (min.getSelectionIndex() - 1)) {
      max.select(min.getSelectionIndex() - 1);
    }
    if (model != null) {
      String val=max.getItem(max.getSelectionIndex());
      if (val.equals(ITEM_ALL)) {
        model.getInputConfig().setMaximumGeneralization(attribute,null);
      }
 else {
        model.getInputConfig().setMaximumGeneralization(attribute,Integer.valueOf(val) - 1);
      }
      return true;
    }
  }
  return false;
}",0.9529042386185244
108681,"/** 
 * Updates the min generalization level
 * @return
 */
private boolean pushMin(){
  if (min.getSelectionIndex() >= 0 && min.getItemCount() > 1) {
    if (min.getSelectionIndex() > (max.getSelectionIndex() + 1)) {
      min.select(max.getSelectionIndex() + 1);
    }
 else {
      if (model != null) {
        String val=min.getItem(min.getSelectionIndex());
        if (val.equals(ITEM_ALL)) {
          model.getInputConfig().setMinimumGeneralization(attribute,null);
        }
 else {
          model.getInputConfig().setMinimumGeneralization(attribute,Integer.valueOf(val) - 1);
        }
        return true;
      }
    }
  }
  return false;
}","/** 
 * Updates the min generalization level
 * @return
 */
private boolean pushMin(){
  if (min.getSelectionIndex() >= 0 && min.getItemCount() > 1) {
    if (min.getSelectionIndex() > (max.getSelectionIndex() + 1)) {
      min.select(max.getSelectionIndex() + 1);
    }
    if (model != null) {
      String val=min.getItem(min.getSelectionIndex());
      if (val.equals(ITEM_ALL)) {
        model.getInputConfig().setMinimumGeneralization(attribute,null);
      }
 else {
        model.getInputConfig().setMinimumGeneralization(attribute,Integer.valueOf(val) - 1);
      }
      return true;
    }
  }
  return false;
}",0.9529042386185244
108682,"@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  if (minimalEquivalenceClassSize == Integer.MAX_VALUE) {
    minimalEquivalenceClassSize=0;
  }
  if (maximalEquivalenceClassSize == Integer.MIN_VALUE) {
    maximalEquivalenceClassSize=0;
  }
  if (numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses == 0) {
    averageEquivalenceClassSize=0;
  }
 else {
    averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  }
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (averageEquivalenceClassSize != 0 && numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
 else {
    averageEquivalenceClassSizeAll=0;
    maximalEquivalenceClassSizeAll=0;
    minimalEquivalenceClassSizeAll=0;
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.891849877859205
108683,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    Hierarchy h=model.getInputConfig().getHierarchy(attribute);
    if (h != null) {
      setHierarchy(h);
      base.setEnabled(true);
      base.redraw();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      updateGlobalHierarchy();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
      updateGlobalHierarchy();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    Hierarchy h=model.getInputConfig().getHierarchy(attribute);
    if (h != null) {
      setHierarchy(h);
      base.setEnabled(true);
      base.redraw();
      updateGlobalHierarchy();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      updateGlobalHierarchy();
    }
  }
}",0.9586666666666668
108684,"/** 
 * Updates the global hierarchy definition
 */
private void updateGlobalHierarchy(){
  updateMinAndMax();
  if (model == null || model.getInputConfig() == null) {
    return;
  }
  final Hierarchy h=Hierarchy.create(hierarchy);
  model.getInputConfig().setHierarchy(attribute,h);
}","/** 
 * Updates the global hierarchy definition
 */
private void updateGlobalHierarchy(){
  updateMinAndMax();
  if (model == null || model.getInputConfig() == null) {
    return;
  }
  final Hierarchy h=Hierarchy.create(hierarchy);
  model.getInputConfig().setHierarchy(attribute,h);
  updateMin();
  updateMax();
}",0.9501661129568106
108685,"/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    Hierarchy hierarchy=i.getModel().getHierarchy();
    if (hierarchy != null) {
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}","/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    Hierarchy hierarchy=i.getModel().getHierarchy();
    if (hierarchy != null) {
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.9397810218978102
108686,"/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy hierarchy=actionImportHierarchy(path,separator);
    if (hierarchy != null) {
      model.getInputConfig().setHierarchy(model.getSelectedAttribute(),hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}","/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy hierarchy=actionImportHierarchy(path,separator);
    if (hierarchy != null) {
      String attr=model.getSelectedAttribute();
      model.getInputConfig().setMaximumGeneralization(attr,null);
      model.getInputConfig().setMinimumGeneralization(attr,null);
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.9325270528325909
108687,"public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    config.getInput().getDefinition().setAttributeType(attr,config.getHierarchy(attr));
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}","public void createCriteriaAndDefinition(ModelConfiguration config){
  config.removeAllCriteria();
  for (  String attr : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
    Hierarchy hierarchy=config.getHierarchy(attr);
    Integer min=config.getMinimumGeneralization(attr);
    Integer max=config.getMaximumGeneralization(attr);
    if (min == null) {
      min=0;
    }
    if (max == null) {
      if (hierarchy.getHierarchy().length == 0) {
        max=0;
      }
 else {
        max=hierarchy.getHierarchy()[0].length - 1;
      }
    }
    config.getInput().getDefinition().setAttributeType(attr,hierarchy);
    config.setMinimumGeneralization(attr,min);
    config.setMaximumGeneralization(attr,max);
  }
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.8498126261170366
108688,"@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input;
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  c.researchSubset=this.getCriterion(DPresence.class).getSubset().getSet();
  return c;
}","@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input;
  c.min=new HashMap<String,Integer>(min);
  c.max=new HashMap<String,Integer>(max);
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  c.researchSubset=this.getCriterion(DPresence.class).getSubset().getSet();
  return c;
}",0.8864864864864865
108689,"/** 
 * Builds all editors for the model
 * @param model
 * @return
 */
private List<IEditor<?>> getEditors(final Model model){
  final List<IEditor<?>> result=new ArrayList<IEditor<?>>();
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      if (s.equals(""String_Node_Str"")) {
        return false;
      }
 else {
        return true;
      }
    }
    @Override public String getValue(){
      return model.getName();
    }
    @Override public void setValue(    final String s){
      model.setName(s);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,true){
    @Override public boolean accepts(    final String s){
      return true;
    }
    @Override public String getValue(){
      return model.getDescription();
    }
    @Override public void setValue(    final String s){
      model.setDescription(s);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      if (s.length() == 1) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override public String getValue(){
      return String.valueOf(model.getSeparator());
    }
    @Override public void setValue(    final String s){
      model.setSeparator(s.toCharArray()[0]);
    }
  }
);
  result.add(new EditorBoolean(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")){
    @Override public Boolean getValue(){
      return model.getInputConfig().isRemoveOutliers();
    }
    @Override public void setValue(    final Boolean t){
      model.getInputConfig().setRemoveOutliers(t);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return true;
    }
    @Override public String getValue(){
      return model.getSuppressionString();
    }
    @Override public void setValue(    final String s){
      model.setSuppressionString(s);
    }
  }
);
  final IntegerValidator v=new IntegerValidator(0,1000001);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaxNodesInLattice());
    }
    @Override public void setValue(    final String s){
      model.setMaxNodesInLattice(Integer.valueOf(s));
    }
  }
);
  final IntegerValidator v2=new IntegerValidator(-1,1001);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v2.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getHistorySize());
    }
    @Override public void setValue(    final String s){
      model.setHistorySize(Integer.valueOf(s));
    }
  }
);
  final DoubleValidator v3=new DoubleValidator(0d,1d);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v3.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getSnapshotSizeDataset());
    }
    @Override public void setValue(    final String s){
      model.setSnapshotSizeDataset(Double.valueOf(s));
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v3.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getSnapshotSizeSnapshot());
    }
    @Override public void setValue(    final String s){
      model.setSnapshotSizeSnapshot(Double.valueOf(s));
    }
  }
);
  final IntegerValidator v5=new IntegerValidator(0,Integer.MAX_VALUE);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v5.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaximalSizeForComplexOperations());
    }
    @Override public void setValue(    final String s){
      model.setMaximalSizeForComplexOperations(Integer.valueOf(s));
    }
  }
);
  result.add(new EditorBoolean(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")){
    @Override public Boolean getValue(){
      return model.isDebugEnabled();
    }
    @Override public void setValue(    final Boolean s){
      model.setDebugEnabled(s);
    }
  }
);
  final IntegerValidator v4=new IntegerValidator(0,10000);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v4.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getInitialNodesInViewer());
    }
    @Override public void setValue(    final String s){
      model.setInitialNodesInViewer(Integer.valueOf(s));
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v4.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaxNodesInViewer());
    }
    @Override public void setValue(    final String s){
      model.setMaxNodesInViewer(Integer.valueOf(s));
    }
  }
);
  return result;
}","/** 
 * Builds all editors for the model
 * @param model
 * @return
 */
private List<IEditor<?>> getEditors(final Model model){
  final List<IEditor<?>> result=new ArrayList<IEditor<?>>();
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      if (s.equals(""String_Node_Str"")) {
        return false;
      }
 else {
        return true;
      }
    }
    @Override public String getValue(){
      return model.getName();
    }
    @Override public void setValue(    final String s){
      model.setName(s);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,true){
    @Override public boolean accepts(    final String s){
      return true;
    }
    @Override public String getValue(){
      return model.getDescription();
    }
    @Override public void setValue(    final String s){
      model.setDescription(s);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      if (s.length() == 1) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override public String getValue(){
      return String.valueOf(model.getSeparator());
    }
    @Override public void setValue(    final String s){
      model.setSeparator(s.toCharArray()[0]);
    }
  }
);
  result.add(new EditorBoolean(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")){
    @Override public Boolean getValue(){
      return model.getInputConfig().isRemoveOutliers();
    }
    @Override public void setValue(    final Boolean t){
      model.getInputConfig().setRemoveOutliers(t);
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return true;
    }
    @Override public String getValue(){
      return model.getSuppressionString();
    }
    @Override public void setValue(    final String s){
      model.setSuppressionString(s);
    }
  }
);
  final IntegerValidator v=new IntegerValidator(0,1000001);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaxNodesInLattice());
    }
    @Override public void setValue(    final String s){
      model.setMaxNodesInLattice(Integer.valueOf(s));
    }
  }
);
  final IntegerValidator v2=new IntegerValidator(0,1000001);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v2.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getHistorySize());
    }
    @Override public void setValue(    final String s){
      model.setHistorySize(Integer.valueOf(s));
    }
  }
);
  final DoubleValidator v3=new DoubleValidator(0d,1d);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v3.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getSnapshotSizeDataset());
    }
    @Override public void setValue(    final String s){
      model.setSnapshotSizeDataset(Double.valueOf(s));
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v3.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getSnapshotSizeSnapshot());
    }
    @Override public void setValue(    final String s){
      model.setSnapshotSizeSnapshot(Double.valueOf(s));
    }
  }
);
  final IntegerValidator v5=new IntegerValidator(0,Integer.MAX_VALUE);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v5.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaximalSizeForComplexOperations());
    }
    @Override public void setValue(    final String s){
      model.setMaximalSizeForComplexOperations(Integer.valueOf(s));
    }
  }
);
  result.add(new EditorBoolean(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"")){
    @Override public Boolean getValue(){
      return model.isDebugEnabled();
    }
    @Override public void setValue(    final Boolean s){
      model.setDebugEnabled(s);
    }
  }
);
  final IntegerValidator v4=new IntegerValidator(0,10000);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v4.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getInitialNodesInViewer());
    }
    @Override public void setValue(    final String s){
      model.setInitialNodesInViewer(Integer.valueOf(s));
    }
  }
);
  result.add(new EditorString(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),ok,false){
    @Override public boolean accepts(    final String s){
      return v4.validate(s);
    }
    @Override public String getValue(){
      return String.valueOf(model.getMaxNodesInViewer());
    }
    @Override public void setValue(    final String s){
      model.setMaxNodesInViewer(Integer.valueOf(s));
    }
  }
);
  return result;
}",0.9995007488766848
108690,"@Override public void widgetSelected(final SelectionEvent arg0){
  if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
    if ((model != null) && (model.getInputConfig().getInput() != null)) {
      String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      DataType<?> type;
      if (description.getLabel().equals(""String_Node_Str"")) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,getValuesAsArray());
        if (array == null) {
          type=DataType.STRING;
        }
 else {
          type=DataType.createOrderedString(array);
          if (!isValidDataType(type,getValuesAsList())) {
            type=DataType.STRING;
          }
        }
      }
 else       if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(controller.getResources().getShell(),text1,text2,description,getValuesAsList());
        if (format == null) {
          type=DataType.STRING;
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,getValuesAsList())) {
          type=DataType.STRING;
        }
      }
      model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
      updateDataType();
      controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
    }
  }
}","@Override public void widgetSelected(final SelectionEvent arg0){
  if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
    if ((model != null) && (model.getInputConfig().getInput() != null)) {
      String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      DataType<?> type;
      if (description.getLabel().equals(""String_Node_Str"")) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,getValuesAsArray());
        if (array == null) {
          type=DataType.STRING;
        }
 else {
          try {
            type=DataType.createOrderedString(array);
            if (!isValidDataType(type,getValuesAsList())) {
              type=DataType.STRING;
            }
          }
 catch (          Exception e) {
            controller.actionShowInfoDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
            type=DataType.STRING;
          }
        }
      }
 else       if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(controller.getResources().getShell(),text1,text2,description,getValuesAsList());
        if (format == null) {
          type=DataType.STRING;
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,getValuesAsList())) {
          type=DataType.STRING;
        }
      }
      model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
      updateDataType();
      controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
    }
  }
}",0.6923488496522204
108691,"/** 
 * Constructor
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=6;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          boolean criteriaDisabled=false;
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            if (model.getLDiversityModel().get(attribute).isEnabled() || model.getTClosenessModel().get(attribute).isEnabled()) {
              criteriaDisabled=true;
            }
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            if (model.getKAnonymityModel().isEnabled() || model.getDPresenceModel().isEnabled()) {
              criteriaDisabled=true;
            }
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
            model.getKAnonymityModel().setEnabled(false);
            model.getDPresenceModel().setEnabled(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          if (criteriaDisabled) {
            controller.update(new ModelEvent(outer,ModelPart.CRITERION_DEFINITION,null));
          }
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(getDataTypes());
  dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          DataType<?> type;
          if (description.getLabel().equals(""String_Node_Str"")) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,getValuesAsArray());
            if (array == null) {
              type=DataType.STRING;
            }
 else {
              type=DataType.createOrderedString(array);
              if (!isValidDataType(type,getValuesAsList())) {
                type=DataType.STRING;
              }
            }
          }
 else           if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(controller.getResources().getShell(),text1,text2,description,getValuesAsList());
            if (format == null) {
              type=DataType.STRING;
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,getValuesAsList())) {
              type=DataType.STRING;
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          updateDataType();
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel3=new Label(type,SWT.PUSH);
  kLabel3.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeText=new Text(type,SWT.READ_ONLY | SWT.BORDER);
  dataTypeText.setLayoutData(SWTUtil.createFillGridData());
  dataTypeText.setEditable(false);
  dataTypeText.setText(""String_Node_Str"");
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}","/** 
 * Constructor
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=6;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          boolean criteriaDisabled=false;
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            if (model.getLDiversityModel().get(attribute).isEnabled() || model.getTClosenessModel().get(attribute).isEnabled()) {
              criteriaDisabled=true;
            }
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            if (model.getKAnonymityModel().isEnabled() || model.getDPresenceModel().isEnabled()) {
              criteriaDisabled=true;
            }
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
            model.getKAnonymityModel().setEnabled(false);
            model.getDPresenceModel().setEnabled(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          if (criteriaDisabled) {
            controller.update(new ModelEvent(outer,ModelPart.CRITERION_DEFINITION,null));
          }
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(getDataTypes());
  dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          DataType<?> type;
          if (description.getLabel().equals(""String_Node_Str"")) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            String[] array=controller.actionShowOrderValuesDialog(text1,text2,DataType.STRING,getValuesAsArray());
            if (array == null) {
              type=DataType.STRING;
            }
 else {
              try {
                type=DataType.createOrderedString(array);
                if (!isValidDataType(type,getValuesAsList())) {
                  type=DataType.STRING;
                }
              }
 catch (              Exception e) {
                controller.actionShowInfoDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
                type=DataType.STRING;
              }
            }
          }
 else           if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(controller.getResources().getShell(),text1,text2,description,getValuesAsList());
            if (format == null) {
              type=DataType.STRING;
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,getValuesAsList())) {
              type=DataType.STRING;
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          updateDataType();
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel3=new Label(type,SWT.PUSH);
  kLabel3.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeText=new Text(type,SWT.READ_ONLY | SWT.BORDER);
  dataTypeText.setLayoutData(SWTUtil.createFillGridData());
  dataTypeText.setEditable(false);
  dataTypeText.setText(""String_Node_Str"");
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}",0.9822520507084266
108692,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.9650492025788938
108693,"/** 
 * @param output the output to set
 */
public void setOutput(final DataHandle output,final ARXNode node){
  this.output=output;
  this.outputNode=node;
  if (node != null) {
    outputNodeAsString=Arrays.toString(node.getTransformation());
  }
  setModified();
}","/** 
 * @param output the output to set
 */
public void setOutput(final DataHandle output,final ARXNode node){
  this.output=output;
  this.outputNode=node;
  if (node != null) {
    outputNodeAsString=Arrays.toString(node.getTransformation());
  }
 else {
    outputNodeAsString=null;
  }
  setModified();
}",0.928695652173913
108694,"/** 
 * Creates the design of this page This adds all the controls to the page along with their listeners. It basically waits for any radio button to be pressed, which will mark the page as completed and lets the user proceed to the next page.
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(1,false));
  btnCsv=new Button(container,SWT.RADIO);
  btnCsv.setText(""String_Node_Str"");
  btnCsv.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.CSV);
      setPageComplete(true);
    }
  }
);
  btnExcel=new Button(container,SWT.RADIO);
  btnExcel.setText(""String_Node_Str"");
  btnExcel.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.EXCEL);
      setPageComplete(true);
    }
  }
);
  btnJdbc=new Button(container,SWT.RADIO);
  btnJdbc.setEnabled(false);
  btnJdbc.setText(""String_Node_Str"");
  btnJdbc.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.JDBC);
      setPageComplete(true);
    }
  }
);
  setPageComplete(false);
}","/** 
 * Creates the design of this page This adds all the controls to the page along with their listeners. It basically waits for any radio button to be pressed, which will mark the page as completed and lets the user proceed to the next page.
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(1,false));
  btnCsv=new Button(container,SWT.RADIO);
  btnCsv.setText(""String_Node_Str"");
  btnCsv.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.CSV);
      setPageComplete(true);
    }
  }
);
  btnExcel=new Button(container,SWT.RADIO);
  btnExcel.setText(""String_Node_Str"");
  btnExcel.setEnabled(false);
  btnExcel.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.EXCEL);
      setPageComplete(true);
    }
  }
);
  btnJdbc=new Button(container,SWT.RADIO);
  btnJdbc.setEnabled(false);
  btnJdbc.setText(""String_Node_Str"");
  btnJdbc.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      wizardImport.getData().setSourceType(SourceType.JDBC);
      setPageComplete(true);
    }
  }
);
  setPageComplete(false);
}",0.9893541518807664
108695,"/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss> max;
  final Map<Integer,InformationLoss> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss>)oos.readObject();
  max=(Map<Integer,InformationLoss>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[0][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}","/** 
 * Reads the lattice from several files
 * @param zip
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
@SuppressWarnings({""String_Node_Str""}) private Map<String,ARXNode> readLattice(final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  ZipEntry entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    return null;
  }
  final Map<Integer,InformationLoss> max;
  final Map<Integer,InformationLoss> min;
  ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  min=(Map<Integer,InformationLoss>)oos.readObject();
  max=(Map<Integer,InformationLoss>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,Map<Integer,Object>> attrs;
  oos=new ObjectInputStream(zip.getInputStream(entry));
  attrs=(Map<Integer,Map<Integer,Object>>)oos.readObject();
  oos.close();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  oos=new ObjectInputStream(zip.getInputStream(entry));
  lattice=(ARXLattice)oos.readObject();
  final Map<String,Integer> headermap=(Map<String,Integer>)oos.readObject();
  oos.close();
  final Map<Integer,List<ARXNode>> levels=new HashMap<Integer,List<ARXNode>>();
  entry=zip.getEntry(""String_Node_Str"");
  if (entry == null) {
    throw new IOException(Resources.getMessage(""String_Node_Str""));
  }
  final Map<Integer,ARXNode> map=new HashMap<Integer,ARXNode>();
  XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int level=0;
    private int id=0;
    private int[] transformation;
    private Anonymity anonymity;
    private boolean checked;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName) || vocabulary.isLevel(localName) || vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        final ARXNode node=lattice.new ARXNode();
        node.access().setAnonymity(anonymity);
        node.access().setChecked(checked);
        node.access().setTransformation(transformation);
        node.access().setMaximumInformationLoss(max.get(id));
        node.access().setMinimumInformationLoss(min.get(id));
        node.access().setAttributes(attrs.get(id));
        node.access().setHeadermap(headermap);
        levels.get(level).add(node);
        map.put(id,node);
        return true;
      }
 else       if (vocabulary.isTransformation(localName)) {
        transformation=readTransformation(payload);
        return true;
      }
 else       if (vocabulary.isAnonymity(localName)) {
        anonymity=Anonymity.valueOf(payload);
        return true;
      }
 else       if (vocabulary.isChecked(localName)) {
        checked=Boolean.valueOf(payload);
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        level=Integer.valueOf(attributes.getValue(vocabulary.getDepth()));
        if (!levels.containsKey(level)) {
          levels.put(level,new ArrayList<ARXNode>());
        }
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  entry=zip.getEntry(""String_Node_Str"");
  xmlReader=XMLReaderFactory.createXMLReader();
  inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    private int id;
    private final List<ARXNode> predecessors=new ArrayList<ARXNode>();
    private final List<ARXNode> successors=new ArrayList<ARXNode>();
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isLattice(localName)) {
        return true;
      }
 else       if (vocabulary.isLevel(localName)) {
        return true;
      }
 else       if (vocabulary.isNode2(localName)) {
        map.get(id).access().setPredecessors(predecessors.toArray(new ARXNode[predecessors.size()]));
        map.get(id).access().setSuccessors(successors.toArray(new ARXNode[successors.size()]));
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isAnonymity(localName) || vocabulary.isChecked(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else       if (vocabulary.isPredecessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            predecessors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isSuccessors(localName)) {
        final String[] a=payload.trim().split(""String_Node_Str"");
        for (        final String s : a) {
          final String b=s.trim();
          if (!b.equals(""String_Node_Str"")) {
            successors.add(map.get(Integer.valueOf(b)));
          }
        }
        return true;
      }
 else       if (vocabulary.isAttribute(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isNode2(localName)) {
        id=Integer.valueOf(attributes.getValue(vocabulary.getId()));
        successors.clear();
        predecessors.clear();
        return true;
      }
 else       if (vocabulary.isTransformation(localName) || vocabulary.isLattice(localName) || vocabulary.isLevel(localName)|| vocabulary.isAnonymity(localName)|| vocabulary.isChecked(localName)|| vocabulary.isPredecessors(localName)|| vocabulary.isSuccessors(localName)|| vocabulary.isAttribute(localName)|| vocabulary.isInfoloss(localName)|| vocabulary.isMax2(localName)|| vocabulary.isMin2(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
  int bottomLevel=Integer.MAX_VALUE;
  final ARXNode[][] llevels=new ARXNode[levels.size()][];
  for (  final Entry<Integer,List<ARXNode>> e : levels.entrySet()) {
    llevels[e.getKey()]=e.getValue().toArray(new ARXNode[]{});
    if (!e.getValue().isEmpty()) {
      bottomLevel=Math.min(e.getKey(),bottomLevel);
    }
  }
  lattice.access().setLevels(llevels);
  lattice.access().setBottom(llevels[bottomLevel][0]);
  lattice.access().setTop(llevels[llevels.length - 1][0]);
  final Map<String,ARXNode> result=new HashMap<String,ARXNode>();
  for (  final List<ARXNode> e : levels.values()) {
    for (    final ARXNode node : e) {
      result.put(Arrays.toString(node.getTransformation()),node);
    }
  }
  return result;
}",0.991047787164292
108696,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    final DataDefinition d=model.getInputConfig().getInput().getDefinition();
    final AttributeType type=d.getAttributeType(attribute);
    if (type instanceof Hierarchy) {
      setHierarchy((Hierarchy)type);
      base.setEnabled(true);
      base.redraw();
    }
 else     if ((type == AttributeType.SENSITIVE_ATTRIBUTE) && (model.getInputConfig().getHierarchy(attribute) != null)) {
      setHierarchy(model.getInputConfig().getHierarchy(attribute));
      base.setEnabled(true);
      base.redraw();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      updateGlobalHierarchy();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    Hierarchy h=model.getInputConfig().getHierarchy(attribute);
    if (h != null) {
      setHierarchy(h);
      base.setEnabled(true);
      base.redraw();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      updateGlobalHierarchy();
    }
  }
}",0.7241186345831002
108697,"/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          Hierarchy hierarchy=config.getHierarchy(attr);
          if (hierarchy == null) {
            try {
              hierarchy=readHierarchy(zip,prefix,ref);
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
          config.getInput().getDefinition().setAttributeType(attr,hierarchy);
          config.setHierarchy(attr,hierarchy);
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          Hierarchy hierarchy=config.getHierarchy(attr);
          if (hierarchy == null) {
            try {
              hierarchy=readHierarchy(zip,prefix,ref);
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
            System.out.print(""String_Node_Str"");
          }
 else {
            System.out.print(""String_Node_Str"");
          }
          System.out.println(hierarchy.getHierarchy()[0].length);
          config.getInput().getDefinition().setAttributeType(attr,hierarchy);
          config.setHierarchy(attr,hierarchy);
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.984118764025548
108698,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  if (message != null) {
    final Label label=new Label(parent,SWT.NONE);
    label.setText(message);
    final GridData d=SWTUtil.createFillHorizontallyGridData();
    d.heightHint=20;
    label.setLayoutData(d);
  }
  if (error != null) {
    final Text text=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.H_SCROLL| SWT.BORDER);
    text.setText(error);
    final GridData d=SWTUtil.createFillGridData();
    d.heightHint=100;
    text.setLayoutData(d);
  }
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  if (message != null) {
    final Label label=new Label(parent,SWT.NONE);
    label.setText(message.replaceAll(""String_Node_Str"",""String_Node_Str""));
    label.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  }
  if (error != null) {
    final Text text=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.H_SCROLL| SWT.BORDER);
    text.setText(error);
    final GridData d=SWTUtil.createFillGridData();
    d.heightHint=100;
    text.setLayoutData(d);
  }
  return parent;
}",0.883876357560568
108699,"/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private AttributeType actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
  }
  return null;
}","/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private AttributeType actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  Throwable error) {
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
  }
  return null;
}",0.7133872416891285
108700,"/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable error=worker.getError();
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.9373571101966164
108701,"/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    final DialogSeparator dialog=new DialogSeparator(main.getShell(),this,path,false);
    dialog.create();
    if (dialog.open() == Window.CANCEL) {
      return;
    }
 else {
      final char separator=dialog.getSeparator();
      final AttributeType h=actionImportHierarchy(path,separator);
      update(new ModelEvent(this,ModelPart.HIERARCHY,h));
    }
  }
}","/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final AttributeType h=actionImportHierarchy(path,separator);
    if (h != null)     update(new ModelEvent(this,ModelPart.HIERARCHY,h));
  }
}",0.7382651145324821
108702,"@Override public void widgetSelected(final SelectionEvent arg0){
  try {
    if (combo.getSelectionIndex() == -1) {
      return;
    }
    selection=combo.getSelectionIndex();
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
  }
}","@Override public void widgetSelected(final SelectionEvent arg0){
  try {
    if (combo.getSelectionIndex() == -1) {
      return;
    }
    selection=combo.getSelectionIndex();
    read(file);
  }
 catch (  final Exception e) {
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
 else {
      throw new RuntimeException(e);
    }
  }
}",0.6538987688098495
108703,"public DialogSeparator(final Shell parent,final Controller controller,final String file,boolean data){
  super(parent);
  this.controller=controller;
  this.file=file;
  this.data=data;
}","public DialogSeparator(final Shell parent,final Controller controller,final String file,boolean data){
  super(parent);
  this.file=file;
  this.data=data;
}",0.9127906976744186
108704,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
    return parent;
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
        close();
      }
    }
  }
);
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
 else {
      throw new RuntimeException(e);
    }
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        if (e instanceof RuntimeException) {
          throw (RuntimeException)e;
        }
 else {
          throw new RuntimeException(e);
        }
      }
    }
  }
);
  return parent;
}",0.8034423407917384
108705,"/** 
 * Evaluates the page This checks whether the current settings on the page make any sense. If everything is fine, the settings are being put into the appropriate data container   {@link ImportData} and the  current page is marked ascomplete by invoking  {@link #setPageComplete(boolean)}. Otherwise an error message is set, which will make sure the user is informed about the reason for the error.
 */
private void evaluatePage(){
  setPageComplete(false);
  setErrorMessage(null);
  tablePreview.setVisible(false);
  if (comboLocation.getText().equals(""String_Node_Str"")) {
    return;
  }
  try {
    if (!customSeparator) {
      detectSeparator();
      comboSeparator.select(selection);
    }
    readPreview();
  }
 catch (  IOException|IllegalArgumentException e) {
    setErrorMessage(e.getMessage());
    return;
  }
  ImportData data=wizardImport.getData();
  data.setWizardColumns(wizardColumns);
  data.setPreviewData(previewData);
  data.setFirstRowContainsHeader(btnContainsHeader.getSelection());
  data.setFileLocation(comboLocation.getText());
  data.setCsvSeparator(separators[selection]);
  setPageComplete(true);
}","/** 
 * Evaluates the page This checks whether the current settings on the page make any sense. If everything is fine, the settings are being put into the appropriate data container   {@link ImportData} and the  current page is marked ascomplete by invoking  {@link #setPageComplete(boolean)}. Otherwise an error message is set, which will make sure the user is informed about the reason for the error.
 */
private void evaluatePage(){
  setPageComplete(false);
  setErrorMessage(null);
  tablePreview.setVisible(false);
  if (comboLocation.getText().equals(""String_Node_Str"")) {
    return;
  }
  try {
    if (!customSeparator) {
      detectSeparator();
      comboSeparator.select(selection);
    }
    readPreview();
  }
 catch (  IOException|IllegalArgumentException e) {
    setErrorMessage(e.getMessage());
    return;
  }
catch (  RuntimeException e) {
    if (e.getCause() != null) {
      setErrorMessage(e.getCause().getMessage());
    }
 else {
      setErrorMessage(e.getMessage());
    }
    return;
  }
  ImportData data=wizardImport.getData();
  data.setWizardColumns(wizardColumns);
  data.setPreviewData(previewData);
  data.setFirstRowContainsHeader(btnContainsHeader.getSelection());
  data.setFileLocation(comboLocation.getText());
  data.setCsvSeparator(separators[selection]);
  setPageComplete(true);
}",0.9237631792376316
108706,"@Override protected String[] readRow() throws IOException {
  final String line=reader.readLine();
  if (line == null) {
    reader.close();
    return null;
  }
  if (columns == -1) {
    columns=countColumns(line);
  }
  final String[] tuple=new String[columns];
  int column=0;
  int offset=0;
  int index=0;
  while (column < (columns - 1)) {
    index=line.indexOf(separator,offset);
    tuple[column++]=line.substring(offset,index);
    offset=index + 1;
  }
  tuple[column]=line.substring(offset);
  return tuple;
}","@Override protected String[] readRow() throws IOException {
  final String line=reader.readLine();
  if (line == null) {
    reader.close();
    return null;
  }
  if (columns == -1) {
    columns=countColumns(line);
  }
  final String[] tuple=new String[columns];
  int column=0;
  int offset=0;
  int index=0;
  while (column < (columns - 1)) {
    index=line.indexOf(separator,offset);
    if (index < 0) {
      throw new IOException(""String_Node_Str"" + tuple.length + ""String_Node_Str"");
    }
    tuple[column++]=line.substring(offset,index);
    offset=index + 1;
  }
  tuple[column]=line.substring(offset);
  return tuple;
}",0.9046793760831888
108707,"/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    if (attributeType == AttributeType.ATTR_TYPE_ID)     return 0;
    int cmp=0;
    try {
      cmp=dataTypes[attributeType][indexMap].compare(internalGetValue(row1,index),internalGetValue(row2,index));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      if (ascending) {
        return -cmp;
      }
 else {
        return cmp;
      }
    }
  }
  return 0;
}","/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    if (attributeType == AttributeType.ATTR_TYPE_ID)     return 0;
    int cmp=0;
    try {
      String s1=internalGetValue(row1,index);
      String s2=internalGetValue(row2,index);
      cmp=(s1 == suppressionString && s2 == suppressionString) ? 0 : (s1 == suppressionString ? +1 : (s2 == suppressionString ? -1 : dataTypes[attributeType][indexMap].compare(s1,s2)));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      if (ascending) {
        return -cmp;
      }
 else {
        return cmp;
      }
    }
  }
  return 0;
}",0.8886993603411514
108708,"/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype);
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute));
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      baseOrder.put(baseArray[i],i);
    }
    for (int i=0; i < _hierarchy.length; i++) {
      if (!order.containsKey(_hierarchy[i][level])) {
        Integer position=baseOrder.get(_hierarchy[i][0]);
        if (position != null) {
          order.put(_hierarchy[i][level],position);
          max=Math.max(position,max) + 1;
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}","/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype,handle.getSuppressionString());
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute),handle.getSuppressionString());
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      baseOrder.put(baseArray[i],i);
    }
    for (int i=0; i < _hierarchy.length; i++) {
      if (!order.containsKey(_hierarchy[i][level])) {
        Integer position=baseOrder.get(_hierarchy[i][0]);
        if (position != null) {
          order.put(_hierarchy[i][level],position);
          max=Math.max(position,max) + 1;
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}",0.983775013520822
108709,"/** 
 * Updates the view config
 * @param force Force update even if unchanged
 */
private void updateViewConfig(boolean force){
  if (!force && !model.isViewConfigChanged())   return;
  ModelViewConfig config=model.getViewConfig();
  DataHandle handle=(config.getMode() == Mode.SORTED_INPUT) ? model.getInputConfig().getInput().getHandle() : model.getOutput();
  handle=config.isSubset() ? handle.getView() : handle;
  DataDefinition definition=handle.getDefinition();
  if (config.getMode() == Mode.SORTED_INPUT || config.getMode() == Mode.SORTED_OUTPUT) {
    Swapper swapper=new Swapper(){
      @Override public void swap(      int arg0,      int arg1){
        model.getInputConfig().getResearchSubset().swap(arg0,arg1);
      }
    }
;
    handle.sort(swapper,true,handle.getColumnIndexOf(config.getAttribute()));
    model.setGroups(null);
  }
 else {
    int[] indices=new int[definition.getQuasiIdentifyingAttributes().size()];
    int index=0;
    for (    String attribute : definition.getQuasiIdentifyingAttributes()) {
      indices[index++]=handle.getColumnIndexOf(attribute);
    }
    Swapper swapper=new Swapper(){
      @Override public void swap(      int arg0,      int arg1){
        model.getInputConfig().getResearchSubset().swap(arg0,arg1);
      }
    }
;
    handle.sort(swapper,true,indices);
    int[] groups=new int[handle.getNumRows()];
    int groupIdx=0;
    groups[0]=0;
    for (int row=1; row < handle.getNumRows(); row++) {
      boolean newClass=false;
      for (      int column : indices) {
        if (!handle.getValue(row,column).equals(handle.getValue(row - 1,column))) {
          newClass=true;
          break;
        }
      }
      groupIdx+=newClass ? 1 : 0;
      groups[row]=groupIdx;
    }
    model.setGroups(groups);
  }
}","/** 
 * Updates the view config
 * @param force Force update even if unchanged
 */
private void updateViewConfig(boolean force){
  ModelViewConfig config=model.getViewConfig();
  if (!force && !config.isChanged())   return;
  DataHandle handle=(config.getMode() == Mode.SORTED_INPUT) ? model.getInputConfig().getInput().getHandle() : model.getOutput();
  handle=config.isSubset() ? handle.getView() : handle;
  DataDefinition definition=handle.getDefinition();
  if (config.getMode() == Mode.SORTED_INPUT || config.getMode() == Mode.SORTED_OUTPUT) {
    Swapper swapper=new Swapper(){
      @Override public void swap(      int arg0,      int arg1){
        model.getInputConfig().getResearchSubset().swap(arg0,arg1);
      }
    }
;
    handle.sort(swapper,config.getSortOrder(),handle.getColumnIndexOf(config.getAttribute()));
    model.setGroups(null);
  }
 else {
    int[] indices=new int[definition.getQuasiIdentifyingAttributes().size()];
    int index=0;
    for (    String attribute : definition.getQuasiIdentifyingAttributes()) {
      indices[index++]=handle.getColumnIndexOf(attribute);
    }
    Swapper swapper=new Swapper(){
      @Override public void swap(      int arg0,      int arg1){
        model.getInputConfig().getResearchSubset().swap(arg0,arg1);
      }
    }
;
    handle.sort(swapper,true,indices);
    int[] groups=new int[handle.getNumRows()];
    int groupIdx=0;
    groups[0]=0;
    for (int row=1; row < handle.getNumRows(); row++) {
      boolean newClass=false;
      for (      int column : indices) {
        if (!handle.getValue(row,column).equals(handle.getValue(row - 1,column))) {
          newClass=true;
          break;
        }
      }
      groupIdx+=newClass ? 1 : 0;
      groups[row]=groupIdx;
    }
    model.setGroups(groups);
  }
}",0.9584736251402918
108710,"public ModelViewConfig getViewConfig(){
  oldViewConfig=viewConfig.clone();
  return this.viewConfig;
}","public ModelViewConfig getViewConfig(){
  return this.viewConfig;
}",0.788235294117647
108711,"public void setAttribute(String attribute){
  this.attribute=attribute;
}","public void setAttribute(String attribute){
  if (attribute == null)   return;
  if (!attribute.equals(this.attribute))   changed=true;
  this.attribute=attribute;
}",0.6134453781512605
108712,"public void setMode(Mode mode){
  this.mode=mode;
}","public void setMode(Mode mode){
  if (mode == null)   return;
  if (mode != this.mode)   changed=true;
  this.mode=mode;
}",0.5895953757225434
108713,"public void setSubset(boolean subset){
  this.subset=subset;
}","public void setSubset(boolean subset){
  if (subset != this.subset)   changed=true;
  this.subset=subset;
}",0.7337278106508875
108714,"/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage(),e);
  }
}","/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage(),e);
  }
}",0.8996478873239436
108715,"/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  if (model.getMaximalSizeForComplexOperations() > 0 && data.getHandle().getNumRows() > model.getMaximalSizeForComplexOperations()) {
    model.setVisualizationEnabled(false);
  }
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVFileConfiguration) {
    model.setInputBytes(new File(((CSVFileConfiguration)config).getFileLocation()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.946561108362197
108716,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    this.repaint();
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          initialize(model.getResult(),(ModelNodeFilter)event.data);
          repaint();
        }
      }
);
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.SELECTED_NODE) {
    selectedNode=(ARXNode)event.data;
    this.repaint();
  }
 else   if (event.part == ModelPart.RESULT) {
    if (model.getResult() == null)     reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.FILTER) {
    if (model != null) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          initialize(model.getResult(),(ModelNodeFilter)event.data);
          repaint();
        }
      }
);
    }
  }
}",0.9138840070298768
108717,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          controller.getToolTip().show(createTooltipText(node));
        }
 else {
          controller.getToolTip().unshow();
        }
      }
 else {
        controller.getToolTip().unshow();
      }
    }
  }
);
  this.tooltipTimer.setRepeats(false);
  resetBuffer();
  initializeListeners();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.RESULT,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          controller.getToolTip().show(createTooltipText(node));
        }
 else {
          controller.getToolTip().unshow();
        }
      }
 else {
        controller.getToolTip().unshow();
      }
    }
  }
);
  this.tooltipTimer.setRepeats(false);
  resetBuffer();
  initializeListeners();
}",0.9891328454202706
108718,"/** 
 * Resets the view
 */
@Override public void reset(){
  table.setRedraw(false);
  table.clearAll();
  table.setRedraw(true);
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
}","/** 
 * Resets the view
 */
@Override public void reset(){
  table.setRedraw(false);
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  list.clear();
  table.setRedraw(true);
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
  SWTUtil.disable(table);
}",0.788235294117647
108719,"/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  if (result == null || result.getLattice() == null)   return;
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      table.clearAll();
      list.clear();
      final ARXLattice l=result.getLattice();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      table.setRedraw(true);
    }
  }
);
}","/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  if (result == null || result.getLattice() == null)   return;
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      SWTUtil.enable(table);
      for (      final TableItem i : table.getItems()) {
        i.dispose();
      }
      list.clear();
      final ARXLattice l=result.getLattice();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      table.setRedraw(true);
    }
  }
);
}",0.9617271835132484
108720,"@Override public void run(){
  table.setRedraw(false);
  table.clearAll();
  list.clear();
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(node)) {
        list.add(node);
      }
    }
  }
  Collections.sort(list,new Comparator<ARXNode>(){
    @Override public int compare(    final ARXNode arg0,    final ARXNode arg1){
      return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
    }
  }
);
  if (list.size() > model.getMaxNodesInViewer()) {
    list.clear();
  }
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
  listener=new Listener(){
    @Override public void handleEvent(    final Event event){
      final TableItem item=(TableItem)event.item;
      final int index=table.indexOf(item);
      createItem(item,index);
    }
  }
;
  table.addListener(SWT.SetData,listener);
  table.setItemCount(list.size());
  table.setRedraw(true);
}","@Override public void run(){
  table.setRedraw(false);
  SWTUtil.enable(table);
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  list.clear();
  final ARXLattice l=result.getLattice();
  for (  final ARXNode[] level : l.getLevels()) {
    for (    final ARXNode node : level) {
      if (filter.isAllowed(node)) {
        list.add(node);
      }
    }
  }
  Collections.sort(list,new Comparator<ARXNode>(){
    @Override public int compare(    final ARXNode arg0,    final ARXNode arg1){
      return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
    }
  }
);
  if (list.size() > model.getMaxNodesInViewer()) {
    list.clear();
  }
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
  listener=new Listener(){
    @Override public void handleEvent(    final Event event){
      final TableItem item=(TableItem)event.item;
      final int index=table.indexOf(item);
      createItem(item,index);
    }
  }
;
  table.addListener(SWT.SetData,listener);
  table.setItemCount(list.size());
  table.setRedraw(true);
}",0.948414576431614
108721,"/** 
 * Init
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  table=new Table(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  final TableColumn column1=new TableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column4=new TableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column2=new TableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column3=new TableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  table.setItemCount(0);
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
}","/** 
 * Init
 * @param parent
 * @param controller
 */
public ViewList(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.RESULT,this);
  this.controller=controller;
  table=new Table(parent,SWT.SINGLE | SWT.VIRTUAL | SWT.BORDER| SWT.V_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  final TableColumn column1=new TableColumn(table,SWT.LEFT);
  column1.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column4=new TableColumn(table,SWT.LEFT);
  column4.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column2=new TableColumn(table,SWT.LEFT);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  final TableColumn column3=new TableColumn(table,SWT.LEFT);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  table.setItemCount(0);
  column1.pack();
  column2.pack();
  column3.pack();
  column4.pack();
}",0.977262180974478
108722,"/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  return ((infoLoss.getValue() - min) / (max - min)) * 100d;
}","/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  if (result == null)   return 0;
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  return ((infoLoss.getValue() - min) / (max - min)) * 100d;
}",0.9589371980676328
108723,"/** 
 * Creates the nattable
 * @param parent
 * @return
 */
private NatTable createTable(final Composite parent){
  final IDataProvider provider=new DataTableHandleDataProvider(null,context);
  gridLayer=new DataTableGridLayerStack(provider,table,context);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  Color light=GUIHelper.getColor(240,240,240);
  Color dark=GUIHelper.getColor(180,180,180);
  Style style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,light);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,dark);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}","/** 
 * Creates the nattable
 * @param parent
 * @return
 */
private NatTable createTable(final Composite parent){
  final IDataProvider provider=new DataTableHandleDataProvider(context);
  gridLayer=new DataTableGridLayerStack(provider,table,context);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  Color light=GUIHelper.getColor(240,240,240);
  Color dark=GUIHelper.getColor(180,180,180);
  Style style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,light);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,dark);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}",0.9989277289298736
108724,"/** 
 * Resets the component
 */
public void reset(){
  this.table.setRedraw(false);
  this.context.getImages().clear();
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(null,context),table,context);
  this.context.reset();
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}","/** 
 * Resets the component
 */
public void reset(){
  this.table.setRedraw(false);
  this.context.getImages().clear();
  this.context.reset();
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(context),table,context);
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}",0.9421015010721944
108725,"@Override public int getRowCount(){
  if (data == null || data.isOrphaned()) {
    return 0;
  }
  return data.getNumRows();
}","@Override public int getRowCount(){
  DataHandle data=context.getHandle();
  if (data == null || data.isOrphaned()) {
    return 0;
  }
  return data.getNumRows();
}",0.865979381443299
108726,"/** 
 * Creates a new instance
 * @param data
 * @param context
 */
public DataTableHandleDataProvider(final DataHandle data,final DataTableContext context){
  this.data=data;
  this.context=context;
}","/** 
 * Creates a new instance
 * @param data
 * @param context
 */
public DataTableHandleDataProvider(final DataTableContext context){
  this.context=context;
}",0.8895027624309392
108727,"@Override public int getColumnCount(){
  if (data == null || data.isOrphaned()) {
    return 0;
  }
  return data.getNumColumns() + (context.getRows() != null ? 1 : 0);
}","@Override public int getColumnCount(){
  DataHandle data=context.getHandle();
  if (data == null || data.isOrphaned()) {
    return 0;
  }
  return data.getNumColumns() + (context.getRows() != null ? 1 : 0);
}",0.8970976253298153
108728,"@Override public Object getDataValue(int arg0,int arg1){
  if (data == null) {
    return null;
  }
  RowSet rows=context.getRows();
  if (rows == null) {
    return data.getValue(arg1,arg0);
  }
 else   if (arg0 == 0) {
    if (data instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)data).getSubset();
      arg1=subset[arg1];
    }
    return rows.contains(arg1);
  }
 else {
    return data.getValue(arg1,arg0 - 1);
  }
}","@Override public Object getDataValue(int arg0,int arg1){
  DataHandle data=context.getHandle();
  if (data == null) {
    return null;
  }
  RowSet rows=context.getRows();
  if (rows == null) {
    return data.getValue(arg1,arg0);
  }
 else   if (arg0 == 0) {
    if (data instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)data).getSubset();
      arg1=subset[arg1];
    }
    return rows.contains(arg1);
  }
 else {
    return data.getValue(arg1,arg0 - 1);
  }
}",0.9578378378378378
108729,"/** 
 * Checks whether a registry is referenced
 */
protected void checkRegistry(){
  if (registry == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Checks whether a registry is referenced
 */
protected void checkRegistry(){
  if (registry == null) {
    throw new RuntimeException(""String_Node_Str"" + this.getClass().getSimpleName() + ""String_Node_Str""+ this.hashCode()+ ""String_Node_Str"");
  }
}",0.7867298578199052
108730,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final Label label=new Label(parent,SWT.CENTER | SWT.NONE);
  final StringBuffer text=new StringBuffer();
  text.append(Resources.getMessage(""String_Node_Str""));
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str""));
  text.append(""String_Node_Str"");
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str"") + Resources.getVersion());
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str""));
  label.setText(text.toString());
  label.setLayoutData(SWTUtil.createFillGridData());
  new Label(parent,SWT.NONE);
  final Text license=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.BORDER);
  license.setText(LICENSE);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=100;
  license.setLayoutData(d);
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final Label label=new Label(parent,SWT.CENTER | SWT.NONE);
  final StringBuffer text=new StringBuffer();
  text.append(Resources.getMessage(""String_Node_Str""));
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str""));
  text.append(""String_Node_Str"");
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str"") + Resources.getVersion());
  text.append(""String_Node_Str"");
  text.append(Resources.getMessage(""String_Node_Str""));
  label.setText(text.toString());
  label.setLayoutData(SWTUtil.createFillGridData());
  new Label(parent,SWT.NONE);
  final Text license=new Text(parent,SWT.NONE | SWT.MULTI | SWT.V_SCROLL| SWT.BORDER);
  license.setText(LICENSE);
  license.setEditable(false);
  final GridData d=SWTUtil.createFillGridData();
  d.heightHint=100;
  license.setLayoutData(d);
  return parent;
}",0.9844074844074844
108731,"/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  double min=model.getResult().getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=model.getResult().getLattice().getTop().getMaximumInformationLoss().getValue();
  return ((infoLoss.getValue() - min) / (max - min)) * 100d;
}","/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  if (model != null && model.getResult() != null && model.getResult().getLattice() != null && model.getResult().getLattice().getBottom() != null && model.getResult().getLattice().getTop() != null) {
    double min=model.getResult().getLattice().getBottom().getMinimumInformationLoss().getValue();
    double max=model.getResult().getLattice().getTop().getMaximumInformationLoss().getValue();
    return ((infoLoss.getValue() - min) / (max - min)) * 100d;
  }
 else {
    return 0;
  }
}",0.7809878844361603
108732,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.7903017797265928
108733,"/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          Hierarchy hierarchy=config.getHierarchy(attr);
          if (hierarchy == null) {
            try {
              hierarchy=readHierarchy(zip,prefix,ref);
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
          config.getInput().getDefinition().setAttributeType(attr,hierarchy);
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              if (config.getHierarchy(attr) == null) {
                config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
              }
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          Hierarchy hierarchy=config.getHierarchy(attr);
          if (hierarchy == null) {
            try {
              hierarchy=readHierarchy(zip,prefix,ref);
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
          config.getInput().getDefinition().setAttributeType(attr,hierarchy);
          config.setHierarchy(attr,hierarchy);
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.9958608542492294
108734,"/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
  }
}","/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showInfoDialog(""String_Node_Str"",e.getMessage());
  }
}",0.9926410466067048
108735,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey());
        builder.append(""String_Node_Str"").append(entry.getValue().getHierarchy()[0].length).append(""String_Node_Str"");
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey());
        builder.append(""String_Node_Str"").append(entry.getValue().getHierarchy()[0].length).append(""String_Node_Str"");
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.95331388078366
108736,"/** 
 * Returns the current context, consisting of a consistent combination of a config and a data handle
 * @return
 */
public Context getContext(){
  DataHandle handle=null;
  ModelConfiguration config=null;
  if (model == null)   return null;
  if (target == ModelPart.INPUT) {
    if (model.getOutputConfig() != null && model.getOutputConfig().getInput() != null) {
      config=model.getOutputConfig();
    }
 else {
      config=model.getInputConfig();
    }
    handle=config.getInput().getHandle();
  }
 else {
    config=model.getOutputConfig();
    handle=model.getOutput();
  }
  if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
    handle=handle.getView();
  }
  return new Context(config,handle);
}","/** 
 * Returns the current context, consisting of a consistent combination of a config and a data handle
 * @return
 */
public Context getContext(){
  DataHandle handle=null;
  ModelConfiguration config=null;
  if (model == null)   return null;
  if (target == ModelPart.INPUT) {
    if (model.getOutputConfig() != null && model.getOutputConfig().getInput() != null) {
      config=model.getOutputConfig();
    }
 else {
      config=model.getInputConfig();
    }
    if (config.getInput() == null)     return null;
    handle=config.getInput().getHandle();
  }
 else {
    config=model.getOutputConfig();
    handle=model.getOutput();
  }
  if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
    handle=handle.getView();
  }
  return new Context(config,handle);
}",0.9685990338164252
108737,"/** 
 * Redraws the plot
 */
private void update(){
  if (model != null && !model.isVisualizationEnabled()) {
    reset();
    return;
  }
  if (model != null && model.getAttributePair() != null && model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
    DataHandle handle=this.context.getContext().handle;
    if (handle == null) {
      reset();
      return;
    }
    String attribute1=model.getAttributePair()[0];
    String attribute2=model.getAttributePair()[1];
    int column1=handle.getColumnIndexOf(attribute1);
    int column2=handle.getColumnIndexOf(attribute2);
    renderer.updateData(model.getAttributePair()[0],model.getAttributePair()[1],handle.getStatistics().getContingencyTable(column1,MAX_SIZE,column2,MAX_SIZE));
    renderer.updatePlot();
    repaint();
  }
 else {
    reset();
    return;
  }
}","/** 
 * Redraws the plot
 */
private void update(){
  if (model != null && !model.isVisualizationEnabled()) {
    reset();
    return;
  }
  if (model != null && model.getAttributePair() != null && model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
    Context context=this.context.getContext();
    if (context == null) {
      reset();
      return;
    }
    DataHandle handle=context.handle;
    if (handle == null) {
      reset();
      return;
    }
    String attribute1=model.getAttributePair()[0];
    String attribute2=model.getAttributePair()[1];
    int column1=handle.getColumnIndexOf(attribute1);
    int column2=handle.getColumnIndexOf(attribute2);
    renderer.updateData(model.getAttributePair()[0],model.getAttributePair()[1],handle.getStatistics().getContingencyTable(column1,MAX_SIZE,column2,MAX_SIZE));
    renderer.updatePlot();
    repaint();
  }
 else {
    reset();
    return;
  }
}",0.9286917462099944
108738,"/** 
 * Updates the view
 */
private void update(){
  if (model != null && !model.isVisualizationEnabled()) {
    clearCache();
    reset();
    return;
  }
  Context context=acontext.getContext();
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}","/** 
 * Updates the view
 */
private void update(){
  if (model != null && !model.isVisualizationEnabled()) {
    clearCache();
    reset();
    return;
  }
  Context context=acontext.getContext();
  if (context == null) {
    clearCache();
    reset();
    return;
  }
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}",0.9766081871345028
108739,"/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage(),e);
  }
}","/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  ImportDataWizard wizard=new ImportDataWizard(this,model);
  new WizardDialog(main.getShell(),wizard).open();
  DataSourceConfiguration config=wizard.getResultingConfiguration();
  if (config == null) {
    return;
  }
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    if (worker.getError() instanceof IllegalArgumentException) {
      main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    }
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showInfoDialog(""String_Node_Str"",worker.getError().getMessage());
  }
}",0.9881584320130664
108740,"/** 
 * Returns a string representation of a definition
 * @param definition
 * @return
 */
private String getDebugData(DataDefinition definition){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"").append(definition.hashCode());
  builder.append(definition.isLocked() ? ""String_Node_Str"" : ""String_Node_Str"");
  return builder.toString();
}","/** 
 * Returns a string representation of a hierarchy
 * @param definition
 * @return
 */
private String getDebugData(Hierarchy hierarchy){
  if (hierarchy == null || hierarchy.getHierarchy() == null || hierarchy.getHierarchy().length == 0)   return ""String_Node_Str"";
 else   return ""String_Node_Str"" + hierarchy.getHierarchy()[0].length;
}",0.423562412342216
108741,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey());
        builder.append(""String_Node_Str"").append(entry.getValue().getHierarchy()[0].length).append(""String_Node_Str"");
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey());
        builder.append(""String_Node_Str"").append(entry.getValue().getHierarchy()[0].length).append(""String_Node_Str"");
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(getDebugData(entry.getValue())).append(""String_Node_Str"");
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(getDebugData(entry.getValue())).append(""String_Node_Str"");
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.949856144677353
108742,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  actionResetOutput();
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.createClonedConfig();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      if (model.getMaximalSizeForComplexOperations() == 0 || model.getInputConfig().getInput().getHandle().getNumRows() <= model.getMaximalSizeForComplexOperations()) {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.GROUPED);
        this.updateViewConfig(true);
      }
 else {
        this.model.getViewConfig().setSubset(true);
        this.model.getViewConfig().setMode(Mode.UNSORTED);
      }
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.9890960253253606
108743,"/** 
 * Resets the output
 */
private void actionResetOutput(){
  model.getViewConfig().setMode(Mode.UNSORTED);
  model.getViewConfig().setSubset(false);
  model.setGroups(null);
  update(new ModelEvent(this,ModelPart.VIEW_CONFIG,null));
  model.setResult(null);
  update(new ModelEvent(this,ModelPart.RESULT,null));
  model.setOutput(null,null);
  update(new ModelEvent(this,ModelPart.OUTPUT,null));
  model.setSelectedNode(null);
  update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
}","/** 
 * Resets the output
 */
private void actionResetOutput(){
  model.getViewConfig().setMode(Mode.UNSORTED);
  model.getViewConfig().setSubset(false);
  model.setGroups(null);
  update(new ModelEvent(this,ModelPart.VIEW_CONFIG,null));
  model.setResult(null);
  model.setOutputConfig(null);
  update(new ModelEvent(this,ModelPart.RESULT,null));
  model.setOutput(null,null);
  update(new ModelEvent(this,ModelPart.OUTPUT,null));
  model.setSelectedNode(null);
  update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
}",0.9695780176643768
108744,"public void setQuery(String query){
  this.query=query;
}","public void setQuery(String query){
  this.query=query;
  setModified();
}",0.8702290076335878
108745,"public void setPath(final String path){
  this.path=path;
}","public void setPath(final String path){
  this.path=path;
  setModified();
}",0.8740740740740741
108746,"public void createClonedConfig(){
  outputConfig=inputConfig.clone();
}","public void createClonedConfig(){
  outputConfig=inputConfig.clone();
  this.setModified();
}",0.8658536585365854
108747,"/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    update(new ModelEvent(this,ModelPart.HIERARCHY,i.getModel().getHierarchy()));
  }
}","/** 
 * Starts the wizard
 */
public void actionMenuEditCreateHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String attr=model.getSelectedAttribute();
  final int index=model.getInputConfig().getInput().getHandle().getColumnIndexOf(attr);
  final WizardHierarchy i=new WizardHierarchy(this,attr,model.getInputConfig().getInput().getDefinition().getDataType(attr),model.getSuppressionString(),model.getInputConfig().getInput().getHandle().getStatistics().getDistinctValues(index));
  if (i.open(main.getShell())) {
    Hierarchy hierarchy=i.getModel().getHierarchy();
    if (hierarchy != null) {
      model.getInputConfig().setHierarchy(attr,hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.9123898392949716
108748,"@Override public void update(final ModelEvent event){
  if (model != null && model.isDebugEnabled())   this.debug.add(event);
  final Map<ModelPart,Set<IView>> dlisteners=getListeners();
  if (dlisteners.get(event.part) != null) {
    for (    final IView listener : dlisteners.get(event.part)) {
      if (listener != event.source) {
        listener.update(event);
      }
    }
  }
}","@Override public void update(final ModelEvent event){
  if (model != null && model.isDebugEnabled())   this.debug.addEvent(event);
  final Map<ModelPart,Set<IView>> dlisteners=getListeners();
  if (dlisteners.get(event.part) != null) {
    for (    final IView listener : dlisteners.get(event.part)) {
      if (listener != event.source) {
        listener.update(event);
      }
    }
  }
}",0.9935649935649936
108749,"/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy h=actionImportHierarchy(path,separator);
    if (h != null)     update(new ModelEvent(this,ModelPart.HIERARCHY,h));
  }
}","/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy hierarchy=actionImportHierarchy(path,separator);
    if (hierarchy != null) {
      model.getInputConfig().setHierarchy(model.getSelectedAttribute(),hierarchy);
      update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
    }
  }
}",0.956430812129662
108750,"/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private AttributeType actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  Throwable error) {
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
  }
  return null;
}","/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private Hierarchy actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  Throwable error) {
    if (error instanceof RuntimeException) {
      if (error.getCause() != null) {
        error=error.getCause();
      }
    }
    if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
      main.showInfoDialog(""String_Node_Str"",error.getMessage());
    }
 else {
      main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
    }
  }
  return null;
}",0.9858557284299858
108751,"/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle h=model.getInputConfig().getInput().getHandle();
    if (h != null) {
      if (h.getNumColumns() > 0) {
        String a=h.getAttributeName(0);
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}","/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getOutput(tempSelectedNode,false);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle handle=model.getInputConfig().getInput().getHandle();
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        String attr=handle.getAttributeName(i);
        Hierarchy hierarchy=model.getInputConfig().getHierarchy(attr);
        if (hierarchy != null) {
          model.setSelectedAttribute(attr);
          update(new ModelEvent(this,ModelPart.HIERARCHY,hierarchy));
        }
      }
    }
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle h=model.getInputConfig().getInput().getHandle();
    if (h != null) {
      if (h.getNumColumns() > 0) {
        String a=h.getAttributeName(0);
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}",0.9270646628981112
108752,"/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final AttributeType h=actionImportHierarchy(path,separator);
    if (h != null)     update(new ModelEvent(this,ModelPart.HIERARCHY,h));
  }
}","/** 
 * File->Import hierarchy
 */
public void actionMenuFileImportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path != null) {
    DialogSeparator dialog=null;
    try {
      dialog=new DialogSeparator(main.getShell(),this,path,false);
      dialog.create();
      if (dialog.open() == Window.CANCEL) {
        return;
      }
    }
 catch (    Throwable error) {
      if (error instanceof RuntimeException) {
        if (error.getCause() != null) {
          error=error.getCause();
        }
      }
      if ((error instanceof IllegalArgumentException) || (error instanceof IOException)) {
        main.showInfoDialog(""String_Node_Str"",error.getMessage());
      }
 else {
        main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),error);
      }
      return;
    }
    final char separator=dialog.getSeparator();
    final Hierarchy h=actionImportHierarchy(path,separator);
    if (h != null)     update(new ModelEvent(this,ModelPart.HIERARCHY,h));
  }
}",0.9927431059506532
108753,"public ARXAnonymizer createAnonymizer(){
  this.anonymizer=new ARXAnonymizer();
  this.anonymizer.setHistorySize(getHistorySize());
  this.anonymizer.setMaximumSnapshotSizeDataset(getSnapshotSizeDataset());
  this.anonymizer.setSuppressionString(getSuppressionString());
  this.anonymizer.setMaximumSnapshotSizeSnapshot(getSnapshotSizeSnapshot());
  this.anonymizer.setRemoveOutliers(inputConfig.isRemoveOutliers());
  this.createCriteria(inputConfig);
  return anonymizer;
}","public ARXAnonymizer createAnonymizer(){
  this.anonymizer=new ARXAnonymizer();
  this.anonymizer.setHistorySize(getHistorySize());
  this.anonymizer.setMaximumSnapshotSizeDataset(getSnapshotSizeDataset());
  this.anonymizer.setSuppressionString(getSuppressionString());
  this.anonymizer.setMaximumSnapshotSizeSnapshot(getSnapshotSizeSnapshot());
  this.anonymizer.setRemoveOutliers(inputConfig.isRemoveOutliers());
  this.createCriteriaAndDefinition(inputConfig);
  return anonymizer;
}",0.9865005192107996
108754,"/** 
 * Updates the global hierarchy definition
 */
private void updateGlobalHierarchy(){
  updateMinAndMax();
  if (model == null) {
    return;
  }
  final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
  final Hierarchy h=Hierarchy.create(hierarchy);
  if (definition.getAttributeType(attribute) instanceof Hierarchy) {
    model.getInputConfig().getInput().getDefinition().setAttributeType(attribute,h);
    updateMin();
    updateMax();
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
  if (definition.getAttributeType(attribute) == AttributeType.SENSITIVE_ATTRIBUTE) {
    model.getInputConfig().setHierarchy(attribute,h);
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
}","/** 
 * Updates the global hierarchy definition
 */
private void updateGlobalHierarchy(){
  updateMinAndMax();
  if (model == null || model.getInputConfig() == null) {
    return;
  }
  final Hierarchy h=Hierarchy.create(hierarchy);
  model.getInputConfig().setHierarchy(attribute,h);
}",0.3658536585365853
108755,"/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          try {
            config.getInput().getDefinition().setAttributeType(attr,readHierarchy(zip,prefix,ref));
          }
 catch (          final IOException e) {
            throw new SAXException(e);
          }
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.createDate(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.list()) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          config.getInput().getDefinition().setAttributeType(attr,config.getHierarchy(attr));
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.6694769112856869
108756,"/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  Set<String> done=new HashSet<String>();
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      for (      final String a : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
        final String[][] h=config.getInput().getDefinition().getHierarchy(a);
        if (h != null) {
          zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
          final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
          out.write(h);
          done.add(a);
        }
      }
    }
  }
  for (  Entry<String,Hierarchy> entry : config.getHierarchies().entrySet()) {
    final String[][] h=entry.getValue().getHierarchy();
    String a=entry.getKey();
    if (!done.contains(a)) {
      if (h != null) {
        zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
        final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
        out.write(h);
      }
    }
  }
}","/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  for (  Entry<String,Hierarchy> entry : config.getHierarchies().entrySet()) {
    zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(entry.getKey())+ ""String_Node_Str""));
    final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
    out.write(entry.getValue().getHierarchy());
  }
}",0.4772087788407428
108757,"/** 
 * Creates a new data view
 * @param parent
 * @param controller
 * @param title
 */
public ViewData(final Composite parent,final Controller controller,final String title){
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  this.controller=controller;
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_ASCENDING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DESCENDING=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitleBar bar=new ComponentTitleBar(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),IMAGE_ASCENDING,new Runnable(){
    @Override public void run(){
      model.getViewConfig().setSortOrder(true);
      actionSort();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),IMAGE_DESCENDING,new Runnable(){
    @Override public void run(){
      model.getViewConfig().setSortOrder(false);
      actionSort();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionDataShowGroups();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),true,new Runnable(){
    @Override public void run(){
      controller.actionDataToggleSubset();
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillGridData());
  Composite c=folder.createItem(title,null);
  folder.setSelection(0);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  c.setLayout(l);
  table=new ComponentDataTable(controller,c);
  table.addSelectionLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        actionCellSelected((CellSelectionEvent)arg0);
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        actionColumnSelected((ColumnSelectionEvent)arg0);
      }
    }
  }
);
  this.groupsButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.groupsButton.setEnabled(false);
  this.subsetButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.subsetButton.setEnabled(false);
}","/** 
 * Creates a new data view
 * @param parent
 * @param controller
 * @param title
 */
public ViewData(final Composite parent,final Controller controller,final String title){
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.OUTPUT,this);
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  controller.addListener(ModelPart.INPUT,this);
  this.controller=controller;
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_ASCENDING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_DESCENDING=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitleBar bar=new ComponentTitleBar(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),IMAGE_ASCENDING,new Runnable(){
    @Override public void run(){
      model.getViewConfig().setSortOrder(true);
      actionSort();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),IMAGE_DESCENDING,new Runnable(){
    @Override public void run(){
      model.getViewConfig().setSortOrder(false);
      actionSort();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionDataShowGroups();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),true,new Runnable(){
    @Override public void run(){
      controller.actionDataToggleSubset();
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillGridData());
  Composite c=folder.createItem(title,null);
  folder.setSelection(0);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  c.setLayout(l);
  table=new ComponentDataTable(controller,c);
  table.addSelectionLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        actionCellSelected((CellSelectionEvent)arg0);
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        actionColumnSelected((ColumnSelectionEvent)arg0);
      }
    }
  }
);
  this.groupsButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.groupsButton.setEnabled(false);
  this.subsetButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.subsetButton.setEnabled(false);
  this.ascendingButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.ascendingButton.setEnabled(false);
  this.descendingButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.descendingButton.setEnabled(false);
}",0.9391243676957962
108758,"@Override public void reset(){
  table.reset();
  groupsButton.setEnabled(false);
  subsetButton.setEnabled(false);
}","@Override public void reset(){
  table.reset();
  groupsButton.setEnabled(false);
  subsetButton.setEnabled(false);
  ascendingButton.setEnabled(false);
  descendingButton.setEnabled(false);
}",0.7572815533980582
108759,"/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataInput(final Composite parent,final Controller controller){
  super(parent,controller,Resources.getMessage(""String_Node_Str""));
  controller.addListener(ModelPart.RESEARCH_SUBSET,this);
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
}","/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataInput(final Composite parent,final Controller controller){
  super(parent,controller,Resources.getMessage(""String_Node_Str""));
  controller.addListener(ModelPart.RESEARCH_SUBSET,this);
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
}",0.9407407407407408
108760,"@Override public void update(final ModelEvent event){
  super.update(event);
  if (event.part == ModelPart.INPUT) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=getDefinition();
    if (definition == null) {
      reset();
      return;
    }
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.setGroups(null);
    table.setData(handle);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG || event.part == ModelPart.RESULT) {
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setData(handle);
    table.setGroups(null);
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.redraw();
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (model != null) {
      DataHandle handle=getHandle();
      if (handle != null) {
        final String attr=(String)event.data;
        DataDefinition definition=getDefinition();
        final int index=handle.getColumnIndexOf(attr);
        updateHeaderImage(index,definition.getAttributeType(attr));
        table.setEnabled(true);
        table.redraw();
      }
    }
  }
}","@Override public void update(final ModelEvent event){
  super.update(event);
  if (event.part == ModelPart.INPUT) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=getDefinition();
    if (definition == null) {
      reset();
      return;
    }
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.setGroups(null);
    table.setData(handle);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
    this.enableSorting();
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG || event.part == ModelPart.RESULT) {
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setData(handle);
    table.setGroups(null);
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.redraw();
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (model != null) {
      DataHandle handle=getHandle();
      if (handle != null) {
        final String attr=(String)event.data;
        DataDefinition definition=getDefinition();
        final int index=handle.getColumnIndexOf(attr);
        updateHeaderImage(index,definition.getAttributeType(attr));
        table.setEnabled(true);
        table.redraw();
      }
    }
  }
}",0.9921686746987952
108761,"@Override public void update(final ModelEvent event){
  super.update(event);
  if (event.part == ModelPart.INPUT) {
    reset();
    return;
  }
  if (event.part == ModelPart.OUTPUT) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=getDefinition();
    if (definition == null) {
      reset();
      return;
    }
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setResearchSubset(getSubset());
    table.setGroups(model.getGroups());
    table.setData(handle);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG || event.part == ModelPart.RESULT) {
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setData(handle);
    table.setGroups(model.getGroups());
    table.setResearchSubset(getSubset());
    table.redraw();
  }
}","@Override public void update(final ModelEvent event){
  super.update(event);
  if (event.part == ModelPart.INPUT) {
    reset();
    return;
  }
  if (event.part == ModelPart.OUTPUT) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=getDefinition();
    if (definition == null) {
      reset();
      return;
    }
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setResearchSubset(getSubset());
    table.setGroups(model.getGroups());
    table.setData(handle);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
    this.enableSorting();
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG || event.part == ModelPart.RESULT) {
    DataHandle handle=getHandle();
    if (handle == null) {
      reset();
      return;
    }
    table.setData(handle);
    table.setGroups(model.getGroups());
    table.setResearchSubset(getSubset());
    table.redraw();
  }
}",0.9896414342629484
108762,"/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataOutput(final Composite parent,final Controller controller){
  super(parent,controller,Resources.getMessage(""String_Node_Str""));
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.OUTPUT,this);
}","/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataOutput(final Composite parent,final Controller controller){
  super(parent,controller,Resources.getMessage(""String_Node_Str""));
}",0.8180112570356473
108763,"/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison. If no datatype is specified for a specific column it uses string comparison.
 * @param row1
 * @param row2
 * @param columns
 * @param ascending
 * @return
 */
protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  checkRegistry();
  try {
    for (int i=0; i < columns.length; i++) {
      int index=columns[i];
      int cmp=dataTypes[0][index].compare(internalGetValue(row1,index),internalGetValue(row2,index));
      if (cmp != 0) {
        return ascending ? -cmp : cmp;
      }
    }
    return 0;
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison. If no datatype is specified for a specific column it uses string comparison.
 * @param row1
 * @param row2
 * @param columns
 * @param ascending
 * @return
 */
protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  checkRegistry();
  try {
    for (int i=0; i < columns.length; i++) {
      int index=columns[i];
      int cmp=dataTypes[0][index].compare(internalGetValue(row1,index),internalGetValue(row2,index));
      if (cmp != 0) {
        return ascending ? cmp : -cmp;
      }
    }
    return 0;
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}",0.9926017262638718
108764,"/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    if (attributeType == AttributeType.ATTR_TYPE_ID)     return 0;
    int cmp=0;
    try {
      String s1=internalGetValue(row1,index);
      String s2=internalGetValue(row2,index);
      cmp=(s1 == suppressionString && s2 == suppressionString) ? 0 : (s1 == suppressionString ? +1 : (s2 == suppressionString ? -1 : dataTypes[attributeType][indexMap].compare(s1,s2)));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      if (ascending) {
        return -cmp;
      }
 else {
        return cmp;
      }
    }
  }
  return 0;
}","/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int internalCompare(final int row1,final int row2,final int[] columns,final boolean ascending){
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    if (attributeType == AttributeType.ATTR_TYPE_ID)     return 0;
    int cmp=0;
    try {
      String s1=internalGetValue(row1,index);
      String s2=internalGetValue(row2,index);
      cmp=(s1 == suppressionString && s2 == suppressionString) ? 0 : (s1 == suppressionString ? +1 : (s2 == suppressionString ? -1 : dataTypes[attributeType][indexMap].compare(s1,s2)));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      return ascending ? cmp : -cmp;
    }
  }
  return 0;
}",0.9597397315982108
108765,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  if (model.getInputConfig() != null || model.getOutputConfig() != null) {
    builder.append(""String_Node_Str"");
    if (model.getInputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getInputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    if (model.getOutputConfig() != null) {
      builder.append(""String_Node_Str"");
      for (      Entry<String,Hierarchy> entry : model.getOutputConfig().getHierarchies().entrySet()) {
        builder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getHierarchy()[0].length);
      }
    }
    builder.append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getMaximalSizeForComplexOperations()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.9863306279367792
108766,"public void createCriteria(ModelConfiguration config){
  config.removeAllCriteria();
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
    config.addCriterion(new Inclusion(subset));
  }
}","public void createCriteria(ModelConfiguration config){
  config.removeAllCriteria();
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    if (getInputConfig() != null && getInputConfig().getInput() != null && getInputConfig().getResearchSubset() != null) {
      DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
      config.addCriterion(new Inclusion(subset));
    }
  }
}",0.9466077880369328
108767,"@SuppressWarnings(""String_Node_Str"") private Interval<T> getInterval(IndexNode index,String sValue){
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  T tValue=type.parse(sValue);
  if (adjustment == DynamicAdjustment.OUT_OF_BOUNDS_LABEL) {
    if (type.compare(tValue,min) < 0) {
      return OUT_OF_BOUNDS_MIN;
    }
 else     if (type.compare(tValue,max) > 0) {
      return OUT_OF_BOUNDS_MAX;
    }
  }
  int iindex=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T lower;
  T upper;
  AggregateFunction<T> function;
  if (iindex < 0) {
    if (adjustment != DynamicAdjustment.SNAP_TO_BOUNDS) {
      throw new IllegalStateException(""String_Node_Str"" + sValue);
    }
 else {
      lower=min;
      upper=intervals.get(0).max;
      function=intervals.get(0).function;
    }
  }
 else {
    T offset=type.multiply(type.subtract(index.max,index.min),iindex);
    Interval<T> interval=query(index,type.subtract(tValue,offset));
    if (interval == null) {
      throw new IllegalStateException(""String_Node_Str"" + sValue);
    }
    function=interval.function;
    if (interval.equals(intervals.get(0)) && iindex == 0) {
      lower=min;
      upper=intervals.get(0).max;
    }
 else {
      lower=type.add(interval.min,offset);
      upper=type.add(interval.max,offset);
    }
    if (type.compare(upper,max) > 0) {
      upper=max;
    }
  }
  return new Interval<T>((DataType<T>)type,lower,upper,function);
}","@SuppressWarnings(""String_Node_Str"") private Interval<T> getInterval(IndexNode index,T actualMax,String sValue){
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  T tValue=type.parse(sValue);
  if (adjustment == DynamicAdjustment.OUT_OF_BOUNDS_LABEL) {
    if (type.compare(tValue,min) < 0) {
      return OUT_OF_BOUNDS_MIN;
    }
 else     if (type.compare(tValue,max) > 0) {
      return OUT_OF_BOUNDS_MAX;
    }
  }
  int iindex=(int)Math.floor(type.ratio(type.subtract(tValue,index.min),type.subtract(index.max,index.min)));
  T offset=type.multiply(type.subtract(index.max,index.min),iindex);
  Interval<T> interval=query(index,type.subtract(tValue,offset));
  if (interval == null) {
    throw new IllegalStateException(""String_Node_Str"" + sValue);
  }
  AggregateFunction<T> function=interval.function;
  T lower=type.add(interval.min,offset);
  T upper=type.add(interval.max,offset);
  if (type.compare(tValue,max) > 0) {
    if (adjustment != DynamicAdjustment.SNAP_TO_BOUNDS) {
      throw new IllegalArgumentException(""String_Node_Str"" + sValue);
    }
 else {
      if (type.compare(lower,tValue) <= 0 && type.compare(upper,tValue) > 0) {
        upper=actualMax;
      }
    }
  }
  return new Interval<T>((DataType<T>)type,lower,upper,function);
}",0.5462396545519971
108768,"@Override @SuppressWarnings(""String_Node_Str"") protected List<Group> prepareGroups(){
  String valid=internalIsValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  if (this.adjustment == DynamicAdjustment.SNAP_TO_BOUNDS) {
    for (    String value : getData()) {
      T parsedValue=type.parse(value);
      try {
        if (type.compare(min,parsedValue) > 0) {
          min=parsedValue;
        }
        if (type.compare(max,parsedValue) < 0) {
          max=parsedValue;
        }
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + value);
      }
    }
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=intervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(intervals.get(j));
    }
    nodes.add(new IndexNode(intervals.get(min).min,intervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  IndexNode index=nodes.get(0);
  String[] data=getData();
  List<Group> groups=new ArrayList<Group>();
  for (int i=0; i < data.length; i++) {
    groups.add(getInterval(index,data[i]));
  }
  return groups;
}","@Override @SuppressWarnings(""String_Node_Str"") protected List<Group> prepareGroups(){
  String valid=internalIsValid();
  if (valid != null) {
    throw new IllegalArgumentException(valid);
  }
  DataTypeWithRatioScale<T> type=(DataTypeWithRatioScale<T>)getDataType();
  T actualMin=min;
  T actualMax=max;
  if (this.adjustment == DynamicAdjustment.SNAP_TO_BOUNDS) {
    for (    String value : getData()) {
      T parsedValue=type.parse(value);
      try {
        if (type.compare(actualMin,parsedValue) > 0) {
          actualMin=parsedValue;
        }
        if (type.compare(actualMax,parsedValue) < 0) {
          actualMax=parsedValue;
        }
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + value);
      }
    }
  }
  List<Interval<T>> actualIntervals=this.intervals;
  if (actualMin != min) {
    actualIntervals=(ArrayList<Interval<T>>)((ArrayList<Interval<T>>)this.intervals).clone();
    Interval<T> first=intervals.get(0);
    actualIntervals.set(0,new Interval<T>((DataType<T>)type,actualMin,first.max,first.function));
  }
  ArrayList<IndexNode> nodes=new ArrayList<IndexNode>();
  for (int i=0, len=actualIntervals.size(); i < len; i+=INDEX_FANOUT) {
    int min=i;
    int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
    List<Interval<T>> leafs=new ArrayList<Interval<T>>();
    for (int j=min; j <= max; j++) {
      leafs.add(actualIntervals.get(j));
    }
    nodes.add(new IndexNode(actualIntervals.get(min).min,actualIntervals.get(max).max,leafs.toArray(new Interval[leafs.size()])));
  }
  while (nodes.size() > 1) {
    List<IndexNode> current=(List<IndexNode>)nodes.clone();
    nodes.clear();
    for (int i=0, len=current.size(); i < len; i+=INDEX_FANOUT) {
      int min=i;
      int max=Math.min(i + INDEX_FANOUT - 1,len - 1);
      List<IndexNode> temp=new ArrayList<IndexNode>();
      for (int j=min; j <= max; j++) {
        temp.add(current.get(j));
      }
      nodes.add(new IndexNode(current.get(min).min,current.get(max).max,temp.toArray(new HierarchyBuilderIntervalBased.IndexNode[temp.size()])));
    }
  }
  IndexNode index=nodes.get(0);
  String[] data=getData();
  List<Group> groups=new ArrayList<Group>();
  Map<Group,Group> cache=new HashMap<Group,Group>();
  for (int i=0; i < data.length; i++) {
    Group group=getInterval(index,actualMax,data[i]);
    Group cached=cache.get(group);
    if (cached != null) {
      groups.add(cached);
    }
 else {
      cache.put(group,group);
      groups.add(group);
    }
  }
  return groups;
}",0.8216288983621269
108769,"/** 
 * Reads in preview data This goes through up to   {@link ImportData#previewDataMaxLines} lineswithin the appropriate file and reads them in. It uses {@link DataSourceImportAdapter} in combination with{@link CSVFileConfiguration} to actually read in the data.
 */
private void readPreview() throws IOException {
  final String location=comboLocation.getText();
  final char separator=separators[selection];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  wizardColumns=new ArrayList<WizardColumn>();
  List<Column> columns=new ArrayList<Column>();
  for (int i=0; i < firstLine.length; i++) {
    Column column=new Column(i,DataType.STRING);
    WizardColumn wizardColumn=new WizardColumn(column);
    wizardColumns.add(wizardColumn);
    columns.add(column);
  }
  CSVFileConfiguration config=new CSVFileConfiguration(location,separator,containsHeader);
  for (  Column c : columns) {
    config.addColumn(c);
  }
  DataSourceImportAdapter importAdapter=DataSourceImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportData.previewDataMaxLines)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  WizardColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(column.getColumn().getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getName());
      tableColumn.setToolTipText(""String_Node_Str"" + column.getColumn().getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}","/** 
 * Reads in preview data This goes through up to   {@link ImportData#previewDataMaxLines} lineswithin the appropriate file and reads them in. It uses {@link DataSourceImportAdapter} in combination with{@link CSVFileConfiguration} to actually read in the data.
 */
private void readPreview() throws IOException {
  previewData.clear();
  final String location=comboLocation.getText();
  final char separator=separators[selection];
  final boolean containsHeader=btnContainsHeader.getSelection();
  final CSVDataInput in=new CSVDataInput(location,separator);
  final Iterator<String[]> it=in.iterator();
  final String[] firstLine;
  if (it.hasNext()) {
    firstLine=it.next();
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  wizardColumns=new ArrayList<WizardColumn>();
  List<Column> columns=new ArrayList<Column>();
  for (int i=0; i < firstLine.length; i++) {
    Column column=new Column(i,DataType.STRING);
    WizardColumn wizardColumn=new WizardColumn(column);
    wizardColumns.add(wizardColumn);
    columns.add(column);
  }
  CSVFileConfiguration config=new CSVFileConfiguration(location,separator,containsHeader);
  for (  Column c : columns) {
    config.addColumn(c);
  }
  DataSourceImportAdapter importAdapter=DataSourceImportAdapter.create(config);
  int count=0;
  while (importAdapter.hasNext() && (count <= ImportData.previewDataMaxLines)) {
    previewData.add(importAdapter.next());
    count++;
  }
  in.close();
  previewData.remove(0);
  if (previewData.size() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  tablePreview.setRedraw(false);
  while (tablePreview.getColumnCount() > 0) {
    tablePreview.getColumns()[0].dispose();
  }
  for (  WizardColumn column : wizardColumns) {
    TableViewerColumn tableViewerColumn=new TableViewerColumn(tableViewerPreview,SWT.NONE);
    tableViewerColumn.setLabelProvider(new CSVColumnLabelProvider(column.getColumn().getIndex()));
    TableColumn tableColumn=tableViewerColumn.getColumn();
    tableColumn.setWidth(100);
    if (btnContainsHeader.getSelection()) {
      tableColumn.setText(column.getColumn().getName());
      tableColumn.setToolTipText(""String_Node_Str"" + column.getColumn().getIndex());
    }
    ColumnViewerToolTipSupport.enableFor(tableViewerPreview,ToolTip.NO_RECREATE);
  }
  tableViewerPreview.setInput(previewData);
  tablePreview.setHeaderVisible(btnContainsHeader.getSelection());
  tablePreview.setVisible(true);
  tablePreview.layout();
  tablePreview.setRedraw(true);
}",0.9953787422141852
108770,"protected synchronized void hide(){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      tip.setVisible(false);
      visible=false;
      text=null;
      bounds=null;
      currentX=-1;
      currentY=-1;
    }
  }
);
}","protected synchronized void hide(){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      shell.setVisible(false);
      visible=false;
      text=null;
      bounds=null;
      currentX=-1;
      currentY=-1;
    }
  }
);
}",0.9844357976653696
108771,"private synchronized void show(){
  if (this.text != null) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        tip.setMessage(text);
        tip.setVisible(true);
        visible=true;
      }
    }
);
  }
}","private synchronized void show(){
  if (this.text != null) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        shellText.setText(text);
        shell.pack();
        shell.setLocation(currentX,currentY);
        shell.setVisible(true);
        visible=true;
      }
    }
);
  }
}",0.7617391304347826
108772,"@Override public void run(){
  tip.setVisible(false);
  visible=false;
  text=null;
  bounds=null;
  currentX=-1;
  currentY=-1;
}","@Override public void run(){
  shell.setVisible(false);
  visible=false;
  text=null;
  bounds=null;
  currentX=-1;
  currentY=-1;
}",0.9694656488549618
108773,"/** 
 * Creates a new instance
 * @param parent
 */
public MainToolTip(final Shell parent){
  tip=new ToolTip(parent,SWT.ICON_INFORMATION);
  tip.setAutoHide(false);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
synchronized (this) {
          if (!visible && bounds != null) {
            Point p=MouseInfo.getPointerInfo().getLocation();
            if (p.x != currentX || p.y != currentY) {
              currentTime=System.currentTimeMillis();
              currentX=p.x;
              currentY=p.y;
            }
 else {
              if (System.currentTimeMillis() - currentTime > THRESHOLD) {
                if (bounds.contains(currentX,currentY)) {
                  show();
                }
              }
            }
          }
          if (visible && bounds != null) {
            Point p=MouseInfo.getPointerInfo().getLocation();
            if (!bounds.contains(p)) {
              hide();
            }
          }
        }
        try {
          Thread.sleep(WAIT);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
);
  t.setDaemon(true);
  t.start();
}","/** 
 * Creates a new instance
 * @param parent
 */
public MainToolTip(final Shell parent){
  shell=new Shell(parent,SWT.TOOL | SWT.ON_TOP);
  shell.setLayout(new GridLayout());
  shell.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
  shellText=new Text(shell,SWT.MULTI);
  shellText.setLayoutData(SWTUtil.createFillGridData());
  shellText.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
  shellText.setForeground(parent.getDisplay().getSystemColor(SWT.COLOR_INFO_FOREGROUND));
  shell.pack();
  shell.setVisible(false);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
synchronized (this) {
          if (!visible && bounds != null) {
            Point p=MouseInfo.getPointerInfo().getLocation();
            if (p.x != currentX || p.y != currentY) {
              currentTime=System.currentTimeMillis();
              currentX=p.x;
              currentY=p.y;
            }
 else {
              if (System.currentTimeMillis() - currentTime > THRESHOLD) {
                if (bounds.contains(currentX,currentY)) {
                  show();
                }
              }
            }
          }
          if (visible && bounds != null) {
            Point p=MouseInfo.getPointerInfo().getLocation();
            if (!bounds.contains(p)) {
              hide();
            }
          }
        }
        try {
          Thread.sleep(WAIT);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
);
  t.setDaemon(true);
  t.start();
}",0.8220183486238533
108774,"protected synchronized void hide(){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      shell.setVisible(false);
      visible=false;
      text=null;
      bounds=null;
      currentX=-1;
      currentY=-1;
    }
  }
);
}","protected void hide(){
synchronized (this) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        shell.setVisible(false);
        visible=false;
        text=null;
        bounds=null;
        currentX=-1;
        currentY=-1;
      }
    }
);
  }
}",0.8087431693989071
108775,"private synchronized void show(){
  if (this.text != null) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        shellText.setText(text);
        shell.pack();
        shell.setLocation(currentX,currentY);
        shell.setVisible(true);
        visible=true;
      }
    }
);
  }
}","private void show(){
synchronized (this) {
    if (this.text != null) {
      Display.getDefault().asyncExec(new Runnable(){
        @Override public void run(){
          shellText.setText(text);
          shell.pack();
          shell.setLocation(currentX,currentY);
          shell.setVisible(true);
          visible=true;
        }
      }
);
    }
  }
}",0.8638360175695461
108776,"public synchronized void setText(String text,org.eclipse.swt.graphics.Rectangle bounds){
  if (this.visible)   return;
  this.text=text;
  this.bounds=new Rectangle(bounds.x,bounds.y,bounds.width,bounds.height);
}","public void setText(String text,org.eclipse.swt.graphics.Rectangle bounds){
synchronized (this) {
    if (this.visible)     return;
    this.text=text;
    this.bounds=new Rectangle(bounds.x,bounds.y,bounds.width,bounds.height);
  }
}",0.8948545861297539
108777,"protected void hide(){
synchronized (this) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        shell.setVisible(false);
        visible=false;
        text=null;
        bounds=null;
        currentX=-1;
        currentY=-1;
      }
    }
);
  }
}","protected void hide(){
synchronized (this) {
    Display.getDefault().syncExec(new Runnable(){
      @Override public void run(){
        shell.setVisible(false);
        visible=false;
        text=null;
        bounds=null;
        currentX=-1;
        currentY=-1;
      }
    }
);
  }
}",0.9982788296041308
108778,"private void show(){
synchronized (this) {
    if (this.text != null) {
      Display.getDefault().asyncExec(new Runnable(){
        @Override public void run(){
          shellText.setText(text);
          shell.pack();
          shell.setLocation(currentX,currentY);
          shell.setVisible(true);
          visible=true;
        }
      }
);
    }
  }
}","private void show(){
synchronized (this) {
    if (this.text != null) {
      Display.getDefault().syncExec(new Runnable(){
        @Override public void run(){
          shellText.setText(text);
          shell.pack();
          shell.setLocation(currentX,currentY);
          shell.setVisible(true);
          visible=true;
        }
      }
);
    }
  }
}",0.99860529986053
108779,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell(),SWT.POP_UP);
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
          final org.eclipse.swt.graphics.Rectangle bounds=new org.eclipse.swt.graphics.Rectangle((int)dbounds.x,(int)dbounds.y,(int)nodeWidth,(int)nodeHeight);
          if (bounds.x < 0)           bounds.x=0;
          if (bounds.y < 0)           bounds.y=0;
          bounds.x=frame.getLocationOnScreen().x + bounds.x;
          bounds.y=frame.getLocationOnScreen().y + bounds.y;
          controller.getToolTip().setText(createTooltipText(node),bounds);
        }
      }
    }
  }
);
  resetBuffer();
  initializeListeners();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          final Bounds dbounds=(Bounds)node.getAttributes().get(ATTRIBUTE_BOUNDS);
          final org.eclipse.swt.graphics.Rectangle bounds=new org.eclipse.swt.graphics.Rectangle((int)dbounds.x,(int)dbounds.y,(int)nodeWidth,(int)nodeHeight);
          if (bounds.x < 0)           bounds.x=0;
          if (bounds.y < 0)           bounds.y=0;
          bounds.x=frame.getLocationOnScreen().x + bounds.x;
          bounds.y=frame.getLocationOnScreen().y + bounds.y;
          controller.getToolTip().setText(createTooltipText(node),bounds);
        }
      }
    }
  }
);
  resetBuffer();
  initializeListeners();
}",0.9978444052518126
108780,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          controller.getToolTip().setText(createTooltipText(node),getBounds(node));
        }
      }
    }
  }
);
  resetBuffer();
  initializeListeners();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewLattice(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.SELECTED_NODE,this);
  controller.addListener(ModelPart.FILTER,this);
  controller.addListener(ModelPart.MODEL,this);
  this.controller=controller;
  parent.setLayout(new GridLayout());
  bridge=new Composite(parent,SWT.BORDER | SWT.NO_BACKGROUND | SWT.EMBEDDED);
  bridge.setLayoutData(SWTUtil.createFillGridData());
  frame=SWT_AWT.new_Frame(bridge);
  frame.setLayout(new BorderLayout());
  frame.add(this,BorderLayout.CENTER);
  frame.setBackground(Color.WHITE);
  menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getClipboard().add(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.CLIPBOARD,selectedNode));
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
      model.setSelectedNode(selectedNode);
      controller.update(new ModelEvent(ViewLattice.this,ModelPart.SELECTED_NODE,selectedNode));
      repaint();
    }
  }
);
  this.tooltipTimer=new Timer(TOOLTIP_WAIT,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (tooltipX != -1 && tooltipY != -1) {
        final ARXNode node=getNode(tooltipX,tooltipY);
        if (node != null) {
          controller.getToolTip().setText(createTooltipText(node),getBounds(node));
        }
      }
    }
  }
);
  this.tooltipTimer.setRepeats(false);
  resetBuffer();
  initializeListeners();
}",0.990756103342024
108781,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell(),SWT.POP_UP);
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.getClipboard().remove(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          controller.getPopup().show(menu,point.x,point.y);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewClipboard(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.CLIPBOARD,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  root.setLayout(groupNodeGridLayout);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL| SWT.H_SCROLL);
  table.setLayoutData(SWTUtil.createFillGridData());
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  table.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      final TableItem[] s=table.getSelection();
      if (s.length > 0) {
        final ARXNode node=(ARXNode)s[0].getData();
        model.setSelectedNode(node);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
      }
    }
  }
);
  this.menu=new Menu(parent.getShell());
  MenuItem item1=new MenuItem(menu,SWT.NONE);
  item1.setText(Resources.getMessage(""String_Node_Str""));
  item1.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        final String label=Arrays.toString(node.getTransformation());
        final String value=controller.actionShowInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + label,selectedTableItem.getText(1));
        if (value != null) {
          selectedTableItem.setText(1,value);
          node.getAttributes().put(NODE_COMMENT,value);
        }
      }
    }
  }
);
  MenuItem item2=new MenuItem(menu,SWT.NONE);
  item2.setText(Resources.getMessage(""String_Node_Str""));
  item2.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (selectedTableItem != null) {
        ARXNode node=(ARXNode)selectedTableItem.getData();
        model.getClipboard().remove(node);
        removeItem(selectedTableItem);
        controller.update(new ModelEvent(ViewClipboard.this,ModelPart.CLIPBOARD,null));
      }
    }
  }
);
  MenuItem item3=new MenuItem(menu,SWT.NONE);
  item3.setText(Resources.getMessage(""String_Node_Str""));
  item3.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      controller.actionApplySelectedTransformation();
    }
  }
);
  table.addListener(SWT.MouseDown,new Listener(){
    @Override public void handleEvent(    final Event event){
      if (event.button == 3) {
        final TableItem i=getItemAt(event.x,event.y);
        if (i != null) {
          final ARXNode node=(ARXNode)i.getData();
          model.setSelectedNode(node);
          controller.update(new ModelEvent(ViewClipboard.this,ModelPart.SELECTED_NODE,node));
          selectedTableItem=i;
          Point point=table.toDisplay(event.x,event.y);
          controller.getPopup().show(menu,point.x,point.y);
        }
      }
    }
  }
);
  final TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  final TableColumn c2=new TableColumn(table,SWT.NONE);
  c2.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c2);
  c.pack();
  c2.pack();
}",0.9985370394999336
108782,"/** 
 * Sets the hierarchy displayed by this view
 * @param type
 */
public void setHierarchy(final AttributeType.Hierarchy type){
  hierarchy=type.getHierarchy();
  table.setRedraw(false);
  for (  final TableColumn t : table.getColumns()) {
    t.dispose();
  }
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  if ((type.getHierarchy() == null) || (type.getHierarchy().length == 0)) {
    table.setRedraw(true);
    table.redraw();
    return;
  }
  final TableColumn[] column=new TableColumn[type.getHierarchy()[0].length];
  for (int i=0; i < column.length; i++) {
    column[i]=new TableColumn(table,SWT.NONE);
    column[i].setText(Resources.getMessage(""String_Node_Str"") + (i + 1));
    column[i].pack();
  }
  for (int i=0; i < type.getHierarchy().length; i++) {
    final TableItem item=new TableItem(table,SWT.NONE);
    item.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_GRAY));
    for (int j=0; j < type.getHierarchy()[i].length; j++) {
      item.setText(j,type.getHierarchy()[i][j]);
    }
  }
  for (  final TableColumn t : table.getColumns()) {
    t.pack();
  }
  table.setRedraw(true);
  table.redraw();
  updateGlobalHierarchy();
}","/** 
 * Sets the hierarchy displayed by this view
 * @param type
 */
public void setHierarchy(final AttributeType.Hierarchy type){
  hierarchy=type.getHierarchy();
  if (table.isDisposed())   return;
  table.setRedraw(false);
  for (  final TableColumn t : table.getColumns()) {
    t.dispose();
  }
  for (  final TableItem i : table.getItems()) {
    i.dispose();
  }
  if ((type.getHierarchy() == null) || (type.getHierarchy().length == 0)) {
    table.setRedraw(true);
    table.redraw();
    return;
  }
  final TableColumn[] column=new TableColumn[type.getHierarchy()[0].length];
  for (int i=0; i < column.length; i++) {
    column[i]=new TableColumn(table,SWT.NONE);
    column[i].setText(Resources.getMessage(""String_Node_Str"") + (i + 1));
    column[i].pack();
  }
  for (int i=0; i < type.getHierarchy().length; i++) {
    final TableItem item=new TableItem(table,SWT.NONE);
    item.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_GRAY));
    for (int j=0; j < type.getHierarchy()[i].length; j++) {
      item.setText(j,type.getHierarchy()[i][j]);
    }
  }
  for (  final TableColumn t : table.getColumns()) {
    t.pack();
  }
  table.setRedraw(true);
  table.redraw();
  updateGlobalHierarchy();
}",0.9850746268656716
108783,"/** 
 * Scales the given string array
 * @param values
 * @param factor
 * @return
 */
private String[] getScaledValues(String[] values,double factor){
  String[] result=new String[(int)Math.round(factor * (double)values.length)];
  int previous=-1;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    if (index == previous) {
      toAggregate.add(values[i]);
    }
 else     if (previous != -1) {
      result[previous]=AggregateFunction.SET.aggregate(toAggregate.toArray(new String[toAggregate.size()]),DataType.STRING);
      toAggregate.clear();
      previous=index;
    }
  }
  return result;
}","/** 
 * Scales the given string array
 * @param values
 * @param factor
 * @return
 */
private String[] getScaledValues(String[] values,double factor){
  AggregateFunction<String> function=AggregateFunction.SET(DataType.STRING);
  String[] result=new String[(int)Math.round(factor * (double)values.length)];
  int previous=-1;
  List<String> toAggregate=new ArrayList<String>();
  for (int i=0; i < values.length; i++) {
    int index=(int)Math.round((double)i * factor);
    if (index == previous) {
      toAggregate.add(values[i]);
    }
 else     if (previous != -1) {
      result[previous]=function.aggregate(toAggregate.toArray(new String[toAggregate.size()]));
      toAggregate.clear();
      previous=index;
    }
  }
  return result;
}",0.3116343490304709
108784,"/** 
 * Create a date with a format string. Format strings must be valid formats for <code>SimpleDateFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"">SimpleDateFormat</a>
 */
private ARXDate(final String format){
  this.format=new SimpleDateFormat(format);
  this.string=format;
}","/** 
 * Create a date with a format string. Format strings must be valid formats for <code>SimpleDateFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"">SimpleDateFormat</a>
 */
private ARXDate(final String formatString){
  if (format == null || format.equals(""String_Node_Str"")) {
    string=""String_Node_Str"";
    format=new SimpleDateFormat(string);
  }
 else {
    this.format=new SimpleDateFormat(formatString);
    this.string=formatString;
  }
}",0.7525655644241733
108785,"/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXInteger(String format){
  if (format != null) {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
 else {
    this.format=null;
    this.string=null;
  }
}","/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXInteger(String format){
  if (format == null || format.equals(""String_Node_Str"")) {
    this.format=null;
    this.string=null;
  }
 else {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
}",0.8191964285714286
108786,"/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXDecimal(String format){
  if (format != null) {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
 else {
    this.format=null;
    this.string=null;
  }
}","/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXDecimal(String format){
  if (format == null || format.equals(""String_Node_Str"")) {
    this.format=null;
    this.string=null;
  }
 else {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
}",0.8191964285714286
108787,"/** 
 * Create a date with a format string. Format strings must be valid formats for <code>SimpleDateFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"">SimpleDateFormat</a>
 */
private ARXDate(final String format){
  this.format=new SimpleDateFormat(format);
  this.string=format;
}","/** 
 * Create a date with a format string. Format strings must be valid formats for <code>SimpleDateFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"">SimpleDateFormat</a>
 */
private ARXDate(final String formatString){
  if (format == null || format.equals(""String_Node_Str"")) {
    string=""String_Node_Str"";
    format=new SimpleDateFormat(string);
  }
 else {
    this.format=new SimpleDateFormat(formatString);
    this.string=formatString;
  }
}",0.7525655644241733
108788,"/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXInteger(String format){
  if (format != null) {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
 else {
    this.format=null;
    this.string=null;
  }
}","/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXInteger(String format){
  if (format == null || format.equals(""String_Node_Str"")) {
    this.format=null;
    this.string=null;
  }
 else {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
}",0.8191964285714286
108789,"/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXDecimal(String format){
  if (format != null) {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
 else {
    this.format=null;
    this.string=null;
  }
}","/** 
 * Create a numeric with a format string. Format strings must be valid formats for <code>DecimalFormat</code>.
 * @param format
 * @see <a href=""http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html"">DecimalFormat</a>
 */
private ARXDecimal(String format){
  if (format == null || format.equals(""String_Node_Str"")) {
    this.format=null;
    this.string=null;
  }
 else {
    this.format=new DecimalFormat(format);
    this.string=format;
  }
}",0.8191964285714286
108790,"/** 
 * Returns the next row The returned element is sorted as defined by   {@link Column#index} andcontains as many elements as there are columns selected to import from {@link #indexes}. The first row   {@link #firstRowReturned}contains the names of the columns.
 */
@Override public String[] next(){
  if (!firstRowReturned) {
    firstRowReturned=true;
    String[] header=lastRow;
    int i=0;
    for (    Column column : config.getColumns()) {
      if (!config.isContainsHeader()) {
        header[i]=""String_Node_Str"" + column.getIndex();
      }
 else {
        header[i]=lastRow[column.getIndex()];
      }
      if (column.getName() != null) {
        header[i]=column.getName();
      }
      column.setName(header[i]);
      i++;
    }
    return header;
  }
  lastRow=it.next();
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=lastRow[indexes[i]];
    if (!types[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return result;
}","/** 
 * Returns the next row The returned element is sorted as defined by   {@link Column#index} andcontains as many elements as there are columns selected to import from {@link #indexes}. The first row   {@link #headerReturned}contains the names of the columns.
 */
@Override public String[] next(){
  if (!headerReturned) {
    headerReturned=true;
    return createHeader();
  }
  String[] result=new String[indexes.length];
  for (int i=0; i < indexes.length; i++) {
    result[i]=row[indexes[i]];
    if (!types[i].isValid(result[i])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (it.hasNext()) {
    row=it.next();
  }
 else {
    row=null;
  }
  return result;
}",0.4379645511720983
108791,"/** 
 * Indicates whether there is another element to return This returns true when the CSV file has another line and there are actually columns to import from   {@link #columns}.
 * @return Boolean value, see above
 */
@Override public boolean hasNext(){
  return it.hasNext() && (config.getColumns().size() != 0);
}","/** 
 * Indicates whether there is another element to return This returns true when the CSV file has another line and there are actually columns to import from   {@link #columns}.
 * @return Boolean value, see above
 */
@Override public boolean hasNext(){
  return row != null;
}",0.912751677852349
108792,"/** 
 * Creates a new instance
 * @param config
 */
protected CSVImportAdapter(CSVConfiguration config) throws IOException {
  super(config);
  this.config=config;
  this.bytesTotal=new File(config.getFile()).length();
  this.indexes=getIndexesToImport();
  this.types=getColumnDatatypes();
  cin=new CountingInputStream(new FileInputStream(new File(config.getFile())));
  in=new CSVDataInput(cin,config.getSeparator());
  it=in.iterator();
  if (it.hasNext()) {
    lastRow=it.next();
    if (config.isContainsHeader()) {
      if (!it.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}","/** 
 * Creates a new instance
 * @param config
 */
protected CSVImportAdapter(CSVConfiguration config) throws IOException {
  super(config);
  this.config=config;
  this.bytesTotal=new File(config.getFile()).length();
  this.indexes=getIndexesToImport();
  this.types=getColumnDatatypes();
  cin=new CountingInputStream(new FileInputStream(new File(config.getFile())));
  in=new CSVDataInput(cin,config.getSeparator());
  it=in.iterator();
  if (it.hasNext()) {
    row=it.next();
    if (config.fileContainsHeader()) {
      if (!it.hasNext()) {
        throw new IOException(""String_Node_Str"");
      }
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}",0.948224852071006
108793,"/** 
 * Creates a new instance
 * @param config
 */
protected DataSourceImportAdapter(DataSourceConfiguration config){
  this.columns=config.getColumns();
  if (this.columns.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Creates a new instance
 * @param config
 */
protected DataSourceImportAdapter(DataSourceConfiguration config){
  this.columns=config.getColumns();
  this.config=config;
  if (this.columns.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9580152671755724
108794,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle()));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle()));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput()));
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getHideVisualizationAt()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getHideVisualizationAt()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.9940397350993376
108795,"@Override public String toString(){
  return ""String_Node_Str"" + part + ""String_Node_Str""+ source.getClass().getSimpleName()+ ""String_Node_Str""+ source.hashCode()+ ""String_Node_Str""+ data.getClass().getSimpleName()+ ""String_Node_Str""+ data.hashCode()+ ""String_Node_Str"";
}","@Override public String toString(){
  String sourceLabel=""String_Node_Str"";
  if (source != null)   sourceLabel=source.getClass().getSimpleName() + ""String_Node_Str"" + source.hashCode();
  String dataLabel=""String_Node_Str"";
  if (data != null)   dataLabel=data.getClass().getSimpleName() + ""String_Node_Str"" + data.hashCode();
  return ""String_Node_Str"" + part + ""String_Node_Str""+ sourceLabel+ ""String_Node_Str""+ dataLabel+ ""String_Node_Str"";
}",0.3927576601671309
108796,"/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVConfiguration) {
    model.setInputBytes(new File(((CSVConfiguration)config).getFile()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
    definition.setDataType(model.getInputConfig().getInput().getHandle().getAttributeName(i),DataType.STRING);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(DataSourceConfiguration config){
  final WorkerImport worker=new WorkerImport(config);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  if (config instanceof CSVConfiguration) {
    model.setInputBytes(new File(((CSVConfiguration)config).getFile()).length());
  }
 else {
    model.setInputBytes(0);
  }
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.969140950792327
108797,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getHideVisualizationAt()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle(),false));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle(),false));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput(),false));
  }
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(!model.isVisualizationEnabled()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(model.getHideVisualizationAt()).append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  if (eventBuffer.isEmpty()) {
    builder.append(""String_Node_Str"");
  }
 else {
    for (    String s : eventBuffer) {
      builder.append(s).append(""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.9996709443896018
108798,"/** 
 * Redraws the plot
 */
public void updatePlot(){
  Graphics2D g2d=(Graphics2D)buffer.getGraphics();
  g2d.setColor(background);
  g2d.fillRect(0,0,buffer.getWidth(),buffer.getHeight());
  if (buffer.getWidth() > OFFSET_LEFT + OFFSET_RIGHT + 100 && buffer.getHeight() > OFFSET_TOP + OFFSET_BOTTOM) {
    int width=buffer.getWidth() - OFFSET_LEFT - OFFSET_RIGHT;
    int height=buffer.getHeight() - OFFSET_TOP - OFFSET_BOTTOM;
    if (heatmap != null) {
      g2d.drawImage(heatmap,OFFSET_LEFT,OFFSET_TOP,width,height,null);
      g2d.setColor(Color.black);
      g2d.drawRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      double tickX=(double)width / (double)heatmap.getWidth();
      if (tickX >= 2d) {
        double currX=tickX;
        while (currX < width - 1) {
          g2d.setColor(Color.darkGray);
          g2d.drawLine(OFFSET_LEFT + (int)currX,OFFSET_TOP + height,OFFSET_LEFT + (int)currX + 1,OFFSET_TOP + height + OFFSET_TICK_SMALL);
          currX+=tickX;
        }
      }
      double tickY=(double)height / (double)heatmap.getHeight();
      if (tickY >= 2d) {
        double currY=tickY;
        while (currY < height - 1) {
          g2d.setColor(Color.darkGray);
          g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + (int)currY,OFFSET_LEFT - OFFSET_TICK_SMALL,OFFSET_TOP + (int)currY + 1);
          currY+=tickY;
        }
      }
    }
 else {
      g2d.setColor(Color.white);
      g2d.fillRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      g2d.setColor(Color.black);
      g2d.drawRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
      g2d.setColor(Color.black);
      drawText(""String_Node_Str"",g2d,OFFSET_LEFT,OFFSET_TOP,width,height);
    }
    RenderingHints hints=g2d.getRenderingHints();
    g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
    int legendWidth=buffer.getWidth() - width - OFFSET_LEFT- 2 * OFFSET_LEGEND;
    g2d.drawImage(LEGEND,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP + height,legendWidth,-height,null);
    g2d.setRenderingHints(hints);
    g2d.setColor(Color.black);
    g2d.drawRect(OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP,legendWidth,height);
    g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    g2d.setColor(Color.black);
    drawText(""String_Node_Str"",g2d,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP - 15,legendWidth,10);
    drawText(""String_Node_Str"",g2d,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP + height + 5,legendWidth,10);
    g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP,OFFSET_LEFT - OFFSET_TICK,OFFSET_TOP);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + height,OFFSET_LEFT - OFFSET_TICK,OFFSET_TOP + height);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + height,OFFSET_LEFT,OFFSET_TOP + height + OFFSET_TICK);
    g2d.drawLine(OFFSET_LEFT + width,OFFSET_TOP + height,OFFSET_LEFT + width,OFFSET_TOP + height + OFFSET_TICK);
    if (attribute1 != null && attribute2 != null) {
      g2d.setColor(Color.black);
      g2d.setFont(FONT);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
      drawText(attribute2,g2d,OFFSET_LEFT,OFFSET_TOP + height + 4,width,10);
      g2d.rotate(Math.PI / 2);
      drawText(attribute1,g2d,OFFSET_TOP,-OFFSET_LEFT + 4,height,10);
      g2d.rotate(-Math.PI / 2);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    }
  }
  g2d.dispose();
}","/** 
 * Redraws the plot
 */
public void updatePlot(){
  Graphics2D g2d=(Graphics2D)buffer.getGraphics();
  g2d.setColor(background);
  g2d.fillRect(0,0,buffer.getWidth(),buffer.getHeight());
  if (buffer.getWidth() > OFFSET_LEFT + OFFSET_RIGHT + 100 && buffer.getHeight() > OFFSET_TOP + OFFSET_BOTTOM) {
    int width=buffer.getWidth() - OFFSET_LEFT - OFFSET_RIGHT;
    int height=buffer.getHeight() - OFFSET_TOP - OFFSET_BOTTOM;
    if (heatmap != null) {
      g2d.drawImage(heatmap,OFFSET_LEFT,OFFSET_TOP,width,height,null);
      g2d.setColor(Color.black);
      g2d.drawRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      double tickX=(double)width / (double)heatmap.getWidth();
      if (tickX >= 2d) {
        double currX=tickX;
        while (currX < width - 1) {
          g2d.setColor(Color.darkGray);
          g2d.drawLine(OFFSET_LEFT + (int)currX,OFFSET_TOP + height,OFFSET_LEFT + (int)currX + 1,OFFSET_TOP + height + OFFSET_TICK_SMALL);
          currX+=tickX;
        }
      }
      double tickY=(double)height / (double)heatmap.getHeight();
      if (tickY >= 2d) {
        double currY=tickY;
        while (currY < height - 1) {
          g2d.setColor(Color.darkGray);
          g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + (int)currY,OFFSET_LEFT - OFFSET_TICK_SMALL,OFFSET_TOP + (int)currY + 1);
          currY+=tickY;
        }
      }
    }
 else {
      g2d.setColor(Color.white);
      g2d.fillRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      g2d.setColor(Color.black);
      g2d.drawRect(OFFSET_LEFT,OFFSET_TOP,width,height);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
      g2d.setColor(Color.black);
      drawText(""String_Node_Str"",g2d,OFFSET_LEFT,OFFSET_TOP,width,height);
    }
    RenderingHints hints=g2d.getRenderingHints();
    g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
    int legendWidth=buffer.getWidth() - width - OFFSET_LEFT- 2 * OFFSET_LEGEND;
    g2d.drawImage(LEGEND,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP + height,legendWidth,-height,null);
    g2d.setRenderingHints(hints);
    g2d.setColor(Color.black);
    g2d.drawRect(OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP,legendWidth,height);
    g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    g2d.setColor(Color.black);
    drawText(""String_Node_Str"",g2d,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP - 15,legendWidth,10);
    drawText(""String_Node_Str"",g2d,OFFSET_LEFT + width + OFFSET_LEGEND,OFFSET_TOP + height + 5,legendWidth,10);
    g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP,OFFSET_LEFT - OFFSET_TICK,OFFSET_TOP);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + height,OFFSET_LEFT - OFFSET_TICK,OFFSET_TOP + height);
    g2d.drawLine(OFFSET_LEFT,OFFSET_TOP + height,OFFSET_LEFT,OFFSET_TOP + height + OFFSET_TICK);
    g2d.drawLine(OFFSET_LEFT + width,OFFSET_TOP + height,OFFSET_LEFT + width,OFFSET_TOP + height + OFFSET_TICK);
    if (attribute1 != null && attribute2 != null) {
      g2d.setColor(Color.black);
      g2d.setFont(FONT);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
      drawText(attribute1,g2d,OFFSET_LEFT,OFFSET_TOP + height + 4,width,10);
      g2d.rotate(Math.PI / 2);
      drawText(attribute2,g2d,OFFSET_TOP,-OFFSET_LEFT + 4,height,10);
      g2d.rotate(-Math.PI / 2);
      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    }
  }
  g2d.dispose();
}",0.9994526546250684
108799,"/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype);
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    for (int i=0; i < _hierarchy.length; i++) {
      baseSet.add(_hierarchy[i][0]);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute));
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      baseOrder.put(baseArray[i],i);
    }
    for (int i=0; i < _hierarchy.length; i++) {
      if (!order.containsKey(_hierarchy[i][level])) {
        int position=baseOrder.get(_hierarchy[i][0]);
        order.put(_hierarchy[i][level],position);
        max=Math.max(position,max) + 1;
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}","/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype);
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    DataType<?> baseType=handle.getBaseDataType(attribute);
    for (int i=0; i < _hierarchy.length; i++) {
      String element=_hierarchy[i][0];
      if (baseType.isValid(element))       baseSet.add(element);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute));
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      baseOrder.put(baseArray[i],i);
    }
    for (int i=0; i < _hierarchy.length; i++) {
      if (!order.containsKey(_hierarchy[i][level])) {
        Integer position=baseOrder.get(_hierarchy[i][0]);
        if (position != null) {
          order.put(_hierarchy[i][level],position);
          max=Math.max(position,max) + 1;
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}",0.9401906963305404
108800,"/** 
 * Redraws the actual heatmap
 */
public void updateData(String attribute1,String attribute2,StatisticsContingencyTable table){
  this.attribute1=attribute1;
  this.attribute2=attribute2;
  if (attribute1 == null || attribute2 == null || table == null) {
    heatmap=null;
    return;
  }
  BufferedImage heatmap=new BufferedImage(table.values1.length,table.values2.length,BufferedImage.TYPE_INT_ARGB);
  Graphics2D g=(Graphics2D)heatmap.getGraphics();
  Iterator<Entry> iterator=table.iterator;
  while (iterator.hasNext()) {
    Entry entry=iterator.next();
    g.setColor(GRADIENT[(int)(entry.frequency * (GRADIENT.length - 1))]);
    g.fillRect(entry.value1,entry.value2,1,1);
  }
  g.dispose();
  this.heatmap=heatmap;
}","/** 
 * Redraws the actual heatmap
 */
public void updateData(String attribute1,String attribute2,StatisticsContingencyTable table){
  this.attribute1=attribute1;
  this.attribute2=attribute2;
  if (attribute1 == null || attribute2 == null || table == null) {
    heatmap=null;
    return;
  }
  BufferedImage heatmap=new BufferedImage(table.values1.length,table.values2.length,BufferedImage.TYPE_INT_ARGB);
  Graphics2D g=(Graphics2D)heatmap.getGraphics();
  g.setColor(GRADIENT[0]);
  g.fillRect(0,0,heatmap.getWidth(),heatmap.getHeight());
  Iterator<Entry> iterator=table.iterator;
  while (iterator.hasNext()) {
    Entry entry=iterator.next();
    g.setColor(GRADIENT[(int)(entry.frequency * (GRADIENT.length - 1))]);
    g.fillRect(entry.value1,entry.value2,1,1);
  }
  g.dispose();
  this.heatmap=heatmap;
}",0.7805825242718447
108801,"/** 
 * Update the data type
 */
private void updateDataType(){
  final DataType<?> dtype=model.getInputConfig().getInput().getDefinition().getDataType(attribute);
  dataTypeCombo.select(getIndexOfDataType(dtype));
  if (dtype instanceof ARXOrderedString || dtype.getDescription().hasFormat()) {
    DataTypeWithFormat dtwf=(DataTypeWithFormat)dtype;
    String format=dtwf.getFormat();
    if (format == null) {
      dataTypeText.setText(""String_Node_Str"");
    }
 else {
      dataTypeText.setText(format);
    }
  }
 else {
    dataTypeText.setText(""String_Node_Str"");
  }
}","/** 
 * Update the data type
 */
private void updateDataType(){
  final DataType<?> dtype=model.getInputConfig().getInput().getDefinition().getDataType(attribute);
  dataTypeCombo.select(getIndexOfDataType(dtype));
  if (!(dtype instanceof ARXOrderedString) && dtype.getDescription().hasFormat()) {
    DataTypeWithFormat dtwf=(DataTypeWithFormat)dtype;
    String format=dtwf.getFormat();
    if (format == null) {
      dataTypeText.setText(""String_Node_Str"");
    }
 else {
      dataTypeText.setText(format);
    }
  }
 else {
    dataTypeText.setText(""String_Node_Str"");
  }
}",0.9922346850733392
108802,"@Override public void widgetSelected(final SelectionEvent arg0){
  if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
    if ((model != null) && (model.getInputConfig().getInput() != null)) {
      String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      DataType<?> type;
      if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(text1,text2,description,getValues());
        if (format == null) {
          type=DataType.STRING;
          dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
          dataTypeText.setText(""String_Node_Str"");
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,getValues())) {
          type=DataType.STRING;
          dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
          dataTypeText.setText(""String_Node_Str"");
        }
      }
      model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
      controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
    }
  }
}","@Override public void widgetSelected(final SelectionEvent arg0){
  if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
    if ((model != null) && (model.getInputConfig().getInput() != null)) {
      String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
      DataTypeDescription<?> description=getDataType(label);
      DataType<?> type;
      if (description.hasFormat()) {
        final String text1=Resources.getMessage(""String_Node_Str"");
        final String text2=Resources.getMessage(""String_Node_Str"");
        final String format=controller.actionShowFormatInputDialog(text1,text2,description,getValues());
        if (format == null) {
          type=DataType.STRING;
        }
 else {
          type=description.newInstance(format);
        }
      }
 else {
        type=description.newInstance();
        if (!isValidDataType(type,getValues())) {
          type=DataType.STRING;
        }
      }
      model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
      updateDataType();
      controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
    }
  }
}",0.6943335993615323
108803,"/** 
 * Constructor
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=6;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          boolean criteriaDisabled=false;
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            if (model.getLDiversityModel().get(attribute).isEnabled() || model.getTClosenessModel().get(attribute).isEnabled()) {
              criteriaDisabled=true;
            }
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            if (model.getKAnonymityModel().isEnabled() || model.getDPresenceModel().isEnabled()) {
              criteriaDisabled=true;
            }
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
            model.getKAnonymityModel().setEnabled(false);
            model.getDPresenceModel().setEnabled(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          if (criteriaDisabled) {
            controller.update(new ModelEvent(outer,ModelPart.CRITERION_DEFINITION,null));
          }
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(getDataTypes());
  dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          DataType<?> type;
          if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(text1,text2,description,getValues());
            if (format == null) {
              type=DataType.STRING;
              dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
              dataTypeText.setText(""String_Node_Str"");
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,getValues())) {
              type=DataType.STRING;
              dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
              dataTypeText.setText(""String_Node_Str"");
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel3=new Label(type,SWT.PUSH);
  kLabel3.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeText=new Text(type,SWT.READ_ONLY | SWT.BORDER);
  dataTypeText.setLayoutData(SWTUtil.createFillGridData());
  dataTypeText.setEditable(false);
  dataTypeText.setText(""String_Node_Str"");
  dataTypeText.setEnabled(false);
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}","/** 
 * Constructor
 * @param parent
 * @param attribute
 * @param controller
 */
public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=6;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          boolean criteriaDisabled=false;
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            if (model.getLDiversityModel().get(attribute).isEnabled() || model.getTClosenessModel().get(attribute).isEnabled()) {
              criteriaDisabled=true;
            }
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            if (model.getKAnonymityModel().isEnabled() || model.getDPresenceModel().isEnabled()) {
              criteriaDisabled=true;
            }
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
            model.getKAnonymityModel().setEnabled(false);
            model.getDPresenceModel().setEnabled(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          if (criteriaDisabled) {
            controller.update(new ModelEvent(outer,ModelPart.CRITERION_DEFINITION,null));
          }
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(getDataTypes());
  dataTypeCombo.select(getIndexOfDataType(DataType.STRING));
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          String label=dataTypeCombo.getItem(dataTypeCombo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          DataType<?> type;
          if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(text1,text2,description,getValues());
            if (format == null) {
              type=DataType.STRING;
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,getValues())) {
              type=DataType.STRING;
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          updateDataType();
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel3=new Label(type,SWT.PUSH);
  kLabel3.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeText=new Text(type,SWT.READ_ONLY | SWT.BORDER);
  dataTypeText.setLayoutData(SWTUtil.createFillGridData());
  dataTypeText.setEditable(false);
  dataTypeText.setText(""String_Node_Str"");
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}",0.9275793650793652
108804,"/** 
 * Updates the view
 */
private void update(){
  Context context=acontext.getContext();
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=null;
      if (this.target == ModelPart.OUTPUT)       hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}","/** 
 * Updates the view
 */
private void update(){
  Context context=acontext.getContext();
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}",0.9772806710940232
108805,"/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null) {
    sort(list,datatype);
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    if (level == 0 || handle.getBaseDataType(attribute) instanceof ARXString) {
      for (int i=0; i < _hierarchy.length; i++) {
        if (!order.containsKey(_hierarchy[i][level])) {
          order.put(_hierarchy[i][level],order.size());
        }
      }
      max=order.size();
    }
 else {
      Set<String> baseSet=new HashSet<String>();
      for (int i=0; i < _hierarchy.length; i++) {
        baseSet.add(_hierarchy[i][0]);
      }
      String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
      sort(baseArray,handle.getBaseDataType(attribute));
      Map<String,Integer> baseOrder=new HashMap<String,Integer>();
      for (int i=0; i < baseArray.length; i++) {
        baseOrder.put(baseArray[i],i);
      }
      for (int i=0; i < _hierarchy.length; i++) {
        if (!order.containsKey(_hierarchy[i][level])) {
          int position=baseOrder.get(_hierarchy[i][0]);
          order.put(_hierarchy[i][level],position);
          max=Math.max(position,max) + 1;
        }
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}","/** 
 * Returns an order list of the distinct set of data items from the given column. This method assumes  that the order of string data items can (and should) be derived from the provided hierarchy
 * @param column The column
 * @param hierarchy The hierarchy, may be null
 * @return
 */
public String[] getDistinctValuesOrdered(int column,Hierarchy hierarchy){
  final String[] list=getDistinctValues(column);
  final String attribute=handle.getAttributeName(column);
  final DataType<?> datatype=handle.getDataType(attribute);
  final int level=handle.getGeneralization(attribute);
  final String[][] _hierarchy=hierarchy != null ? hierarchy.getHierarchy() : null;
  if (_hierarchy == null || level == 0) {
    sort(list,datatype);
  }
 else {
    final Map<String,Integer> order=new HashMap<String,Integer>();
    int max=0;
    Set<String> baseSet=new HashSet<String>();
    for (int i=0; i < _hierarchy.length; i++) {
      baseSet.add(_hierarchy[i][0]);
    }
    String[] baseArray=baseSet.toArray(new String[baseSet.size()]);
    sort(baseArray,handle.getBaseDataType(attribute));
    Map<String,Integer> baseOrder=new HashMap<String,Integer>();
    for (int i=0; i < baseArray.length; i++) {
      baseOrder.put(baseArray[i],i);
    }
    for (int i=0; i < _hierarchy.length; i++) {
      if (!order.containsKey(_hierarchy[i][level])) {
        int position=baseOrder.get(_hierarchy[i][0]);
        order.put(_hierarchy[i][level],position);
        max=Math.max(position,max) + 1;
      }
    }
    String supp=handle.getSuppressionString();
    if (supp != null)     order.put(supp,max);
    sort(list,order);
  }
  return list;
}",0.8082039911308204
108806,"/** 
 * Instantiates a new handle.
 * @param registry The registry
 * @param manager The data manager
 * @param checker The node checker
 * @param node The node to apply
 * @param eqStatistics Statistics for the whole data
 * @param peqStatistics Statistics for the subset
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param removeOutliers Do we remove outliers
 * @param node The underlying transformation
 * @param config The underlying config
 */
protected DataHandleOutput(final DataRegistry registry,final DataManager manager,final Data buffer,final ARXNode node,final EquivalenceClassStatistics eqStatistics,final EquivalenceClassStatistics peqStatistics,final String suppressionString,final DataDefinition definition,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.removeOutliers=removeOutliers;
  this.suppressionString=suppressionString;
  this.definition=definition;
  this.statistics=new DataStatistics(this,eqStatistics);
  this.node=node;
  this.dataQI=buffer;
  this.dataSE=manager.getDataSE();
  this.dataIS=manager.getDataIS();
  this.header=manager.getHeader();
  GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  this.quasiIdentifiers=new String[hierarchies.length];
  this.map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.quasiIdentifiers[i]=hierarchies[i].getName();
    this.map[i]=hierarchies[i].getArray();
  }
  this.inverseMap=new int[header.length];
  for (int i=0; i < this.inverseMap.length; i++) {
    this.inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataQI.getMap().length; i++) {
    this.inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataSE.getMap().length; i++) {
    this.inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  this.inverseData=new int[3][][];
  this.inverseData[AttributeType.ATTR_TYPE_IS]=this.dataIS.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_SE]=this.dataSE.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_QI]=this.dataQI.getArray();
  this.inverseDictionaries=new Dictionary[3];
  this.inverseDictionaries[AttributeType.ATTR_TYPE_IS]=this.dataIS.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_SE]=this.dataSE.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_QI]=this.dataQI.getDictionary();
  this.getRegistry().createOutputSubset(node,config,peqStatistics);
  this.dataTypes=getDataTypeArray();
}","/** 
 * Instantiates a new handle.
 * @param registry The registry
 * @param manager The data manager
 * @param checker The node checker
 * @param node The node to apply
 * @param statistics Statistics for the dataset
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param removeOutliers Do we remove outliers
 * @param node The underlying transformation
 * @param config The underlying config
 */
protected DataHandleOutput(final DataRegistry registry,final DataManager manager,final Data buffer,final ARXNode node,final EquivalenceClassStatistics statistics,final String suppressionString,final DataDefinition definition,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.removeOutliers=removeOutliers;
  this.suppressionString=suppressionString;
  this.definition=definition;
  this.statistics=new DataStatistics(this,statistics);
  this.node=node;
  this.dataQI=buffer;
  this.dataSE=manager.getDataSE();
  this.dataIS=manager.getDataIS();
  this.header=manager.getHeader();
  GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  this.quasiIdentifiers=new String[hierarchies.length];
  this.map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.quasiIdentifiers[i]=hierarchies[i].getName();
    this.map[i]=hierarchies[i].getArray();
  }
  this.inverseMap=new int[header.length];
  for (int i=0; i < this.inverseMap.length; i++) {
    this.inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataQI.getMap().length; i++) {
    this.inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataSE.getMap().length; i++) {
    this.inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  this.inverseData=new int[3][][];
  this.inverseData[AttributeType.ATTR_TYPE_IS]=this.dataIS.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_SE]=this.dataSE.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_QI]=this.dataQI.getArray();
  this.inverseDictionaries=new Dictionary[3];
  this.inverseDictionaries[AttributeType.ATTR_TYPE_IS]=this.dataIS.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_SE]=this.dataSE.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_QI]=this.dataQI.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}",0.966865833785986
108807,"/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics[] getGroupStatistics();","/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics();",0.991150442477876
108808,"@Override public GroupStatistics[] getGroupStatistics(){
  return currentGroupify.getGroupStatistics();
}","@Override public GroupStatistics getGroupStatistics(){
  return currentGroupify.getGroupStatistics();
}",0.9903846153846154
108809,"@Override public GroupStatistics[] getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  if (subset == null) {
    HashGroupifyEntry entry=firstEntry;
    while (entry != null) {
      final boolean anonymous=isAnonymous(entry);
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        numberOfEquivalenceClasses++;
        averageEquivalenceClassSize+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
      entry=entry.nextOrdered;
    }
    averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
    return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples)};
  }
 else {
    double pAverageEquivalenceClassSize=0;
    int pMaximalEquivalenceClassSize=Integer.MIN_VALUE;
    int pMinimalEquivalenceClassSize=Integer.MAX_VALUE;
    int pNumberOfEquivalenceClasses=this.size();
    int pNumberOfOutlyingEquivalenceClasses=0;
    int pNumberOfOutlyingTuples=0;
    HashGroupifyEntry entry=firstEntry;
    while (entry != null) {
      final boolean anonymous=isAnonymous(entry);
      if (!anonymous) {
        if (entry.pcount > 0) {
          numberOfOutlyingEquivalenceClasses++;
          numberOfOutlyingTuples+=entry.pcount;
        }
        if (entry.count > 0) {
          pNumberOfOutlyingEquivalenceClasses++;
          pNumberOfOutlyingTuples+=entry.count;
        }
      }
 else {
        if (entry.pcount > 0) {
          averageEquivalenceClassSize+=entry.pcount;
          maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.pcount);
          minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.pcount);
        }
        if (entry.count > 0) {
          numberOfEquivalenceClasses++;
          pAverageEquivalenceClassSize+=entry.count;
          pMaximalEquivalenceClassSize=Math.max(pMaximalEquivalenceClassSize,entry.count);
          pMinimalEquivalenceClassSize=Math.min(pMinimalEquivalenceClassSize,entry.count);
        }
      }
      entry=entry.nextOrdered;
    }
    averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
    pAverageEquivalenceClassSize=pAverageEquivalenceClassSize / (double)(pNumberOfEquivalenceClasses - pNumberOfOutlyingEquivalenceClasses);
    return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(pAverageEquivalenceClassSize,pMaximalEquivalenceClassSize,pMinimalEquivalenceClassSize,pNumberOfEquivalenceClasses,pNumberOfOutlyingEquivalenceClasses,pNumberOfOutlyingTuples)};
  }
}","@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  double averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
  int maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
  int minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.356253591266041
108810,"/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}","/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param averageEquivalenceClassSizeIncludingOutliers
 * @param maximalEquivalenceClassSizeIncludingOutliers
 * @param minimalEquivalenceClassSizeIncludingOutliers
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,double averageEquivalenceClassSizeIncludingOutliers,int maximalEquivalenceClassSizeIncludingOutliers,int minimalEquivalenceClassSizeIncludingOutliers,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.averageEquivalenceClassSize=averageEquivalenceClassSizeIncludingOutliers;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSizeIncludingOutliers;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSizeIncludingOutliers;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}",0.7515583259127337
108811,"/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics[] getGroupStatistics();","/** 
 * Returns statistics about the groups
 * @return
 */
public abstract GroupStatistics getGroupStatistics();",0.991150442477876
108812,"@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  double averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
  int maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
  int minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int averageEquivalenceClassSizeCounter=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    if (entry.count > 0) {
      final boolean anonymous=isAnonymous(entry);
      numberOfEquivalenceClasses++;
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        averageEquivalenceClassSizeCounter+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=(double)averageEquivalenceClassSizeCounter / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  double averageEquivalenceClassSizeAll=averageEquivalenceClassSize;
  int maximalEquivalenceClassSizeAll=maximalEquivalenceClassSize;
  int minimalEquivalenceClassSizeAll=minimalEquivalenceClassSize;
  if (numberOfOutlyingTuples > 0) {
    averageEquivalenceClassSizeAll=(double)(averageEquivalenceClassSizeCounter + numberOfOutlyingTuples) / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses + 1);
    maximalEquivalenceClassSizeAll=Math.max(maximalEquivalenceClassSize,numberOfOutlyingTuples);
    minimalEquivalenceClassSizeAll=Math.min(minimalEquivalenceClassSize,numberOfOutlyingTuples);
  }
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,averageEquivalenceClassSizeAll,maximalEquivalenceClassSizeAll,minimalEquivalenceClassSizeAll,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.9355179704016914
108813,"/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null)   return ""String_Node_Str"";
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle()));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle()));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput()));
  }
  builder.append(""String_Node_Str"");
  for (  String s : list) {
    builder.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null || model.getInputConfig() == null || model.getInputConfig().getInput() == null) {
    return ""String_Node_Str"";
  }
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle()));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle()));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput()));
  }
  builder.append(""String_Node_Str"");
  for (  String s : list) {
    builder.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
  }
  return builder.toString();
}",0.9320843091334896
108814,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      addDebugData(""String_Node_Str"" + String.valueOf(result.getOutput(false).hashCode()));
      addDebugData(""String_Node_Str"" + String.valueOf(result.getOutput(false).getDefinition().hashCode()));
      addDebugData(""String_Node_Str"" + String.valueOf(result.getGlobalOptimum().hashCode()));
      addDebugData(""String_Node_Str"" + String.valueOf(result.getOutput(false).hashCode()));
      addDebugData(""String_Node_Str"" + String.valueOf(result.getOutput(false).getDefinition().hashCode()));
      addDebugData(""String_Node_Str"" + String.valueOf(result.getGlobalOptimum().hashCode()));
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.90622009569378
108815,"/** 
 * Returns debug data
 * @return
 */
public String getDebugData(){
  return new DebugData(model).getData();
}","/** 
 * Returns debug data
 * @return
 */
public String getDebugData(){
  return this.debug.getData(model);
}",0.8878923766816144
108816,"/** 
 * Returns some debug data
 * @return
 */
protected String getData(){
  if (model == null)   return ""String_Node_Str"";
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle()));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle()));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput()));
  }
  return builder.toString();
}","/** 
 * Returns some debug data
 * @param Model The model
 * @return
 */
protected String getData(Model model){
  if (model == null)   return ""String_Node_Str"";
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(model.getInputConfig().getInput().getDefinition()));
  builder.append(""String_Node_Str"");
  builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getInputConfig().getInput().getHandle()));
  if (model.getOutput() != null) {
    builder.append(""String_Node_Str"");
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutputConfig().getInput().getHandle()));
    builder.append(""String_Node_Str"").append(getDebugData(""String_Node_Str"",model.getOutput()));
  }
  builder.append(""String_Node_Str"");
  for (  String s : list) {
    builder.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
  }
  return builder.toString();
}",0.874129619710766
108817,"/** 
 * Instantiates a new handle.
 * @param registry The registry
 * @param manager The data manager
 * @param checker The node checker
 * @param node The node to apply
 * @param statistics Statistics for the dataset
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param removeOutliers Do we remove outliers
 * @param node The underlying transformation
 * @param config The underlying config
 */
protected DataHandleOutput(final DataRegistry registry,final DataManager manager,final Data buffer,final ARXNode node,final EquivalenceClassStatistics statistics,final String suppressionString,final DataDefinition definition,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.removeOutliers=removeOutliers;
  this.suppressionString=suppressionString;
  this.definition=definition;
  this.statistics=new DataStatistics(this,statistics);
  this.node=node;
  this.dataQI=buffer;
  this.dataSE=manager.getDataSE();
  this.dataIS=manager.getDataIS();
  this.header=manager.getHeader();
  GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  this.quasiIdentifiers=new String[hierarchies.length];
  this.map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.quasiIdentifiers[i]=hierarchies[i].getName();
    this.map[i]=hierarchies[i].getArray();
  }
  this.inverseMap=new int[header.length];
  for (int i=0; i < this.inverseMap.length; i++) {
    this.inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataQI.getMap().length; i++) {
    this.inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataSE.getMap().length; i++) {
    this.inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  this.inverseData=new int[3][][];
  this.inverseData[AttributeType.ATTR_TYPE_IS]=this.dataIS.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_SE]=this.dataSE.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_QI]=this.dataQI.getArray();
  this.inverseDictionaries=new Dictionary[3];
  this.inverseDictionaries[AttributeType.ATTR_TYPE_IS]=this.dataIS.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_SE]=this.dataSE.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_QI]=this.dataQI.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}","/** 
 * Instantiates a new handle.
 * @param registry The registry
 * @param manager The data manager
 * @param checker The node checker
 * @param node The node to apply
 * @param statistics Statistics for the dataset
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param removeOutliers Do we remove outliers
 * @param node The underlying transformation
 * @param config The underlying config
 */
protected DataHandleOutput(final ARXResult result,final DataRegistry registry,final DataManager manager,final Data buffer,final ARXNode node,final EquivalenceClassStatistics statistics,final String suppressionString,final DataDefinition definition,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(node,this);
  this.setRegistry(registry);
  this.result=result;
  this.removeOutliers=removeOutliers;
  this.suppressionString=suppressionString;
  this.definition=definition;
  this.statistics=new DataStatistics(this,statistics);
  this.node=node;
  this.dataQI=buffer;
  this.dataSE=manager.getDataSE();
  this.dataIS=manager.getDataIS();
  this.header=manager.getHeader();
  GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  this.quasiIdentifiers=new String[hierarchies.length];
  this.map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    this.quasiIdentifiers[i]=hierarchies[i].getName();
    this.map[i]=hierarchies[i].getArray();
  }
  this.inverseMap=new int[header.length];
  for (int i=0; i < this.inverseMap.length; i++) {
    this.inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataQI.getMap().length; i++) {
    this.inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < this.dataSE.getMap().length; i++) {
    this.inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  this.inverseData=new int[3][][];
  this.inverseData[AttributeType.ATTR_TYPE_IS]=this.dataIS.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_SE]=this.dataSE.getArray();
  this.inverseData[AttributeType.ATTR_TYPE_QI]=this.dataQI.getArray();
  this.inverseDictionaries=new Dictionary[3];
  this.inverseDictionaries[AttributeType.ATTR_TYPE_IS]=this.dataIS.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_SE]=this.dataSE.getDictionary();
  this.inverseDictionaries[AttributeType.ATTR_TYPE_QI]=this.dataQI.getDictionary();
  this.getRegistry().createOutputSubset(node,config,statistics);
  this.dataTypes=getDataTypeArray();
}",0.9917567320021982
108818,"/** 
 * Releases all resources
 */
protected void doRelease(){
  node=null;
  dataIS=null;
  dataQI=null;
  dataSE=null;
  inverseData=null;
  inverseDictionaries=null;
  inverseMap=null;
  map=null;
  quasiIdentifiers=null;
  suppressionString=null;
  registry=null;
  subset=null;
  dataTypes=null;
  definition=null;
  header=null;
  statistics=null;
  node=null;
}","/** 
 * Releases all resources
 */
protected void doRelease(){
  result.releaseBuffer(this);
  node=null;
  dataIS=null;
  dataQI=null;
  dataSE=null;
  inverseData=null;
  inverseDictionaries=null;
  inverseMap=null;
  map=null;
  quasiIdentifiers=null;
  suppressionString=null;
  registry=null;
  subset=null;
  dataTypes=null;
  definition=null;
  header=null;
  statistics=null;
  node=null;
}",0.9608355091383812
108819,"/** 
 * Updates the view
 */
private void update(){
  Context context=acontext.getContext();
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}","/** 
 * Updates the view
 */
private void update(){
  Context context=acontext.getContext();
  if (!context.equals(this.context)) {
    this.cache.clear();
    this.context=context;
  }
  if (context.config == null || context.handle == null) {
    return;
  }
  if (!cache.containsKey(attribute)) {
    DataHandle handle=context.handle;
    int column=handle.getColumnIndexOf(attribute);
    if (column >= 0) {
      Hierarchy hierarchy=null;
      if (this.target == ModelPart.OUTPUT)       hierarchy=acontext.getHierarchy(context,attribute);
      double[] frequency=handle.getStatistics().getFrequencyDistribution(column,hierarchy).frequency;
      cache.put(attribute,frequency);
    }
  }
  if (cache.isEmpty() || (cache.get(attribute) == null)) {
    return;
  }
  chart.setRedraw(false);
  final ISeriesSet seriesSet=chart.getSeriesSet();
  final IBarSeries series=(IBarSeries)seriesSet.createSeries(SeriesType.BAR,Resources.getMessage(""String_Node_Str""));
  series.getLabel().setVisible(false);
  series.getLabel().setFont(MainWindow.FONT);
  series.setBarColor(Display.getDefault().getSystemColor(SWT.COLOR_BLACK));
  series.setYSeries(cache.get(attribute));
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  yAxis.setRange(new Range(0d,1d));
  yAxis.adjustRange();
  final IAxis xAxis=axisSet.getXAxis(0);
  xAxis.adjustRange();
  chart.updateLayout();
  chart.update();
  chart.setRedraw(true);
  chart.redraw();
}",0.9772806710940232
108820,"/** 
 * Converter  TODO: Seems to not work
 * @param value
 * @return
 */
private double intToInformationLoss(final int value){
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  if (value == 0) {
    return min;
  }
 else   if (value >= SCALE_MAX_VALUE - 1) {
    return max;
  }
  double val=min + ((double)value / (double)SCALE_MAX_VALUE * (max - min));
  return (int)val;
}","/** 
 * Converter  TODO: Seems to not work
 * @param value
 * @return
 */
private double intToInformationLoss(final int value){
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  if (value == 0) {
    return min;
  }
 else   if (value >= SCALE_MAX_VALUE - 1) {
    return max;
  }
  double val=min + (((double)value / (double)SCALE_MAX_VALUE) * (max - min));
  return val;
}",0.9929078014184396
108821,"/** 
 * Converter TODO: Seems to not work
 * @param value
 * @return
 */
private int informationLossToInt(final double value){
  Double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  Double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  double val=(value - min) / (max - min);
  val=val * SCALE_MAX_VALUE;
  return (int)val;
}","/** 
 * Converter TODO: Seems to not work
 * @param value
 * @return
 */
private int informationLossToInt(final double value){
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  double val=(value - min) / (max - min);
  val=val * SCALE_MAX_VALUE;
  return (int)val;
}",0.9948051948051948
108822,"/** 
 * Creates the view
 * @param parent
 */
private void create(final Composite parent){
  final IView outer=this;
  final Label tableItem1=new Label(parent,SWT.NONE);
  tableItem1.setText(Resources.getMessage(""String_Node_Str""));
  attribute=new Combo(parent,SWT.BORDER);
  attribute.pack();
  attribute.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  attribute.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (attribute.getSelectionIndex() != -1) {
        if (result != null) {
          createGeneralization(result.getLattice().getBottom().getQuasiIdentifyingAttributes()[attribute.getSelectionIndex()]);
        }
      }
    }
  }
);
  generalization=new Table(parent,SWT.CHECK | SWT.BORDER | SWT.V_SCROLL| SWT.SINGLE);
  final GridData d=SWTUtil.createFillVerticallyGridData();
  d.verticalSpan=6;
  generalization.setLayoutData(d);
  generalization.setHeaderVisible(true);
  generalization.setLinesVisible(true);
  final TableColumn col=new TableColumn(generalization,SWT.NONE);
  col.setText(Resources.getMessage(""String_Node_Str""));
  col.pack();
  generalization.pack();
  generalization.addListener(SWT.Selection,new Listener(){
    @Override public void handleEvent(    Event event){
      if (event.detail == SWT.CHECK && event.item instanceof TableItem) {
        if (filter != null) {
          final int level=generalization.indexOf((TableItem)event.item);
          if (generalization.getItems()[level].getChecked()) {
            filter.allowGeneralization(selectedDimension,level);
          }
 else {
            filter.disallowGeneralization(selectedDimension,level);
          }
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem2=new Label(parent,SWT.NONE);
  tableItem2.setText(Resources.getMessage(""String_Node_Str""));
  anonymous=new Combo(parent,SWT.BORDER);
  anonymous.add(Resources.getMessage(""String_Node_Str""));
  anonymous.add(Resources.getMessage(""String_Node_Str""));
  anonymous.pack();
  anonymous.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  anonymous.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (anonymous.getSelectionIndex() == 0) {
          filter.allowAnonymous();
        }
 else {
          filter.disallowAnonymous();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem3=new Label(parent,SWT.NONE);
  tableItem3.setText(Resources.getMessage(""String_Node_Str""));
  notanonymous=new Combo(parent,SWT.BORDER);
  notanonymous.add(Resources.getMessage(""String_Node_Str""));
  notanonymous.add(Resources.getMessage(""String_Node_Str""));
  notanonymous.pack();
  notanonymous.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  notanonymous.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (notanonymous.getSelectionIndex() == 0) {
          filter.allowNonAnonymous();
        }
 else {
          filter.disallowNonAnonymous();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem4=new Label(parent,SWT.NONE);
  tableItem4.setText(Resources.getMessage(""String_Node_Str""));
  unknown=new Combo(parent,SWT.BORDER);
  unknown.add(Resources.getMessage(""String_Node_Str""));
  unknown.add(Resources.getMessage(""String_Node_Str""));
  unknown.pack();
  unknown.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  unknown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (unknown.getSelectionIndex() == 0) {
          filter.allowUnknown();
        }
 else {
          filter.disallowUnknown();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem5=new Label(parent,SWT.NONE);
  tableItem5.setText(Resources.getMessage(""String_Node_Str""));
  min=new Scale(parent,SWT.HORIZONTAL);
  min.setMaximum(SCALE_MAX_VALUE);
  min.setMinimum(0);
  min.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  min.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        filter.allowInformationLoss(intToInformationLoss(min.getSelection()),filter.getAllowedMaxInformationLoss());
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem6=new Label(parent,SWT.NONE);
  tableItem6.setText(Resources.getMessage(""String_Node_Str""));
  max=new Scale(parent,SWT.HORIZONTAL);
  max.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  max.setMaximum(SCALE_MAX_VALUE);
  max.setMinimum(0);
  max.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        filter.allowInformationLoss(filter.getAllowedMinInformationLoss(),intToInformationLoss(max.getSelection()));
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
}","/** 
 * Creates the view
 * @param parent
 */
private void create(final Composite parent){
  final IView outer=this;
  final Label tableItem1=new Label(parent,SWT.NONE);
  tableItem1.setText(Resources.getMessage(""String_Node_Str""));
  attribute=new Combo(parent,SWT.BORDER);
  attribute.pack();
  attribute.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  attribute.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (attribute.getSelectionIndex() != -1) {
        if (result != null) {
          createGeneralization(result.getLattice().getBottom().getQuasiIdentifyingAttributes()[attribute.getSelectionIndex()]);
        }
      }
    }
  }
);
  generalization=new Table(parent,SWT.CHECK | SWT.BORDER | SWT.V_SCROLL| SWT.SINGLE);
  final GridData d=SWTUtil.createFillVerticallyGridData();
  d.verticalSpan=6;
  generalization.setLayoutData(d);
  generalization.setHeaderVisible(true);
  generalization.setLinesVisible(true);
  final TableColumn col=new TableColumn(generalization,SWT.NONE);
  col.setText(Resources.getMessage(""String_Node_Str""));
  col.pack();
  generalization.pack();
  generalization.addListener(SWT.Selection,new Listener(){
    @Override public void handleEvent(    Event event){
      if (event.detail == SWT.CHECK && event.item instanceof TableItem) {
        if (filter != null) {
          final int level=generalization.indexOf((TableItem)event.item);
          if (generalization.getItems()[level].getChecked()) {
            filter.allowGeneralization(selectedDimension,level);
          }
 else {
            filter.disallowGeneralization(selectedDimension,level);
          }
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem2=new Label(parent,SWT.NONE);
  tableItem2.setText(Resources.getMessage(""String_Node_Str""));
  anonymous=new Combo(parent,SWT.BORDER);
  anonymous.add(Resources.getMessage(""String_Node_Str""));
  anonymous.add(Resources.getMessage(""String_Node_Str""));
  anonymous.pack();
  anonymous.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  anonymous.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (anonymous.getSelectionIndex() == 0) {
          filter.allowAnonymous();
        }
 else {
          filter.disallowAnonymous();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem3=new Label(parent,SWT.NONE);
  tableItem3.setText(Resources.getMessage(""String_Node_Str""));
  notanonymous=new Combo(parent,SWT.BORDER);
  notanonymous.add(Resources.getMessage(""String_Node_Str""));
  notanonymous.add(Resources.getMessage(""String_Node_Str""));
  notanonymous.pack();
  notanonymous.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  notanonymous.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (notanonymous.getSelectionIndex() == 0) {
          filter.allowNonAnonymous();
        }
 else {
          filter.disallowNonAnonymous();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem4=new Label(parent,SWT.NONE);
  tableItem4.setText(Resources.getMessage(""String_Node_Str""));
  unknown=new Combo(parent,SWT.BORDER);
  unknown.add(Resources.getMessage(""String_Node_Str""));
  unknown.add(Resources.getMessage(""String_Node_Str""));
  unknown.pack();
  unknown.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  unknown.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        if (unknown.getSelectionIndex() == 0) {
          filter.allowUnknown();
        }
 else {
          filter.disallowUnknown();
        }
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem5=new Label(parent,SWT.NONE);
  tableItem5.setText(Resources.getMessage(""String_Node_Str""));
  min=new Scale(parent,SWT.HORIZONTAL);
  min.setMaximum(SCALE_MAX_VALUE);
  min.setMinimum(0);
  min.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  min.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        double minLoss=intToInformationLoss(min.getSelection());
        double maxLoss=filter.getAllowedMaxInformationLoss();
        filter.allowInformationLoss(minLoss,maxLoss);
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
  final Label tableItem6=new Label(parent,SWT.NONE);
  tableItem6.setText(Resources.getMessage(""String_Node_Str""));
  max=new Scale(parent,SWT.HORIZONTAL);
  max.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  max.setMaximum(SCALE_MAX_VALUE);
  max.setMinimum(0);
  max.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (filter != null) {
        filter.allowInformationLoss(filter.getAllowedMinInformationLoss(),intToInformationLoss(max.getSelection()));
        controller.update(new ModelEvent(outer,ModelPart.FILTER,filter));
      }
    }
  }
);
}",0.9850553505535056
108823,"/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize())});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMinimalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getMaximalEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize()) + ""String_Node_Str"" + String.valueOf(statistics.getAverageEquivalenceClassSizeIncludingOutliers())+ ""String_Node_Str""});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9712988487108803
108824,"/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param averageEquivalenceClassSizeIncludingOutliers
 * @param maximalEquivalenceClassSizeIncludingOutliers
 * @param minimalEquivalenceClassSizeIncludingOutliers
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,double averageEquivalenceClassSizeIncludingOutliers,int maximalEquivalenceClassSizeIncludingOutliers,int minimalEquivalenceClassSizeIncludingOutliers,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.averageEquivalenceClassSize=averageEquivalenceClassSizeIncludingOutliers;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSizeIncludingOutliers;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSizeIncludingOutliers;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}","/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param averageEquivalenceClassSizeIncludingOutliers
 * @param maximalEquivalenceClassSizeIncludingOutliers
 * @param minimalEquivalenceClassSizeIncludingOutliers
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,double averageEquivalenceClassSizeIncludingOutliers,int maximalEquivalenceClassSizeIncludingOutliers,int minimalEquivalenceClassSizeIncludingOutliers,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.averageEquivalenceClassSizeIncludingOutliers=averageEquivalenceClassSizeIncludingOutliers;
  this.maximalEquivalenceClassSizeIncludingOutliers=maximalEquivalenceClassSizeIncludingOutliers;
  this.minimalEquivalenceClassSizeIncludingOutliers=minimalEquivalenceClassSizeIncludingOutliers;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}",0.9821366024518388
108825,"@Override public GroupStatistics[] getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  double pAverageEquivalenceClassSize=0;
  int pMaximalEquivalenceClassSize=Integer.MIN_VALUE;
  int pMinimalEquivalenceClassSize=Integer.MAX_VALUE;
  int pNumberOfEquivalenceClasses=this.size();
  int pNumberOfOutlyingEquivalenceClasses=0;
  int pNumberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      if (entry.count > 0) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
      if (entry.pcount > 0) {
        pNumberOfOutlyingEquivalenceClasses++;
        pNumberOfOutlyingTuples+=entry.pcount;
      }
    }
 else {
      if (entry.pcount > 0) {
        pAverageEquivalenceClassSize+=entry.pcount;
        pMaximalEquivalenceClassSize=Math.max(pMaximalEquivalenceClassSize,entry.pcount);
        pMinimalEquivalenceClassSize=Math.min(pMinimalEquivalenceClassSize,entry.pcount);
      }
      numberOfEquivalenceClasses++;
      averageEquivalenceClassSize+=entry.count;
      maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
      minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
  pAverageEquivalenceClassSize=pAverageEquivalenceClassSize / (double)(pNumberOfEquivalenceClasses - pNumberOfOutlyingEquivalenceClasses);
  return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(pAverageEquivalenceClassSize,pMaximalEquivalenceClassSize,pMinimalEquivalenceClassSize,pNumberOfEquivalenceClasses,pNumberOfOutlyingEquivalenceClasses,pNumberOfOutlyingTuples)};
}","@Override public GroupStatistics[] getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  if (subset == null) {
    HashGroupifyEntry entry=firstEntry;
    while (entry != null) {
      final boolean anonymous=isAnonymous(entry);
      if (!anonymous) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
 else {
        numberOfEquivalenceClasses++;
        averageEquivalenceClassSize+=entry.count;
        maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
        minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
      }
      entry=entry.nextOrdered;
    }
    averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
    return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples)};
  }
 else {
    double pAverageEquivalenceClassSize=0;
    int pMaximalEquivalenceClassSize=Integer.MIN_VALUE;
    int pMinimalEquivalenceClassSize=Integer.MAX_VALUE;
    int pNumberOfEquivalenceClasses=this.size();
    int pNumberOfOutlyingEquivalenceClasses=0;
    int pNumberOfOutlyingTuples=0;
    HashGroupifyEntry entry=firstEntry;
    while (entry != null) {
      final boolean anonymous=isAnonymous(entry);
      if (!anonymous) {
        if (entry.pcount > 0) {
          numberOfOutlyingEquivalenceClasses++;
          numberOfOutlyingTuples+=entry.pcount;
        }
        if (entry.count > 0) {
          pNumberOfOutlyingEquivalenceClasses++;
          pNumberOfOutlyingTuples+=entry.count;
        }
      }
 else {
        if (entry.pcount > 0) {
          averageEquivalenceClassSize+=entry.pcount;
          maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.pcount);
          minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.pcount);
        }
        if (entry.count > 0) {
          numberOfEquivalenceClasses++;
          pAverageEquivalenceClassSize+=entry.count;
          pMaximalEquivalenceClassSize=Math.max(pMaximalEquivalenceClassSize,entry.count);
          pMinimalEquivalenceClassSize=Math.min(pMinimalEquivalenceClassSize,entry.count);
        }
      }
      entry=entry.nextOrdered;
    }
    averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
    pAverageEquivalenceClassSize=pAverageEquivalenceClassSize / (double)(pNumberOfEquivalenceClasses - pNumberOfOutlyingEquivalenceClasses);
    return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(pAverageEquivalenceClassSize,pMaximalEquivalenceClassSize,pMinimalEquivalenceClassSize,pNumberOfEquivalenceClasses,pNumberOfOutlyingEquivalenceClasses,pNumberOfOutlyingTuples)};
  }
}",0.772165312610385
108826,"/** 
 * Update the view
 */
protected void update(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final DataHandle data;
  if (config.getInput() == null) {
    reset();
    return;
  }
 else {
    data=config.getInput().getHandle();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  root.setRedraw(false);
  roots.clear();
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumRows())});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(config.getAllowedOutliers() * 100d) + Resources.getMessage(""String_Node_Str"")});
  final Property attributes=new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumColumns())});
  final Property identifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getIdentifyingAttributes().size())});
  int index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=data.getDefinition().getDataType(s).toString();
      new Property(identifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property quasiIdentifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getQuasiIdentifyingAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getQuasiIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (data.getDefinition().getHierarchy(s) != null) {
        DataType<?> type=data.getDefinition().getDataType(s);
        values[1]=type.getDescription().getLabel();
        if (type.getDescription().hasFormat() && ((DataTypeWithFormat)type).getFormat() != null) {
          values[2]=((DataTypeWithFormat)type).getFormat();
        }
        values[3]=String.valueOf(data.getDefinition().getHierarchyHeight(s));
        values[4]=String.valueOf(data.getDefinition().getMinimumGeneralization(s));
        values[5]=String.valueOf(data.getDefinition().getMaximumGeneralization(s));
      }
      new Property(quasiIdentifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property sensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getSensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getSensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (config.getHierarchy(s) != null) {
        int height=0;
        if (config.getHierarchy(s).getHierarchy().length > 0) {
          height=config.getHierarchy(s).getHierarchy()[0].length;
        }
        values[1]=data.getDefinition().getDataType(s).toString();
        values[2]=String.valueOf(height);
      }
      new Property(sensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property insensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getInsensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getInsensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=data.getDefinition().getDataType(s).toString();
      new Property(insensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view
 */
protected void update(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final DataHandle data;
  if (config == null || config.getInput() == null) {
    reset();
    return;
  }
 else {
    data=config.getInput().getHandle();
  }
  if (data == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  roots.clear();
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumRows())});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(config.getAllowedOutliers() * 100d) + Resources.getMessage(""String_Node_Str"")});
  final Property attributes=new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getNumColumns())});
  final Property identifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getIdentifyingAttributes().size())});
  int index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=data.getDefinition().getDataType(s).toString();
      new Property(identifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property quasiIdentifying=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getQuasiIdentifyingAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getQuasiIdentifyingAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (data.getDefinition().getHierarchy(s) != null) {
        DataType<?> type=data.getDefinition().getDataType(s);
        values[1]=type.getDescription().getLabel();
        if (type.getDescription().hasFormat() && ((DataTypeWithFormat)type).getFormat() != null) {
          values[2]=((DataTypeWithFormat)type).getFormat();
        }
        values[3]=String.valueOf(data.getDefinition().getHierarchyHeight(s));
        values[4]=String.valueOf(data.getDefinition().getMinimumGeneralization(s));
        values[5]=String.valueOf(data.getDefinition().getMaximumGeneralization(s));
      }
      new Property(quasiIdentifying,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property sensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getSensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getSensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      if (config.getHierarchy(s) != null) {
        int height=0;
        if (config.getHierarchy(s).getHierarchy().length > 0) {
          height=config.getHierarchy(s).getHierarchy()[0].length;
        }
        values[1]=data.getDefinition().getDataType(s).toString();
        values[2]=String.valueOf(height);
      }
      new Property(sensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  final Property insensitive=new Property(attributes,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(data.getDefinition().getInsensitiveAttributes().size())});
  index=0;
  for (int i=0; i < data.getNumColumns(); i++) {
    final String s=data.getAttributeName(i);
    if (data.getDefinition().getInsensitiveAttributes().contains(s)) {
      final String[] values=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      values[0]=s;
      values[1]=data.getDefinition().getDataType(s).toString();
      new Property(insensitive,Resources.getMessage(""String_Node_Str"") + (index++),values);
    }
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9690513568064588
108827,"/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param target
 * @param reset
 */
public ViewDistribution(final Composite parent,final Controller controller,final ModelPart target,final ModelPart reset){
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(target,this);
  this.controller=controller;
  if (reset != null) {
    controller.addListener(reset,this);
  }
  this.reset=reset;
  this.target=target;
  this.parent=parent;
  reset();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 * @param target
 * @param reset
 */
public ViewDistribution(final Composite parent,final Controller controller,final ModelPart target,final ModelPart reset){
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.DATA_TYPE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(target,this);
  this.controller=controller;
  if (reset != null) {
    controller.addListener(reset,this);
  }
  this.reset=reset;
  this.target=target;
  this.parent=parent;
  reset();
}",0.9620991253644317
108828,"public ModelViewConfig clone(){
  ModelViewConfig result=new ModelViewConfig();
  result.mode=this.mode;
  result.attribute=this.attribute;
  result.subset=this.subset;
  return result;
}","@Override public ModelViewConfig clone(){
  ModelViewConfig result=new ModelViewConfig();
  result.mode=this.mode;
  result.attribute=this.attribute;
  result.subset=this.subset;
  return result;
}",0.9739583333333334
108829,"@Override public final boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  return Arrays.equals(array,((IntArrayWrapper)obj).array);
}","@Override public final boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null)   return false;
  return Arrays.equals(array,((IntArrayWrapper)obj).array);
}",0.9014084507042254
108830,"@Override public boolean equals(Object obj){
  Entry other=(Entry)obj;
  return Arrays.equals(data,other.data);
}","@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  Entry other=(Entry)obj;
  return Arrays.equals(data,other.data);
}",0.8659003831417624
108831,"public RowSet clone(){
  RowSet set=new RowSet(this.length);
  set.size=this.size;
  System.arraycopy(this.array,0,set.array,0,this.array.length);
  return set;
}","@Override public RowSet clone(){
  RowSet set=new RowSet(this.length);
  set.size=this.size;
  System.arraycopy(this.array,0,set.array,0,this.array.length);
  return set;
}",0.9700598802395208
108832,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getHandle(),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getHandle()));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getOutput(false),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getOutput(false)));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.9933004231311706
108833,"@Override public void widgetSelected(final SelectionEvent e){
  controller.actionMenuHelpAbout();
}","@Override public void widgetSelected(final SelectionEvent e){
  controller.actionMenuHelpDebug();
}",0.9696969696969696
108834,"/** 
 * Creates a new instance
 * @param shell
 * @param controller
 */
public MainMenu(final Shell shell,final Controller controller){
  final Menu menuBar=new Menu(shell,SWT.BAR);
  final MenuItem fileMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu fileMenu=new Menu(shell,SWT.DROP_DOWN);
  fileMenuItem.setText(FILE_NAME);
  fileMenuItem.setMenu(fileMenu);
  final MenuItem newItem=new MenuItem(fileMenu,SWT.PUSH);
  newItem.setText(Resources.getMessage(""String_Node_Str""));
  newItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  newItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileNew();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem openItem=new MenuItem(fileMenu,SWT.PUSH);
  openItem.setText(Resources.getMessage(""String_Node_Str""));
  openItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  openItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileOpen();
    }
  }
);
  final MenuItem saveItem=new MenuItem(fileMenu,SWT.PUSH);
  saveItem.setText(Resources.getMessage(""String_Node_Str""));
  saveItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  saveItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileSave();
    }
  }
);
  final MenuItem saveasItem=new MenuItem(fileMenu,SWT.PUSH);
  saveasItem.setText(Resources.getMessage(""String_Node_Str""));
  saveasItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  saveasItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileSaveAs();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem importItem=new MenuItem(fileMenu,SWT.PUSH);
  importItem.setText(Resources.getMessage(""String_Node_Str""));
  importItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  importItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileImportData();
    }
  }
);
  final MenuItem exportItem=new MenuItem(fileMenu,SWT.PUSH);
  exportItem.setText(Resources.getMessage(""String_Node_Str""));
  exportItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  exportItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExportData();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem importHier=new MenuItem(fileMenu,SWT.PUSH);
  importHier.setText(Resources.getMessage(""String_Node_Str""));
  importHier.setImage(controller.getResources().getImage(""String_Node_Str""));
  importHier.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileImportHierarchy();
    }
  }
);
  final MenuItem exportHier=new MenuItem(fileMenu,SWT.PUSH);
  exportHier.setText(Resources.getMessage(""String_Node_Str""));
  exportHier.setImage(controller.getResources().getImage(""String_Node_Str""));
  exportHier.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExportHierarchy();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem exitItem=new MenuItem(fileMenu,SWT.PUSH);
  exitItem.setText(Resources.getMessage(""String_Node_Str""));
  exitItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  exitItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExit();
    }
  }
);
  shell.setMenuBar(menuBar);
  final MenuItem editMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu editMenu=new Menu(shell,SWT.DROP_DOWN);
  editMenuItem.setText(EDIT_NAME);
  editMenuItem.setMenu(editMenu);
  final MenuItem editAnonymize=new MenuItem(editMenu,SWT.PUSH);
  editAnonymize.setText(Resources.getMessage(""String_Node_Str""));
  editAnonymize.setImage(controller.getResources().getImage(""String_Node_Str""));
  editAnonymize.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditAnonymize();
    }
  }
);
  new MenuItem(editMenu,SWT.SEPARATOR);
  final MenuItem editCreateHierarchy=new MenuItem(editMenu,SWT.PUSH);
  editCreateHierarchy.setText(Resources.getMessage(""String_Node_Str""));
  editCreateHierarchy.setImage(controller.getResources().getImage(""String_Node_Str""));
  editCreateHierarchy.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditCreateHierarchy();
    }
  }
);
  new MenuItem(editMenu,SWT.SEPARATOR);
  final MenuItem editSettings=new MenuItem(editMenu,SWT.PUSH);
  editSettings.setText(Resources.getMessage(""String_Node_Str""));
  editSettings.setImage(controller.getResources().getImage(""String_Node_Str""));
  editSettings.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditSettings();
    }
  }
);
  final MenuItem helpMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu helpMenu=new Menu(shell,SWT.DROP_DOWN);
  helpMenuItem.setText(HELP_NAME);
  helpMenuItem.setMenu(helpMenu);
  final MenuItem updateItem=new MenuItem(helpMenu,SWT.PUSH);
  updateItem.setText(Resources.getMessage(""String_Node_Str""));
  updateItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  updateItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuHelpHelp();
    }
  }
);
  final MenuItem infoItem=new MenuItem(helpMenu,SWT.PUSH);
  infoItem.setText(Resources.getMessage(""String_Node_Str""));
  infoItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  infoItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuHelpAbout();
    }
  }
);
}","/** 
 * Creates a new instance
 * @param shell
 * @param controller
 */
public MainMenu(final Shell shell,final Controller controller){
  final Menu menuBar=new Menu(shell,SWT.BAR);
  final MenuItem fileMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu fileMenu=new Menu(shell,SWT.DROP_DOWN);
  fileMenuItem.setText(FILE_NAME);
  fileMenuItem.setMenu(fileMenu);
  final MenuItem newItem=new MenuItem(fileMenu,SWT.PUSH);
  newItem.setText(Resources.getMessage(""String_Node_Str""));
  newItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  newItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileNew();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem openItem=new MenuItem(fileMenu,SWT.PUSH);
  openItem.setText(Resources.getMessage(""String_Node_Str""));
  openItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  openItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileOpen();
    }
  }
);
  final MenuItem saveItem=new MenuItem(fileMenu,SWT.PUSH);
  saveItem.setText(Resources.getMessage(""String_Node_Str""));
  saveItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  saveItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileSave();
    }
  }
);
  final MenuItem saveasItem=new MenuItem(fileMenu,SWT.PUSH);
  saveasItem.setText(Resources.getMessage(""String_Node_Str""));
  saveasItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  saveasItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileSaveAs();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem importItem=new MenuItem(fileMenu,SWT.PUSH);
  importItem.setText(Resources.getMessage(""String_Node_Str""));
  importItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  importItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileImportData();
    }
  }
);
  final MenuItem exportItem=new MenuItem(fileMenu,SWT.PUSH);
  exportItem.setText(Resources.getMessage(""String_Node_Str""));
  exportItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  exportItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExportData();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem importHier=new MenuItem(fileMenu,SWT.PUSH);
  importHier.setText(Resources.getMessage(""String_Node_Str""));
  importHier.setImage(controller.getResources().getImage(""String_Node_Str""));
  importHier.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileImportHierarchy();
    }
  }
);
  final MenuItem exportHier=new MenuItem(fileMenu,SWT.PUSH);
  exportHier.setText(Resources.getMessage(""String_Node_Str""));
  exportHier.setImage(controller.getResources().getImage(""String_Node_Str""));
  exportHier.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExportHierarchy();
    }
  }
);
  new MenuItem(fileMenu,SWT.SEPARATOR);
  final MenuItem exitItem=new MenuItem(fileMenu,SWT.PUSH);
  exitItem.setText(Resources.getMessage(""String_Node_Str""));
  exitItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  exitItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuFileExit();
    }
  }
);
  shell.setMenuBar(menuBar);
  final MenuItem editMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu editMenu=new Menu(shell,SWT.DROP_DOWN);
  editMenuItem.setText(EDIT_NAME);
  editMenuItem.setMenu(editMenu);
  final MenuItem editAnonymize=new MenuItem(editMenu,SWT.PUSH);
  editAnonymize.setText(Resources.getMessage(""String_Node_Str""));
  editAnonymize.setImage(controller.getResources().getImage(""String_Node_Str""));
  editAnonymize.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditAnonymize();
    }
  }
);
  new MenuItem(editMenu,SWT.SEPARATOR);
  final MenuItem editCreateHierarchy=new MenuItem(editMenu,SWT.PUSH);
  editCreateHierarchy.setText(Resources.getMessage(""String_Node_Str""));
  editCreateHierarchy.setImage(controller.getResources().getImage(""String_Node_Str""));
  editCreateHierarchy.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditCreateHierarchy();
    }
  }
);
  new MenuItem(editMenu,SWT.SEPARATOR);
  final MenuItem editSettings=new MenuItem(editMenu,SWT.PUSH);
  editSettings.setText(Resources.getMessage(""String_Node_Str""));
  editSettings.setImage(controller.getResources().getImage(""String_Node_Str""));
  editSettings.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuEditSettings();
    }
  }
);
  final MenuItem helpMenuItem=new MenuItem(menuBar,SWT.CASCADE);
  final Menu helpMenu=new Menu(shell,SWT.DROP_DOWN);
  helpMenuItem.setText(HELP_NAME);
  helpMenuItem.setMenu(helpMenu);
  final MenuItem updateItem=new MenuItem(helpMenu,SWT.PUSH);
  updateItem.setText(Resources.getMessage(""String_Node_Str""));
  updateItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  updateItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuHelpHelp();
    }
  }
);
  final MenuItem infoItem=new MenuItem(helpMenu,SWT.PUSH);
  infoItem.setText(Resources.getMessage(""String_Node_Str""));
  infoItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  infoItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuHelpAbout();
    }
  }
);
  final MenuItem debugItem=new MenuItem(helpMenu,SWT.PUSH);
  debugItem.setText(""String_Node_Str"");
  debugItem.setImage(controller.getResources().getImage(""String_Node_Str""));
  debugItem.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      controller.actionMenuHelpDebug();
    }
  }
);
}",0.9729852440408626
108835,"/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),config.getInput().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}","/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new ARXResult(config.getInput().getHandle(),config.getInput().getHandle().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}",0.9973707274320772
108836,"/** 
 * Returns a string representation 
 */
@Override public String toString(){
switch (type) {
case ATTR_TYPE_ID:
    return ""String_Node_Str"";
case ATTR_TYPE_SE:
  return ""String_Node_Str"";
case ATTR_TYPE_IS:
return ""String_Node_Str"";
case ATTR_TYPE_QI:
return ""String_Node_Str"";
default :
return null;
}
}","/** 
 * Returns a string representation 
 */
@Override public String toString(){
switch (type) {
case ATTR_TYPE_ID:
    return ""String_Node_Str"";
case ATTR_TYPE_SE:
  return ""String_Node_Str"";
case ATTR_TYPE_IS:
return ""String_Node_Str"";
case ATTR_TYPE_QI:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.9667194928684628
108837,"/** 
 * Returns the maximal size of an equivalence class
 * @return
 */
public int getAverageEquivalenceClassSize(){
  return groupStatistics.getAverageEquivalenceClassSize();
}","/** 
 * Returns the maximal size of an equivalence class
 * @return
 */
public double getAverageEquivalenceClassSize(){
  return groupStatistics.getAverageEquivalenceClassSize();
}",0.9747899159663864
108838,"/** 
 * Returns the maximal size of an equivalence class
 * @return
 */
public int getAverageEquivalenceClassSize(){
  return averageEquivalenceClassSize;
}","/** 
 * Returns the maximal size of an equivalence class
 * @return
 */
public double getAverageEquivalenceClassSize(){
  return averageEquivalenceClassSize;
}",0.9714285714285714
108839,"@Override public GroupStatistics getGroupStatistics(){
  int averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=this.size();
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      numberOfOutlyingEquivalenceClasses++;
      numberOfOutlyingTuples+=entry.count;
    }
 else {
      averageEquivalenceClassSize+=entry.count;
      maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
      minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=(int)((double)averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses));
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}","@Override public GroupStatistics getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=this.size();
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      numberOfOutlyingEquivalenceClasses++;
      numberOfOutlyingTuples+=entry.count;
    }
 else {
      averageEquivalenceClassSize+=entry.count;
      maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
      minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  return new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples);
}",0.7320656871218669
108840,"/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(int averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}","/** 
 * Creates a new instance
 * @param handle
 * @param averageEquivalenceClassSize
 * @param maximalEquivalenceClassSize
 * @param minimalEquivalenceClassSize
 * @param numberOfGroups
 * @param numberOfOutlyingEquivalenceClasses
 * @param numberOfOutlyingTuples
 */
protected GroupStatistics(double averageEquivalenceClassSize,int maximalEquivalenceClassSize,int minimalEquivalenceClassSize,int numberOfGroups,int numberOfOutlyingEquivalenceClasses,int numberOfOutlyingTuples){
  this.averageEquivalenceClassSize=averageEquivalenceClassSize;
  this.maximalEquivalenceClassSize=maximalEquivalenceClassSize;
  this.minimalEquivalenceClassSize=minimalEquivalenceClassSize;
  this.numberOfGroups=numberOfGroups;
  this.numberOfOutlyingEquivalenceClasses=numberOfOutlyingEquivalenceClasses;
  this.numberOfOutlyingTuples=numberOfOutlyingTuples;
}",0.9946587537091988
108841,"@Override public final boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  return Arrays.equals(array,((IntArrayWrapper)obj).array);
}","@Override public final boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null)   return false;
  return Arrays.equals(array,((IntArrayWrapper)obj).array);
}",0.9014084507042254
108842,"/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize())});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize())});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9983322214809872
108843,"/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize())});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}","/** 
 * Update the view
 */
protected void update(){
  Context context=getContext().getContext();
  if (context == null || context.config == null || context.handle == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  ARXResult result=model.getResult();
  ARXNode node=model.getSelectedNode();
  roots.clear();
  EquivalenceClassStatistics statistics=context.handle.getStatistics().getEquivalenceClassStatistics();
  if (statistics != null) {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingTuples())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfGroups())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getNumberOfOutlyingEquivalenceClasses())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMinimalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getMaximalEquivalenceClassSize())});
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(statistics.getAverageEquivalenceClassSize())});
  }
  if (node.getMaximumInformationLoss().getValue() == node.getMinimumInformationLoss().getValue()) {
    final String infoloss=String.valueOf(node.getMinimumInformationLoss().getValue()) + ""String_Node_Str"" + format.format(asRelativeValue(node.getMinimumInformationLoss(),result))+ ""String_Node_Str"";
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{infoloss});
  }
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getSuccessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(node.getPredecessors().length)});
  new Property(Resources.getMessage(""String_Node_Str""),new String[]{Arrays.toString(node.getTransformation())});
  if (node.isAnonymous() == Anonymity.ANONYMOUS) {
    if (context.config.containsCriterion(DPresence.class)) {
      DPresence criterion=context.config.getCriterion(DPresence.class);
      if (!(criterion.getDMin() == 0d && criterion.getDMax() == 1d)) {
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMin())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getDMax())});
      }
    }
    if (context.config.containsCriterion(KAnonymity.class)) {
      KAnonymity criterion=context.config.getCriterion(KAnonymity.class);
      Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
      new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getK())});
    }
    int index=0;
    for (    PrivacyCriterion c : context.config.getCriteria()) {
      if (c instanceof DistinctLDiversity) {
        DistinctLDiversity criterion=(DistinctLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EntropyLDiversity) {
        EntropyLDiversity criterion=(EntropyLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof RecursiveCLDiversity) {
        RecursiveCLDiversity criterion=(RecursiveCLDiversity)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getC())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getL())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof EqualDistanceTCloseness) {
        EqualDistanceTCloseness criterion=(EqualDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
      }
 else       if (c instanceof HierarchicalDistanceTCloseness) {
        HierarchicalDistanceTCloseness criterion=(HierarchicalDistanceTCloseness)c;
        Property n=new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{String.valueOf(criterion.getT())});
        new Property(n,Resources.getMessage(""String_Node_Str""),new String[]{criterion.getAttribute()});
        final int height=context.config.getHierarchy(criterion.getAttribute()).getHierarchy()[0].length;
        new Property(n,""String_Node_Str"" + (index++),new String[]{Resources.getMessage(""String_Node_Str"") + String.valueOf(height)});
      }
    }
  }
 else {
    new Property(Resources.getMessage(""String_Node_Str""),new String[]{Resources.getMessage(""String_Node_Str"")});
  }
  treeViewer.refresh();
  treeViewer.expandAll();
  root.setRedraw(true);
}",0.9983322214809872
108844,"@Override public GroupStatistics[] getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=this.size();
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  double pAverageEquivalenceClassSize=0;
  int pMaximalEquivalenceClassSize=Integer.MIN_VALUE;
  int pMinimalEquivalenceClassSize=Integer.MAX_VALUE;
  int pNumberOfEquivalenceClasses=this.size();
  int pNumberOfOutlyingEquivalenceClasses=0;
  int pNumberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      numberOfOutlyingEquivalenceClasses++;
      numberOfOutlyingTuples+=entry.count;
      if (entry.pcount > 0) {
        pNumberOfOutlyingEquivalenceClasses++;
        pNumberOfOutlyingTuples+=entry.pcount;
      }
    }
 else {
      if (entry.pcount > 0) {
        pAverageEquivalenceClassSize+=entry.pcount;
        pMaximalEquivalenceClassSize=Math.max(pMaximalEquivalenceClassSize,entry.pcount);
        pMinimalEquivalenceClassSize=Math.min(pMinimalEquivalenceClassSize,entry.pcount);
      }
      averageEquivalenceClassSize+=entry.count;
      maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
      minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses - numberOfOutlyingEquivalenceClasses);
  pAverageEquivalenceClassSize=pAverageEquivalenceClassSize / (double)(pNumberOfEquivalenceClasses - pNumberOfOutlyingEquivalenceClasses);
  return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(pAverageEquivalenceClassSize,pMaximalEquivalenceClassSize,pMinimalEquivalenceClassSize,pNumberOfEquivalenceClasses,pNumberOfOutlyingEquivalenceClasses,pNumberOfOutlyingTuples)};
}","@Override public GroupStatistics[] getGroupStatistics(){
  double averageEquivalenceClassSize=0;
  int maximalEquivalenceClassSize=Integer.MIN_VALUE;
  int minimalEquivalenceClassSize=Integer.MAX_VALUE;
  int numberOfEquivalenceClasses=0;
  int numberOfOutlyingEquivalenceClasses=0;
  int numberOfOutlyingTuples=0;
  double pAverageEquivalenceClassSize=0;
  int pMaximalEquivalenceClassSize=Integer.MIN_VALUE;
  int pMinimalEquivalenceClassSize=Integer.MAX_VALUE;
  int pNumberOfEquivalenceClasses=this.size();
  int pNumberOfOutlyingEquivalenceClasses=0;
  int pNumberOfOutlyingTuples=0;
  HashGroupifyEntry entry=firstEntry;
  while (entry != null) {
    final boolean anonymous=isAnonymous(entry);
    if (!anonymous) {
      if (entry.count > 0) {
        numberOfOutlyingEquivalenceClasses++;
        numberOfOutlyingTuples+=entry.count;
      }
      if (entry.pcount > 0) {
        pNumberOfOutlyingEquivalenceClasses++;
        pNumberOfOutlyingTuples+=entry.pcount;
      }
    }
 else {
      if (entry.pcount > 0) {
        pAverageEquivalenceClassSize+=entry.pcount;
        pMaximalEquivalenceClassSize=Math.max(pMaximalEquivalenceClassSize,entry.pcount);
        pMinimalEquivalenceClassSize=Math.min(pMinimalEquivalenceClassSize,entry.pcount);
      }
      numberOfEquivalenceClasses++;
      averageEquivalenceClassSize+=entry.count;
      maximalEquivalenceClassSize=Math.max(maximalEquivalenceClassSize,entry.count);
      minimalEquivalenceClassSize=Math.min(minimalEquivalenceClassSize,entry.count);
    }
    entry=entry.nextOrdered;
  }
  averageEquivalenceClassSize=averageEquivalenceClassSize / (double)(numberOfEquivalenceClasses);
  pAverageEquivalenceClassSize=pAverageEquivalenceClassSize / (double)(pNumberOfEquivalenceClasses - pNumberOfOutlyingEquivalenceClasses);
  return new GroupStatistics[]{new GroupStatistics(averageEquivalenceClassSize,maximalEquivalenceClassSize,minimalEquivalenceClassSize,numberOfEquivalenceClasses,numberOfOutlyingEquivalenceClasses,numberOfOutlyingTuples),new GroupStatistics(pAverageEquivalenceClassSize,pMaximalEquivalenceClassSize,pMinimalEquivalenceClassSize,pNumberOfEquivalenceClasses,pNumberOfOutlyingEquivalenceClasses,pNumberOfOutlyingTuples)};
}",0.9713896457765668
108845,"/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  return ((infoLoss.getValue() - result.getLattice().getBottom().getMinimumInformationLoss().getValue()) / result.getLattice().getTop().getMaximumInformationLoss().getValue()) * 100d;
}","/** 
 * Converts an information loss into a relative value in percent
 * @param infoLoss
 * @return
 */
private double asRelativeValue(final InformationLoss infoLoss){
  double min=result.getLattice().getBottom().getMinimumInformationLoss().getValue();
  double max=result.getLattice().getTop().getMaximumInformationLoss().getValue();
  return ((infoLoss.getValue() - min) / (max - min)) * 100d;
}",0.5386666666666666
108846,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.RESULT) {
    result=(ARXResult)event.data;
    reset();
  }
 else   if (event.part == ModelPart.SELECTED_NODE) {
    if (event.data == null) {
      reset();
    }
 else {
      setSelectedNode((ARXNode)event.data);
      SWTUtil.enable(root);
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.RESULT) {
    result=(ARXResult)event.data;
    reset();
  }
 else   if (event.part == ModelPart.SELECTED_NODE) {
    if (event.data == null) {
      reset();
    }
 else {
      update((ARXNode)event.data);
      SWTUtil.enable(root);
    }
  }
}",0.9716840536512668
108847,"public ViewProperties(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  groupNodeGridLayout.numColumns=1;
  root.setLayout(groupNodeGridLayout);
  createNodeGroup(root);
  reset();
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public ViewProperties(final Composite parent,final Controller controller){
  controller.addListener(ModelPart.RESULT,this);
  controller.addListener(ModelPart.SELECTED_NODE,this);
  this.controller=controller;
  ComponentTitledBorder border=new ComponentTitledBorder(parent,controller,Resources.getMessage(""String_Node_Str""),""String_Node_Str"");
  root=new Composite(border.getControl(),SWT.NONE);
  border.setChild(root);
  border.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupNodeGridLayout=new GridLayout();
  groupNodeGridLayout.numColumns=1;
  root.setLayout(groupNodeGridLayout);
  createNodeGroup(root);
  reset();
}",0.946441672780631
108848,"private void createNodeGroup(final Composite groupNode){
  table=new Table(groupNode,SWT.BORDER);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  final GridData gdata=SWTUtil.createFillGridData();
  table.setLayoutData(gdata);
  TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  for (  final TableColumn col : columns) {
    col.pack();
  }
}","/** 
 * Creates the required controls
 * @param groupNode
 */
private void createNodeGroup(final Composite groupNode){
  table=new Table(groupNode,SWT.BORDER);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  final GridData gdata=SWTUtil.createFillGridData();
  table.setLayoutData(gdata);
  TableColumn c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  c=new TableColumn(table,SWT.NONE);
  c.setText(Resources.getMessage(""String_Node_Str""));
  columns.add(c);
  for (  final TableColumn col : columns) {
    col.pack();
  }
}",0.9456140350877194
108849,"public void stop(){
  stop=true;
synchronized (monitor) {
    try {
      monitor.wait();
    }
 catch (    final InterruptedException e) {
    }
  }
}","public void stop(){
  stop=true;
synchronized (monitor) {
    try {
      while (synchronizer != null) {
        monitor.wait();
      }
    }
 catch (    final InterruptedException e) {
    }
  }
}",0.8653295128939829
108850,"public void stop(){
  stop=true;
synchronized (stop) {
    try {
      stop.wait();
    }
 catch (    final InterruptedException e) {
    }
  }
}","public void stop(){
  stop=true;
synchronized (LayoutAnalyze.this) {
    try {
      LayoutAnalyze.this.wait();
    }
 catch (    final InterruptedException e) {
    }
  }
}",0.8742138364779874
108851,"@Override public void run(){
  final long time=System.currentTimeMillis();
  while (!stop && ((System.currentTimeMillis() - time) < 1000)) {
    if ((in != null) && (out != null)) {
      try {
        if (Display.getCurrent() != null) {
          runnable.run();
        }
 else {
          Display.getDefault().syncExec(runnable);
        }
      }
 catch (      final Exception e) {
      }
    }
    try {
      Thread.sleep(10);
    }
 catch (    final InterruptedException e) {
    }
  }
  synchronizer=null;
synchronized (stop) {
    stop.notify();
  }
}","@Override public void run(){
  final long time=System.currentTimeMillis();
  while (!stop && ((System.currentTimeMillis() - time) < 1000)) {
    if ((in != null) && (out != null)) {
      try {
        if (Display.getCurrent() != null) {
          runnable.run();
        }
 else {
          Display.getDefault().syncExec(runnable);
        }
      }
 catch (      final Exception e) {
      }
    }
    try {
      Thread.sleep(10);
    }
 catch (    final InterruptedException e) {
    }
  }
  synchronizer=null;
synchronized (LayoutAnalyze.this) {
    LayoutAnalyze.this.notify();
  }
}",0.9478260869565216
108852,"@Override public void reset(){
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(parent,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  final ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(MainWindow.FONT);
  chart.setBackground(parent.getBackground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final org.eclipse.swt.graphics.Color c2=new org.eclipse.swt.graphics.Color(controller.getResources().getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  final IAxis xAxis=axisSet.getXAxis(0);
  final ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(MainWindow.FONT);
  yAxis.getTitle().setFont(MainWindow.FONT);
  xAxis.getTick().setFont(MainWindow.FONT);
  yAxis.getTick().setFont(MainWindow.FONT);
  final ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  if (chart != null) {
    chart.setEnabled(false);
  }
}","@Override public void reset(){
  if (chart != null) {
    chart.dispose();
  }
  chart=new Chart(parent,SWT.NONE);
  chart.setOrientation(SWT.HORIZONTAL);
  final ITitle graphTitle=chart.getTitle();
  graphTitle.setText(""String_Node_Str"");
  graphTitle.setFont(MainWindow.FONT);
  chart.setBackground(parent.getBackground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=chart.getBackground().getRed() - 13;
    int g=chart.getBackground().getGreen() - 13;
    int b=chart.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final org.eclipse.swt.graphics.Color c2=new org.eclipse.swt.graphics.Color(controller.getResources().getDisplay(),r,g,b);
    chart.setBackground(c2);
    chart.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  final IAxisSet axisSet=chart.getAxisSet();
  final IAxis yAxis=axisSet.getYAxis(0);
  final IAxis xAxis=axisSet.getXAxis(0);
  final ITitle xAxisTitle=xAxis.getTitle();
  xAxisTitle.setText(""String_Node_Str"");
  xAxis.getTitle().setFont(MainWindow.FONT);
  yAxis.getTitle().setFont(MainWindow.FONT);
  xAxis.getTick().setFont(MainWindow.FONT);
  yAxis.getTick().setFont(MainWindow.FONT);
  final ITitle yAxisTitle=yAxis.getTitle();
  yAxisTitle.setText(""String_Node_Str"");
  chart.setEnabled(false);
}",0.9734207801173628
108853,"public ViewData getIn(){
  return in;
}","/** 
 * Returns the input view
 * @return
 */
public ViewData getIn(){
  return in;
}",0.6290322580645161
108854,"public Synchronizer(final ViewData in,final ViewData out){
  this.in=in;
  this.out=out;
  runnable=new Runnable(){
    @Override public void run(){
      out.getViewportLayer().setOriginRowPosition(in.getViewportLayer().getOriginRowPosition());
      out.getViewportLayer().setOriginColumnPosition(in.getViewportLayer().getOriginColumnPosition());
    }
  }
;
  new Thread(this).start();
}","/** 
 * Creates a new instance
 * @param in
 * @param out
 */
public Synchronizer(final ViewData in,final ViewData out){
  this.in=in;
  this.out=out;
  runnable=new Runnable(){
    @Override public void run(){
      ViewportLayer outLayer=out.getViewportLayer();
      ViewportLayer inLayer=in.getViewportLayer();
      outLayer.setOriginRowPosition(inLayer.getOriginRowPosition());
      outLayer.setOriginColumnPosition(inLayer.getOriginColumnPosition());
    }
  }
;
  new Thread(this).start();
}",0.7280898876404495
108855,"public void stop(){
  stop=true;
synchronized (LayoutAnalyze.this) {
    try {
      LayoutAnalyze.this.wait();
    }
 catch (    final InterruptedException e) {
    }
  }
}","public void stop(){
  stop=true;
synchronized (monitor) {
    try {
      monitor.wait();
    }
 catch (    final InterruptedException e) {
    }
  }
}",0.8703703703703703
108856,"@Override public void run(){
  final long time=System.currentTimeMillis();
  while (!stop && ((System.currentTimeMillis() - time) < 1000)) {
    if ((in != null) && (out != null)) {
      try {
        if (Display.getCurrent() != null) {
          runnable.run();
        }
 else {
          Display.getDefault().syncExec(runnable);
        }
      }
 catch (      final Exception e) {
      }
    }
    try {
      Thread.sleep(10);
    }
 catch (    final InterruptedException e) {
    }
  }
  synchronizer=null;
synchronized (LayoutAnalyze.this) {
    LayoutAnalyze.this.notify();
  }
}","@Override public void run(){
  final long time=System.currentTimeMillis();
  while (!stop && ((System.currentTimeMillis() - time) < 1000)) {
    if ((in != null) && (out != null)) {
      try {
        if (Display.getCurrent() != null) {
          runnable.run();
        }
 else {
          Display.getDefault().syncExec(runnable);
        }
      }
 catch (      final Exception e) {
      }
    }
    try {
      Thread.sleep(10);
    }
 catch (    final InterruptedException e) {
    }
  }
  synchronizer=null;
synchronized (monitor) {
    monitor.notify();
  }
}",0.9429065743944636
108857,"public LayoutAnalyze(final Composite parent,final Controller controller){
  centerSash=new SashForm(parent,SWT.VERTICAL);
  centerSash.setLayoutData(SWTUtil.createFillGridData());
  final Composite center=new Composite(centerSash,SWT.NONE);
  center.setLayoutData(SWTUtil.createFillGridData());
  center.setLayout(SWTUtil.createGridLayout(2));
  centerLeft=new Composite(center,SWT.NONE);
  centerLeft.setLayoutData(SWTUtil.createFillGridData());
  centerLeft.setLayout(SWTUtil.createGridLayout(1));
  centerRight=new Composite(center,SWT.NONE);
  centerRight.setLayoutData(SWTUtil.createFillGridData());
  centerRight.setLayout(SWTUtil.createGridLayout(1));
  dataInputView=new ViewDataInput(centerLeft,controller);
  dataOutputView=new ViewDataOutput(centerRight,controller);
  dataInputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataInputView.getViewportLayer().getOriginRowPosition();
      final int col=dataInputView.getViewportLayer().getOriginColumnPosition();
      if (dataOutputView != null) {
        dataOutputView.getViewportLayer().setOriginRowPosition(row);
        dataOutputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataInputView,dataOutputView);
      }
    }
  }
);
  dataOutputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataOutputView.getViewportLayer().getOriginRowPosition();
      final int col=dataOutputView.getViewportLayer().getOriginColumnPosition();
      if (dataInputView != null) {
        dataInputView.getViewportLayer().setOriginRowPosition(row);
        dataInputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataOutputView,dataInputView);
      }
    }
  }
);
  final Composite compositeBottom=new Composite(centerSash,SWT.NONE);
  compositeBottom.setLayout(new FillLayout());
  final SashForm bottomSash=new SashForm(compositeBottom,SWT.HORIZONTAL | SWT.SMOOTH);
  bottomLeft=new Composite(bottomSash,SWT.NONE);
  bottomLeft.setLayout(new FillLayout());
  bottomRight=new Composite(bottomSash,SWT.NONE);
  bottomRight.setLayout(new FillLayout());
  statisticsInputLayout=new LayoutStatistics(bottomLeft,controller,ModelPart.INPUT,null);
  statisticsOutputLayout=new LayoutStatistics(bottomRight,controller,ModelPart.OUTPUT,ModelPart.INPUT);
  statisticsInputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsOutputLayout.setSelectionIdex(statisticsInputLayout.getSelectionIndex());
    }
  }
);
  statisticsOutputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsInputLayout.setSelectionIdex(statisticsOutputLayout.getSelectionIndex());
    }
  }
);
  centerSash.setWeights(new int[]{WEIGHT_TOP,WEIGHT_BOTTOM});
  bottomSash.setWeights(new int[]{WEIGHT_LEFT,WEIGHT_RIGHT});
}","/** 
 * Creates a new instance
 * @param parent
 * @param controller
 */
public LayoutAnalyze(final Composite parent,final Controller controller){
  centerSash=new SashForm(parent,SWT.VERTICAL);
  centerSash.setLayoutData(SWTUtil.createFillGridData());
  final Composite center=new Composite(centerSash,SWT.NONE);
  center.setLayoutData(SWTUtil.createFillGridData());
  center.setLayout(SWTUtil.createGridLayout(2));
  centerLeft=new Composite(center,SWT.NONE);
  centerLeft.setLayoutData(SWTUtil.createFillGridData());
  centerLeft.setLayout(SWTUtil.createGridLayout(1));
  centerRight=new Composite(center,SWT.NONE);
  centerRight.setLayoutData(SWTUtil.createFillGridData());
  centerRight.setLayout(SWTUtil.createGridLayout(1));
  dataInputView=new ViewDataInput(centerLeft,controller);
  dataOutputView=new ViewDataOutput(centerRight,controller);
  dataInputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataInputView.getViewportLayer().getOriginRowPosition();
      final int col=dataInputView.getViewportLayer().getOriginColumnPosition();
      if (dataOutputView != null) {
        dataOutputView.getViewportLayer().setOriginRowPosition(row);
        dataOutputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataInputView,dataOutputView);
      }
    }
  }
);
  dataOutputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataOutputView.getViewportLayer().getOriginRowPosition();
      final int col=dataOutputView.getViewportLayer().getOriginColumnPosition();
      if (dataInputView != null) {
        dataInputView.getViewportLayer().setOriginRowPosition(row);
        dataInputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataOutputView,dataInputView);
      }
    }
  }
);
  final Composite compositeBottom=new Composite(centerSash,SWT.NONE);
  compositeBottom.setLayout(new FillLayout());
  final SashForm bottomSash=new SashForm(compositeBottom,SWT.HORIZONTAL | SWT.SMOOTH);
  bottomLeft=new Composite(bottomSash,SWT.NONE);
  bottomLeft.setLayout(new FillLayout());
  bottomRight=new Composite(bottomSash,SWT.NONE);
  bottomRight.setLayout(new FillLayout());
  statisticsInputLayout=new LayoutStatistics(bottomLeft,controller,ModelPart.INPUT,null);
  statisticsOutputLayout=new LayoutStatistics(bottomRight,controller,ModelPart.OUTPUT,ModelPart.INPUT);
  statisticsInputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsOutputLayout.setSelectionIdex(statisticsInputLayout.getSelectionIndex());
    }
  }
);
  statisticsOutputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsInputLayout.setSelectionIdex(statisticsOutputLayout.getSelectionIndex());
    }
  }
);
  centerSash.setWeights(new int[]{WEIGHT_TOP,WEIGHT_BOTTOM});
  bottomSash.setWeights(new int[]{WEIGHT_LEFT,WEIGHT_RIGHT});
}",0.988042588042588
108858,"/** 
 * Redraws the plot
 */
private void redraw(){
  if (model != null && model.getAttributePair() != null & model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
    final DataHandle data=getData();
    if (data == null) {
      reset();
      return;
    }
    final int index1=data.getColumnIndexOf(model.getAttributePair()[0]);
    final int index2=data.getColumnIndexOf(model.getAttributePair()[1]);
    if (index1 < 0 || index2 < 0) {
      reset();
      return;
    }
    attribute1=model.getAttributePair()[0];
    attribute2=model.getAttributePair()[1];
    handle=data;
    updateData();
    updatePlot();
    repaint();
  }
 else {
    reset();
    return;
  }
}","/** 
 * Redraws the plot
 */
private void redraw(){
  if (model != null && model.getAttributePair() != null && model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
    final DataHandle data=getData();
    if (data == null) {
      reset();
      return;
    }
    final int index1=data.getColumnIndexOf(model.getAttributePair()[0]);
    final int index2=data.getColumnIndexOf(model.getAttributePair()[1]);
    if (index1 < 0 || index2 < 0) {
      reset();
      return;
    }
    attribute1=model.getAttributePair()[0];
    attribute2=model.getAttributePair()[1];
    handle=data;
    updateData();
    updatePlot();
    repaint();
  }
 else {
    reset();
    return;
  }
}",0.9992852037169406
108859,"/** 
 * Lists all available data types
 * @return
 */
private static List<DataTypeDescription<?>> listDataTypes(){
  List<DataTypeDescription<?>> list=new ArrayList<DataTypeDescription<?>>();
  list.add(STRING.getDescription());
  list.add(DATE.getDescription());
  list.add(DECIMAL.getDescription());
  list.add(INTEGER.getDescription());
  return list;
}","/** 
 * Lists all available data types
 * @return
 */
private static final List<DataTypeDescription<?>> listDataTypes(){
  List<DataTypeDescription<?>> list=new ArrayList<DataTypeDescription<?>>();
  list.add(STRING.getDescription());
  list.add(DATE.getDescription());
  list.add(DECIMAL.getDescription());
  list.add(INTEGER.getDescription());
  return list;
}",0.9916434540389972
108860,"/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.DATE(dtype));
          }
        }
 else         if (vocabulary.getVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.LIST) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,DataType.STRING);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          try {
            config.getInput().getDefinition().setAttributeType(attr,readHierarchy(zip,prefix,ref));
          }
 catch (          final IOException e) {
            throw new SAXException(e);
          }
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new XMLHandler(){
    String attr, dtype, atype, ref, min, max, format;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          if (dtype.equals(DataType.STRING.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.STRING);
          }
 else           if (dtype.equals(DataType.DECIMAL.toString())) {
            config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
          }
 else {
            config.getInput().getDefinition().setDataType(attr,DataType.DATE(dtype));
          }
        }
 else         if (vocabulary.getVocabularyVersion().equals(""String_Node_Str"")) {
          DataType<?> datatype=null;
          for (          DataTypeDescription<?> description : DataType.LIST) {
            if (description.getLabel().equals(dtype)) {
              if (format != null) {
                if (!description.hasFormat()) {
                  throw new RuntimeException(""String_Node_Str"");
                }
                datatype=description.newInstance(format);
              }
 else {
                datatype=description.newInstance();
              }
              break;
            }
          }
          if (datatype == null) {
            throw new RuntimeException(""String_Node_Str"" + attr);
          }
          config.getInput().getDefinition().setDataType(attr,datatype);
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          try {
            config.getInput().getDefinition().setAttributeType(attr,readHierarchy(zip,prefix,ref));
          }
 catch (          final IOException e) {
            throw new SAXException(e);
          }
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        format=null;
        return true;
      }
 else       if (vocabulary.isName(localName)) {
        attr=payload;
        return true;
      }
 else       if (vocabulary.isType(localName)) {
        atype=payload;
        return true;
      }
 else       if (vocabulary.isDatatype(localName)) {
        dtype=payload;
        return true;
      }
 else       if (vocabulary.isFormat(localName)) {
        format=payload;
        return true;
      }
 else       if (vocabulary.isRef(localName)) {
        ref=payload;
        return true;
      }
 else       if (vocabulary.isMin(localName)) {
        min=payload;
        return true;
      }
 else       if (vocabulary.isMax(localName)) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (vocabulary.isDefinition(localName)) {
        return true;
      }
 else       if (vocabulary.isAssigment(localName)) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (vocabulary.isName(localName) || vocabulary.isType(localName) || vocabulary.isDatatype(localName)|| vocabulary.isFormat(localName)|| vocabulary.isRef(localName)|| vocabulary.isMin(localName)|| vocabulary.isMax(localName)) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.9960328443583356
108861,"@Test public void testExample14(){
  try {
    Example12.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}","@Test public void testExample14(){
  try {
    Example14.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}",0.9934640522875816
108862,"@Test public void testExample13(){
  try {
    Example12.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}","@Test public void testExample13(){
  try {
    Example13.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}",0.9934640522875816
108863,"@Test public void testExample16(){
  try {
    Example12.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}","@Test public void testExample16(){
  try {
    Example16.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}",0.9934640522875816
108864,"@Test public void testExample15(){
  try {
    Example12.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}","@Test public void testExample15(){
  try {
    Example15.main(null);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
}",0.9934640522875816
108865,"@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  for (  String type : getDataTypes()) {
    combo.add(type);
  }
  combo.select(0);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() >= 0) {
        DataType<?> type=model.getDataType();
        if (combo.getSelectionIndex() > 0) {
          String label=combo.getItem(combo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(text1,text2,description,model.getItems());
            if (format == null) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,model.getItems())) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
          }
        }
        try {
          sort(type);
        }
 catch (        Exception e) {
          sort(DataType.STRING);
        }
      }
    }
  }
);
  setControl(composite);
}","@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  for (  String type : getDataTypes()) {
    combo.add(type);
  }
  combo.select(0);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() >= 0) {
        DataType<?> type=model.getDataType();
        if (combo.getSelectionIndex() > 0) {
          String label=combo.getItem(combo.getSelectionIndex());
          DataTypeDescription<?> description=getDataType(label);
          if (description.hasFormat()) {
            final String text1=Resources.getMessage(""String_Node_Str"");
            final String text2=Resources.getMessage(""String_Node_Str"");
            final String format=controller.actionShowFormatInputDialog(text1,text2,description,model.getItems());
            if (format == null) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
 else {
              type=description.newInstance(format);
            }
          }
 else {
            type=description.newInstance();
            if (!isValidDataType(type,model.getItems())) {
              type=DataType.STRING;
              combo.select(getIndexOfDataType(DataType.STRING) + 1);
            }
          }
        }
        try {
          sort(type);
        }
 catch (        Exception e) {
          sort(DataType.STRING);
        }
      }
    }
  }
);
  sort(model.getDataType());
  setControl(composite);
}",0.9958243340532758
108866,"/** 
 * @param xlsSheetIndex {@link #xlsSheetIndex}
 */
public void setXlsSheetIndex(int xlsSheetIndex){
  this.xlsSheetIndex=xlsSheetIndex;
}","/** 
 * @param {@link #xlsSheetIndex}
 */
public void setXlsSheetIndex(int xlsSheetIndex){
  this.xlsSheetIndex=xlsSheetIndex;
}",0.9481481481481482
108867,"/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  return dvals;
}","/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=super.getConfig();
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  return dvals;
}",0.9806598407281
108868,"private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}","private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=super.getConfig();
  DataHandle data=super.getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}",0.9679163662581112
108869,"/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  if (model != null) {
    if (target == ModelPart.INPUT) {
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      DataHandle handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}","/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  DataHandle handle=null;
  if (model != null) {
    if (target == ModelPart.INPUT) {
      handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}",0.966987620357634
108870,"public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
 else {
      try {
        Class.forName(JDK16_FRAME);
      }
 catch (      Exception e) {
        SWT_AWT.embeddedFrameClass=JDK17_FRAME;
      }
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
 else {
      try {
        Class.forName(JDK16_FRAME);
      }
 catch (      Exception e) {
        SWT_AWT.embeddedFrameClass=JDK17_FRAME;
      }
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.addListener(SWT.Show,new Listener(){
      @Override public void handleEvent(      Event arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.923809523809524
108871,"/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  return dvals;
}","/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=super.getConfig();
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  return dvals;
}",0.9806598407281
108872,"private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}","private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=super.getConfig();
  DataHandle data=super.getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}",0.9679163662581112
108873,"/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  if (model != null) {
    if (target == ModelPart.INPUT) {
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      DataHandle handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}","/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  DataHandle handle=null;
  if (model != null) {
    if (target == ModelPart.INPUT) {
      handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}",0.966987620357634
108874,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
        close();
      }
    }
  }
);
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
    return parent;
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
        close();
      }
    }
  }
);
  return parent;
}",0.9934460158675406
108875,"/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  if (model != null) {
    if (target == ModelPart.INPUT) {
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      DataHandle handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}","/** 
 * Returns the data handle
 * @return
 */
protected DataHandle getHandle(){
  if (model != null) {
    if (target == ModelPart.INPUT) {
      DataHandle handle=model.getInputConfig().getInput().getHandle();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
 else {
      DataHandle handle=model.getOutput();
      if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null && handle != null) {
        handle=handle.getView();
      }
      return handle;
    }
  }
 else {
    return null;
  }
}",0.9745403111739744
108876,"/** 
 * Column selection event
 * @param arg1
 */
protected void actionColumnSelected(ColumnSelectionEvent arg1){
  if (model != null) {
    int column=arg1.getColumnPositionRanges().iterator().next().start - 1;
    if (column >= 0) {
      DataHandle handle=getHandle();
      if (handle != null) {
        final String attr=handle.getAttributeName(column);
        table.setAttribute(attr);
        table.redraw();
        model.setSelectedAttribute(attr);
        controller.update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attr));
      }
    }
  }
}","/** 
 * Selects the given column
 * @param index
 */
private void actionColumnSelected(int index){
  DataHandle handle=getHandle();
  if (handle != null) {
    final String attr=handle.getAttributeName(index);
    model.setSelectedAttribute(attr);
    table.setSelectedAttribute(attr);
    controller.update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attr));
  }
}",0.309344790547798
108877,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT || event.part == ModelPart.VIEW_CONFIG) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
  if (event.part == ModelPart.VIEW_CONFIG) {
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT || event.part == ModelPart.VIEW_CONFIG) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
  if (event.part == ModelPart.VIEW_CONFIG) {
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
  if (event.part == ModelPart.SELECTED_ATTRIBUTE) {
    table.setSelectedAttribute((String)event.data);
  }
}",0.9166666666666666
108878,"/** 
 * Cell selection event
 * @param arg1
 */
protected abstract void actionCellSelected(CellSelectionEvent arg1);","/** 
 * Cell selection event
 * @param arg1
 */
protected void actionCellSelected(CellSelectionEvent arg1){
  if (model != null) {
    int column=arg1.getColumnPosition() - 1;
    if (column >= 0)     actionColumnSelected(column);
  }
}",0.6079545454545454
108879,"@Override protected void actionCellSelected(CellSelectionEvent arg1){
  if (model == null)   return;
  int column=arg1.getColumnPosition();
  int row=arg1.getRowPosition();
  if (column == 0 && row >= 0) {
    if (table.getData() instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)table.getData()).getSubset();
      row=subset[row];
    }
    RowSet subset=model.getInputConfig().getResearchSubset();
    if (subset.contains(row)) {
      subset.remove(row);
    }
 else {
      subset.add(row);
    }
    model.setSubsetManual();
    controller.update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","@Override protected void actionCellSelected(CellSelectionEvent arg1){
  super.actionCellSelected(arg1);
  if (model == null)   return;
  int column=arg1.getColumnPosition();
  int row=arg1.getRowPosition();
  if (column == 0 && row >= 0) {
    if (table.getData() instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)table.getData()).getSubset();
      row=subset[row];
    }
    RowSet subset=model.getInputConfig().getResearchSubset();
    if (subset.contains(row)) {
      subset.remove(row);
    }
 else {
      subset.add(row);
    }
    model.setSubsetManual();
    controller.update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.9738461538461538
108880,"@Override protected void actionCellSelected(CellSelectionEvent arg1){
}","@Override protected void actionCellSelected(CellSelectionEvent arg1){
  super.actionCellSelected(arg1);
}",0.8068181818181818
108881,"/** 
 * This is a dirty hack to push the hierarchies into the definition. It is triggered by a change event on the attribute type 
 */
private void pushHierarchy(){
  updateMinAndMax();
  if (model == null) {
    return;
  }
  final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
  final Hierarchy h=Hierarchy.create(hierarchy);
  if (definition.getAttributeType(attribute) instanceof Hierarchy) {
    model.getInputConfig().getInput().getDefinition().setAttributeType(attribute,h);
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
  if (definition.getAttributeType(attribute) == AttributeType.SENSITIVE_ATTRIBUTE) {
    model.getInputConfig().setHierarchy(attribute,h);
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
}","/** 
 * TODO: This is a dirty hack to push the hierarchies into the definition. It is triggered by a change event on the attribute type 
 */
private void pushHierarchy(){
  updateMinAndMax();
  if (model == null) {
    return;
  }
  final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
  final Hierarchy h=Hierarchy.create(hierarchy);
  if (definition.getAttributeType(attribute) instanceof Hierarchy) {
    model.getInputConfig().getInput().getDefinition().setAttributeType(attribute,h);
    updateMin();
    updateMax();
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
  if (definition.getAttributeType(attribute) == AttributeType.SENSITIVE_ATTRIBUTE) {
    model.getInputConfig().setHierarchy(attribute,h);
    controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
  }
}",0.976218787158145
108882,"private void create(final Composite parent){
  base=new Composite(parent,SWT.NONE);
  final GridData bottomLayoutData=SWTUtil.createFillGridData();
  bottomLayoutData.grabExcessVerticalSpace=true;
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=1;
  base.setLayout(bottomLayout);
  base.setLayoutData(bottomLayoutData);
  final Label l=new Label(base,SWT.NONE);
  l.setText(Resources.getMessage(""String_Node_Str"") + attribute + Resources.getMessage(""String_Node_Str""));
  table=new Table(base,SWT.BORDER | SWT.MULTI | SWT.FULL_SELECTION);
  final TableColumn newColumn=new TableColumn(table,SWT.NONE,0);
  newColumn.setWidth(60);
  table.redraw();
  updateColumnTitles();
  if (editable) {
    final Composite bottom=new Composite(base,SWT.NONE);
    bottom.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    final GridLayout layout=new GridLayout();
    layout.numColumns=4;
    bottom.setLayout(layout);
    final Label l1=new Label(bottom,SWT.NONE);
    l1.setText(Resources.getMessage(""String_Node_Str""));
    min=new Combo(bottom,SWT.READ_ONLY);
    min.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    min.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      final SelectionEvent arg0){
        if (min.getSelectionIndex() >= 0 && min.getItemCount() > 1) {
          if (min.getSelectionIndex() > (max.getSelectionIndex() + 1)) {
            min.select(max.getSelectionIndex() + 1);
          }
 else {
            if (model != null) {
              String val=min.getItem(min.getSelectionIndex());
              if (val.equals(ITEM_ALL)) {
                val=""String_Node_Str"";
              }
              model.getInputConfig().getInput().getDefinition().setMinimumGeneralization(attribute,Integer.valueOf(val) - 1);
              controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
            }
          }
        }
      }
    }
);
    final Label l2=new Label(bottom,SWT.NONE);
    l2.setText(Resources.getMessage(""String_Node_Str""));
    max=new Combo(bottom,SWT.READ_ONLY);
    max.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    max.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      final SelectionEvent arg0){
        if (max.getSelectionIndex() >= 0 && max.getItemCount() > 1) {
          if (max.getSelectionIndex() < (min.getSelectionIndex() - 1)) {
            max.select(min.getSelectionIndex() - 1);
          }
 else {
            if (model != null) {
              String val=max.getItem(max.getSelectionIndex());
              if (val.equals(ITEM_ALL)) {
                val=String.valueOf(max.getItem(max.getSelectionIndex() - 1));
              }
              model.getInputConfig().getInput().getDefinition().setMaximumGeneralization(attribute,Integer.valueOf(val) - 1);
              controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
            }
          }
        }
      }
    }
);
  }
  init();
}","private void create(final Composite parent){
  base=new Composite(parent,SWT.NONE);
  final GridData bottomLayoutData=SWTUtil.createFillGridData();
  bottomLayoutData.grabExcessVerticalSpace=true;
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=1;
  base.setLayout(bottomLayout);
  base.setLayoutData(bottomLayoutData);
  final Label l=new Label(base,SWT.NONE);
  l.setText(Resources.getMessage(""String_Node_Str"") + attribute + Resources.getMessage(""String_Node_Str""));
  table=new Table(base,SWT.BORDER | SWT.MULTI | SWT.FULL_SELECTION);
  final TableColumn newColumn=new TableColumn(table,SWT.NONE,0);
  newColumn.setWidth(60);
  table.redraw();
  updateColumnTitles();
  if (editable) {
    final Composite bottom=new Composite(base,SWT.NONE);
    bottom.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    final GridLayout layout=new GridLayout();
    layout.numColumns=4;
    bottom.setLayout(layout);
    final Label l1=new Label(bottom,SWT.NONE);
    l1.setText(Resources.getMessage(""String_Node_Str""));
    min=new Combo(bottom,SWT.READ_ONLY);
    min.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    min.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      final SelectionEvent arg0){
        if (updateMin())         controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
      }
    }
);
    final Label l2=new Label(bottom,SWT.NONE);
    l2.setText(Resources.getMessage(""String_Node_Str""));
    max=new Combo(bottom,SWT.READ_ONLY);
    max.setLayoutData(SWTUtil.createFillHorizontallyGridData());
    max.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      final SelectionEvent arg0){
        if (updateMax())         controller.update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,attribute));
      }
    }
);
  }
  init();
}",0.7549238578680203
108883,"/** 
 * Reds the first few files with chosen separator
 * @param file
 * @return
 * @throws IOException
 */
private void read(final String file) throws IOException {
  final CSVDataInput in=new CSVDataInput(file,separators[selection]);
  final Iterator<String[]> it=in.iterator();
  final List<String[]> data=new ArrayList<String[]>();
  int count=0;
  while (it.hasNext() && (count < LINES)) {
    data.add(it.next());
    count++;
  }
  in.close();
  if (!this.data) {
    data.add(data.get(data.size() - 1));
    for (int i=data.size() - 2; i >= 0; i--) {
      data.set(i + 1,data.get(i));
    }
    int length=data.get(0).length;
    String[] header=new String[length];
    for (int i=0; i < length; i++) {
      header[i]=Resources.getMessage(""String_Node_Str"") + (i + 1);
    }
    data.set(0,header);
  }
  table.setRedraw(false);
  table.removeAll();
  for (  final TableColumn c : columns) {
    c.dispose();
  }
  columns.clear();
  if (data.size() == 0) {
    return;
  }
  for (  final String s : data.get(0)) {
    final TableColumn c=new TableColumn(table,SWT.NONE);
    c.setText(s);
    columns.add(c);
    c.pack();
  }
  for (int i=1; i < data.size(); i++) {
    final TableItem item=new TableItem(table,SWT.NONE);
    for (int j=0; j < data.get(i).length; j++) {
      item.setText(j,data.get(i)[j]);
    }
  }
  table.setRedraw(true);
  table.redraw();
}","/** 
 * Reds the first few files with chosen separator
 * @param file
 * @return
 * @throws IOException
 */
private void read(final String file) throws IOException {
  final CSVDataInput in=new CSVDataInput(file,separators[selection]);
  final Iterator<String[]> it=in.iterator();
  final List<String[]> data=new ArrayList<String[]>();
  int count=0;
  while (it.hasNext() && (count < LINES)) {
    data.add(it.next());
    count++;
  }
  in.close();
  if (!this.data && data.size() > 0) {
    data.add(data.get(data.size() - 1));
    for (int i=data.size() - 2; i >= 0; i--) {
      data.set(i + 1,data.get(i));
    }
    int length=data.get(0).length;
    String[] header=new String[length];
    for (int i=0; i < length; i++) {
      header[i]=Resources.getMessage(""String_Node_Str"") + (i + 1);
    }
    data.set(0,header);
  }
  table.setRedraw(false);
  table.removeAll();
  for (  final TableColumn c : columns) {
    c.dispose();
  }
  columns.clear();
  if (data.size() == 0) {
    return;
  }
  for (  final String s : data.get(0)) {
    final TableColumn c=new TableColumn(table,SWT.NONE);
    c.setText(s);
    columns.add(c);
    c.pack();
  }
  for (int i=1; i < data.size(); i++) {
    final TableItem item=new TableItem(table,SWT.NONE);
    for (int j=0; j < data.get(i).length; j++) {
      item.setText(j,data.get(i)[j]);
    }
  }
  table.setRedraw(true);
  table.redraw();
}",0.9931383170819792
108884,"public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","public static void main(final String[] args){
  try {
    if (!isOSX()) {
      splash=new MainSplash();
      splash.setVisible(true);
    }
 else {
      try {
        Class.forName(JDK16_FRAME);
      }
 catch (      Exception e) {
        SWT_AWT.embeddedFrameClass=JDK17_FRAME;
      }
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    hideSplash();
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.9025769956002514
108885,"public MainSplash() throws IOException {
  this.setSize(new Dimension(400,240));
  this.setLocationRelativeTo(null);
  this.setAlwaysOnTop(true);
  this.setUndecorated(true);
  this.setIconImage(Resources.getImageIcon());
  AWTUtilities.setWindowOpaque(this,false);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      repaint();
    }
  }
);
}","public MainSplash() throws IOException {
  this.setSize(new Dimension(400,240));
  this.setLocationRelativeTo(null);
  this.setAlwaysOnTop(true);
  this.setUndecorated(true);
  this.setIconImage(Resources.getImageIcon());
  try {
    AWTUtilities.setWindowOpaque(this,false);
  }
 catch (  Exception e) {
  }
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      repaint();
    }
  }
);
}",0.9507445589919816
108886,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.INPUT) {
    reset();
  }
 else   if (event.part == ModelPart.RESULT) {
    initialize(model.getResult(),null);
    SWTUtil.enable(root);
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
 else   if (event.part == ModelPart.FILTER) {
    if ((filter == null) || (model.getNodeFilter() != filter)) {
      initialize(model.getResult(),model.getNodeFilter());
      SWTUtil.enable(root);
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.INPUT) {
    reset();
  }
 else   if (event.part == ModelPart.RESULT) {
    if (model.getResult() == null || model.getResult().getLattice() == null) {
      reset();
      SWTUtil.disable(root);
    }
 else {
      initialize(model.getResult(),null);
      SWTUtil.enable(root);
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
 else   if (event.part == ModelPart.FILTER) {
    if ((filter == null) || (model.getNodeFilter() != filter)) {
      if (model.getResult() == null || model.getResult().getLattice() == null) {
        reset();
        SWTUtil.disable(root);
      }
 else {
        initialize(model.getResult(),model.getNodeFilter());
        SWTUtil.enable(root);
      }
    }
  }
}",0.6976401179941003
108887,"private void initialize(final ARXResult result,final ModelNodeFilter nodeFilter){
  reset();
  maxlevels=result.getLattice().getTop().getTransformation();
  if (nodeFilter == null) {
    filter=new ModelNodeFilter(maxlevels,model.getInitialNodesInViewer());
    filter.initialize(result);
  }
 else {
    filter=nodeFilter;
  }
  this.result=result;
  for (  final String attr : result.getLattice().getBottom().getQuasiIdentifyingAttributes()) {
    attribute.add(attr);
  }
  attribute.select(0);
  attribute.setEnabled(true);
  if (filter.isAllowedAnonymous()) {
    anonymous.select(0);
  }
 else {
    anonymous.select(1);
  }
  anonymous.setEnabled(true);
  if (filter.isAllowedNonAnonymous()) {
    notanonymous.select(0);
  }
 else {
    notanonymous.select(1);
  }
  notanonymous.setEnabled(true);
  if (filter.isAllowedUnknown()) {
    unknown.select(0);
  }
 else {
    unknown.select(1);
  }
  unknown.setEnabled(true);
  min.setMinimum(informationLossToInt(result.getLattice().getBottom().getMinimumInformationLoss().getValue()));
  max.setMaximum(informationLossToInt(result.getLattice().getTop().getMaximumInformationLoss().getValue()));
  min.setSelection(informationLossToInt(filter.getAllowedMinInformationLoss()));
  max.setSelection(informationLossToInt(filter.getAllowedMaxInformationLoss()));
  min.setEnabled(true);
  max.setEnabled(true);
  generalization.removeAll();
  createGeneralization(result.getLattice().getBottom().getQuasiIdentifyingAttributes()[attribute.getSelectionIndex()]);
  generalization.setEnabled(true);
  if (model != null) {
    model.setNodeFilter(filter);
    controller.update(new ModelEvent(this,ModelPart.FILTER,filter));
  }
}","private void initialize(final ARXResult result,final ModelNodeFilter nodeFilter){
  reset();
  if (result == null || result.getLattice() == null)   return;
  maxlevels=result.getLattice().getTop().getTransformation();
  if (nodeFilter == null) {
    filter=new ModelNodeFilter(maxlevels,model.getInitialNodesInViewer());
    filter.initialize(result);
  }
 else {
    filter=nodeFilter;
  }
  this.result=result;
  for (  final String attr : result.getLattice().getBottom().getQuasiIdentifyingAttributes()) {
    attribute.add(attr);
  }
  attribute.select(0);
  attribute.setEnabled(true);
  if (filter.isAllowedAnonymous()) {
    anonymous.select(0);
  }
 else {
    anonymous.select(1);
  }
  anonymous.setEnabled(true);
  if (filter.isAllowedNonAnonymous()) {
    notanonymous.select(0);
  }
 else {
    notanonymous.select(1);
  }
  notanonymous.setEnabled(true);
  if (filter.isAllowedUnknown()) {
    unknown.select(0);
  }
 else {
    unknown.select(1);
  }
  unknown.setEnabled(true);
  min.setMinimum(informationLossToInt(result.getLattice().getBottom().getMinimumInformationLoss().getValue()));
  max.setMaximum(informationLossToInt(result.getLattice().getTop().getMaximumInformationLoss().getValue()));
  min.setSelection(informationLossToInt(filter.getAllowedMinInformationLoss()));
  max.setSelection(informationLossToInt(filter.getAllowedMaxInformationLoss()));
  min.setEnabled(true);
  max.setEnabled(true);
  generalization.removeAll();
  createGeneralization(result.getLattice().getBottom().getQuasiIdentifyingAttributes()[attribute.getSelectionIndex()]);
  generalization.setEnabled(true);
  if (model != null) {
    model.setNodeFilter(filter);
    controller.update(new ModelEvent(this,ModelPart.FILTER,filter));
  }
}",0.9815627743634768
108888,"/** 
 * Resets the view
 */
@Override public void reset(){
  optimum=null;
  selectedNode=null;
  table.setRedraw(false);
  table.clearAll();
  table.setRedraw(true);
}","/** 
 * Resets the view
 */
@Override public void reset(){
  optimum=null;
  selectedNode=null;
  table.setRedraw(false);
  table.clearAll();
  table.setRedraw(true);
  if (listener != null) {
    table.removeListener(SWT.SetData,listener);
  }
}",0.8115942028985508
108889,"/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      table.clearAll();
      list.clear();
      final ARXLattice l=result.getLattice();
      optimum=result.getGlobalOptimum();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      table.setRedraw(true);
    }
  }
);
}","/** 
 * Updates the list
 * @param result
 * @param filter
 */
private void update(final ARXResult result,final ModelNodeFilter filter){
  if (result == null || result.getLattice() == null)   return;
  if (filter == null)   return;
  controller.getResources().getDisplay().asyncExec(new Runnable(){
    @Override public void run(){
      table.setRedraw(false);
      table.clearAll();
      list.clear();
      final ARXLattice l=result.getLattice();
      optimum=result.getGlobalOptimum();
      for (      final ARXNode[] level : l.getLevels()) {
        for (        final ARXNode node : level) {
          if (filter.isAllowed(node)) {
            list.add(node);
          }
        }
      }
      Collections.sort(list,new Comparator<ARXNode>(){
        @Override public int compare(        final ARXNode arg0,        final ARXNode arg1){
          return arg0.getMaximumInformationLoss().compareTo(arg1.getMaximumInformationLoss());
        }
      }
);
      if (list.size() > model.getMaxNodesInViewer()) {
        list.clear();
      }
      if (listener != null) {
        table.removeListener(SWT.SetData,listener);
      }
      listener=new Listener(){
        @Override public void handleEvent(        final Event event){
          final TableItem item=(TableItem)event.item;
          final int index=table.indexOf(item);
          createItem(item,index);
        }
      }
;
      table.addListener(SWT.SetData,listener);
      table.setItemCount(list.size());
      table.setRedraw(true);
    }
  }
);
}",0.9678293261090416
108890,"@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
 else   if (event.part == ModelPart.CRITERION_DEFINITION) {
    if (model != null) {
      root.setRedraw(false);
      table.removeAll();
      if (model.getKAnonymityModel().isActive() && model.getKAnonymityModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getKAnonymityModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolK);
      }
      if (model.getDPresenceModel().isActive() && model.getDPresenceModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getDPresenceModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolD);
      }
      for (      ModelLDiversityCriterion c : model.getLDiversityModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolL);
        }
      }
      for (      ModelTClosenessCriterion c : model.getTClosenessModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolT);
        }
      }
      column1.pack();
      column2.pack();
      column3.pack();
      root.setRedraw(true);
    }
  }
}","@Override public void update(ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    this.model=(Model)event.data;
  }
  if (event.part == ModelPart.CRITERION_DEFINITION || event.part == ModelPart.MODEL) {
    if (model != null) {
      root.setRedraw(false);
      table.removeAll();
      if (model.getKAnonymityModel().isActive() && model.getKAnonymityModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getKAnonymityModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolK);
      }
      if (model.getDPresenceModel().isActive() && model.getDPresenceModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getDPresenceModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolD);
      }
      for (      ModelLDiversityCriterion c : model.getLDiversityModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolL);
        }
      }
      for (      ModelTClosenessCriterion c : model.getTClosenessModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolT);
        }
      }
      column1.pack();
      column2.pack();
      column3.pack();
      root.setRedraw(true);
    }
  }
}",0.9880624426078972
108891,"/** 
 * File->export data
 */
public void actionMenuFileExportData(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getOutput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getOutputNode().isAnonymous() != Anonymity.ANONYMOUS) {
    if (!main.showQuestionDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""))) {
      return;
    }
  }
  String file=main.showSaveFileDialog(""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  final WorkerExport worker=new WorkerExport(file,model.getSeparator(),model.getOutput(),model.getOutputConfig().getConfig(),model.getInputBytes());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
}","/** 
 * File->export data
 */
public void actionMenuFileExportData(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (model.getOutput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getOutputNode().isAnonymous() != Anonymity.ANONYMOUS) {
    if (!main.showQuestionDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""))) {
      return;
    }
  }
  String file=main.showSaveFileDialog(""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  final WorkerExport worker=new WorkerExport(file,model.getSeparator(),model.getOutput(),model.getOutputConfig().getConfig(),model.getInputBytes());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
}",0.9927567106945036
108892,"/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    String message=worker.getError().getMessage();
    if (worker.getError() instanceof InvocationTargetException) {
      message=worker.getError().getCause().getMessage();
    }
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + message);
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getHandle(),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getHandle()));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}","/** 
 * Starts the anonymization
 */
public void actionMenuEditAnonymize(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (model.getInputConfig().getInput() == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  if (!model.isValidLatticeSize()) {
    final String message=Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str"")+ Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  if (model.getInputConfig().getResearchSubset().size() == 0) {
    final String message=Resources.getMessage(""String_Node_Str"");
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),message);
    return;
  }
  model.setResult(null);
  model.setOutput(null,null);
  final WorkerAnonymize worker=new WorkerAnonymize(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  model.createClonedConfig();
  if (worker.getError() != null) {
    Throwable t=worker.getError();
    if (worker.getError() instanceof InvocationTargetException) {
      t=worker.getError().getCause();
    }
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + t.getMessage());
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    worker.getError().printStackTrace(pw);
    getResources().getLogger().info(sw.toString());
    return;
  }
  if (worker.getResult() != null) {
    final ARXResult result=worker.getResult();
    model.setResult(result);
    model.getClipboard().clear();
    update(new ModelEvent(this,ModelPart.RESULT,result));
    update(new ModelEvent(this,ModelPart.CLIPBOARD,null));
    if (result.isResultAvailable()) {
      model.setOutput(result.getHandle(),result.getGlobalOptimum());
      model.setSelectedNode(result.getGlobalOptimum());
      update(new ModelEvent(this,ModelPart.OUTPUT,result.getHandle()));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,result.getGlobalOptimum()));
      this.model.getViewConfig().setMode(Mode.GROUPED);
      this.updateViewConfig(true);
      this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
    }
 else {
      model.setOutput(null,null);
      model.setSelectedNode(null);
      model.setGroups(null);
      update(new ModelEvent(this,ModelPart.OUTPUT,null));
      update(new ModelEvent(this,ModelPart.SELECTED_NODE,null));
    }
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,model.getSelectedAttribute()));
  }
}",0.9843612721841504
108893,"/** 
 * Shows an error dialog
 * @param header
 * @param text
 */
public void actionShowErrorDialog(final String header,final String text){
  main.showErrorDialog(header,text);
}","/** 
 * Shows an error dialog
 * @param header
 * @param text
 */
public void actionShowErrorDialog(final String header,final String text,final Throwable t){
  main.showErrorDialog(header,text,t);
}",0.946808510638298
108894,"/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private AttributeType actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
  }
  return null;
}","/** 
 * Internal method for importing hierarchies
 * @param path
 * @param separator
 * @return
 */
private AttributeType actionImportHierarchy(final String path,final char separator){
  try {
    return Hierarchy.create(path,separator);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
  }
  return null;
}",0.976913730255164
108895,"/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path == null) {
    return;
  }
  final DialogSeparator dialog=new DialogSeparator(main.getShell(),this,path,true);
  dialog.create();
  if (dialog.open() == Window.CANCEL) {
    return;
  }
  final WorkerImport worker=new WorkerImport(path,dialog.getSeparator());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage());
  }
}","/** 
 * Creates a research subset from a file
 */
public void actionSubsetFile(){
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path == null) {
    return;
  }
  final DialogSeparator dialog=new DialogSeparator(main.getShell(),this,path,true);
  dialog.create();
  if (dialog.open() == Window.CANCEL) {
    return;
  }
  final WorkerImport worker=new WorkerImport(path,dialog.getSeparator());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getSet());
    model.setSubsetOrigin(""String_Node_Str"");
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset.getSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage(),e);
  }
}",0.9915367483296214
108896,"/** 
 * Shows the ""about"" dialog
 */
public void actionMenuHelpAbout(){
  final DialogAbout dialog=new DialogAbout(main.getShell(),this);
  dialog.create();
  dialog.open();
}","/** 
 * Shows the ""about"" dialog
 */
public void actionMenuHelpAbout(){
  main.showAboutDialog();
}",0.635036496350365
108897,"/** 
 * Internal method for saving a project
 */
private void actionSaveProject(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final WorkerSave worker=new WorkerSave(model.getPath(),this,model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
}","/** 
 * Internal method for saving a project
 */
private void actionSaveProject(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  final WorkerSave worker=new WorkerSave(model.getPath(),this,model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
}",0.9861450692746536
108898,"/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getHandle(tempSelectedNode);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle h=model.getInputConfig().getInput().getHandle();
    if (h != null) {
      if (h.getNumColumns() > 0) {
        String a=h.getAttributeName(0);
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}","/** 
 * Internal method for loading a project
 * @param path
 */
private void actionOpenProject(String path){
  if (!path.endsWith(""String_Node_Str"")) {
    path+=""String_Node_Str"";
  }
  WorkerLoad worker=null;
  try {
    worker=new WorkerLoad(path,this);
  }
 catch (  final IOException e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    return;
  }
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    getResources().getLogger().info(worker.getError());
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  model=worker.getResult();
  model.setPath(path);
  final ModelNodeFilter tempNodeFilter=model.getNodeFilter();
  final String tempSelectedAttribute=model.getSelectedAttribute();
  final ARXNode tempSelectedNode=model.getSelectedNode();
  final Set<ARXNode> tempClipboard=new HashSet<ARXNode>();
  if (model.getClipboard() == null) {
    model.setClipboard(new HashSet<ARXNode>());
  }
 else {
    tempClipboard.addAll(model.getClipboard());
  }
  update(new ModelEvent(this,ModelPart.MODEL,model));
  if (model.getInputConfig().getInput() != null) {
    update(new ModelEvent(this,ModelPart.INPUT,model.getInputConfig().getInput().getHandle()));
  }
  if (model.getResult() != null) {
    update(new ModelEvent(this,ModelPart.RESULT,model.getResult()));
  }
  if (tempSelectedNode != null) {
    model.setSelectedNode(tempSelectedNode);
    update(new ModelEvent(this,ModelPart.SELECTED_NODE,model.getSelectedNode()));
    final DataHandle handle=model.getResult().getHandle(tempSelectedNode);
    model.setOutput(handle,tempSelectedNode);
    update(new ModelEvent(this,ModelPart.OUTPUT,handle));
  }
  if (tempNodeFilter != null) {
    model.setNodeFilter(tempNodeFilter);
    update(new ModelEvent(this,ModelPart.FILTER,tempNodeFilter));
  }
  if (model.getInputConfig() != null && model.getInputConfig().getInput() != null) {
    DataHandle h=model.getInputConfig().getInput().getHandle();
    if (h != null) {
      if (h.getNumColumns() > 0) {
        String a=h.getAttributeName(0);
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
        model.setSelectedAttribute(a);
        update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,a));
      }
    }
  }
  if (tempSelectedAttribute != null) {
    model.setSelectedAttribute(tempSelectedAttribute);
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,tempSelectedAttribute));
  }
  if (tempClipboard != null) {
    model.getClipboard().clear();
    model.getClipboard().addAll(tempClipboard);
    update(new ModelEvent(this,ModelPart.CLIPBOARD,model.getClipboard()));
  }
  if (model.getInputConfig().getInput() != null) {
    final DataHandle handle=model.getInputConfig().getInput().getHandle();
    for (int i=0; i < handle.getNumColumns(); i++) {
      update(new ModelEvent(this,ModelPart.ATTRIBUTE_TYPE,handle.getAttributeName(i)));
    }
  }
  update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,model.getInputConfig().getResearchSubset()));
  if (model.getOutput() != null) {
    update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
  model.setUnmodified();
}",0.994660338178582
108899,"/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(final String path,final char separator){
  final WorkerImport worker=new WorkerImport(path,separator);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  model.setInputBytes(new File(path).length());
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
    definition.setDataType(model.getInputConfig().getInput().getHandle().getAttributeName(i),DataType.STRING);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Internal method for importing data
 * @param path
 * @param separator
 */
private void actionImportData(final String path,final char separator){
  final WorkerImport worker=new WorkerImport(path,separator);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  model.setInputBytes(new File(path).length());
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
    definition.setDataType(model.getInputConfig().getInput().getHandle().getAttributeName(i),DataType.STRING);
  }
  model.resetCriteria();
  model.setGroups(null);
  model.setOutput(null,null);
  model.setViewConfig(new ModelViewConfig());
  update(new ModelEvent(this,ModelPart.MODEL,model));
  update(new ModelEvent(this,ModelPart.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,ModelPart.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.9951580746226146
108900,"/** 
 * Applies the selected transformation
 */
public void actionApplySelectedTransformation(){
  final WorkerTransform worker=new WorkerTransform(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(""String_Node_Str"",Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  if (worker.getResult() != null) {
    this.model.setOutput(worker.getResult(),model.getSelectedNode());
    this.update(new ModelEvent(this,ModelPart.OUTPUT,worker.getResult()));
    this.model.getViewConfig().setMode(Mode.GROUPED);
    this.updateViewConfig(true);
    this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
}","/** 
 * Applies the selected transformation
 */
public void actionApplySelectedTransformation(){
  final WorkerTransform worker=new WorkerTransform(model);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(""String_Node_Str"",Resources.getMessage(""String_Node_Str""),worker.getError());
    return;
  }
  if (worker.getResult() != null) {
    this.model.setOutput(worker.getResult(),model.getSelectedNode());
    this.update(new ModelEvent(this,ModelPart.OUTPUT,worker.getResult()));
    this.model.getViewConfig().setMode(Mode.GROUPED);
    this.updateViewConfig(true);
    this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
  }
}",0.9885829415715244
108901,"/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    Hierarchy h=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
    if (h == null) {
      main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else {
      out.write(h.getHierarchy());
    }
  }
 catch (  final Exception e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
  }
}","/** 
 * File->Export hierarchy
 */
public void actionMenuFileExportHierarchy(){
  if (model == null) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
 else   if (!(model.isQuasiIdentifierSelected() || model.isSensitiveAttributeSelected())) {
    main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    return;
  }
  String file=main.showSaveFileDialog(""String_Node_Str"");
  if (file == null) {
    return;
  }
  if (!file.endsWith(""String_Node_Str"")) {
    file=file + ""String_Node_Str"";
  }
  try {
    final CSVDataOutput out=new CSVDataOutput(file,model.getSeparator());
    Hierarchy h=model.getInputConfig().getHierarchy(model.getSelectedAttribute());
    if (h == null) {
      main.showInfoDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""));
    }
 else {
      out.write(h.getHierarchy());
    }
  }
 catch (  final Exception e) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
  }
}",0.9915367483296214
108902,"public static void main(final String[] args){
  try {
    splash=new Splash();
    splash.setVisible(true);
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    if (splash != null) {
      hideSplash();
    }
    JOptionPane.showMessageDialog(null,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","public static void main(final String[] args){
  try {
    splash=new Splash();
    splash.setVisible(true);
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    if (splash != null) {
      hideSplash();
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.8738461538461538
108903,"public Resources(final Shell shell){
  this.shell=shell;
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  LOGGER.addAppender(consoleAppender);
  LOGGER.setLevel(Level.ALL);
}","public Resources(final Shell shell){
  this.shell=shell;
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  LOGGER.addAppender(consoleAppender);
  LOGGER.setLevel(Level.OFF);
}",0.9981949458483754
108904,"public void show(){
  shell.open();
  while (!shell.isDisposed()) {
    try {
      if (!display.readAndDispatch()) {
        display.sleep();
      }
    }
 catch (    final Exception e) {
      controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage() + Resources.getMessage(""String_Node_Str""));
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      e.printStackTrace(pw);
      controller.getResources().getLogger().info(sw.toString());
    }
  }
  display.dispose();
}","public void show(){
  shell.open();
  while (!shell.isDisposed()) {
    try {
      if (!display.readAndDispatch()) {
        display.sleep();
      }
    }
 catch (    final Exception e) {
      controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + Resources.getMessage(""String_Node_Str""),e);
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      e.printStackTrace(pw);
      controller.getResources().getLogger().info(sw.toString());
    }
  }
  display.dispose();
}",0.983406113537118
108905,"public void showErrorDialog(final String header,final String text){
  MessageDialog.openError(getShell(),header,text);
}","public void showErrorDialog(final String header,final String message,final Throwable t){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  t.printStackTrace(pw);
  final String trace=sw.toString();
  showErrorDialog(header,message,trace);
}",0.4329896907216495
108906,"public Splash() throws IOException {
  this.setSize(new Dimension(400,240));
  this.setLocationRelativeTo(null);
  this.setAlwaysOnTop(true);
  this.setAutoRequestFocus(true);
  this.setUndecorated(true);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      repaint();
    }
  }
);
}","public Splash() throws IOException {
  this.setSize(new Dimension(400,240));
  this.setLocationRelativeTo(null);
  this.setAlwaysOnTop(true);
  this.setAutoRequestFocus(true);
  this.setUndecorated(true);
  this.setBackground(Color.WHITE);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      repaint();
    }
  }
);
}",0.9528936742934052
108907,"@Override protected Control createDialogArea(final Composite parent){
  Composite compTools=new Composite(parent,SWT.NONE);
  compTools.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  compTools.setLayout(new GridLayout(1,false));
  ToolBar navBar=new ToolBar(compTools,SWT.NONE);
  navBar.setLayoutData(new GridData(GridData.FILL_HORIZONTAL | GridData.HORIZONTAL_ALIGN_END));
  final ToolItem back=new ToolItem(navBar,SWT.PUSH);
  back.setText(""String_Node_Str"");
  back.setEnabled(false);
  final ToolItem forward=new ToolItem(navBar,SWT.PUSH);
  forward.setText(""String_Node_Str"");
  forward.setEnabled(false);
  Composite comp=new Composite(parent,SWT.NONE);
  comp.setLayoutData(SWTUtil.createFillGridData());
  comp.setLayout(new FillLayout());
  final SashForm form=new SashForm(comp,SWT.HORIZONTAL);
  form.setLayout(new FillLayout());
  list=new List(form,SWT.SINGLE);
  try {
    browser=new Browser(form,SWT.NONE);
  }
 catch (  SWTError e) {
    controller.actionShowErrorDialog(""String_Node_Str"",""String_Node_Str"");
    this.close();
  }
  for (  Entry entry : config.getEntries()) {
    list.add(entry.title);
  }
  form.setWeights(new int[]{25,75});
  back.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      browser.back();
    }
  }
);
  forward.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      browser.forward();
    }
  }
);
  browser.addLocationListener(new LocationAdapter(){
    public void changed(    LocationEvent event){
      Browser browser=(Browser)event.widget;
      back.setEnabled(browser.isBackEnabled());
      forward.setEnabled(browser.isForwardEnabled());
      list.select(getIndexOf(event.location));
    }
  }
);
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      browser.setUrl(getUrlOf(list.getSelectionIndex()));
    }
  }
);
  int index=id == null ? 0 : config.getIndexForId(id);
  list.select(index);
  browser.setUrl(getUrlOf(index));
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  Composite compTools=new Composite(parent,SWT.NONE);
  compTools.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  compTools.setLayout(new GridLayout(1,false));
  ToolBar navBar=new ToolBar(compTools,SWT.NONE);
  navBar.setLayoutData(new GridData(GridData.FILL_HORIZONTAL | GridData.HORIZONTAL_ALIGN_END));
  final ToolItem back=new ToolItem(navBar,SWT.PUSH);
  back.setText(""String_Node_Str"");
  back.setEnabled(false);
  final ToolItem forward=new ToolItem(navBar,SWT.PUSH);
  forward.setText(""String_Node_Str"");
  forward.setEnabled(false);
  Composite comp=new Composite(parent,SWT.NONE);
  comp.setLayoutData(SWTUtil.createFillGridData());
  comp.setLayout(new FillLayout());
  final SashForm form=new SashForm(comp,SWT.HORIZONTAL);
  form.setLayout(new FillLayout());
  list=new List(form,SWT.SINGLE);
  try {
    browser=new Browser(form,SWT.BORDER);
  }
 catch (  SWTError e) {
    throw new RuntimeException(e);
  }
  for (  Entry entry : config.getEntries()) {
    list.add(entry.title);
  }
  form.setWeights(new int[]{25,75});
  back.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      browser.back();
    }
  }
);
  forward.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      browser.forward();
    }
  }
);
  browser.addLocationListener(new LocationAdapter(){
    public void changed(    LocationEvent event){
      Browser browser=(Browser)event.widget;
      back.setEnabled(browser.isBackEnabled());
      forward.setEnabled(browser.isForwardEnabled());
      list.select(getIndexOf(event.location));
    }
  }
);
  list.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent arg0){
      browser.setUrl(getUrlOf(list.getSelectionIndex()));
    }
  }
);
  int index=id == null ? 0 : config.getIndexForId(id);
  list.select(index);
  browser.setUrl(getUrlOf(index));
  return parent;
}",0.970486965076242
108908,"@Override public void widgetSelected(final SelectionEvent arg0){
  try {
    if (combo.getSelectionIndex() == -1) {
      return;
    }
    selection=combo.getSelectionIndex();
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
    close();
  }
}","@Override public void widgetSelected(final SelectionEvent arg0){
  try {
    if (combo.getSelectionIndex() == -1) {
      return;
    }
    selection=combo.getSelectionIndex();
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
  }
}",0.9746328437917224
108909,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
    close();
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + e.getMessage());
        close();
      }
    }
  }
);
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  final GridLayout l=new GridLayout();
  l.numColumns=2;
  parent.setLayout(l);
  table=new Table(parent,SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
  GridData d=SWTUtil.createFillGridData();
  d.horizontalSpan=2;
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  table.setLayoutData(d);
  table.setHeaderVisible(true);
  table.setLinesVisible(true);
  try {
    detect(file);
    read(file);
  }
 catch (  final Exception e) {
    controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
    close();
  }
  final Combo combo=new Combo(parent,SWT.NONE);
  d=SWTUtil.createFillHorizontallyGridData();
  d.horizontalSpan=2;
  combo.setLayoutData(d);
  for (  final String s : labels) {
    combo.add(s);
  }
  combo.select(selection);
  combo.pack();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      try {
        if (combo.getSelectionIndex() == -1) {
          return;
        }
        selection=combo.getSelectionIndex();
        read(file);
      }
 catch (      final Exception e) {
        controller.actionShowErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),e);
        close();
      }
    }
  }
);
  return parent;
}",0.9869415807560138
108910,"/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  return dvals;
}","/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  return dvals;
}",0.967144840351689
108911,"private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}","private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    try {
      Arrays.sort(v,new Comparator<String>(){
        @Override public int compare(        final String arg0,        final String arg1){
          try {
            return dtype.compare(arg0,arg1);
          }
 catch (          final Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
);
    }
 catch (    Exception e) {
      controller.getResources().getLogger().warn(""String_Node_Str"");
    }
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}",0.9744420446364292
108912,"/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (config.isProtectSensitiveAssociations() && config.isPracticalMonotonicity() && data.getDefinition().getSensitiveAttributes().size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(data,config);
  DataHandle handle=data.getHandle();
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    DataDefinition definition=handle.getDefinition().clone();
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    DataDefinition currentDefinition=null;
    DataDefinition previousDefinition=handle.getDefinition();
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      ARXConfiguration currentConfig=config.clone();
      previousDefinition=currentDefinition;
      currentDefinition=handle.getDefinition().clone();
      for (      LDiversity c : currentConfig.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : currentConfig.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        int numAnonymous=alterLattice(result.lattice,config,((DataHandleInput)handle).header,previousDefinition,currentDefinition);
        lattice=result.lattice;
        algorithm=result.algorithm;
        if (numAnonymous == 0) {
          break;
        }
      }
      result=anonymizeInternal(handle,currentDefinition,currentConfig,lattice,sensitive.size(),algorithm,null);
    }
    if (config.isProtectSensitiveAssociations()) {
      DataDefinition finalDefinition=createFinalDefinition(definition);
      ARXConfiguration finalConfig=createFinalConfig(config);
      LatticeManipulator finalManipulator=createFinalManipulator(result.lattice,config,((DataHandleInput)handle).header,currentDefinition,definition);
      result=anonymizeInternal(handle,finalDefinition,finalConfig,null,1,null,finalManipulator);
    }
    return result.asResult(config,handle,time);
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}","/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (config.getMaxOutliers() > 0d && data.getDefinition().getSensitiveAttributes().size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(data,config);
  DataHandle handle=data.getHandle();
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    DataDefinition definition=handle.getDefinition().clone();
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    DataDefinition currentDefinition=null;
    DataDefinition previousDefinition=handle.getDefinition();
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      ARXConfiguration currentConfig=config.clone();
      previousDefinition=currentDefinition;
      currentDefinition=handle.getDefinition().clone();
      for (      LDiversity c : currentConfig.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : currentConfig.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        int numAnonymous=alterLattice(result.lattice,config,((DataHandleInput)handle).header,previousDefinition,currentDefinition);
        lattice=result.lattice;
        algorithm=result.algorithm;
        if (numAnonymous == 0) {
          break;
        }
      }
      result=anonymizeInternal(handle,currentDefinition,currentConfig,lattice,sensitive.size(),algorithm,null);
    }
    if (config.isProtectSensitiveAssociations()) {
      DataDefinition finalDefinition=createFinalDefinition(definition);
      ARXConfiguration finalConfig=createFinalConfig(config);
      LatticeManipulator finalManipulator=createFinalManipulator(result.lattice,config,((DataHandleInput)handle).header,currentDefinition,definition);
      result=anonymizeInternal(handle,finalDefinition,finalConfig,null,1,null,finalManipulator);
    }
    return result.asResult(config,handle,time);
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}",0.9858651502843216
108913,"/** 
 * Instantiates a new ARX result.
 * @param manager The data manager
 * @param checker The node checker
 * @param time The elapsed wall-clock  time
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param lattice The lattice
 * @param practicalMonotonicity Do we assume practical monotonicity
 * @param removeOutliers Do we remove outliers
 * @param maximumAbsoluteOutliers The maximum number of outliers
 * @param config The configuration
 * @param projection A projection mask for results of iterative executions.projection[i] must contain true if the ith QI is to be preserved
 */
public DataHandleOutput(final DataRegistry registry,final DataManager manager,final INodeChecker checker,final long time,final String suppressionString,final DataDefinition definition,final Lattice lattice,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(this);
  this.setRegistry(registry);
  final ARXLattice flattice=new ARXLattice(lattice,manager.getDataQI().getHeader(),config);
  init(manager,checker,time,suppressionString,definition,flattice,removeOutliers,config);
}","/** 
 * Instantiates a new ARX result.
 * @param manager The data manager
 * @param checker The node checker
 * @param time The elapsed wall-clock  time
 * @param suppressionString The suppression string
 * @param definition The data definition
 * @param lattice The lattice
 * @param practicalMonotonicity Do we assume practical monotonicity
 * @param removeOutliers Do we remove outliers
 * @param maximumAbsoluteOutliers The maximum number of outliers
 * @param config The configuration
 * @param projection A projection mask for results of iterative executions.projection[i] must contain true if the ith QI is to be preserved
 */
public DataHandleOutput(final DataRegistry registry,final DataManager manager,final INodeChecker checker,final long time,final String suppressionString,final DataDefinition definition,final Lattice lattice,final boolean removeOutliers,final ARXConfiguration config){
  registry.updateOutput(this);
  this.setRegistry(registry);
  this.source=checker.getData();
  final ARXLattice flattice=new ARXLattice(lattice,manager.getDataQI().getHeader(),config);
  init(manager,checker,time,suppressionString,definition,flattice,removeOutliers,config);
}",0.9857942315970728
108914,"/** 
 * Swap internal.
 * @param row1 the row1
 * @param row2 the row2
 */
protected void internalSwap(final int row1,final int row2){
  getHandle(currentNode);
  int[] temp=dataQI.getArray()[row1];
  dataQI.getArray()[row1]=dataQI.getArray()[row2];
  dataQI.getArray()[row2]=temp;
  temp=dataSE.getArray()[row1];
  dataSE.getArray()[row1]=dataSE.getArray()[row2];
  dataSE.getArray()[row2]=temp;
  temp=dataIS.getArray()[row1];
  dataIS.getArray()[row1]=dataIS.getArray()[row2];
  dataIS.getArray()[row2]=temp;
}","/** 
 * Swap internal.
 * @param row1 the row1
 * @param row2 the row2
 */
protected void internalSwap(final int row1,final int row2){
  getHandle(currentNode);
  int[] temp=dataQI.getArray()[row1];
  dataQI.getArray()[row1]=dataQI.getArray()[row2];
  dataQI.getArray()[row2]=temp;
  temp=dataSE.getArray()[row1];
  dataSE.getArray()[row1]=dataSE.getArray()[row2];
  dataSE.getArray()[row2]=temp;
  temp=dataIS.getArray()[row1];
  dataIS.getArray()[row1]=dataIS.getArray()[row2];
  dataIS.getArray()[row2]=temp;
  temp=source.getArray()[row1];
  source.getArray()[row1]=source.getArray()[row2];
  source.getArray()[row2]=temp;
}",0.8992112182296231
108915,"@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(true,0,1,2);
  String[][] given=iteratorToArray(data.getHandle().getView().iterator());
  printArray(given);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getHandle(n);
  String[][] given2=iteratorToArray(h.getView().iterator());
  printArray(given2);
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given2,expected));
}","@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(true,0,1,2);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getHandle(n);
  String[][] given=iteratorToArray(h.getView().iterator());
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}",0.9568655643421998
108916,"/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  int level=0;
  for (  int i : fnode.getTransformation())   level+=i;
  node.setTransformation(fnode.getTransformation(),level);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (config.isPracticalMonotonicity()) {
      if (node.isAnonymous()) {
        currentNode.access().setAnonymous();
      }
 else {
        currentNode.access().setNotAnonymous();
      }
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}","/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  int level=0;
  for (  int i : fnode.getTransformation())   level+=i;
  node.setTransformation(fnode.getTransformation(),level);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (definition.getSensitiveAttributes().size() <= 1) {
      if (node.isAnonymous()) {
        currentNode.access().setAnonymous();
      }
 else {
        currentNode.access().setNotAnonymous();
      }
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}",0.962457337883959
108917,"/** 
 * Initializer
 * @param manager
 * @param checker
 * @param time
 * @param suppressionString
 * @param defintion
 * @param lattice
 * @param removeOutliers
 * @param config
 */
private void init(final DataManager manager,final INodeChecker checker,final long time,final String suppressionString,final DataDefinition defintion,final ARXLattice lattice,final boolean removeOutliers,final ARXConfiguration config){
  this.config=config;
  this.removeOutliers=removeOutliers;
  this.lattice=lattice;
  this.optimalNode=this.lattice.getOptimum();
  this.duration=time;
  this.currentNode=optimalNode;
  this.lastNode=null;
  this.suppressionString=suppressionString;
  this.checker=checker;
  this.definition=defintion;
  dataQI=checker.getBuffer();
  dataSE=manager.getDataSE();
  dataIS=manager.getDataIS();
  super.header=manager.getHeader();
  final GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  quasiIdentifiers=new String[hierarchies.length];
  map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    quasiIdentifiers[i]=hierarchies[i].getName();
    map[i]=hierarchies[i].getArray();
  }
  inverseMap=new int[header.length];
  for (int i=0; i < inverseMap.length; i++) {
    inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < dataQI.getMap().length; i++) {
    inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < dataSE.getMap().length; i++) {
    inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  inverseData=new int[3][][];
  inverseData[AttributeType.ATTR_TYPE_IS]=dataIS.getArray();
  inverseData[AttributeType.ATTR_TYPE_SE]=dataSE.getArray();
  inverseData[AttributeType.ATTR_TYPE_QI]=dataQI.getArray();
  inverseDictionaries=new Dictionary[3];
  inverseDictionaries[AttributeType.ATTR_TYPE_IS]=dataIS.getDictionary();
  inverseDictionaries[AttributeType.ATTR_TYPE_SE]=dataSE.getDictionary();
  inverseDictionaries[AttributeType.ATTR_TYPE_QI]=dataQI.getDictionary();
  this.getRegistry().createOutputSubset(config);
}","/** 
 * Initializer
 * @param manager
 * @param checker
 * @param time
 * @param suppressionString
 * @param defintion
 * @param lattice
 * @param removeOutliers
 * @param config
 */
private void init(final DataManager manager,final INodeChecker checker,final long time,final String suppressionString,final DataDefinition defintion,final ARXLattice lattice,final boolean removeOutliers,final ARXConfiguration config){
  this.removeOutliers=removeOutliers;
  this.lattice=lattice;
  this.optimalNode=this.lattice.getOptimum();
  this.duration=time;
  this.currentNode=optimalNode;
  this.lastNode=null;
  this.suppressionString=suppressionString;
  this.checker=checker;
  this.definition=defintion;
  dataQI=checker.getBuffer();
  dataSE=manager.getDataSE();
  dataIS=manager.getDataIS();
  super.header=manager.getHeader();
  final GeneralizationHierarchy[] hierarchies=manager.getHierarchies();
  quasiIdentifiers=new String[hierarchies.length];
  map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    quasiIdentifiers[i]=hierarchies[i].getName();
    map[i]=hierarchies[i].getArray();
  }
  inverseMap=new int[header.length];
  for (int i=0; i < inverseMap.length; i++) {
    inverseMap[i]=(AttributeType.ATTR_TYPE_ID << AttributeType.SHIFT);
  }
  for (int i=0; i < dataQI.getMap().length; i++) {
    inverseMap[dataQI.getMap()[i]]=i | (AttributeType.ATTR_TYPE_QI << AttributeType.SHIFT);
  }
  for (int i=0; i < dataSE.getMap().length; i++) {
    inverseMap[dataSE.getMap()[i]]=i | (AttributeType.ATTR_TYPE_SE << AttributeType.SHIFT);
  }
  for (int i=0; i < dataIS.getMap().length; i++) {
    inverseMap[dataIS.getMap()[i]]=i | (AttributeType.ATTR_TYPE_IS << AttributeType.SHIFT);
  }
  inverseData=new int[3][][];
  inverseData[AttributeType.ATTR_TYPE_IS]=dataIS.getArray();
  inverseData[AttributeType.ATTR_TYPE_SE]=dataSE.getArray();
  inverseData[AttributeType.ATTR_TYPE_QI]=dataQI.getArray();
  inverseDictionaries=new Dictionary[3];
  inverseDictionaries[AttributeType.ATTR_TYPE_IS]=dataIS.getDictionary();
  inverseDictionaries[AttributeType.ATTR_TYPE_SE]=dataSE.getDictionary();
  inverseDictionaries[AttributeType.ATTR_TYPE_QI]=dataQI.getDictionary();
  this.getRegistry().createOutputSubset(config);
}",0.9951370468611848
108918,"@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),8);
  try {
    final ZipFile zip=zipfile;
    readMetadata(zip);
    arg0.worked(1);
    readModel(zip);
    arg0.worked(2);
    final Map<String,ARXNode> map=readLattice(zip);
    arg0.worked(3);
    readClipboard(map,zip);
    arg0.worked(4);
    readFilter(zip);
    arg0.worked(5);
    readConfiguration(map,zip);
    arg0.worked(6);
    zip.close();
    arg0.worked(7);
  }
 catch (  final Exception e) {
    error=e;
    arg0.done();
    return;
  }
  result=model;
  arg0.worked(8);
  arg0.done();
}","@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),8);
  try {
    final ZipFile zip=zipfile;
    readMetadata(zip);
    arg0.worked(1);
    readModel(zip);
    arg0.worked(2);
    final Map<String,ARXNode> map=readLattice(zip);
    arg0.worked(3);
    readClipboard(map,zip);
    arg0.worked(4);
    readFilter(zip);
    arg0.worked(5);
    readConfiguration(map,zip);
    arg0.worked(6);
    zip.close();
    arg0.worked(7);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    error=e;
    arg0.done();
    return;
  }
  result=model;
  arg0.worked(8);
  arg0.done();
}",0.9818445896877268
108919,"@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(true,0,1,2);
  String[][] given=iteratorToArray(data.getHandle().getView().iterator());
  printArray(given);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getHandle(n);
  String[][] given2=iteratorToArray(h.getView().iterator());
  printArray(given2);
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given,expected));
}","@Test public void testSubset5() throws IllegalArgumentException, IOException {
  Data data=Data.create(""String_Node_Str"",';');
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",Hierarchy.create(""String_Node_Str"",';'));
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  DataSubset subset=DataSubset.create(data,selector);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=ARXConfiguration.create();
  config.addCriterion(new Inclusion(subset));
  ARXResult result=anonymizer.anonymize(data,config);
  data.getHandle().sort(true,0,1,2);
  String[][] given=iteratorToArray(data.getHandle().getView().iterator());
  printArray(given);
  ARXNode n=result.getLattice().getLevels()[2][1];
  DataHandle h=result.getHandle(n);
  String[][] given2=iteratorToArray(h.getView().iterator());
  printArray(given2);
  String[][] expected={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  assertTrue(Arrays.deepEquals(given2,expected));
}",0.9996552912788692
108920,"public static void main(final String[] args){
  try {
    splash=new Splash();
    splash.setVisible(true);
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    if (splash != null) {
      hideSplash();
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}","public static void main(final String[] args){
  try {
    splash=new MainSplash();
    splash.setVisible(true);
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MainWindow main=new MainWindow();
    main.addShellListener(new ShellAdapter(){
      @Override public void shellActivated(      ShellEvent arg0){
        hideSplash();
      }
    }
);
    main.show();
  }
 catch (  Throwable e) {
    if (splash != null) {
      hideSplash();
    }
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    e.printStackTrace(pw);
    final String trace=sw.toString();
    JOptionPane.showMessageDialog(null,trace,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(1);
  }
}",0.9972222222222222
108921,"/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (config.isProtectSensitiveAssociations() && config.isPracticalMonotonicity() && data.getDefinition().getSensitiveAttributes().size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(data,config);
  DataHandle handle=data.getHandle();
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    DataDefinition currentDefinition=null;
    DataDefinition previousDefinition=handle.getDefinition();
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      ARXConfiguration currentConfig=config.clone();
      previousDefinition=currentDefinition;
      currentDefinition=handle.getDefinition().clone();
      for (      LDiversity c : currentConfig.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : currentConfig.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        int numAnonymous=alterLattice(result.lattice,config,((DataHandleInput)handle).header,previousDefinition,currentDefinition);
        lattice=result.lattice;
        algorithm=result.algorithm;
        if (numAnonymous == 0) {
          break;
        }
      }
      result=anonymizeInternal(handle,currentDefinition,currentConfig,lattice,sensitive.size(),algorithm);
    }
    return result.asResult(config,handle,time);
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}","/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  if (config.isProtectSensitiveAssociations() && config.isPracticalMonotonicity() && data.getDefinition().getSensitiveAttributes().size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final long time=System.currentTimeMillis();
  checkBeforeEncoding(data,config);
  DataHandle handle=data.getHandle();
  handle.getRegistry().reset();
  handle.getRegistry().createInputSubset(config);
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    DataDefinition definition=handle.getDefinition().clone();
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    DataDefinition currentDefinition=null;
    DataDefinition previousDefinition=handle.getDefinition();
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      ARXConfiguration currentConfig=config.clone();
      previousDefinition=currentDefinition;
      currentDefinition=handle.getDefinition().clone();
      for (      LDiversity c : currentConfig.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : currentConfig.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          currentConfig.removeCriterion(c);
          currentDefinition.setAttributeType(c.getAttribute(),substition);
        }
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        int numAnonymous=alterLattice(result.lattice,config,((DataHandleInput)handle).header,previousDefinition,currentDefinition);
        lattice=result.lattice;
        algorithm=result.algorithm;
        if (numAnonymous == 0) {
          break;
        }
      }
      result=anonymizeInternal(handle,currentDefinition,currentConfig,lattice,sensitive.size(),algorithm,null);
    }
    if (config.isProtectSensitiveAssociations()) {
      DataDefinition finalDefinition=createFinalDefinition(definition);
      ARXConfiguration finalConfig=createFinalConfig(config);
      LatticeManipulator finalManipulator=createFinalManipulator(result.lattice,config,((DataHandleInput)handle).header,currentDefinition,definition);
      result=anonymizeInternal(handle,finalDefinition,finalConfig,null,1,null,finalManipulator);
    }
    return result.asResult(config,handle,time);
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}",0.9111657303370788
108922,"/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  }
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  checker.getHistory().reset();
  checker.getHistory().setSize(0);
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}","/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm,LatticeManipulator manipulator) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
    if (manipulator != null) {
      for (      Node[] level : lattice.getLevels()) {
        for (        Node node : level) {
          manipulator.process(lattice,node);
        }
      }
    }
  }
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  checker.getHistory().reset();
  checker.getHistory().setSize(0);
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}",0.9227642276422764
108923,"/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  int level=0;
  for (  int i : fnode.getTransformation())   level+=i;
  node.setTransformation(fnode.getTransformation(),level);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (node.isAnonymous()) {
      currentNode.access().setAnonymous();
    }
 else {
      currentNode.access().setNotAnonymous();
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}","/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  int level=0;
  for (  int i : fnode.getTransformation())   level+=i;
  node.setTransformation(fnode.getTransformation(),level);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (config.isPracticalMonotonicity()) {
      if (node.isAnonymous()) {
        currentNode.access().setAnonymous();
      }
 else {
        currentNode.access().setNotAnonymous();
      }
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}",0.9696356275303644
108924,"/** 
 * Checks the bottom node
 */
protected void checkBottom(){
  for (  final Node[] level : lattice.getLevels()) {
    if (level.length != 0) {
      if (level.length == 1) {
        checker.check(level[0]);
        break;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Checks the bottom node
 */
protected void checkBottom(){
  for (  final Node[] level : lattice.getLevels()) {
    if (level.length != 0) {
      if (level.length == 1) {
        Node node=level[0];
        if (!node.isChecked())         checker.check(level[0]);
        break;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}",0.874095513748191
108925,"@Override public void paint(final Graphics g){
  final Graphics bg=buffer.getGraphics();
  if (model != null) {
    draw(bg);
  }
 else {
    bg.setColor(Color.WHITE);
    bg.fillRect(0,0,buffer.getWidth(),buffer.getHeight());
  }
  bg.dispose();
  g.drawImage(buffer,0,0,this);
}","@Override public void paint(final Graphics g){
  if (buffer != null) {
    final Graphics bg=buffer.getGraphics();
    if (model != null) {
      draw(bg);
    }
 else {
      bg.setColor(Color.WHITE);
      bg.fillRect(0,0,buffer.getWidth(),buffer.getHeight());
    }
    bg.dispose();
    g.drawImage(buffer,0,0,this);
  }
}",0.7095709570957096
108926,"public Resources(final Shell shell){
  this.shell=shell;
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  LOGGER.addAppender(consoleAppender);
  LOGGER.setLevel(Level.INFO);
}","public Resources(final Shell shell){
  this.shell=shell;
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  DATE_FORMATS.add(this.getFormat(""String_Node_Str""));
  SimpleLayout layout=new SimpleLayout();
  ConsoleAppender consoleAppender=new ConsoleAppender(layout);
  LOGGER.addAppender(consoleAppender);
  LOGGER.setLevel(Level.ALL);
}",0.9978947368421052
108927,"public ARXConfiguration createSubsetConfig(){
  ARXConfiguration config=ARXConfiguration.create();
  DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
  config.addCriterion(new Enclosure(subset));
  return config;
}","public ARXConfiguration createSubsetConfig(){
  ARXConfiguration config=ARXConfiguration.create();
  DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
  config.addCriterion(new Inclusion(subset));
  return config;
}",0.9776119402985076
108928,"public void createCriteria(ModelConfiguration config){
  config.removeAllCriteria();
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
    config.addCriterion(new Enclosure(subset));
  }
}","public void createCriteria(ModelConfiguration config){
  config.removeAllCriteria();
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    config.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    config.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      config.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!config.containsCriterion(DPresence.class)) {
    DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
    config.addCriterion(new Inclusion(subset));
  }
}",0.9923664122137404
108929,"@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input.clone();
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  c.researchSubset=researchSubset;
  return c;
}","@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input.clone();
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  c.researchSubset=this.getCriterion(DPresence.class).getSubset().getSet();
  return c;
}",0.9096671949286846
108930,"/** 
 * Constructor
 * @param path
 * @param controller
 * @throws IOException
 */
public WorkerLoad(final String path,final Controller controller) throws IOException {
  zipfile=new ZipFile(path);
  this.controller=controller;
}","/** 
 * Constructor
 * @param path
 * @param controller
 * @throws IOException
 */
public WorkerLoad(final String path,final Controller controller) throws IOException {
  this.zipfile=new ZipFile(path);
  this.controller=controller;
}",0.9892008639308856
108931,"@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),10);
  try {
    final FileOutputStream f=new FileOutputStream(path);
    final ZipOutputStream zip=new ZipOutputStream(new BufferedOutputStream(f));
    writeMetadata(model,zip);
    arg0.worked(1);
    writeModel(model,zip);
    arg0.worked(2);
    writeInput(model,zip);
    arg0.worked(3);
    writeInputSubset(model,zip);
    arg0.worked(4);
    writeOutput(model,zip);
    arg0.worked(5);
    writeOutputSubset(model,zip);
    arg0.worked(6);
    writeConfiguration(model,zip);
    arg0.worked(7);
    final Map<String,Integer> map=writeLattice(model,zip);
    arg0.worked(8);
    writeClipboard(model,map,zip);
    arg0.worked(9);
    writeFilter(model,zip);
    zip.close();
    arg0.worked(10);
  }
 catch (  final Exception e) {
    error=e;
    arg0.done();
    return;
  }
  arg0.worked(100);
  arg0.done();
}","@Override public void run(final IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  arg0.beginTask(Resources.getMessage(""String_Node_Str""),10);
  try {
    final FileOutputStream f=new FileOutputStream(path);
    final ZipOutputStream zip=new ZipOutputStream(new BufferedOutputStream(f));
    writeMetadata(model,zip);
    arg0.worked(1);
    writeModel(model,zip);
    arg0.worked(2);
    writeInput(model,zip);
    arg0.worked(4);
    writeOutput(model,zip);
    arg0.worked(5);
    writeOutputSubset(model,zip);
    arg0.worked(6);
    writeConfiguration(model,zip);
    arg0.worked(7);
    final Map<String,Integer> map=writeLattice(model,zip);
    arg0.worked(8);
    writeClipboard(model,map,zip);
    arg0.worked(9);
    writeFilter(model,zip);
    zip.close();
    arg0.worked(10);
  }
 catch (  final Exception e) {
    error=e;
    arg0.done();
    return;
  }
  arg0.worked(100);
  arg0.done();
}",0.9724961079398028
108932,"/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput().clone(false));
    model.setOutputConfig(config);
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new DataHandleOutput(config.getInput().getHandle(),config.getInput().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}","/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput());
    model.setOutputConfig(config);
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new DataHandleOutput(config.getInput().getHandle(),config.getInput().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}",0.9971609521729636
108933,"/** 
 * Returns the respective data handle
 * @return
 */
private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}","/** 
 * Returns the respective data handle
 * @return
 */
private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}",0.7704918032786885
108934,"private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}","private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data=getHandle();
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}",0.980257199782648
108935,"public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=4;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(COMBO2_VALUES);
  dataTypeCombo.select(0);
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          DataType<?> type=COMBO2_TYPES[dataTypeCombo.getSelectionIndex()];
          if (type == DataType.DATE) {
            final String format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),getValues());
            if (format == null) {
              type=DataType.STRING;
              dataTypeCombo.select(0);
            }
 else {
              type=DataType.DATE(format);
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}","public ViewAttributeDefinition(final CTabFolder parent,final String attribute,final Controller controller){
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  this.controller=controller;
  this.attribute=attribute;
  this.controller.addListener(ModelPart.MODEL,this);
  this.controller.addListener(ModelPart.INPUT,this);
  this.controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  tab=new CTabItem(parent,SWT.NULL);
  tab.setText(attribute);
  tab.setShowClose(false);
  tab.setImage(IMAGE_INSENSITIVE);
  Composite group=new Composite(parent,SWT.NULL);
  group.setLayoutData(SWTUtil.createFillGridData());
  final GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=1;
  group.setLayout(groupInputGridLayout);
  final Composite type=new Composite(group,SWT.NULL);
  type.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout typeInputGridLayout=new GridLayout();
  typeInputGridLayout.numColumns=4;
  type.setLayout(typeInputGridLayout);
  final IView outer=this;
  final Label kLabel=new Label(type,SWT.PUSH);
  kLabel.setText(Resources.getMessage(""String_Node_Str""));
  typeCombo=new Combo(type,SWT.READ_ONLY);
  typeCombo.setLayoutData(SWTUtil.createFillGridData());
  typeCombo.setItems(COMBO1_VALUES);
  typeCombo.select(0);
  typeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((typeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          final AttributeType type=COMBO1_TYPES[typeCombo.getSelectionIndex()];
          final DataDefinition definition=model.getInputConfig().getInput().getDefinition();
          if (type == null) {
            definition.setAttributeType(attribute,Hierarchy.create());
          }
 else {
            definition.setAttributeType(attribute,type);
          }
          boolean criteriaDisabled=false;
          if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
            model.getLDiversityModel().get(attribute).setActive(true);
            model.getTClosenessModel().get(attribute).setActive(true);
          }
 else {
            if (model.getLDiversityModel().get(attribute).isEnabled() || model.getTClosenessModel().get(attribute).isEnabled()) {
              criteriaDisabled=true;
            }
            model.getLDiversityModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setActive(false);
            model.getTClosenessModel().get(attribute).setEnabled(false);
            model.getLDiversityModel().get(attribute).setEnabled(false);
          }
          if (definition.getQuasiIdentifyingAttributes().isEmpty()) {
            if (model.getKAnonymityModel().isEnabled() || model.getDPresenceModel().isEnabled()) {
              criteriaDisabled=true;
            }
            model.getKAnonymityModel().setActive(false);
            model.getDPresenceModel().setActive(false);
            model.getKAnonymityModel().setEnabled(false);
            model.getDPresenceModel().setEnabled(false);
          }
 else {
            model.getKAnonymityModel().setActive(true);
            model.getDPresenceModel().setActive(true);
          }
          updateIcon();
          if (criteriaDisabled) {
            controller.update(new ModelEvent(outer,ModelPart.CRITERION_DEFINITION,null));
          }
          controller.update(new ModelEvent(outer,ModelPart.ATTRIBUTE_TYPE,attribute));
        }
      }
    }
  }
);
  final Label kLabel2=new Label(type,SWT.PUSH);
  kLabel2.setText(Resources.getMessage(""String_Node_Str""));
  dataTypeCombo=new Combo(type,SWT.READ_ONLY);
  dataTypeCombo.setLayoutData(SWTUtil.createFillGridData());
  dataTypeCombo.setItems(COMBO2_VALUES);
  dataTypeCombo.select(0);
  dataTypeCombo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if ((dataTypeCombo.getSelectionIndex() != -1) && (attribute != null)) {
        if ((model != null) && (model.getInputConfig().getInput() != null)) {
          DataType<?> type=COMBO2_TYPES[dataTypeCombo.getSelectionIndex()];
          if (type == DataType.DATE) {
            final String format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),getValues());
            if (format == null) {
              type=DataType.STRING;
              dataTypeCombo.select(0);
            }
 else {
              type=DataType.DATE(format);
            }
          }
          model.getInputConfig().getInput().getDefinition().setDataType(attribute,type);
          controller.update(new ModelEvent(outer,ModelPart.DATA_TYPE,attribute));
        }
      }
    }
  }
);
  editor=new ViewHierarchy(group,attribute,controller);
  tab.setControl(group);
}",0.8754396854955514
108936,"@Override public void reset(){
  sliderL.setSelection(0);
  sliderC.setSelection(0);
  labelC.setText(""String_Node_Str"");
  labelL.setText(""String_Node_Str"");
  comboVariant.select(0);
  super.reset();
}","@Override public void reset(){
  sliderL.setSelection(0);
  sliderC.setSelection(0);
  sliderC.setEnabled(false);
  labelC.setText(""String_Node_Str"");
  labelL.setText(""String_Node_Str"");
  comboVariant.select(0);
  super.reset();
}",0.9333333333333332
108937,"@Override protected void parse(){
  ModelLDiversityCriterion m=model.getLDiversityModel().get(attribute);
  if (m == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  labelC.setText(String.valueOf(m.getC()));
  labelL.setText(String.valueOf(m.getL()));
  sliderL.setSelection(intToSlider(2,100,m.getL()));
  sliderC.setSelection(doubleToSlider(0.001d,100d,m.getC()));
  comboVariant.select(m.getVariant());
  if (m.isActive() && m.isEnabled()) {
    SWTUtil.enable(root);
  }
 else {
    SWTUtil.disable(root);
  }
  root.setRedraw(true);
}","@Override protected void parse(){
  ModelLDiversityCriterion m=model.getLDiversityModel().get(attribute);
  if (m == null) {
    reset();
    return;
  }
  root.setRedraw(false);
  labelC.setText(String.valueOf(m.getC()));
  labelL.setText(String.valueOf(m.getL()));
  sliderL.setSelection(intToSlider(2,100,m.getL()));
  sliderC.setSelection(doubleToSlider(0.001d,100d,m.getC()));
  comboVariant.select(m.getVariant());
  if (m.isActive() && m.isEnabled()) {
    SWTUtil.enable(root);
  }
 else {
    SWTUtil.disable(root);
  }
  if (m.getVariant() == 2) {
    sliderC.setEnabled(true);
  }
 else {
    sliderC.setEnabled(false);
  }
  root.setRedraw(true);
}",0.912685337726524
108938,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    final DataDefinition d=model.getInputConfig().getInput().getDefinition();
    final AttributeType type=d.getAttributeType(attribute);
    if (type instanceof Hierarchy) {
      setHierarchy((Hierarchy)type);
      base.setEnabled(true);
      base.redraw();
    }
 else     if ((type == AttributeType.SENSITIVE_ATTRIBUTE) && (model.getInputConfig().getHierarchy(model.getSelectedAttribute()) != null)) {
      setHierarchy(model.getInputConfig().getHierarchy(model.getSelectedAttribute()));
      base.setEnabled(true);
      base.redraw();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      pushHierarchy();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.HIERARCHY) {
    if (attribute.equals(model.getSelectedAttribute())) {
      setHierarchy((Hierarchy)event.data);
      base.setEnabled(true);
      base.redraw();
    }
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
  }
 else   if (event.part == ModelPart.INPUT) {
    final DataDefinition d=model.getInputConfig().getInput().getDefinition();
    final AttributeType type=d.getAttributeType(attribute);
    if (type instanceof Hierarchy) {
      setHierarchy((Hierarchy)type);
      base.setEnabled(true);
      base.redraw();
    }
 else     if ((type == AttributeType.SENSITIVE_ATTRIBUTE) && (model.getInputConfig().getHierarchy(attribute) != null)) {
      setHierarchy(model.getInputConfig().getHierarchy(attribute));
      base.setEnabled(true);
      base.redraw();
    }
 else {
      reset();
    }
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if (event.data.equals(this.attribute)) {
      pushHierarchy();
    }
  }
}",0.9212233549582948
108939,"/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new WorkerLoadXMLHandler(){
    String attr, dtype, atype, ref, min, max;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (dtype.equals(DataType.STRING.toString())) {
          config.getInput().getDefinition().setDataType(attr,DataType.STRING);
        }
 else         if (dtype.equals(DataType.DECIMAL.toString())) {
          config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
        }
 else {
          config.getInput().getDefinition().setDataType(attr,DataType.DATE(dtype));
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          try {
            config.getInput().getDefinition().setAttributeType(attr,readHierarchy(zip,prefix,ref));
          }
 catch (          final IOException e) {
            throw new SAXException(e);
          }
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        attr=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        atype=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        dtype=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        ref=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        min=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}","/** 
 * Reads the data definition from the file
 * @param config
 * @param prefix
 * @param zip
 * @throws IOException
 * @throws SAXException
 */
private void readDefinition(final ModelConfiguration config,final String prefix,final ZipFile zip) throws IOException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final XMLReader xmlReader=XMLReaderFactory.createXMLReader();
  final InputSource inputSource=new InputSource(zip.getInputStream(entry));
  xmlReader.setContentHandler(new WorkerLoadXMLHandler(){
    String attr, dtype, atype, ref, min, max;
    @Override protected boolean end(    final String uri,    final String localName,    final String qName) throws SAXException {
      if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        if (attr == null) {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        if (dtype.equals(DataType.STRING.toString())) {
          config.getInput().getDefinition().setDataType(attr,DataType.STRING);
        }
 else         if (dtype.equals(DataType.DECIMAL.toString())) {
          config.getInput().getDefinition().setDataType(attr,DataType.DECIMAL);
        }
 else {
          config.getInput().getDefinition().setDataType(attr,DataType.DATE(dtype));
        }
        if (atype.equals(AttributeType.IDENTIFYING_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.IDENTIFYING_ATTRIBUTE);
        }
 else         if (atype.equals(AttributeType.SENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.SENSITIVE_ATTRIBUTE);
          if (ref != null) {
            try {
              config.setHierarchy(attr,readHierarchy(zip,prefix,ref));
            }
 catch (            final IOException e) {
              throw new SAXException(e);
            }
          }
        }
 else         if (atype.equals(AttributeType.INSENSITIVE_ATTRIBUTE.toString())) {
          config.getInput().getDefinition().setAttributeType(attr,AttributeType.INSENSITIVE_ATTRIBUTE);
        }
 else         if (atype.equals(Hierarchy.create().toString())) {
          try {
            config.getInput().getDefinition().setAttributeType(attr,readHierarchy(zip,prefix,ref));
          }
 catch (          final IOException e) {
            throw new SAXException(e);
          }
          config.getInput().getDefinition().setMinimumGeneralization(attr,Double.valueOf(min).intValue());
          config.getInput().getDefinition().setMaximumGeneralization(attr,Double.valueOf(max).intValue());
        }
 else {
          throw new SAXException(Resources.getMessage(""String_Node_Str""));
        }
        attr=null;
        atype=null;
        dtype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        attr=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        atype=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        dtype=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        ref=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        min=payload;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        max=payload;
        return true;
      }
 else {
        return false;
      }
    }
    @Override protected boolean start(    final String uri,    final String localName,    final String qName,    final Attributes attributes) throws SAXException {
      if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        attr=null;
        dtype=null;
        atype=null;
        ref=null;
        min=null;
        max=null;
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else       if (localName.equals(""String_Node_Str"")) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  xmlReader.parse(inputSource);
}",0.9605336297943302
108940,"/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      for (      final String a : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
        final String[][] h=config.getInput().getDefinition().getHierarchy(a);
        if (h != null) {
          zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
          final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
          out.write(h);
        }
      }
    }
  }
  Set<String> additional=new HashSet<String>();
  for (  HierarchicalDistanceTCloseness c : config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    additional.add(c.getAttribute());
  }
  for (  String attribute : additional) {
    Hierarchy h=config.getHierarchy(attribute);
    zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(attribute)+ ""String_Node_Str""));
    final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
    out.write(h.getHierarchy());
  }
}","/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  Set<String> done=new HashSet<String>();
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      for (      final String a : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
        final String[][] h=config.getInput().getDefinition().getHierarchy(a);
        if (h != null) {
          zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
          final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
          out.write(h);
          done.add(a);
        }
      }
    }
  }
  for (  Entry<String,Hierarchy> entry : config.getHierarchies().entrySet()) {
    final String[][] h=entry.getValue().getHierarchy();
    String a=entry.getKey();
    if (!done.contains(a)) {
      if (h != null) {
        zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
        final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
        out.write(h);
      }
    }
  }
}",0.7792937399678973
108941,"/** 
 * Writes the data definition to the file
 * @param zip
 * @throws IOException
 */
private void writeDefinition(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str""));
      final Writer w=new OutputStreamWriter(zip);
      w.write(toXML(config.getInput().getHandle(),config.getInput().getDefinition()));
      w.flush();
    }
  }
}","/** 
 * Writes the data definition to the file
 * @param zip
 * @throws IOException
 */
private void writeDefinition(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str""));
      final Writer w=new OutputStreamWriter(zip);
      w.write(toXML(config,config.getInput().getHandle(),config.getInput().getDefinition()));
      w.flush();
    }
  }
}",0.9935125115848008
108942,"/** 
 * Sort
 * @param handle
 * @param swapper
 * @param from
 * @param to
 * @param ascending
 * @param columns
 */
private void sortSubset(final DataHandleSubset handle,final Swapper swapper,final int from,final int to,final boolean ascending,final int... columns){
  final DataHandleSubset outer=handle;
  final IntComparator c=new IntComparator(){
    @Override public int compare(    final int arg0,    final int arg1){
      return outer.internalCompare(arg0,arg1,columns,ascending);
    }
  }
;
  final Swapper s=new Swapper(){
    @Override public void swap(    final int arg0,    final int arg1){
      if (input != null)       input.internalSwap(outer.internalTranslate(arg0),outer.internalTranslate(arg1));
      if (output != null)       output.internalSwap(outer.internalTranslate(arg0),outer.internalTranslate(arg1));
      if (swapper != null)       swapper.swap(arg0,arg1);
    }
  }
;
  GenericSorting.mergeSort(from,to,c,s);
}","/** 
 * Sort
 * @param handle
 * @param swapper
 * @param from
 * @param to
 * @param ascending
 * @param columns
 */
private void sortSubset(final DataHandleSubset handle,final Swapper swapper,final int from,final int to,final boolean ascending,final int... columns){
  final DataHandleSubset outer=handle;
  final IntComparator c=new IntComparator(){
    @Override public int compare(    final int arg0,    final int arg1){
      return outer.internalCompare(arg0,arg1,columns,ascending);
    }
  }
;
  final Swapper s=new Swapper(){
    @Override public void swap(    final int arg0,    final int arg1){
      if (input != null)       input.internalSwap(outer.internalTranslate(arg0),outer.internalTranslate(arg1));
      if (output != null)       output.internalSwap(outer.internalTranslate(arg0),outer.internalTranslate(arg1));
      if (swapper != null)       swapper.swap(outer.internalTranslate(arg0),outer.internalTranslate(arg1));
    }
  }
;
  GenericSorting.mergeSort(from,to,c,s);
}",0.9731958762886598
108943,"/** 
 * Rebuild array representation of subset
 */
protected void internalRebuild(){
  int index=0;
  for (int i=0; i < subset.getArray().length; i++) {
    if (this.subset.getSet().contains(i)) {
      this.subset.getArray()[index++]=i;
    }
  }
}","/** 
 * Rebuild array representation of subset
 */
protected void internalRebuild(){
  int index=0;
  for (int i=0; i < subset.getSet().length(); i++) {
    if (this.subset.getSet().contains(i)) {
      this.subset.getArray()[index++]=i;
    }
  }
}",0.9799196787148594
108944,"/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  }
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}","/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  }
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  checker.getHistory().reset();
  checker.getHistory().setSize(0);
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}",0.9747835905156192
108945,"/** 
 * Creates a new NodeChecker instance.
 * @param manager The manager
 * @param metric The metric
 * @param config The anonymization configuration
 * @param historyMaxSize The history max size
 * @param snapshotSizeDataset The history threshold
 * @param snapshotSizeSnapshot The history threshold replacement
 */
public NodeChecker(final DataManager manager,final Metric<?> metric,final ARXConfiguration config,final int historyMaxSize,final double snapshotSizeDataset,final double snapshotSizeSnapshot){
  this.metric=metric;
  this.config=config;
  data=manager.getDataQI();
  final int initialSize=(int)(manager.getDataQI().getDataLength() * 0.01d);
  final IntArrayDictionary dictionarySensValue;
  final IntArrayDictionary dictionarySensFreq;
  if ((config.getRequirements() & ARXConfiguration.REQUIREMENT_DISTRIBUTION) != 0) {
    dictionarySensValue=new IntArrayDictionary(initialSize);
    dictionarySensFreq=new IntArrayDictionary(initialSize);
  }
 else {
    dictionarySensValue=new IntArrayDictionary(0);
    dictionarySensFreq=new IntArrayDictionary(0);
  }
  history=new History(manager.getDataQI().getArray().length,historyMaxSize,snapshotSizeDataset,snapshotSizeSnapshot,config,dictionarySensValue,dictionarySensFreq);
  stateMachine=new StateMachine(history);
  currentGroupify=new HashGroupify(initialSize,config);
  lastGroupify=new HashGroupify(initialSize,config);
  transformer=new Transformer(manager.getDataQI().getArray(),manager.getHierarchies(),manager.getDataSE().getArray(),config,dictionarySensValue,dictionarySensFreq);
}","/** 
 * Creates a new NodeChecker instance.
 * @param manager The manager
 * @param metric The metric
 * @param config The anonymization configuration
 * @param historyMaxSize The history max size
 * @param snapshotSizeDataset The history threshold
 * @param snapshotSizeSnapshot The history threshold replacement
 */
public NodeChecker(final DataManager manager,final Metric<?> metric,final ARXConfiguration config,final int historyMaxSize,final double snapshotSizeDataset,final double snapshotSizeSnapshot){
  this.metric=metric;
  this.config=config;
  this.data=manager.getDataQI();
  final int initialSize=(int)(manager.getDataQI().getDataLength() * 0.01d);
  final IntArrayDictionary dictionarySensValue;
  final IntArrayDictionary dictionarySensFreq;
  if ((config.getRequirements() & ARXConfiguration.REQUIREMENT_DISTRIBUTION) != 0) {
    dictionarySensValue=new IntArrayDictionary(initialSize);
    dictionarySensFreq=new IntArrayDictionary(initialSize);
  }
 else {
    dictionarySensValue=new IntArrayDictionary(0);
    dictionarySensFreq=new IntArrayDictionary(0);
  }
  this.history=new History(manager.getDataQI().getArray().length,historyMaxSize,snapshotSizeDataset,snapshotSizeSnapshot,config,dictionarySensValue,dictionarySensFreq);
  this.stateMachine=new StateMachine(history);
  this.currentGroupify=new HashGroupify(initialSize,config);
  this.lastGroupify=new HashGroupify(initialSize,config);
  this.transformer=new Transformer(manager.getDataQI().getArray(),manager.getHierarchies(),manager.getDataSE().getArray(),config,dictionarySensValue,dictionarySensFreq);
}",0.9904580152671756
108946,"/** 
 * Stores a snapshot.
 * @param node the node
 * @param g the g
 */
public boolean store(final Node node,final IHashGroupify g,final int[] usedSnapshot){
  if ((node.isAnonymous() || (g.size() > snapshotSizeDataset) || canPrune(node))) {
    return false;
  }
  if (usedSnapshot != null) {
    final double percentSize=(g.size() / ((double)usedSnapshot.length / config.getSnapshotLength()));
    if (percentSize > snapshotSizeSnapshot) {
      return false;
    }
  }
  final int[] data=createSnapshot(g);
  if (cache.size() >= maxSize) {
    purgeCache();
  }
  nodeToSnapshot.put(node,data);
  cache.append(node);
  return true;
}","/** 
 * Stores a snapshot.
 * @param node the node
 * @param g the g
 */
public boolean store(final Node node,final IHashGroupify g,final int[] usedSnapshot){
  if ((node.isAnonymous() || (g.size() > snapshotSizeDataset) || canPrune(node))) {
    return false;
  }
  if (usedSnapshot != null) {
    final double percentSize=(g.size() / ((double)usedSnapshot.length / config.getSnapshotLength()));
    if (percentSize > snapshotSizeSnapshot) {
      return false;
    }
  }
  final int[] data=createSnapshot(g);
  if (cache.size() >= size) {
    purgeCache();
  }
  nodeToSnapshot.put(node,data);
  cache.append(node);
  return true;
}",0.996066089693155
108947,"/** 
 * Creates a new history.
 * @param rowCount the row count
 * @param maxSize the max size
 * @param snapshotSizeDataset the snapshotSizeDataset
 */
public History(final int rowCount,final int maxSize,final double snapshotSizeDataset,final double snapshotSizeSnapshot,final ARXConfiguration config,final IntArrayDictionary dictionarySensValue,final IntArrayDictionary dictionarySensFreq){
  this.snapshotSizeDataset=(long)(rowCount * snapshotSizeDataset);
  this.snapshotSizeSnapshot=snapshotSizeSnapshot;
  cache=new MRUCache<Node>(maxSize);
  nodeToSnapshot=new HashMap<Node,int[]>(maxSize);
  this.maxSize=maxSize;
  this.dictionarySensFreq=dictionarySensFreq;
  this.dictionarySensValue=dictionarySensValue;
  this.config=config;
  requirements=config.getRequirements();
}","/** 
 * Creates a new history.
 * @param rowCount the row count
 * @param size the max size
 * @param snapshotSizeDataset the snapshotSizeDataset
 */
public History(final int rowCount,final int size,final double snapshotSizeDataset,final double snapshotSizeSnapshot,final ARXConfiguration config,final IntArrayDictionary dictionarySensValue,final IntArrayDictionary dictionarySensFreq){
  this.snapshotSizeDataset=(long)(rowCount * snapshotSizeDataset);
  this.snapshotSizeSnapshot=snapshotSizeSnapshot;
  this.cache=new MRUCache<Node>(size);
  this.nodeToSnapshot=new HashMap<Node,int[]>(size);
  this.size=size;
  this.dictionarySensFreq=dictionarySensFreq;
  this.dictionarySensValue=dictionarySensValue;
  this.config=config;
  this.requirements=config.getRequirements();
}",0.9659601798330122
108948,"/** 
 * Clears the history.
 */
public void reset(){
  cache.clear();
  nodeToSnapshot.clear();
}","/** 
 * Clears the history.
 */
public void reset(){
  this.cache.clear();
  this.nodeToSnapshot.clear();
  this.dictionarySensFreq.clear();
  this.dictionarySensValue.clear();
  this.resultNode=null;
}",0.5351170568561873
108949,"/** 
 * Sorts the data
 * @param input
 */
public void actionDataSort(boolean input){
  if (model.getOutput() == null)   return;
  if (model.getSelectedAttribute() == null)   return;
  if (input) {
    this.model.getViewConfig().setMode(Mode.SORTED_INPUT);
  }
 else {
    this.model.getViewConfig().setMode(Mode.SORTED_OUTPUT);
  }
  this.model.getViewConfig().setAttribute(model.getSelectedAttribute());
  this.updateViewConfig(false);
  this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
}","/** 
 * Sorts the data
 * @param input
 */
public void actionDataSort(boolean input){
  if (model.getSelectedAttribute() == null)   return;
  if (input) {
    this.model.getViewConfig().setMode(Mode.SORTED_INPUT);
  }
 else {
    this.model.getViewConfig().setMode(Mode.SORTED_OUTPUT);
  }
  this.model.getViewConfig().setAttribute(model.getSelectedAttribute());
  this.updateViewConfig(false);
  this.update(new ModelEvent(this,ModelPart.VIEW_CONFIG,model.getOutput()));
}",0.9565217391304348
108950,"/** 
 * Cell selection event
 * @param arg1
 */
protected void actionCellSelected(CellSelectionEvent arg1){
  if (model == null)   return;
  int column=arg1.getColumnPosition();
  int row=arg1.getRowPosition();
  if (column == 0 && row >= 0) {
    if (table.getData() instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)table.getData()).getSubset();
      row=subset[row];
    }
    RowSet subset=model.getInputConfig().getResearchSubset();
    if (subset.contains(row)) {
      subset.remove(row);
    }
 else {
      subset.add(row);
    }
    model.setSubsetManual();
    controller.update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Cell selection event
 * @param arg1
 */
protected abstract void actionCellSelected(CellSelectionEvent arg1);",0.2719186785260483
108951,"/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=data.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < data.getNumRows(); i++) {
    elems.add(data.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  return dvals;
}","/** 
 * Returns the labels sorted per hierarchy or per data type
 * @param attribute
 * @return
 */
private String[] getLabels(final String attribute){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final int index=handle.getColumnIndexOf(attribute);
  final Set<String> elems=new HashSet<String>();
  for (int i=0; i < handle.getNumRows(); i++) {
    elems.add(handle.getValue(i,index));
  }
  final String[] dvals;
  if (hierarchy != null && hierarchy.getHierarchy() != null && hierarchy.getHierarchy().length != 0) {
    final int level=handle.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (elems.contains(val) && !done.contains(val)) {
        list.add(val);
        done.add(val);
      }
    }
    if (model.getAnonymizer() != null && elems.contains(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=handle.getDataType(attribute);
    final String[] v=new String[elems.size()];
    int i=0;
    for (    final String s : elems) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  return dvals;
}",0.9550301344459898
108952,"/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataOutput(final Composite parent,final Controller controller){
  super(parent,controller,(""String_Node_Str""));
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.OUTPUT,this);
}","/** 
 * Creates a new data view
 * @param parent
 * @param controller
 */
public ViewDataOutput(final Composite parent,final Controller controller){
  super(parent,controller,Resources.getMessage(""String_Node_Str""));
  controller.addListener(ModelPart.INPUT,this);
  controller.addListener(ModelPart.OUTPUT,this);
}",0.9672131147540984
108953,"/** 
 * Updates the header image in the table
 * @param index
 * @param type
 */
protected void updateHeaderImage(final int index,final AttributeType type){
  if (table.getHeaderImages().size() <= index) {
    table.getHeaderImages().add(null);
  }
  if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_IDENTIFYING);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_SENSITIVE);
  }
 else {
    table.getHeaderImages().set(index,IMAGE_QUASI_IDENTIFYING);
  }
}","/** 
 * Updates the header image in the table
 * @param index
 * @param type
 */
protected void updateHeaderImage(final int index,final AttributeType type){
  while (table.getHeaderImages().size() <= index) {
    table.getHeaderImages().add(null);
  }
  if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_IDENTIFYING);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_SENSITIVE);
  }
 else {
    table.getHeaderImages().set(index,IMAGE_QUASI_IDENTIFYING);
  }
}",0.9948567229977956
108954,"public LayoutAnalyze(final Composite parent,final Controller controller){
  centerSash=new SashForm(parent,SWT.VERTICAL);
  centerSash.setLayoutData(SWTUtil.createFillGridData());
  final Composite center=new Composite(centerSash,SWT.NONE);
  center.setLayoutData(SWTUtil.createFillGridData());
  center.setLayout(SWTUtil.createGridLayout(2));
  centerLeft=new Composite(center,SWT.NONE);
  centerLeft.setLayoutData(SWTUtil.createFillGridData());
  centerLeft.setLayout(SWTUtil.createGridLayout(1));
  centerRight=new Composite(center,SWT.NONE);
  centerRight.setLayoutData(SWTUtil.createFillGridData());
  centerRight.setLayout(SWTUtil.createGridLayout(1));
  dataInputView=new ViewData(centerLeft,controller,Resources.getMessage(""String_Node_Str""),ModelPart.INPUT,null);
  dataOutputView=new ViewData(centerRight,controller,Resources.getMessage(""String_Node_Str""),ModelPart.OUTPUT,ModelPart.INPUT);
  dataInputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataInputView.getViewportLayer().getOriginRowPosition();
      final int col=dataInputView.getViewportLayer().getOriginColumnPosition();
      if (dataOutputView != null) {
        dataOutputView.getViewportLayer().setOriginRowPosition(row);
        dataOutputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataInputView,dataOutputView);
      }
    }
  }
);
  dataOutputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataOutputView.getViewportLayer().getOriginRowPosition();
      final int col=dataOutputView.getViewportLayer().getOriginColumnPosition();
      if (dataInputView != null) {
        dataInputView.getViewportLayer().setOriginRowPosition(row);
        dataInputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataOutputView,dataInputView);
      }
    }
  }
);
  final Composite compositeBottom=new Composite(centerSash,SWT.NONE);
  compositeBottom.setLayout(new FillLayout());
  final SashForm bottomSash=new SashForm(compositeBottom,SWT.HORIZONTAL | SWT.SMOOTH);
  bottomLeft=new Composite(bottomSash,SWT.NONE);
  bottomLeft.setLayout(new FillLayout());
  bottomRight=new Composite(bottomSash,SWT.NONE);
  bottomRight.setLayout(new FillLayout());
  statisticsInputLayout=new LayoutStatistics(bottomLeft,controller,ModelPart.INPUT,null);
  statisticsOutputLayout=new LayoutStatistics(bottomRight,controller,ModelPart.OUTPUT,ModelPart.INPUT);
  statisticsInputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsOutputLayout.setSelectionIdex(statisticsInputLayout.getSelectionIndex());
    }
  }
);
  statisticsOutputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsInputLayout.setSelectionIdex(statisticsOutputLayout.getSelectionIndex());
    }
  }
);
  centerSash.setWeights(new int[]{WEIGHT_TOP,WEIGHT_BOTTOM});
  bottomSash.setWeights(new int[]{WEIGHT_LEFT,WEIGHT_RIGHT});
}","public LayoutAnalyze(final Composite parent,final Controller controller){
  centerSash=new SashForm(parent,SWT.VERTICAL);
  centerSash.setLayoutData(SWTUtil.createFillGridData());
  final Composite center=new Composite(centerSash,SWT.NONE);
  center.setLayoutData(SWTUtil.createFillGridData());
  center.setLayout(SWTUtil.createGridLayout(2));
  centerLeft=new Composite(center,SWT.NONE);
  centerLeft.setLayoutData(SWTUtil.createFillGridData());
  centerLeft.setLayout(SWTUtil.createGridLayout(1));
  centerRight=new Composite(center,SWT.NONE);
  centerRight.setLayoutData(SWTUtil.createFillGridData());
  centerRight.setLayout(SWTUtil.createGridLayout(1));
  dataInputView=new ViewDataInput(centerLeft,controller);
  dataOutputView=new ViewDataOutput(centerRight,controller);
  dataInputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataInputView.getViewportLayer().getOriginRowPosition();
      final int col=dataInputView.getViewportLayer().getOriginColumnPosition();
      if (dataOutputView != null) {
        dataOutputView.getViewportLayer().setOriginRowPosition(row);
        dataOutputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataInputView,dataOutputView);
      }
    }
  }
);
  dataOutputView.addScrollBarListener(new Listener(){
    @Override public void handleEvent(    final Event arg0){
      final int row=dataOutputView.getViewportLayer().getOriginRowPosition();
      final int col=dataOutputView.getViewportLayer().getOriginColumnPosition();
      if (dataInputView != null) {
        dataInputView.getViewportLayer().setOriginRowPosition(row);
        dataInputView.getViewportLayer().setOriginColumnPosition(col);
        synchronize(dataOutputView,dataInputView);
      }
    }
  }
);
  final Composite compositeBottom=new Composite(centerSash,SWT.NONE);
  compositeBottom.setLayout(new FillLayout());
  final SashForm bottomSash=new SashForm(compositeBottom,SWT.HORIZONTAL | SWT.SMOOTH);
  bottomLeft=new Composite(bottomSash,SWT.NONE);
  bottomLeft.setLayout(new FillLayout());
  bottomRight=new Composite(bottomSash,SWT.NONE);
  bottomRight.setLayout(new FillLayout());
  statisticsInputLayout=new LayoutStatistics(bottomLeft,controller,ModelPart.INPUT,null);
  statisticsOutputLayout=new LayoutStatistics(bottomRight,controller,ModelPart.OUTPUT,ModelPart.INPUT);
  statisticsInputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsOutputLayout.setSelectionIdex(statisticsInputLayout.getSelectionIndex());
    }
  }
);
  statisticsOutputLayout.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      statisticsInputLayout.setSelectionIdex(statisticsOutputLayout.getSelectionIndex());
    }
  }
);
  centerSash.setWeights(new int[]{WEIGHT_TOP,WEIGHT_BOTTOM});
  bottomSash.setWeights(new int[]{WEIGHT_LEFT,WEIGHT_RIGHT});
}",0.9588952071486596
108955,"public void addScrollBarListener(final Listener listener){
  table.addScrollBarListener(listener);
}","/** 
 * Add a scrollbar listener to this view
 * @param listener
 */
public void addScrollBarListener(final Listener listener){
  table.addScrollBarListener(listener);
}",0.7434944237918215
108956,"/** 
 * Column selection event
 * @param arg1
 */
private void actionColumnSelected(ColumnSelectionEvent arg1){
  if (model != null) {
    int column=arg1.getColumnPositionRanges().iterator().next().start - 1;
    if (column >= 0) {
      final String attr=handle.getAttributeName(column);
      table.setAttribute(attr);
      table.redraw();
      model.setSelectedAttribute(attr);
      controller.update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attr));
    }
  }
}","/** 
 * Column selection event
 * @param arg1
 */
protected void actionColumnSelected(ColumnSelectionEvent arg1){
  if (model != null) {
    int column=arg1.getColumnPositionRanges().iterator().next().start - 1;
    if (column >= 0) {
      DataHandle handle=getHandle();
      if (handle != null) {
        final String attr=handle.getAttributeName(column);
        table.setAttribute(attr);
        table.redraw();
        model.setSelectedAttribute(attr);
        controller.update(new ModelEvent(this,ModelPart.SELECTED_ATTRIBUTE,attr));
      }
    }
  }
}",0.9083895853423336
108957,"/** 
 * Creates a new data view
 * @param parent
 * @param controller
 * @param title
 * @param target
 * @param reset
 */
public ViewData(final Composite parent,final Controller controller,final String title,final ModelPart target,final ModelPart reset){
  controller.addListener(ModelPart.RESEARCH_SUBSET,this);
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  controller.addListener(target,this);
  if (reset != null) {
    controller.addListener(reset,this);
  }
  this.controller=controller;
  this.reset=reset;
  this.target=target;
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitleBar bar=new ComponentTitleBar(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionDataSort(target == ModelPart.INPUT);
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionDataShowGroups();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),true,new Runnable(){
    @Override public void run(){
      controller.actionDataToggleSubset();
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillGridData());
  Composite c=folder.createItem(title,null);
  folder.setSelection(0);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  c.setLayout(l);
  table=new ComponentDataTable(controller,c);
  table.addSelectionLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        actionCellSelected((CellSelectionEvent)arg0);
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        actionColumnSelected((ColumnSelectionEvent)arg0);
      }
    }
  }
);
  this.groupsButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.groupsButton.setEnabled(false);
  this.subsetButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.subsetButton.setEnabled(false);
}","/** 
 * Creates a new data view
 * @param parent
 * @param controller
 * @param title
 */
public ViewData(final Composite parent,final Controller controller,final String title){
  controller.addListener(ModelPart.ATTRIBUTE_TYPE,this);
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  this.controller=controller;
  IMAGE_INSENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_SENSITIVE=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_QUASI_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  IMAGE_IDENTIFYING=controller.getResources().getImage(""String_Node_Str"");
  ComponentTitleBar bar=new ComponentTitleBar(""String_Node_Str"");
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      actionSort();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),new Runnable(){
    @Override public void run(){
      controller.actionDataShowGroups();
    }
  }
);
  bar.add(Resources.getMessage(""String_Node_Str""),controller.getResources().getImage(""String_Node_Str""),true,new Runnable(){
    @Override public void run(){
      controller.actionDataToggleSubset();
    }
  }
);
  ComponentTitledFolder folder=new ComponentTitledFolder(parent,controller,bar,null);
  folder.setLayoutData(SWTUtil.createFillGridData());
  Composite c=folder.createItem(title,null);
  folder.setSelection(0);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  c.setLayout(l);
  table=new ComponentDataTable(controller,c);
  table.addSelectionLayerListener(new ILayerListener(){
    @Override public void handleLayerEvent(    ILayerEvent arg0){
      if (arg0 instanceof CellSelectionEvent) {
        actionCellSelected((CellSelectionEvent)arg0);
      }
 else       if (arg0 instanceof ColumnSelectionEvent) {
        actionColumnSelected((ColumnSelectionEvent)arg0);
      }
    }
  }
);
  this.groupsButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.groupsButton.setEnabled(false);
  this.subsetButton=folder.getBarItem(Resources.getMessage(""String_Node_Str""));
  this.subsetButton.setEnabled(false);
}",0.9223689475790317
108958,"@Override public void reset(){
  table.reset();
  groupsButton.setEnabled(false);
  subsetButton.setEnabled(false);
  handle=null;
}","@Override public void reset(){
  table.reset();
  groupsButton.setEnabled(false);
  subsetButton.setEnabled(false);
}",0.9397590361445785
108959,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT || event.part == ModelPart.VIEW_CONFIG) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == ModelPart.SELECTED_ATTRIBUTE) {
    table.setAttribute(model.getSelectedAttribute());
    table.redraw();
  }
 else   if (event.part == reset) {
    reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
 else   if (event.part == target) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=model.getInputConfig().getInput().getDefinition();
    if (target == ModelPart.OUTPUT) {
      definition=model.getOutputConfig().getInput().getDefinition();
    }
    handle=(DataHandle)event.data;
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView();
    }
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    table.setData(data);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if ((model != null) && (handle != null)) {
      final String attr=(String)event.data;
      DataDefinition definition=model.getInputConfig().getInput().getDefinition();
      if (target == ModelPart.OUTPUT) {
        definition=model.getOutputConfig().getInput().getDefinition();
      }
      final int index=handle.getColumnIndexOf(attr);
      updateHeaderImage(index,definition.getAttributeType(attr));
      table.setEnabled(true);
      table.redraw();
    }
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG) {
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView();
    }
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    if (table.getData() != data)     table.setData(data);
    table.redraw();
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT || event.part == ModelPart.VIEW_CONFIG) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
  if (event.part == ModelPart.VIEW_CONFIG) {
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
}",0.3350103580941106
108960,"/** 
 * Updates the header image in the table
 * @param index
 * @param type
 */
private void updateHeaderImage(final int index,final AttributeType type){
  if (table.getHeaderImages().size() <= index) {
    table.getHeaderImages().add(null);
  }
  if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_IDENTIFYING);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_SENSITIVE);
  }
 else {
    table.getHeaderImages().set(index,IMAGE_QUASI_IDENTIFYING);
  }
}","/** 
 * Updates the header image in the table
 * @param index
 * @param type
 */
protected void updateHeaderImage(final int index,final AttributeType type){
  if (table.getHeaderImages().size() <= index) {
    table.getHeaderImages().add(null);
  }
  if (type == AttributeType.INSENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_INSENSITIVE);
  }
 else   if (type == AttributeType.IDENTIFYING_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_IDENTIFYING);
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    table.getHeaderImages().set(index,IMAGE_SENSITIVE);
  }
 else {
    table.getHeaderImages().set(index,IMAGE_QUASI_IDENTIFYING);
  }
}",0.991150442477876
108961,"/** 
 * Cell selection event
 * @param arg1
 */
private void actionCellSelected(CellSelectionEvent arg1){
  if (model == null)   return;
  int column=arg1.getColumnPosition();
  int row=arg1.getRowPosition();
  if (column == 0 && row >= 0) {
    if (table.getData() instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)table.getData()).getSubset();
      row=subset[row];
    }
    RowSet subset=model.getInputConfig().getResearchSubset();
    if (subset.contains(row)) {
      subset.remove(row);
    }
 else {
      subset.add(row);
    }
    model.setSubsetManual();
    controller.update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}","/** 
 * Cell selection event
 * @param arg1
 */
protected void actionCellSelected(CellSelectionEvent arg1){
  if (model == null)   return;
  int column=arg1.getColumnPosition();
  int row=arg1.getRowPosition();
  if (column == 0 && row >= 0) {
    if (table.getData() instanceof DataHandleSubset) {
      int[] subset=((DataHandleSubset)table.getData()).getSubset();
      row=subset[row];
    }
    RowSet subset=model.getInputConfig().getResearchSubset();
    if (subset.contains(row)) {
      subset.remove(row);
    }
 else {
      subset.add(row);
    }
    model.setSubsetManual();
    controller.update(new ModelEvent(this,ModelPart.RESEARCH_SUBSET,subset));
  }
}",0.991044776119403
108962,"public ViewportLayer getViewportLayer(){
  return table.getViewportLayer();
}","/** 
 * Returns the NatTable viewport layer
 * @return
 */
public ViewportLayer getViewportLayer(){
  return table.getViewportLayer();
}",0.7230046948356808
108963,"@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final double originalInfoLoss=super.evaluateInternal(node,g).getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  for (int i=0; i < original.length; i++) {
    for (    final double count : original[i].values()) {
      additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}","@Override @SuppressWarnings(""String_Node_Str"") protected InformationLossDefault evaluateInternal(final Node node,final IHashGroupify g){
  final double originalInfoLoss=super.evaluateInternal(node,g).getValue();
  double suppressedTuples=0;
  double additionalInfoLoss=0;
  int key;
  Integer val;
  final Map<Integer,Integer>[] original=new Map[node.getTransformation().length];
  for (int i=0; i < original.length; i++) {
    original[i]=new HashMap<Integer,Integer>();
  }
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    if (!m.isNotOutlier && m.count > 0) {
      suppressedTuples+=m.count;
      for (int i=0; i < original.length; i++) {
        key=m.key[i];
        val=original[i].get(key);
        if (val == null) {
          original[i].put(key,m.count);
        }
 else {
          original[i].put(key,m.count + val);
        }
      }
    }
    m=m.nextOrdered;
  }
  if (suppressedTuples != 0) {
    for (int i=0; i < original.length; i++) {
      for (      final double count : original[i].values()) {
        additionalInfoLoss+=count * MetricEntropy.log2(count / suppressedTuples);
      }
    }
  }
  return new InformationLossDefault(originalInfoLoss - additionalInfoLoss);
}",0.9695688926458156
108964,"private void analyze(){
  if (model == null) {
    return;
  }
  final long time=System.currentTimeMillis();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  boolean suppressed=false;
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    if (!suppressed) {
      suppressed|=data.isOutlier(i);
    }
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val) || ((model.getAnonymizer() != null) && val.equals(model.getAnonymizer().getSuppressionString()))) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (suppressed) {
      if (!done.contains(model.getAnonymizer().getSuppressionString())) {
        list.add(model.getAnonymizer().getSuppressionString());
        if (!map.containsKey(list.add(model.getAnonymizer().getSuppressionString()))) {
          map.put(model.getAnonymizer().getSuppressionString(),0d);
        }
      }
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  int step=map.size() / MAX_DIMENSION;
  step=Math.max(step,1);
  final int length=(int)Math.ceil((double)map.size() / (double)step);
  controller.getResources().getLogger().info(""String_Node_Str"" + length + ""String_Node_Str""+ step+ ""String_Node_Str""+ dvals.length+ ""String_Node_Str""+ MAX_DIMENSION);
  int sindex=0;
  final double[] distribution=new double[length];
  for (int i=0; i < dvals.length; i+=step) {
    for (int j=0; j < step; j++) {
      if (sindex < distribution.length) {
        if ((i + j) < dvals.length) {
          distribution[sindex]+=map.get(dvals[i + j]) / sum;
        }
      }
 else {
        controller.getResources().getLogger().warn(""String_Node_Str"");
      }
    }
    sindex++;
  }
  cache.put(attribute,distribution);
  controller.getResources().getLogger().info(""String_Node_Str"" + (System.currentTimeMillis() - time));
}","private void analyze(){
  if (model == null) {
    return;
  }
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView();
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val)) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (model.getAnonymizer() != null && map.containsKey(model.getAnonymizer().getSuppressionString()) && !done.contains(model.getAnonymizer().getSuppressionString())) {
      list.add(model.getAnonymizer().getSuppressionString());
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  final double[] distribution=new double[map.size()];
  for (int i=0; i < dvals.length; i++) {
    distribution[i]=map.get(dvals[i]) / sum;
  }
  cache.put(attribute,distribution);
}",0.7474965336619935
108965,"/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      for (      final String a : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
        final String[][] h=config.getInput().getDefinition().getHierarchy(a);
        if (h != null) {
          zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
          final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
          out.write(h);
        }
      }
    }
  }
  Set<String> additional=new HashSet<String>();
  for (  HierarchicalDistanceTCloseness c : config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    additional.add(c.getAttribute());
  }
  for (  String attribute : additional) {
    Hierarchy h=model.getOutputConfig().getHierarchy(attribute);
    zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(attribute)+ ""String_Node_Str""));
    final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
    out.write(h.getHierarchy());
  }
}","/** 
 * Writes the hierarchies to the file
 * @param zip
 * @throws IOException
 */
private void writeHierarchies(final ModelConfiguration config,final String prefix,final ZipOutputStream zip) throws IOException {
  if (config.getInput() != null) {
    if (config.getInput().getDefinition() != null) {
      for (      final String a : config.getInput().getDefinition().getQuasiIdentifyingAttributes()) {
        final String[][] h=config.getInput().getDefinition().getHierarchy(a);
        if (h != null) {
          zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(a)+ ""String_Node_Str""));
          final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
          out.write(h);
        }
      }
    }
  }
  Set<String> additional=new HashSet<String>();
  for (  HierarchicalDistanceTCloseness c : config.getCriteria(HierarchicalDistanceTCloseness.class)) {
    additional.add(c.getAttribute());
  }
  for (  String attribute : additional) {
    Hierarchy h=config.getHierarchy(attribute);
    zip.putNextEntry(new ZipEntry(prefix + ""String_Node_Str"" + toFileName(attribute)+ ""String_Node_Str""));
    final CSVDataOutput out=new CSVDataOutput(zip,model.getSeparator());
    out.write(h.getHierarchy());
  }
}",0.9884416102032684
108966,"/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput().clone(false));
    model.setOutputConfig(config);
    DataHandleInput inHandle=((DataHandleInput)model.getInputConfig().getInput().getHandle());
    DPresence criterion=model.getOutputConfig().getCriterion(DPresence.class);
    inHandle.setSubset(criterion.getBitSet(),criterion.getArray());
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new DataHandleOutput(config.getInput().getHandle(),config.getInput().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}","/** 
 * Reads the configuration from the file
 * @param prefix
 * @param output
 * @param map
 * @param zip
 * @throws IOException
 * @throws ClassNotFoundException
 * @throws SAXException
 */
private void readConfiguration(final String prefix,final boolean output,final Map<String,ARXNode> map,final ZipFile zip) throws IOException, ClassNotFoundException, SAXException {
  final ZipEntry entry=zip.getEntry(prefix + ""String_Node_Str"");
  if (entry == null) {
    return;
  }
  final ObjectInputStream oos=new ObjectInputStream(zip.getInputStream(entry));
  final ModelConfiguration config=(ModelConfiguration)oos.readObject();
  oos.close();
  if (!output) {
    readInput(config,zip);
    model.setInputConfig(config);
  }
 else {
    config.setInput(model.getInputConfig().getInput().clone(false));
    model.setOutputConfig(config);
    if (model.getOutputConfig() != null) {
      DataHandleInput inHandle=((DataHandleInput)model.getInputConfig().getInput().getHandle());
      DPresence criterion=model.getOutputConfig().getCriterion(DPresence.class);
      if (criterion != null) {
        inHandle.setSubset(criterion.getBitSet(),criterion.getArray());
      }
    }
  }
  readDefinition(config,prefix,zip);
  if (output) {
    final String suppressionString=model.getSuppressionString();
    final int historySize=model.getHistorySize();
    final double snapshotSizeSnapshot=model.getSnapshotSizeSnapshot();
    final double snapshotSizeDataset=model.getSnapshotSizeDataset();
    final boolean removeOutliers=model.getOutputConfig().isRemoveOutliers();
    final Metric<?> metric=config.getMetric();
    final long time=model.getTime();
    final ARXNode optimalNode;
    final ARXNode outputNode;
    if (model.getOptimalNodeAsString() != null) {
      optimalNode=map.get(model.getOptimalNodeAsString());
    }
 else {
      optimalNode=null;
    }
    if (model.getOutputNodeAsString() != null) {
      outputNode=map.get(model.getOutputNodeAsString());
    }
 else {
      outputNode=null;
    }
    model.setSelectedNode(outputNode);
    model.setResult(new DataHandleOutput(config.getInput().getHandle(),config.getInput().getDefinition(),lattice,removeOutliers,suppressionString,historySize,snapshotSizeSnapshot,snapshotSizeDataset,metric,model.getOutputConfig().getConfig(),optimalNode,time));
    final ARXAnonymizer f=new ARXAnonymizer();
    model.setAnonymizer(f);
    f.setRemoveOutliers(removeOutliers);
    f.setSuppressionString(suppressionString);
    f.setHistorySize(historySize);
    f.setMaximumSnapshotSizeSnapshot(snapshotSizeSnapshot);
    f.setMaximumSnapshotSizeDataset(snapshotSizeDataset);
  }
}",0.9814385150812064
108967,"/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  node.setTransformation(fnode.getTransformation(),0);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (node.isAnonymous()) {
      currentNode.access().setAnonymous();
    }
 else {
      currentNode.access().setNotAnonymous();
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}","/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  int level=0;
  for (  int i : fnode.getTransformation())   level+=i;
  node.setTransformation(fnode.getTransformation(),level);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (node.isAnonymous()) {
      currentNode.access().setAnonymous();
    }
 else {
      currentNode.access().setNotAnonymous();
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}",0.9516567083107008
108968,"/** 
 * Creates a new combined metric
 * @param main
 */
protected MetricCombined(final Metric<?> main,final Set<Metric<?>> metrics){
  super(main.isMonotonic(),isIndependent(main,metrics));
}","/** 
 * Creates a new combined metric
 * @param main
 */
protected MetricCombined(final Metric<?> main,final Set<Metric<?>> metrics){
  super(main.isMonotonic(),isIndependent(main,metrics));
  this.main=main;
  this.metrics=metrics;
}",0.9014084507042254
108969,"@Override protected InformationLossCombined evaluateInternal(final Node node,final IHashGroupify groupify){
  final double value=main.evaluateInternal(node,groupify).getValue();
  final InformationLossCombined result=new InformationLossCombined(value);
  for (  final Metric<?> metric : metrics) {
    result.setValue(metric,metric.evaluateInternal(node,groupify));
  }
  return result;
}","@Override protected InformationLossCombined evaluateInternal(final Node node,final IHashGroupify groupify){
  final double value=main.evaluateInternal(node,groupify).getValue();
  final InformationLossCombined result=new InformationLossCombined(value);
  for (  final Metric<?> metric : metrics) {
    InformationLoss loss=metric.evaluateInternal(node,groupify);
    result.setValue(metric,loss);
  }
  return result;
}",0.9021065675340768
108970,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    for (int i=0; i < ITEMS_METRIC.length; i++) {
      if (ITEMS_METRIC[i].getClass().equals(model.getInputConfig().getMetric().getClass())) {
        comboMetric.select(i);
        break;
      }
    }
    updateControlls();
    root.setRedraw(true);
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION) {
    if (model != null) {
      updateControlls();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    root.setRedraw(false);
    sliderOutliers.setSelection(doubleToSlider(0d,0.999d,model.getInputConfig().getAllowedOutliers()));
    labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
    buttonPracticalMonotonicity.setSelection(model.getInputConfig().isPracticalMonotonicity());
    buttonProtectSensitiveAssociations.setSelection(model.getInputConfig().isProtectSensitiveAssociations());
    for (int i=0; i < ITEMS_METRIC.length; i++) {
      if (ITEMS_METRIC[i].getClass().equals(model.getInputConfig().getMetric().getClass())) {
        comboMetric.select(i);
        break;
      }
    }
    updateControlls();
    root.setRedraw(true);
  }
 else   if (event.part == ModelPart.INPUT) {
    SWTUtil.enable(root);
    updateControlls();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.ATTRIBUTE_TYPE || event.part == ModelPart.CRITERION_DEFINITION) {
    if (model != null) {
      updateControlls();
    }
  }
}",0.9479166666666666
108971,"@Override public void reset(){
  disable();
}","@Override public void reset(){
  size.setText(""String_Node_Str"");
  total.setText(""String_Node_Str"");
  percent.setText(""String_Node_Str"");
  origin.setText(""String_Node_Str"");
  disable();
}",0.3813559322033898
108972,"private void update(){
  int size=model.getInputConfig().getResearchSubset().size();
  int total=model.getInputConfig().getInput().getHandle().getNumRows();
  double percent=(double)size / (double)total * 100d;
  this.size.setText(String.valueOf(size));
  this.total.setText(String.valueOf(total));
  this.percent.setText(format.format(percent));
  if (this.model != null) {
    this.origin.setText(model.getSubsetOrigin());
  }
}","private void update(){
  if (model.getInputConfig().getResearchSubset() == null) {
    reset();
    return;
  }
  int size=model.getInputConfig().getResearchSubset().size();
  int total=model.getInputConfig().getInput().getHandle().getNumRows();
  double percent=(double)size / (double)total * 100d;
  this.size.setText(String.valueOf(size));
  this.total.setText(String.valueOf(total));
  this.percent.setText(format.format(percent));
  if (this.model != null) {
    this.origin.setText(model.getSubsetOrigin());
  }
}",0.9062170706006324
108973,"/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int compare(final int row1,final int row2,final int[] columns,final boolean ascending){
  getHandle(currentNode);
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    int cmp=0;
    try {
      cmp=dataTypes[attributeType][indexMap].compare(getValueInternal(row1,index),getValueInternal(row2,index));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      if (ascending) {
        return -cmp;
      }
 else {
        return cmp;
      }
    }
  }
  return 0;
}","/** 
 * A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. It uses the specified data types for comparison if no generalization was applied, otherwise it uses string comparison.
 * @param row1 the row1
 * @param row2 the row2
 * @param columns the columns
 * @param ascending the ascending
 * @return the int
 */
@Override protected int compare(final int row1,final int row2,final int[] columns,final boolean ascending){
  getHandle(currentNode);
  for (  final int index : columns) {
    final int attributeType=inverseMap[index] >>> AttributeType.SHIFT;
    final int indexMap=inverseMap[index] & AttributeType.MASK;
    if (attributeType == AttributeType.ATTR_TYPE_ID)     return 0;
    int cmp=0;
    try {
      cmp=dataTypes[attributeType][indexMap].compare(getValueInternal(row1,index),getValueInternal(row2,index));
    }
 catch (    final Exception e) {
      throw new RuntimeException(e);
    }
    if (cmp != 0) {
      if (ascending) {
        return -cmp;
      }
 else {
        return cmp;
      }
    }
  }
  return 0;
}",0.968822708236389
108974,"private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle().getView(config.getConfig());
  }
 else {
    data=model.getOutput().getView(config.getConfig());
  }
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}","private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if (data != null)   data=data.getView(config.getConfig());
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}",0.8240635641316686
108975,"private void analyze(){
  if (model == null) {
    return;
  }
  final long time=System.currentTimeMillis();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  final DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle().getView(config.getConfig());
  }
 else {
    data=model.getOutput().getView(config.getConfig());
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  boolean suppressed=false;
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    if (!suppressed) {
      suppressed|=data.isOutlier(i);
    }
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val) || ((model.getAnonymizer() != null) && val.equals(model.getAnonymizer().getSuppressionString()))) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (suppressed) {
      if (!done.contains(model.getAnonymizer().getSuppressionString())) {
        list.add(model.getAnonymizer().getSuppressionString());
        if (!map.containsKey(list.add(model.getAnonymizer().getSuppressionString()))) {
          map.put(model.getAnonymizer().getSuppressionString(),0d);
        }
      }
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  int step=map.size() / MAX_DIMENSION;
  step=Math.max(step,1);
  final int length=(int)Math.ceil((double)map.size() / (double)step);
  controller.getResources().getLogger().info(""String_Node_Str"" + length + ""String_Node_Str""+ step+ ""String_Node_Str""+ dvals.length+ ""String_Node_Str""+ MAX_DIMENSION);
  int sindex=0;
  final double[] distribution=new double[length];
  for (int i=0; i < dvals.length; i+=step) {
    for (int j=0; j < step; j++) {
      if (sindex < distribution.length) {
        if ((i + j) < dvals.length) {
          distribution[sindex]+=map.get(dvals[i + j]) / sum;
        }
      }
 else {
        controller.getResources().getLogger().warn(""String_Node_Str"");
      }
    }
    sindex++;
  }
  cache.put(attribute,distribution);
  controller.getResources().getLogger().info(""String_Node_Str"" + (System.currentTimeMillis() - time));
}","private void analyze(){
  if (model == null) {
    return;
  }
  final long time=System.currentTimeMillis();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null)   data=data.getView(config.getConfig());
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  boolean suppressed=false;
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    if (!suppressed) {
      suppressed|=data.isOutlier(i);
    }
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val) || ((model.getAnonymizer() != null) && val.equals(model.getAnonymizer().getSuppressionString()))) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (suppressed) {
      if (!done.contains(model.getAnonymizer().getSuppressionString())) {
        list.add(model.getAnonymizer().getSuppressionString());
        if (!map.containsKey(list.add(model.getAnonymizer().getSuppressionString()))) {
          map.put(model.getAnonymizer().getSuppressionString(),0d);
        }
      }
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  int step=map.size() / MAX_DIMENSION;
  step=Math.max(step,1);
  final int length=(int)Math.ceil((double)map.size() / (double)step);
  controller.getResources().getLogger().info(""String_Node_Str"" + length + ""String_Node_Str""+ step+ ""String_Node_Str""+ dvals.length+ ""String_Node_Str""+ MAX_DIMENSION);
  int sindex=0;
  final double[] distribution=new double[length];
  for (int i=0; i < dvals.length; i+=step) {
    for (int j=0; j < step; j++) {
      if (sindex < distribution.length) {
        if ((i + j) < dvals.length) {
          distribution[sindex]+=map.get(dvals[i + j]) / sum;
        }
      }
 else {
        controller.getResources().getLogger().warn(""String_Node_Str"");
      }
    }
    sindex++;
  }
  cache.put(attribute,distribution);
  controller.getResources().getLogger().info(""String_Node_Str"" + (System.currentTimeMillis() - time));
}",0.9835010060362172
108976,"@Override public void reset(){
  table.reset();
  handle=null;
}","@Override public void reset(){
  table.reset();
  groupsButton.setEnabled(false);
  subsetButton.setEnabled(false);
  handle=null;
}",0.6530612244897959
108977,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == reset) {
    reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
 else   if (event.part == target) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=model.getInputConfig().getInput().getDefinition();
    if (target == ModelPart.OUTPUT) {
      definition=model.getOutputConfig().getInput().getDefinition();
    }
    handle=(DataHandle)event.data;
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView(model.getOutputConfig().getConfig());
    }
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    table.setData(data);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if ((model != null) && (handle != null)) {
      final String attr=(String)event.data;
      DataDefinition definition=model.getInputConfig().getInput().getDefinition();
      if (target == ModelPart.OUTPUT) {
        definition=model.getOutputConfig().getInput().getDefinition();
      }
      final int index=handle.getColumnIndexOf(attr);
      updateHeaderImage(index,definition.getAttributeType(attr));
      table.setEnabled(true);
      table.redraw();
    }
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG) {
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView(model.getOutputConfig().getConfig());
    }
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    if (table.getData() != data)     table.setData(data);
    table.redraw();
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT || event.part == ModelPart.INPUT || event.part == ModelPart.VIEW_CONFIG) {
    if (model != null && model.getOutput() != null) {
      groupsButton.setEnabled(true);
      subsetButton.setEnabled(true);
    }
 else {
      groupsButton.setEnabled(false);
      subsetButton.setEnabled(false);
    }
  }
  if (event.part == reset) {
    reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    model=(Model)event.data;
    reset();
  }
 else   if (event.part == target) {
    if (event.data == null) {
      reset();
      return;
    }
    DataDefinition definition=model.getInputConfig().getInput().getDefinition();
    if (target == ModelPart.OUTPUT) {
      definition=model.getOutputConfig().getInput().getDefinition();
    }
    handle=(DataHandle)event.data;
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView(model.getOutputConfig().getConfig());
    }
    table.setResearchSubset(model.getInputConfig().getResearchSubset());
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    table.setData(data);
    table.getHeaderImages().clear();
    for (int i=0; i < handle.getNumColumns(); i++) {
      updateHeaderImage(i,definition.getAttributeType(handle.getAttributeName(i)));
    }
    table.setEnabled(true);
    table.redraw();
  }
 else   if (event.part == ModelPart.ATTRIBUTE_TYPE) {
    if ((model != null) && (handle != null)) {
      final String attr=(String)event.data;
      DataDefinition definition=model.getInputConfig().getInput().getDefinition();
      if (target == ModelPart.OUTPUT) {
        definition=model.getOutputConfig().getInput().getDefinition();
      }
      final int index=handle.getColumnIndexOf(attr);
      updateHeaderImage(index,definition.getAttributeType(attr));
      table.setEnabled(true);
      table.redraw();
    }
  }
 else   if (event.part == ModelPart.RESEARCH_SUBSET) {
    table.setResearchSubset((RowSet)event.data);
    table.redraw();
  }
 else   if (event.part == ModelPart.VIEW_CONFIG) {
    DataHandle data=handle;
    if (model.getViewConfig().isSubset() && model.getOutputConfig() != null && model.getOutputConfig().getConfig() != null) {
      data=handle.getView(model.getOutputConfig().getConfig());
    }
    table.setGroups(target == ModelPart.OUTPUT ? model.getGroups() : null);
    if (table.getData() != data)     table.setData(data);
    table.redraw();
    subsetButton.setSelection(model.getViewConfig().isSubset());
  }
}",0.9925756710451172
108978,"public void setData(final DataHandle handle){
  this.table.setRedraw(false);
  this.context.reset();
  this.context.setHandle(handle);
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(handle,context),table,context);
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnWidthByPosition(0,18);
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnPositionResizable(0,false);
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
}","public void setData(final DataHandle handle){
  this.table.setRedraw(false);
  this.context.setHandle(handle);
  this.context.setArray(null);
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(handle,context),table,context);
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnWidthByPosition(0,18);
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnPositionResizable(0,false);
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
}",0.9739130434782608
108979,"public void setRows(RowSet rows){
  this.rows=rows;
}","public void setRows(RowSet rows){
  System.out.println(""String_Node_Str"" + rows);
  this.rows=rows;
}",0.6883116883116883
108980,"public MainWindow(){
  display=new Display();
  shell=new Shell(display);
  controller=new Controller(this);
  controller.addListener(ModelPart.MODEL,this);
  shell.setImage(controller.getResources().getImage(""String_Node_Str""));
  shell.setMaximized(true);
  shell.setText(TITLE);
  shell.setMinimumSize(800,600);
  tooltip=new MainToolTip(shell);
  popup=new MainPopUp(shell);
  shell.addListener(SWT.Close,new Listener(){
    @Override public void handleEvent(    final Event event){
      controller.actionMenuFileExit();
      event.doit=false;
    }
  }
);
  new MainMenu(shell,controller);
  new MainToolBar(shell,controller);
  shell.setLayout(SWTUtil.createGridLayout(1));
  root=new ComponentTitledFolder(shell,controller,null,""String_Node_Str"");
  root.setLayoutData(SWTUtil.createFillGridData());
  Composite item1=root.createItem(TAB_DEFINE_TRANSFORMATION,controller.getResources().getImage(""String_Node_Str""));
  new LayoutDefinition(item1,controller);
  Composite item2=root.createItem(TAB_EXPLORE_SEARCHSPACE,controller.getResources().getImage(""String_Node_Str""));
  new LayoutExplore(item2,controller);
  Composite item3=root.createItem(TAB_ANALYZE_DATA,controller.getResources().getImage(""String_Node_Str""));
  new LayoutAnalyze(item3,controller);
  controller.reset();
}","public MainWindow(){
  Display current=Display.getCurrent();
  display=current != null ? current : new Display();
  shell=new Shell(display);
  controller=new Controller(this);
  controller.addListener(ModelPart.MODEL,this);
  shell.setImage(controller.getResources().getImage(""String_Node_Str""));
  shell.setMaximized(true);
  shell.setText(TITLE);
  shell.setMinimumSize(800,600);
  tooltip=new MainToolTip(shell);
  popup=new MainPopUp(shell);
  shell.addListener(SWT.Close,new Listener(){
    @Override public void handleEvent(    final Event event){
      controller.actionMenuFileExit();
      event.doit=false;
    }
  }
);
  new MainMenu(shell,controller);
  new MainToolBar(shell,controller);
  shell.setLayout(SWTUtil.createGridLayout(1));
  root=new ComponentTitledFolder(shell,controller,null,""String_Node_Str"");
  root.setLayoutData(SWTUtil.createFillGridData());
  Composite item1=root.createItem(TAB_DEFINE_TRANSFORMATION,controller.getResources().getImage(""String_Node_Str""));
  new LayoutDefinition(item1,controller);
  Composite item2=root.createItem(TAB_EXPLORE_SEARCHSPACE,controller.getResources().getImage(""String_Node_Str""));
  new LayoutExplore(item2,controller);
  Composite item3=root.createItem(TAB_ANALYZE_DATA,controller.getResources().getImage(""String_Node_Str""));
  new LayoutAnalyze(item3,controller);
  controller.reset();
}",0.9743008314436886
108981,"private NatTable createTable(final Composite parent){
  final IDataProvider provider=new DataTableHandleDataProvider(null,context);
  gridLayer=new DataTableGridLayerStack(provider,context);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  Color light=GUIHelper.getColor(240,240,240);
  Color dark=GUIHelper.getColor(180,180,180);
  Style style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,light);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,dark);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}","private NatTable createTable(final Composite parent){
  final IDataProvider provider=new DataTableHandleDataProvider(null,context);
  gridLayer=new DataTableGridLayerStack(provider,table,context);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  Color light=GUIHelper.getColor(240,240,240);
  Color dark=GUIHelper.getColor(180,180,180);
  Style style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,light);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  style=new Style();
  style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,dark);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"");
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}",0.9986784140969164
108982,"public void setData(final DataHandle handle){
  this.table.setRedraw(false);
  this.context.reset();
  this.context.setHandle(handle);
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(handle,context),context);
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnWidthByPosition(0,18);
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnPositionResizable(0,false);
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
}","public void setData(final DataHandle handle){
  this.table.setRedraw(false);
  this.context.reset();
  this.context.setHandle(handle);
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(handle,context),table,context);
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnWidthByPosition(0,18);
  ((DataLayer)this.gridLayer.getBodyDataLayer()).setColumnPositionResizable(0,false);
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
}",0.9964953271028038
108983,"public ComponentDataTable(final Controller controller,final Composite parent){
  this.table=createControl(parent);
  this.context=new DataTableContext(this.table);
  this.table.setVisible(false);
}","public ComponentDataTable(final Controller controller,final Composite parent){
  this.context=new DataTableContext(controller);
  this.table=createControl(parent);
  this.table.setVisible(false);
}",0.751269035532995
108984,"private void createTableStyling(final NatTable natTable){
  final DefaultNatTableStyleConfiguration natTableConfiguration=new DefaultNatTableStyleConfiguration();
  natTableConfiguration.bgColor=GUIHelper.getColor(249,172,7);
  natTableConfiguration.fgColor=GUIHelper.getColor(0,0,0);
  natTableConfiguration.hAlign=HorizontalAlignmentEnum.LEFT;
  natTableConfiguration.vAlign=VerticalAlignmentEnum.TOP;
  natTableConfiguration.font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  natTableConfiguration.cellPainter=new PaddingDecorator(new TextPainter(),1);
  final DefaultRowStyleConfiguration rowStyleConfiguration=new DefaultRowStyleConfiguration();
  rowStyleConfiguration.oddRowBgColor=GUIHelper.getColor(254,251,243);
  rowStyleConfiguration.evenRowBgColor=GUIHelper.COLOR_WHITE;
  final DefaultSelectionStyleConfiguration selectionStyle=new DefaultSelectionStyleConfiguration();
  selectionStyle.selectionFont=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  selectionStyle.selectionBgColor=GUIHelper.getColor(220,220,220);
  selectionStyle.selectionFgColor=GUIHelper.COLOR_BLACK;
  selectionStyle.anchorBorderStyle=new BorderStyle(1,GUIHelper.COLOR_DARK_GRAY,LineStyleEnum.SOLID);
  selectionStyle.anchorBgColor=GUIHelper.getColor(220,220,220);
  selectionStyle.anchorFgColor=GUIHelper.getColor(0,0,0);
  selectionStyle.selectedHeaderBgColor=GUIHelper.getColor(156,209,103);
  selectionStyle.selectedHeaderFont=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  natTable.addConfiguration(natTableConfiguration);
  natTable.addConfiguration(rowStyleConfiguration);
  natTable.addConfiguration(selectionStyle);
  natTable.addConfiguration(new DataTableRowHeaderConfiguration());
  natTable.addConfiguration(new DataTableColumnHeaderConfiguration(context));
}","private void createTableStyling(final NatTable natTable){
  final DefaultNatTableStyleConfiguration natTableConfiguration=new DefaultNatTableStyleConfiguration();
  natTableConfiguration.bgColor=GUIHelper.getColor(249,172,7);
  natTableConfiguration.fgColor=GUIHelper.getColor(0,0,0);
  natTableConfiguration.hAlign=HorizontalAlignmentEnum.LEFT;
  natTableConfiguration.vAlign=VerticalAlignmentEnum.TOP;
  natTableConfiguration.font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  natTableConfiguration.cellPainter=new PaddingDecorator(new TextPainter(),1);
  final DefaultRowStyleConfiguration rowStyleConfiguration=new DefaultRowStyleConfiguration();
  rowStyleConfiguration.oddRowBgColor=GUIHelper.getColor(254,251,243);
  rowStyleConfiguration.evenRowBgColor=GUIHelper.COLOR_WHITE;
  final DefaultSelectionStyleConfiguration selectionStyle=new DefaultSelectionStyleConfiguration();
  selectionStyle.selectionFont=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  selectionStyle.selectionBgColor=GUIHelper.getColor(220,220,220);
  selectionStyle.selectionFgColor=GUIHelper.COLOR_BLACK;
  selectionStyle.anchorBorderStyle=new BorderStyle(1,GUIHelper.COLOR_DARK_GRAY,LineStyleEnum.SOLID);
  selectionStyle.anchorBgColor=GUIHelper.getColor(220,220,220);
  selectionStyle.anchorFgColor=GUIHelper.getColor(0,0,0);
  selectionStyle.selectedHeaderBgColor=GUIHelper.getColor(156,209,103);
  selectionStyle.selectedHeaderFont=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  natTable.addConfiguration(natTableConfiguration);
  natTable.addConfiguration(rowStyleConfiguration);
  natTable.addConfiguration(selectionStyle);
  natTable.addConfiguration(new DataTableRowHeaderConfiguration(context));
  natTable.addConfiguration(new DataTableColumnHeaderConfiguration(context));
}",0.9980774512496566
108985,"public void reset(){
  this.table.setRedraw(false);
  this.context.getImages().clear();
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(null,context),context);
  this.context.reset();
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}","public void reset(){
  this.table.setRedraw(false);
  this.context.getImages().clear();
  this.gridLayer=new DataTableGridLayerStack(new DataTableHandleDataProvider(null,context),table,context);
  this.context.reset();
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}",0.9954954954954957
108986,"public DataTableBodyLayerStack(IUniqueIndexLayer underlyingLayer,DataTableContext context){
  this.selectionLayer=new SelectionLayer(underlyingLayer);
  this.viewportLayer=new ViewportLayer(selectionLayer);
  this.setUnderlyingLayer(viewportLayer);
  this.setConfigLabelAccumulator(new DataTableConfigLabelAccumulator(context));
  this.registerCommandHandler(new CopyDataCommandHandler(selectionLayer));
}","public DataTableBodyLayerStack(IUniqueIndexLayer underlyingLayer,NatTable table,DataTableContext context){
  this.selectionLayer=new SelectionLayer(underlyingLayer);
  this.viewportLayer=new ViewportLayer(selectionLayer);
  this.setUnderlyingLayer(viewportLayer);
  this.setConfigLabelAccumulator(new DataTableConfigLabelAccumulator(table,context));
  this.registerCommandHandler(new CopyDataCommandHandler(selectionLayer));
}",0.9747292418772564
108987,"public DataTableColumnHeaderConfiguration(DataTableContext context){
  this.font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  this.context=context;
}","public DataTableColumnHeaderConfiguration(DataTableContext context){
  this.font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  this.context=context;
  IMAGE_COL_BACK=context.getController().getResources().getImage(""String_Node_Str"");
  IMAGE_COL_SELECT=context.getController().getResources().getImage(""String_Node_Str"");
}",0.6653696498054474
108988,"@Override public void accumulateConfigLabels(LabelStack configLabels,int columnPosition,int rowPosition){
  NatTable table=context.getTable();
  int[] groups=context.getGroups();
  RowSet rows=context.getRows();
  if (table != null && groups != null) {
    int row=table.getRowIndexByPosition(rowPosition + 1);
    configLabels.addLabel(""String_Node_Str"" + (groups[row] % 2));
    if (row < groups.length - 1 && groups[row] != groups[row + 1]) {
      configLabels.addLabel(DataTableDecorator.BOTTOM_LINE_BORDER_LABEL);
    }
  }
  if (table != null && rows != null) {
    int column=table.getColumnIndexByPosition(columnPosition + 1);
    if (column == 0) {
      configLabels.addLabel(""String_Node_Str"");
    }
  }
}","@Override public void accumulateConfigLabels(LabelStack configLabels,int columnPosition,int rowPosition){
  int[] groups=context.getGroups();
  RowSet rows=context.getRows();
  if (table != null && groups != null) {
    int row=table.getRowIndexByPosition(rowPosition + 1);
    configLabels.addLabel(""String_Node_Str"" + (groups[row] % 2));
    if (row < groups.length - 1 && groups[row] != groups[row + 1]) {
      configLabels.addLabel(DataTableDecorator.BOTTOM_LINE_BORDER_LABEL);
    }
  }
  if (table != null && rows != null) {
    int column=table.getColumnIndexByPosition(columnPosition + 1);
    if (column == 0) {
      configLabels.addLabel(""String_Node_Str"");
    }
  }
}",0.9735525375268048
108989,"public DataTableConfigLabelAccumulator(DataTableContext context){
  this.context=context;
}","public DataTableConfigLabelAccumulator(NatTable table,DataTableContext context){
  this.context=context;
  this.table=table;
}",0.8387096774193549
108990,"public DataTableContext(NatTable table){
  this.table=table;
}","public DataTableContext(Controller controller){
  this.controller=controller;
}",0.723404255319149
108991,"protected DataTableGridLayer(boolean useDefaultConfiguration,DataTableContext context){
  super(useDefaultConfiguration);
  this.context=context;
}","protected DataTableGridLayer(boolean useDefaultConfiguration,NatTable table,DataTableContext context){
  super(useDefaultConfiguration);
  this.context=context;
  this.table=table;
}",0.8936170212765957
108992,"public DataTableGridLayerStack(final IDataProvider bodyDataProvider,DataTableContext context){
  super(true,context);
  List<String> lcolumns=new ArrayList<String>();
  RowSet rows=context.getRows();
  DataHandle handle=context.getHandle();
  String[][] data=context.getArray();
  if (bodyDataProvider.getColumnCount() != 0) {
    if (rows != null) {
      lcolumns.add(""String_Node_Str"");
    }
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        lcolumns.add(handle.getAttributeName(i));
      }
    }
 else     if (data != null) {
      for (int i=0; i < data[0].length; i++) {
        lcolumns.add(data[0][i]);
      }
    }
  }
  String[] columns=lcolumns.toArray(new String[]{});
  final IDataProvider columnHeaderDataProvider=new DefaultColumnHeaderDataProvider(columns);
  final IDataProvider rowHeaderDataProvider=new DefaultRowHeaderDataProvider(bodyDataProvider);
  final IDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnHeaderDataProvider,rowHeaderDataProvider);
  init(bodyDataProvider,columnHeaderDataProvider,rowHeaderDataProvider,cornerDataProvider);
}","public DataTableGridLayerStack(final IDataProvider bodyDataProvider,NatTable table,DataTableContext context){
  super(true,table,context);
  List<String> lcolumns=new ArrayList<String>();
  RowSet rows=context.getRows();
  DataHandle handle=context.getHandle();
  String[][] data=context.getArray();
  if (bodyDataProvider.getColumnCount() != 0) {
    if (rows != null) {
      lcolumns.add(""String_Node_Str"");
    }
    if (handle != null) {
      for (int i=0; i < handle.getNumColumns(); i++) {
        lcolumns.add(handle.getAttributeName(i));
      }
    }
 else     if (data != null) {
      for (int i=0; i < data[0].length; i++) {
        lcolumns.add(data[0][i]);
      }
    }
  }
  String[] columns=lcolumns.toArray(new String[]{});
  final IDataProvider columnHeaderDataProvider=new DefaultColumnHeaderDataProvider(columns);
  final IDataProvider rowHeaderDataProvider=new DefaultRowHeaderDataProvider(bodyDataProvider);
  final IDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnHeaderDataProvider,rowHeaderDataProvider);
  init(bodyDataProvider,columnHeaderDataProvider,rowHeaderDataProvider,cornerDataProvider);
}",0.9872302950242184
108993,"public DataTableRowHeaderConfiguration(){
  font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  final TextPainter txtPainter=new TextPainter(false,false);
  final ICellPainter bgImagePainter=new BackgroundImagePainter(txtPainter,IMAGE_ROW_BACK,null);
  cellPainter=bgImagePainter;
}","public DataTableRowHeaderConfiguration(DataTableContext context){
  font=GUIHelper.getFont(new FontData(""String_Node_Str"",8,SWT.NORMAL));
  IMAGE_ROW_BACK=context.getController().getResources().getImage(""String_Node_Str"");
  IMAGE_ROW_SELECT=context.getController().getResources().getImage(""String_Node_Str"");
  final TextPainter txtPainter=new TextPainter(false,false);
  final ICellPainter bgImagePainter=new BackgroundImagePainter(txtPainter,IMAGE_ROW_BACK,null);
  cellPainter=bgImagePainter;
}",0.37
108994,"public ViewDensity(final Composite parent,final Controller controller,final ModelPart target,final ModelPart reset){
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(target,this);
  this.controller=controller;
  if (reset != null) {
    controller.addListener(reset,this);
  }
  this.reset=reset;
  this.target=target;
  canvas=new Canvas(parent,SWT.NONE);
  lws=new LightweightSystem(canvas);
  intensityGraph=new IntensityGraphFigure();
  lws.setContents(intensityGraph);
  intensityGraph.getXAxis().setTitleFont(MainWindow.FONT);
  intensityGraph.getYAxis().setTitleFont(MainWindow.FONT);
  intensityGraph.getXAxis().setFont(MainWindow.FONT);
  intensityGraph.getYAxis().setFont(MainWindow.FONT);
  intensityGraph.setFont(MainWindow.FONT);
  canvas.setBackground(parent.getBackground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=canvas.getBackground().getRed() - 13;
    int g=canvas.getBackground().getGreen() - 13;
    int b=canvas.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final org.eclipse.swt.graphics.Color c2=new org.eclipse.swt.graphics.Color(controller.getResources().getDisplay(),r,g,b);
    canvas.setBackground(c2);
    canvas.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  reset();
}","public ViewDensity(final Composite parent,final Controller controller,final ModelPart target,final ModelPart reset){
  controller.addListener(ModelPart.SELECTED_ATTRIBUTE,this);
  controller.addListener(ModelPart.MODEL,this);
  controller.addListener(ModelPart.VIEW_CONFIG,this);
  controller.addListener(target,this);
  this.controller=controller;
  if (reset != null) {
    controller.addListener(reset,this);
  }
  this.reset=reset;
  this.target=target;
  canvas=new Canvas(parent,SWT.NONE);
  lws=new LightweightSystem(canvas);
  intensityGraph=new IntensityGraphFigure();
  lws.setContents(intensityGraph);
  intensityGraph.getXAxis().setTitleFont(MainWindow.FONT);
  intensityGraph.getYAxis().setTitleFont(MainWindow.FONT);
  intensityGraph.getXAxis().setFont(MainWindow.FONT);
  intensityGraph.getYAxis().setFont(MainWindow.FONT);
  intensityGraph.setFont(MainWindow.FONT);
  canvas.setBackground(parent.getBackground());
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    int r=canvas.getBackground().getRed() - 13;
    int g=canvas.getBackground().getGreen() - 13;
    int b=canvas.getBackground().getBlue() - 13;
    r=r > 0 ? r : 0;
    r=g > 0 ? g : 0;
    r=b > 0 ? b : 0;
    final org.eclipse.swt.graphics.Color c2=new org.eclipse.swt.graphics.Color(controller.getResources().getDisplay(),r,g,b);
    canvas.setBackground(c2);
    canvas.addDisposeListener(new DisposeListener(){
      public void widgetDisposed(      DisposeEvent arg0){
        c2.dispose();
      }
    }
);
  }
  reset();
}",0.9822950819672132
108995,"@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT) {
    canvas.setEnabled(true);
    redraw();
  }
  if (event.part == reset) {
    reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    reset();
    model=(Model)event.data;
  }
 else   if (event.part == target) {
    canvas.setEnabled(true);
    redraw();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE) {
    if (model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
      canvas.setEnabled(true);
      redraw();
    }
  }
}","@Override public void update(final ModelEvent event){
  if (event.part == ModelPart.OUTPUT) {
    canvas.setEnabled(true);
    redraw();
  }
  if (event.part == reset) {
    reset();
  }
 else   if (event.part == ModelPart.MODEL) {
    reset();
    model=(Model)event.data;
  }
 else   if (event.part == target) {
    canvas.setEnabled(true);
    redraw();
  }
 else   if (event.part == ModelPart.SELECTED_ATTRIBUTE || event.part == ModelPart.VIEW_CONFIG) {
    if (model.getAttributePair()[0] != null && model.getAttributePair()[1] != null) {
      canvas.setEnabled(true);
      redraw();
    }
  }
}",0.9665236051502146
108996,"private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if (data != null)   data=data.getView(config.getConfig());
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}","private DataHandle getData(){
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView(config.getConfig());
  }
  if ((config == null) || (data == null)) {
    return null;
  }
 else {
    return data;
  }
}",0.8961038961038961
108997,"private void analyze(){
  if (model == null) {
    return;
  }
  final long time=System.currentTimeMillis();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null)   data=data.getView(config.getConfig());
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  boolean suppressed=false;
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    if (!suppressed) {
      suppressed|=data.isOutlier(i);
    }
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val) || ((model.getAnonymizer() != null) && val.equals(model.getAnonymizer().getSuppressionString()))) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (suppressed) {
      if (!done.contains(model.getAnonymizer().getSuppressionString())) {
        list.add(model.getAnonymizer().getSuppressionString());
        if (!map.containsKey(list.add(model.getAnonymizer().getSuppressionString()))) {
          map.put(model.getAnonymizer().getSuppressionString(),0d);
        }
      }
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  int step=map.size() / MAX_DIMENSION;
  step=Math.max(step,1);
  final int length=(int)Math.ceil((double)map.size() / (double)step);
  controller.getResources().getLogger().info(""String_Node_Str"" + length + ""String_Node_Str""+ step+ ""String_Node_Str""+ dvals.length+ ""String_Node_Str""+ MAX_DIMENSION);
  int sindex=0;
  final double[] distribution=new double[length];
  for (int i=0; i < dvals.length; i+=step) {
    for (int j=0; j < step; j++) {
      if (sindex < distribution.length) {
        if ((i + j) < dvals.length) {
          distribution[sindex]+=map.get(dvals[i + j]) / sum;
        }
      }
 else {
        controller.getResources().getLogger().warn(""String_Node_Str"");
      }
    }
    sindex++;
  }
  cache.put(attribute,distribution);
  controller.getResources().getLogger().info(""String_Node_Str"" + (System.currentTimeMillis() - time));
}","private void analyze(){
  if (model == null) {
    return;
  }
  final long time=System.currentTimeMillis();
  ModelConfiguration config=model.getOutputConfig();
  if (config == null) {
    config=model.getInputConfig();
  }
  DataHandle data;
  if (target == ModelPart.INPUT) {
    data=config.getInput().getHandle();
  }
 else {
    data=model.getOutput();
  }
  if ((config == null) || (data == null)) {
    reset();
    return;
  }
  if (data != null && model.getViewConfig().isSubset()) {
    data=data.getView(config.getConfig());
  }
  final int index=data.getColumnIndexOf(attribute);
  if (index == -1) {
    clearCache();
    reset();
    return;
  }
  if (cache.containsKey(attribute)) {
    return;
  }
  final AttributeType type=config.getInput().getDefinition().getAttributeType(attribute);
  Hierarchy hierarchy=null;
  if (type instanceof Hierarchy) {
    hierarchy=(Hierarchy)type;
  }
 else   if (type == AttributeType.SENSITIVE_ATTRIBUTE) {
    hierarchy=config.getHierarchy(attribute);
  }
  boolean suppressed=false;
  final Map<String,Double> map=new HashMap<String,Double>();
  for (int i=0; i < data.getNumRows(); i++) {
    if (!suppressed) {
      suppressed|=data.isOutlier(i);
    }
    final String val=data.getValue(i,index);
    if (!map.containsKey(val)) {
      map.put(val,1d);
    }
 else {
      map.put(val,map.get(val) + 1);
    }
  }
  final String[] dvals;
  if (hierarchy != null) {
    final int level=data.getGeneralization(attribute);
    final List<String> list=new ArrayList<String>();
    final Set<String> done=new HashSet<String>();
    final String[][] h=hierarchy.getHierarchy();
    for (int i=0; i < h.length; i++) {
      final String val=h[i][level];
      if (map.containsKey(val) || ((model.getAnonymizer() != null) && val.equals(model.getAnonymizer().getSuppressionString()))) {
        if (!done.contains(val)) {
          list.add(val);
          done.add(val);
        }
      }
    }
    if (suppressed) {
      if (!done.contains(model.getAnonymizer().getSuppressionString())) {
        list.add(model.getAnonymizer().getSuppressionString());
        if (!map.containsKey(list.add(model.getAnonymizer().getSuppressionString()))) {
          map.put(model.getAnonymizer().getSuppressionString(),0d);
        }
      }
    }
    dvals=list.toArray(new String[]{});
  }
 else {
    final DataType<?> dtype=data.getDataType(attribute);
    final String[] v=new String[map.size()];
    int i=0;
    for (    final String s : map.keySet()) {
      v[i++]=s;
    }
    Arrays.sort(v,new Comparator<String>(){
      @Override public int compare(      final String arg0,      final String arg1){
        try {
          return dtype.compare(arg0,arg1);
        }
 catch (        final Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    dvals=v;
  }
  double sum=0;
  for (  final double i : map.values()) {
    sum+=i;
  }
  int step=map.size() / MAX_DIMENSION;
  step=Math.max(step,1);
  final int length=(int)Math.ceil((double)map.size() / (double)step);
  controller.getResources().getLogger().info(""String_Node_Str"" + length + ""String_Node_Str""+ step+ ""String_Node_Str""+ dvals.length+ ""String_Node_Str""+ MAX_DIMENSION);
  int sindex=0;
  final double[] distribution=new double[length];
  for (int i=0; i < dvals.length; i+=step) {
    for (int j=0; j < step; j++) {
      if (sindex < distribution.length) {
        if ((i + j) < dvals.length) {
          distribution[sindex]+=map.get(dvals[i + j]) / sum;
        }
      }
 else {
        controller.getResources().getLogger().warn(""String_Node_Str"");
      }
    }
    sindex++;
  }
  cache.put(attribute,distribution);
  controller.getResources().getLogger().info(""String_Node_Str"" + (System.currentTimeMillis() - time));
}",0.9871965857562016
108998,"public ARXAnonymizer createAnonymizer(){
  outputConfig=inputConfig.clone();
  this.anonymizer=new ARXAnonymizer();
  this.anonymizer.setHistorySize(getHistorySize());
  this.anonymizer.setMaximumSnapshotSizeDataset(getSnapshotSizeDataset());
  this.anonymizer.setSuppressionString(getSuppressionString());
  this.anonymizer.setMaximumSnapshotSizeSnapshot(getSnapshotSizeSnapshot());
  this.anonymizer.setRemoveOutliers(inputConfig.isRemoveOutliers());
  return anonymizer;
}","public ARXAnonymizer createAnonymizer(){
  outputConfig=inputConfig.clone();
  this.anonymizer=new ARXAnonymizer();
  this.anonymizer.setHistorySize(getHistorySize());
  this.anonymizer.setMaximumSnapshotSizeDataset(getSnapshotSizeDataset());
  this.anonymizer.setSuppressionString(getSuppressionString());
  this.anonymizer.setMaximumSnapshotSizeSnapshot(getSnapshotSizeSnapshot());
  this.anonymizer.setRemoveOutliers(inputConfig.isRemoveOutliers());
  inputConfig.removeAllCriteria();
  if (this.kAnonymityModel != null && this.kAnonymityModel.isActive() && this.kAnonymityModel.isEnabled()) {
    inputConfig.addCriterion(this.kAnonymityModel.getCriterion(this));
  }
  if (this.dPresenceModel != null && this.dPresenceModel.isActive() && this.dPresenceModel.isEnabled()) {
    inputConfig.addCriterion(this.dPresenceModel.getCriterion(this));
  }
  for (  Entry<String,ModelLDiversityCriterion> entry : this.lDiversityModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      inputConfig.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  for (  Entry<String,ModelTClosenessCriterion> entry : this.tClosenessModel.entrySet()) {
    if (entry.getValue() != null && entry.getValue().isActive() && entry.getValue().isEnabled()) {
      inputConfig.addCriterion(entry.getValue().getCriterion(this));
    }
  }
  if (!inputConfig.containsCriterion(DPresence.class)) {
    DataSubset subset=DataSubset.create(getInputConfig().getInput(),getInputConfig().getResearchSubset());
    inputConfig.addCriterion(new DPresence(0d,1d,subset));
  }
  return anonymizer;
}",0.4493850520340586
108999,"@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input.clone();
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  return c;
}","@Override public ModelConfiguration clone(){
  final ModelConfiguration c=new ModelConfiguration();
  c.removeOutliers=removeOutliers;
  c.input=input.clone();
  c.config=config.clone();
  c.hierarchies=new HashMap<String,Hierarchy>(hierarchies);
  c.researchSubset=researchSubset;
  return c;
}",0.9369369369369368
109000,"public CriteriaListView(final Composite parent,final Controller controller,final Model model){
  this.controller=controller;
  this.controller.addListener(EventTarget.CRITERION_DEFINITION,this);
  this.model=model;
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  root=new Composite(parent,SWT.NONE);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  root.setLayout(l);
  final Table table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  table.setLayoutData(d);
  column1=new TableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  column2=new TableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column3=new TableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column1.pack();
  column2.pack();
  column3.pack();
}","public CriteriaListView(final Composite parent,final Controller controller){
  this.controller=controller;
  this.controller.addListener(EventTarget.CRITERION_DEFINITION,this);
  this.controller.addListener(EventTarget.MODEL,this);
  this.symbolL=controller.getResources().getImage(""String_Node_Str"");
  this.symbolT=controller.getResources().getImage(""String_Node_Str"");
  this.symbolK=controller.getResources().getImage(""String_Node_Str"");
  this.symbolD=controller.getResources().getImage(""String_Node_Str"");
  root=new Composite(parent,SWT.NONE);
  GridLayout l=new GridLayout();
  l.numColumns=1;
  root.setLayout(l);
  table=new Table(root,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  table.setHeaderVisible(true);
  final GridData d=SWTUtil.createFillGridData();
  table.setLayoutData(d);
  column1=new TableColumn(table,SWT.NONE);
  column1.setText(""String_Node_Str"");
  column2=new TableColumn(table,SWT.NONE);
  column2.setText(Resources.getMessage(""String_Node_Str""));
  column3=new TableColumn(table,SWT.NONE);
  column3.setText(Resources.getMessage(""String_Node_Str""));
  column1.pack();
  column2.pack();
  column3.pack();
}",0.9580943978826644
